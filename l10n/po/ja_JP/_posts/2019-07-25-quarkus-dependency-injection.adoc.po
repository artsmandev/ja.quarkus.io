msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#. type: Title =
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy, no-wrap
msgid "Quarkus Dependency Injection"
msgstr "Quarkus Dependency Injection（依存性注入）。"

#. type: YAML Front Matter: synopsis
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy, no-wrap
msgid "Quarkus ArC is a build-time oriented dependency injection based on CDI 2.0. But what does it actually mean and what benefits does a build-time processing DI bring?"
msgstr "Quarkus ArCは、CDI 2.0をベースにしたビルドタイム指向の依存性注入法です。しかし、実際にはどのような意味があり、ビルドタイム処理のDIはどのような利点をもたらすのでしょうか。"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"Quarkus ArC is a build-time oriented dependency injection based on http://cdi-spec.org/[CDI 2.0].\n"
"In this blogpost, we're going to explain the relationship to the specification and describe some of the benefits and drawbacks of the build-time processing design."
msgstr ""

#. type: Title ==
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, no-wrap
msgid "Compatibility"
msgstr "互換性"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"It does not make sense to reinvent the wheel, especially when it comes to dependency injection.\n"
"There are many frameworks that try to solve similar problems.\n"
"A year ago, we made a design decision to build Quarkus DI on top of CDI.\n"
"We had some very good reasons to choose CDI:"
msgstr ""

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "CDI is a mature and proven component model"
msgstr "CDIは成熟し、実績のあるコンポーネントモデル"

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "We at Red Hat have almost ten years of experience with developing http://weld.cdi-spec.org/[Weld - the CDI Reference Implementation]"
msgstr "私たちRed Hatは、 link:http://weld.cdi-spec.org/[Weld - CDI Reference Implementationの] 開発で10年近い経験があります。"

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "The CDI API is built on top of `javax.inject` so that it should be easy to migrate from any DI framework compatible with `@Inject`"
msgstr "CDI APIは、 `javax.inject` の上に構築されているので、以下のような互換性のあるDIフレームワークから簡単に移行できるはずです。 `@Inject`"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"Our primary goal was to implement a supersonic build-time oriented DI solution compatible with CDI.\n"
"This would allow users to continue using CDI in their applications but also leverage Quarkus build-time optimizations.\n"
"However, ArC is not a full CDI implementation verified by the TCK - see also the list of https://quarkus.io/guides/cdi-reference#supported_features[supported features] and the list of https://quarkus.io/guides/cdi-reference#limitations[limitations]."
msgstr ""

#. type: Title ==
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy, no-wrap
msgid "Build-time Processing Benefits and Drawbacks"
msgstr "ビルドタイム処理の利点と欠点"

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy, no-wrap
msgid "Fail Fast"
msgstr "フェイルファスト"

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "Beans and dependencies are validated during the build so that your application can never fail in production with common problems such as `AmbiguousResolutionException` or `UnsatisfiedResolutionException`."
msgstr "Beanと依存関係はビルド中に検証されるため、 `AmbiguousResolutionException` や `UnsatisfiedResolutionException` といった一般的な問題でアプリケーションが本番で失敗することはありません。"

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy, no-wrap
msgid "Instant Startup"
msgstr "インスタント・スタートアップ"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"When the app starts ArC just loads all the metadata and initializes some internal structures.\n"
"There is no need to analyze the application classes again.\n"
"This means negligible startup overhead."
msgstr ""

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "This applies to both the GraalVM and OpenJDK HotSpot runtimes."
msgstr "これは、GraalVMとOpenJDK HotSpotの両方のランタイムに適用されます。"

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy, no-wrap
msgid "Minimized Runtime"
msgstr "ランタイムの最小化"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"In Quarkus 0.19, ArC plus integration runtime consist of 72 classes and occupies ~ 140 KB in jars.\n"
"http://weld.cdi-spec.org/[Weld 3.1.1] (CDI Reference Implementation) core is roughly 1200 classes and approx. 2 MB jar.\n"
"In other words, ArC runtime takes approx. 7% of the Weld runtime in terms of number of classes and jar footprint."
msgstr ""

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy, no-wrap
msgid "Optimized Code Paths and Metadata Structures"
msgstr "最適化されたコードパスとメタデータ構造"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"When generating the metadata classes ArC can sometimes produce leaner and smarter logic because it has the whole application analyzed already.\n"
"This is one of the areas where we would like to develop and improve ArC."
msgstr ""

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, no-wrap
msgid "Extension Points"
msgstr "拡張ポイント"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"Unfortunately, CDI portable extensions are inherently runtime constructs and therefore cannot be fully supported in Quarkus.\n"
"In fact, all CDI extensions are ignored at the moment.\n"
"Nevertheless, most of the functionality can be achieved using https://quarkus.io/guides/cdi-reference#build-time-extension-points[Quarkus extensions].\n"
"The CDI extensions are encouraged to generalize the code, and if possible provide a Quarkus extension to make full use of build-time metadata processing."
msgstr ""

#. type: Title ==
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, no-wrap
msgid "Non-standard Features"
msgstr "標準外の機能"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"ArC is not limited to standards and we're constantly looking for ways to go beyond and extend the possibilities.\n"
"Following are some examples of non-standard features provided by Quarkus DI."
msgstr ""

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, no-wrap
msgid "Qualified Injected Fields"
msgstr "修飾された注入フィールド"

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "Normally, if you declare an injected field you'll always need to use `@Inject` and optionally required qualifiers:"
msgstr "通常、注入フィールドを宣言する場合、必ず `@Inject` とオプションで必須修飾子を使用する必要があります："

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "In Quarkus, you can skip the `@Inject` annotation completely if an injected field declares at least one qualifier:"
msgstr "Quarkusでは、注入されたフィールドが少なくとも1つの修飾子を宣言している場合、 `@Inject` アノテーションを完全に省略することができます："

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "`@Inject` is still required for constructor and method injection."
msgstr "`@Inject` は、コンストラクタやメソッドインジェクションのために依然として必要です。"

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, no-wrap
msgid "Simplified Constructor Injection"
msgstr "簡略化されたコンストラクター注入"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).\n"
"However, this requirement complicates constructor injection - you would need to provide a dummy no-args constructor to make things work in CDI."
msgstr ""

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.\n"
"Also if there's only one constructor there is no need for `@Inject`."
msgstr "Quarkusでは、通常のスコープ付き Bean のためにダミーのコンストラクターを宣言する必要はありません。自動的に生成されます。また、コンストラクターが 1 つしかない場合は、`@Inject` の必要性はありません。"

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "We don't generate a no-args constructor automatically if a bean class extends another class that does not declare a no-args constructor."
msgstr "Beanクラスがno-argsコンストラクタを宣言していない別のクラスを拡張した場合、no-argsコンストラクタを自動的に生成することはない。"

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, no-wrap
msgid "Default Beans"
msgstr "デフォルトの Bean"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"CDI has a feature called https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#alternatives[alternatives].\n"
"Simply said a bean annotated with `@Alternative` and `@Priority` takes precedence over the non-alternative beans during type-safe resolution."
msgstr ""

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"So, what if a user wants to override a bean defined by a library/extension?\n"
"The bean would have to be marked as a CDI `@Alternative` that is enabled using the `@Priority` annotation.\n"
"Is there a simpler approach?\n"
"Yes, there is.\n"
"You can use a non-standard feature called \"default beans\".\n"
"In this case, a bean that can be overridden should be annotated with `@io.quarkus.arc.DefaultBean`.\n"
"And that's it."
msgstr ""

#. type: Title ===
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, no-wrap
msgid "Removing Unused Beans"
msgstr "未使用の Bean の削除"

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"GraalVM native image does a pretty good job when removing all classes that are not reachable from your application.\n"
"However, sometimes checking reachability is not enough.\n"
"Sometimes the framework itself must decide whether a component is needed or not.\n"
"In standard CDI, all beans are retained by the container no matter whether they're needed or not."
msgstr ""

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"Let's suppose we have a bean class `org.acme.Foo`.\n"
"This bean class imports and uses a lot of various classes.\n"
"It's annotated with `@ApplicationScoped` and so Quarkus needs to generate a bean metadata class and a client proxy and register this metadata when the application starts.\n"
"But what if nobody ever uses this bean?\n"
"We would still hold a reference on the generated metadata, and the bean class itself, and its dependencies.\n"
"In other words, all these classes would be reachable."
msgstr ""

#: _posts/2019-07-25-quarkus-dependency-injection.adoc
msgid ""
"Quarkus attempts to remove all *unused beans* during build by default.\n"
"This helps to reduce the number of generated classes and also the amount of memory needed at runtime.\n"
"But how do we actually detect an unused bean?\n"
"The rules are described in the https://quarkus.io/guides/cdi-reference#remove_unused_beans[reference guide] but simply said: if a bean is not injected anywhere and cannot be reached in any other standard way (e.g. observer notification) it is removed.\n"
"Moreover, users can instruct the container to not remove a bean by annotating the bean class with `@io.quarkus.arc.Unremovable`.\n"
"Finally, this optimization can be disabled and fine tuned by using the `quarkus.arc.remove-unused-beans` property."
msgstr ""

#. type: Plain text
#: _posts/2019-07-25-quarkus-dependency-injection.adoc
#, fuzzy
msgid "This feature applies to the JVM mode as well."
msgstr "この機能は、JVMモードにも適用されます。"
