msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit"

#. type: YAML Front Matter: title
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "How to implement Kafka Serializers and Deserializers?"
msgstr "KafkaのSerializersとDeserializersはどのように実装するのですか？"

#. type: YAML Front Matter: synopsis
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "JSON, Avro and Custom Kafka Serializers and Deserializers with Quarkus"
msgstr "QuarkusによるJSON、Avro、カスタムKafkaのシリアライザーとデシリアライザー"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"When your application writes a _record_ into a Kafka topic or when it consumes a _record_ from a Kafka topic, a mechanism of serialization and deserialization happens.\n"
"The serialization process transforms the business objects you want to send to Kafka into bytes.\n"
"The deserialization process is the opposite.\n"
"It receives the bytes from Kafka and recreates the business objects."
msgstr ""

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "This blog post explores different approaches for this serialization and deserialization and explains how you can implement a custom serializer and deserializer. It also highlights facilities provided by the Kafka connector from Quarkus."
msgstr "このブログ記事では、このシリアライズとデシリアライズのさまざまなアプローチについて説明し、カスタムのシリアライザーとデシリアライザーを実装する方法について説明します。また、QuarkusのKafkaコネクターが提供する機能にも注目しています。"

#. type: Title ==
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "Why do I need a custom serializer and deserializer?"
msgstr "なぜカスタムシリアライザーとデシリアライザーが必要なのですか？"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"https://javadoc.io/static/org.apache.kafka/kafka-clients/3.2.1/org/apache/kafka/common/serialization/package-summary.html[Kafka] provides a set of serializers and deserializers for the common types: `String`, `Double`, `Integer`, `Bytes`...\n"
"But that's rarely enough for business objects, even for objects are simple as:"
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"Fortunately, Kafka lets us implement our own.\n"
"To achieve this, you need to implement the following interfaces:"
msgstr ""

#. type: Block title
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "The Serializer interface"
msgstr "Serializerインターフェイス"

#. type: Block title
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "The Deserializer interface"
msgstr "Deserializer インタフェース"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"Once implemented, you need to configure your Kafka producer and consumer's key and value serializer and deserializer.\n"
"If you are using the Kafka connector from Quarkus, it will look like this:"
msgstr ""

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "But, no worries, Quarkus has a few magic tricks for you."
msgstr "でも、心配ご無用！Quarkusはいくつかのマジックを用意しています。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "In the rest of this post, we will use the following application:"
msgstr "この記事の続きでは、以下のアプリケーションを使用します："

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"The code can be found on https://github.com/cescoffier/quarkus-kafka-serde-demo.\n"
"We will develop three variants:"
msgstr ""

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "The first version uses JSON."
msgstr "最初のバージョンは、JSONを使用しています。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "The second version uses Avro."
msgstr "第2弾はアブロを使用。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "The third version uses custom (and dumb) serializer and deserializer."
msgstr "第3のバージョンは、カスタム（そしてダム）シリアライザーとデシリアライザーを使用します。"

#. type: Title ==
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "Using JSON"
msgstr "JSONの使用"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"Using JSON with Kafka is very popular.\n"
"As most web applications use JSON to exchange messages, using it with Kafka sounds like a natural extension."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"In our case, it means transforming the instances of https://github.com/cescoffier/quarkus-kafka-serde-demo/blob/main/json-serde/json-serde-publisher/src/main/java/me/escoffier/quarkus/json/publisher/Hero.java[Hero] to a JSON document and then using the String serializer.\n"
"For the deserialization process, we would do the reverse process.\n"
"To do that with Quarkus, you have *nothing* to do: Quarkus generates the custom JSON serializer and deserializer for you."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"In the https://github.com/cescoffier/quarkus-kafka-serde-demo/tree/main/json-serde[json-serde directory], you can find a version of the application using JSON to serialize and deserialize the records.\n"
"It does not contain any custom code or configuration.\n"
"Quarkus automatically detects that you need to write and consume Heroes and generates the serializer and deserializer for you.\n"
"It also configures the channels for you.\n"
"Of course, you can override the configuration, but it's what you want most of the time."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"To run this application, open two terminals.\n"
"In the first one, navigate to `json-serde/json-serde-publisher`, and run `mvn quarkus:dev`.\n"
"In the second terminal, navigate to `json-serde/json-serde-consumer`, and run `mvn quarkus:dev`.\n"
"Then, open a browser to http://localhost:8080.\n"
"Every 5 seconds, a new picture of a hero is displayed."
msgstr ""

#. type: Title ==
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "Using Avro"
msgstr "アブロの使用"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"The second approach uses https://avro.apache.org/[Avro].\n"
"Avro has several advantages over (bare) JSON:"
msgstr ""

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "It's a binary and compact protocol. The payloads will be a lot smaller than with JSON."
msgstr "バイナリでコンパクトなプロトコルです。ペイロードはJSONの場合よりもずっと小さくなります。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "The serialization and deserialization processes are a lot faster (avoiding reflection)."
msgstr "シリアライズとデシリアライズの処理は、（リフレクションを回避して）かなり高速になります。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "The format of the message is defined using a schema stored on a schema registry which enables versioning and enforces the structure."
msgstr "メッセージのフォーマットは、バージョン管理を可能にし、構造を強制するスキーマレジストリに格納されたスキーマを使用して定義されます。"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"The last point is essential.\n"
"To use Avro, you need a schema registry.\n"
"In this post, we are using https://www.apicur.io/registry/[Apicurio], but you can use the https://docs.confluent.io/platform/current/schema-registry/index.html[Confluent Schema Registry] or https://github.com/aiven/karapace[Karapace].\n"
"Quarkus provides a dev service for Apicurio, so you have nothing to do (as soon as you can run containers on your machine)."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"To use Avro, we need a schema.\n"
"In https://github.com/cescoffier/quarkus-kafka-serde-demo/blob/main/avro-serde/avro-serde-consumer/src/main/avro/hero.avsc[hero.avsc], you can find the schema representing our heroes:"
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"Avro relies on code generation.\n"
"It processes the schema to generate Java classes with the defined fields and serialization and deserialization methods."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"While in general, using code generation is an extra step, with Quarkus, it's built-in!\n"
"Once you have a schema in `src/main/avro`, it generates the code for you, and you are ready to use the produced classes."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"In https://github.com/cescoffier/quarkus-kafka-serde-demo/blob/main/avro-serde/avro-serde-publisher/src/main/java/me/escoffier/quarkus/json/publisher/AvroPublisherApp.java[AvroPublisherApp] and https://github.com/cescoffier/quarkus-kafka-serde-demo/blob/main/avro-serde/avro-serde-consumer/src/main/java/me/escoffier/quarkus/AvroConsumerResource.java[AvroConsumerResource], we are using the `Hero` class generated from the schema.\n"
"As an example, the consumer application looks like this:"
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"Quarkus automatically finds the serializer and deserializer and configures the channels, so again: *no config*.\n"
"However, you still need to instruct Apicurio to register the schema.\n"
"In general, it's a manual operation, but for development, you can use the following property:"
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"To run this application, open two terminals.\n"
"In the first one, navigate to `avro-serde/avro-serde-publisher`, and run `mvn quarkus:dev`.\n"
"In the second terminal, navigate to `avro-serde/avro-serde-consumer`, and run `mvn quarkus:dev`.\n"
"Then, open a browser to http://localhost:8080.\n"
"As for the JSON variant, every 5 seconds, a new picture of a hero is displayed.\n"
"This time the Kafka records are serialized using Avro"
msgstr ""

#. type: Title ==
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy, no-wrap
msgid "Writing a custom serializer and deserializer"
msgstr "カスタムシリアライザーとデシリアライザーを書く"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"Of course, you can still write your custom serializer and deserializer.\n"
"As mentioned above, you need to implement the `Serializer` and `Deserializer` interfaces."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid "For example, the  https://github.com/cescoffier/quarkus-kafka-serde-demo/blob/main/custom-serde/custom-serde-publisher/src/main/java/me/escoffier/quarkus/json/publisher/HeroSerializer.java[HeroSerializer class] contains a straightforward (and inefficient) approach to serializing our heroes:"
msgstr ""

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "The https://github.com/cescoffier/quarkus-kafka-serde-demo/blob/main/custom-serde/custom-serde-consumer/src/main/java/me/escoffier/quarkus/HeroDeserializer.java[HeroDeserializer class] contains the deserialization counterpart."
msgstr "link:https://github.com/cescoffier/quarkus-kafka-serde-demo/blob/main/custom-serde/custom-serde-consumer/src/main/java/me/escoffier/quarkus/HeroDeserializer.java[HeroDeserializerクラスは] 、デシリアライズの対応部分を含んでいます。"

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"As before, Quarkus discovers these implementations and configures the channels for you.\n"
"So you do not have to configure anything."
msgstr ""

#: _posts/2022-08-30-kafka-serde.adoc
msgid ""
"Custom serializers and deserializers can receive configuration attributes.\n"
"They receive the producer/consumer configuration in the `configure` method."
msgstr ""

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "Custom serializers and deserializers cannot be CDI beans. Kafka instantiates them directly using reflection."
msgstr "カスタムシリアライザーとデシリアライザーは、CDI Beanにすることはできません。Kafkaはリフレクションを使用して直接インスタンス化します。"

#. type: Title ==
#: _posts/2022-08-30-kafka-serde.adoc
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "This post explores different possibilities to serialize and deserialize your messages with Kafka and how Quarkus reduces the amount of boilerplate and configuration you need to use."
msgstr "この記事では、Kafkaでメッセージをシリアライズおよびデシリアライズするさまざまな可能性と、Quarkusが使用する必要のある定型文や設定の量をいかに減らすかについて説明します。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "So, what should you use?"
msgstr "では、何を使えばいいのでしょうか？"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "JSON is massively used, but the lack of structure verification, by default, can quickly be a problem if the format evolves rapidly."
msgstr "JSONは大量に使われていますが、デフォルトでは構造検証ができないため、フォーマットが急速に進化するとすぐに問題になってしまいます。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "Avro provides better performances and handles validation and evolutions. But it requires a schema registry. If your system exchanges lots of messages with evolving structures, Avro should be preferred. Also, Avro produces smaller payloads."
msgstr "Avroはより良いパフォーマンスを提供し、バリデーションやエボリューションを処理することができます。しかし、スキーマレジストリが必要です。もし、あなたのシステムが進化する構造と多くのメッセージを交換するのであれば、Avroを優先すべきです。また、Avroはより小さなペイロードを生成します。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "If you have stringent requirements not covered by the JSON and Avro approaches, you can develop a custom serializer and deserializer."
msgstr "JSONやAvroのアプローチではカバーできない厳しい要件がある場合は、カスタムシリアライザーとデシリアライザーを開発することができます。"

#. type: Plain text
#: _posts/2022-08-30-kafka-serde.adoc
#, fuzzy
msgid "Note that JSON can be combined with JSON-Schema (with the schema stored on a schema registry). Protobuf is also a possible alternative if you prefer a binary format."
msgstr "なお、JSONはJSON-Schemaと組み合わせることができます（スキーマはスキーマレジストリに保存されます）。バイナリ形式を好む場合は、Protobufも代替となりえます。"
