# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-08 08:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr "cescoffier"

#. type: YAML Front Matter: date
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:1
#, fuzzy, no-wrap
msgid "2023-10-02"
msgstr "2023-10-02"

#. type: YAML Front Matter: layout
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:1
#, fuzzy, no-wrap
msgid "How to detect pinning while running tests."
msgstr "テスト実行中にピン留めを検出する方法。"

#. type: YAML Front Matter: tags
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:1
#, fuzzy, no-wrap
msgid "virtual threads, reactive, test"
msgstr "仮想スレッド、リアクティブ、テスト"

#. type: YAML Front Matter: title
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:1
#, fuzzy, no-wrap
msgid "Testing virtual thread applications"
msgstr "仮想スレッドアプリケーションのテスト"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:13
#, fuzzy
msgid "https://quarkus.io/blog/virtual-threads-2/[In a previous post], we have seen how to implement a CRUD application using virtual threads in Quarkus.  The following video shows how to test this application and, specifically, how to detect pinning."
msgstr "link:https://quarkus.io/blog/virtual-threads-2/[以前の投稿で] 、Quarkusで仮想スレッドを使用してCRUDアプリケーションを実装する方法を紹介しました。次のビデオでは、このアプリケーションをテストする方法、特にピン留めを検出する方法を紹介します。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:17
#, fuzzy
msgid "+++ <iframe style=\"margin-left: auto; margin-right: auto; display: block;\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/GOHAEh3Ujh8?si=t8n8jLek0X7JC4MR\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe> +++"
msgstr "+++ <iframe style=\"margin-left: auto; margin-right: auto; display: block;\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/GOHAEh3Ujh8?si=t8n8jLek0X7JC4MR\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe> +++"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:19
#, fuzzy
msgid "The complete code of the application and the tests are available in the https://github.com/quarkusio/virtual-threads-demos/tree/main/crud-example[virtual threads demos repository]."
msgstr "アプリケーションの完全なコードとテストは、 link:https://github.com/quarkusio/virtual-threads-demos/tree/main/crud-example[virtual threads demosリポジトリで] 入手できる。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:21
#, fuzzy
msgid "## Pinning and Monopolization"
msgstr "ピン止めと独占\n"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:25
#, fuzzy
msgid "Virtual threads combine an imperative development model with a reactive execution mode.  It may provide a simple way to increase the concurrency of an application.  However, this might not always be the case."
msgstr "仮想スレッドは、命令型の開発モデルと反応型の実行モードを組み合わせたものである。これは、アプリケーションの並行性を高める簡単な方法を提供するかもしれない。しかし、必ずしもそうとは限りません。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:29
#, fuzzy
msgid "As described in https://quarkus.io/blog/virtual-thread-1/[another blog post], there are a few limitations, including monopolizing and pinning carrier threads.  When this happens, the application's performance can drastically decrease and increase memory usage.  Pinning for a short period can be tolerated, but it can be dramatic under load."
msgstr "link:https://quarkus.io/blog/virtual-thread-1/[別のブログ記事で] 紹介したように、キャリアのスレッドを独占したり固定したりするなど、いくつかの制限がある。これが発生すると、アプリケーションのパフォーマンスが極端に低下したり、メモリ使用量が増えたりします。短時間のピン止めは許容できますが、負荷がかかると劇的になる可能性があります。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:31
#, fuzzy
msgid "While, at the moment, there are no reliable ways to detect monopolization, there are mechanisms to detect pinning."
msgstr "今のところ、独占を検知する確実な方法はないが、ピン止めを検知するメカニズムはある。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:33
#, fuzzy
msgid "## Printing stack traces when a carrier thread gets pinned"
msgstr "キャリアスレッドがピン留めされたときのスタックトレースの表示\n"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:38
#, fuzzy
msgid "Suppose you have your application, and your code base contains tests.  You can configure Surefire (or the plugin you use to execute your tests) to dump a stack trace as soon as a virtual thread is going to pin the carrier thread (instead of being unmounted smoothly).  You must set the `jdk.tracePinnedThreads` system property to achieve this.  For the Surefire Maven plugin, add the `argLine` parameter to the configuration:"
msgstr "アプリケーションがあり、コードベースにテストが含まれているとします。Surefire（またはテストを実行するために使用するプラグイン）は、仮想スレッドが（スムーズにアンマウントされるのではなく）キャリアスレッドを固定しようとするとすぐにスタックトレースをダンプするように設定することができます。これを実現するには、 `jdk.tracePinnedThreads` システムプロパティを設定する必要があります。Surefire Maven プラグインの場合は、設定に `argLine` パラメータを追加します："

#. type: delimited block -
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:42
#, no-wrap
msgid "<argLine>-Djdk.tracePinnedThreads</argLine>\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:45
#, fuzzy
msgid "With this configuration, when, while running your test, a carrier thread is pinned, the stack trace is dumped in the console:"
msgstr "この設定により、テスト実行中にキャリアスレッドがピン留めされると、スタックトレースがコンソールにダンプされる："

#. type: delimited block -
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:64
#, no-wrap
msgid ""
"2023-09-15 07:51:18,312 INFO  [org.acm.cru.TodoResource] (quarkus-virtual-thread-0) Called on VirtualThread[#140,quarkus-virtual-thread-0]/runnable@ForkJoinPool-1-worker-1\n"
"Thread[#141,ForkJoinPool-1-worker-1,5,CarrierThreads]\n"
"    java.base/java.lang.VirtualThread$VThreadContinuation.onPinned(VirtualThread.java:185)\n"
"    java.base/jdk.internal.vm.Continuation.onPinned0(Continuation.java:393)\n"
"    java.base/java.lang.VirtualThread.parkNanos(VirtualThread.java:631)\n"
"    java.base/java.lang.VirtualThread.sleepNanos(VirtualThread.java:803)\n"
"    java.base/java.lang.Thread.sleep(Thread.java:507)\n"
"    org.acme.crud.TodoResource.pinTheCarrierThread(TodoResource.java:93) <== monitors:1\n"
"    org.acme.crud.TodoResource.getAll(TodoResource.java:32)\n"
"    org.acme.crud.TodoResource$quarkusrestinvoker$getAll_0e9c86666ef01bafda5560c4bf86952c6cf09993.invoke(Unknown Source)\n"
"    org.jboss.resteasy.reactive.server.handlers.InvocationHandler.handle(InvocationHandler.java:29)\n"
"    io.quarkus.resteasy.reactive.server.runtime.QuarkusResteasyReactiveRequestContext.invokeHandler(QuarkusResteasyReactiveRequestContext.java:141)\n"
"    org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext.run(AbstractResteasyReactiveContext.java:147)\n"
"    io.quarkus.virtual.threads.ContextPreservingExecutorService$1.run(ContextPreservingExecutorService.java:36)\n"
"    java.base/java.util.concurrent.ThreadPerTaskExecutor$TaskRunner.run(ThreadPerTaskExecutor.java:314)\n"
"    java.base/java.lang.VirtualThread.run(VirtualThread.java:311)\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:70
#, fuzzy
msgid "Analyzing the application logs will tell you whether your application is pinning.  Furthermore, a closer look at the stack trace will give you the reason.  In our example, the `pinTheCarrierThread` method is taking a lock.  This is indicated by the `monitors:1` text:"
msgstr "アプリケーションのログを分析すれば、アプリケーションがピン止めされているかどうかがわかる。さらに、スタックトレースを詳しく見れば、その理由がわかります。この例では、 `pinTheCarrierThread` メソッドがロックを取っています。これは `monitors:1` というテキストで示されています："

#. type: delimited block -
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:74
#, no-wrap
msgid "    org.acme.crud.TodoResource.pinTheCarrierThread(TodoResource.java:93) <== monitors:1\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:78
#, fuzzy
msgid "This approach can also be used in production (so, not only in tests).  You can also determine how long the carrier thread was blocked by correlating the pinned stack trace with other log events (like what happened just after in the same thread)."
msgstr "このやり方は本番でも使えます（つまり、テストだけではありません）。また、ピン留めされたスタックトレースと他のログイベント (同じスレッドで直後に何が起こったかなど) を関連付けることで、キャリアスレッドがブロックされた時間を判断することもできます。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:80
#, fuzzy
msgid "## Failing tests"
msgstr "テスト不合格\n"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:84
#, fuzzy
msgid "Dumping the stack trace may not be very convenient when your logs are already long.  Fortunately, we released a small Junit 5 extension that allows you to fail the tests when pinning is detected.  It's advantageous when you integrate a third-party library, and you need to know how virtual-thread-friendly it is (to decide between regular worker threads and virtual threads)"
msgstr "スタックトレースをダンプするのは、ログがすでに長い場合はあまり便利ではないかもしれません。幸い、私たちは小さな Junit 5 拡張モジュールをリリースしました。これは、サードパーティのライブラリを統合する際に、 そのライブラリがどの程度仮想スレッドに対応しているのか (通常のワーカースレッドか仮想スレッドかを判断するため) を知っておく必要がある場合に便利です。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:87
#, fuzzy
msgid "The loom-unit Junit5 extension is currently a separated project.  We are integrating it into the Quarkus test framework (under the `junit5-virtual-threads` name), so some of the steps mentioned below won't be necessary anymore or will be changed slightly."
msgstr "loom-unit Junit5エクステンションは、現在分離されたプロジェクトです。Quarkusのテストフレームワーク（ `junit5-virtual-threads` という名前）に統合する予定です。そのため、以下で説明する手順のいくつかは不要になるか、少し変更される予定です。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:89
#, fuzzy
msgid "To use this extension, make sure you have the loom-unit extension in your project:"
msgstr "このエクステンションを使用するには、プロジェクトにloom-unitエクステンションがあることを確認してください："

#. type: delimited block -
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:98
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>me.escoffier.loom</groupId> <!-- Will become io.quarkus.junit5 -->\n"
"    <artifactId>loom-unit</artifactId>   <!-- Will become junit5-virtual-threads -->\n"
"    <version>0.3.0</version>             <!-- Will become unnecessary --> \n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:101
#, fuzzy
msgid "Then, in your test, use `@ExtendWith` to enable the extension:"
msgstr "そして、テストでは、 `@ExtendWith` を使って拡張機能を有効にする："

#. type: delimited block -
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:111
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n"
"@ExtendWith(LoomUnitExtension.class) // <--- Enable the extension (will become @VirtualThreadUnit)\n"
"@ShouldNotPin  // <--- Detect pinning\n"
"class TodoResourceTest {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:115
#, fuzzy
msgid "Finally, use the `@ShouldNotPin` annotation to indicate to fail the test if any of the methods of the test case pins the carrier thread.  You can also use the `@ShouldNotPin` annotation on methods."
msgstr "最後に、 `@ShouldNotPin` アノテーションを使用して、テスト・ケースのメソッドのいずれかがキャ リア・スレッドをピン留めした場合にテストを失敗させることを示します。メソッドに `@ShouldNotPin` アノテーションを使用することもできます。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:118
#, fuzzy
msgid "If, during the execution of a test, a pinning event is captured, the test fails.  The stack trace of the event is attached to the test failure:"
msgstr "テストの実行中にピン留めイベントが発生すると、テストは失敗します。そのイベントのスタックトレースは、テストの失敗に添付されます："

#. type: delimited block -
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:141
#, no-wrap
msgid ""
"java.lang.AssertionError: The test testInitialItems() was expected to NOT pin the carrier thread, but we collected 1 event(s)\n"
"* Pinning event captured: \n"
"\tjava.lang.VirtualThread.parkOnCarrierThread(java.lang.VirtualThread.java:687)\n"
"\tjava.lang.VirtualThread.parkNanos(java.lang.VirtualThread.java:646)\n"
"\tjava.lang.VirtualThread.sleepNanos(java.lang.VirtualThread.java:803)\n"
"\tjava.lang.Thread.sleep(java.lang.Thread.java:507)\n"
"\torg.acme.crud.TodoResource.pinTheCarrierThread(org.acme.crud.TodoResource.java:93)\n"
"\torg.acme.crud.TodoResource.getAll(org.acme.crud.TodoResource.java:32)\n"
"\torg.acme.crud.TodoResource$quarkusrestinvoker$getAll_0e9c86666ef01bafda5560c4bf86952c6cf09993.invoke(org.acme.crud.TodoResource$quarkusrestinvoker$getAll_0e9c86666ef01bafda5560c4bf86952c6cf09993.java:-1)\n"
"\torg.jboss.resteasy.reactive.server.handlers.InvocationHandler.handle(org.jboss.resteasy.reactive.server.handlers.InvocationHandler.java:29)\n"
"\tio.quarkus.resteasy.reactive.server.runtime.QuarkusResteasyReactiveRequestContext.invokeHandler(io.quarkus.resteasy.reactive.server.runtime.QuarkusResteasyReactiveRequestContext.java:141)\n"
"\torg.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext.run(org.jboss.resteasy.reactive.common.core.AbstractResteasyReactiveContext.java:147)\n"
"\tio.quarkus.virtual.threads.ContextPreservingExecutorService$1.run(io.quarkus.virtual.threads.ContextPreservingExecutorService$1.java:36)\n"
"\tjava.util.concurrent.ThreadPerTaskExecutor$TaskRunner.run(java.util.concurrent.ThreadPerTaskExecutor$TaskRunner.java:314)\n"
"\tjava.lang.VirtualThread.runWith(java.lang.VirtualThread.java:341)\n"
"\tjava.lang.VirtualThread.run(java.lang.VirtualThread.java:311)\n"
"\tjava.lang.VirtualThread$VThreadContinuation$1.run(java.lang.VirtualThread$VThreadContinuation$1.java:192)\n"
"\tjdk.internal.vm.Continuation.enter0(jdk.internal.vm.Continuation.java:320)\n"
"\tjdk.internal.vm.Continuation.enter(jdk.internal.vm.Continuation.java:312)\n"
"\tjdk.internal.vm.Continuation.enterSpecial(jdk.internal.vm.Continuation.java:-1)\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:144
#, fuzzy
msgid "Find more about the loom-unit extension on https://github.com/cescoffier/loom-unit[the project repository] or its https://github.com/quarkusio/quarkus/tree/main/independent-projects/junit5-virtual-threads[Quarkus sibling]."
msgstr "loom-unitエクステンションの詳細については、 link:https://github.com/cescoffier/loom-unit[プロジェクトリポジトリ] または link:https://github.com/quarkusio/quarkus/tree/main/independent-projects/junit5-virtual-threads[Quarkusの兄弟] サイトを参照してください。"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:146
#, fuzzy
msgid "## Summary"
msgstr "概要\n"

#. type: Plain text
#: upstream/_posts/2023-09-25-virtual-threads-3.adoc:151
#, fuzzy
msgid "This blog explains how you can detect pinning events while running your tests.  First, you can dump the stack trace in the log.  Second, you can use the `@ShouldNotPin` annotation to fail the tests if a pinning event is captured.  Thanks to this https://github.com/quarkusio/quarkus/pull/35992[PR], the loom-unit extension will be integrated into the `@QuarkusTest` to provide a simpler developer experience.  It will be part of Quarkus in the next release (3.5.x)."
msgstr "このブログでは、テストの実行中にピン止めイベントを検出する方法を説明する。まず、スタックトレースをログにダンプします。次に、 `@ShouldNotPin` アノテーションを使用して、ピニングイベントが発生した場合にテストを失敗させることができます。この link:https://github.com/quarkusio/quarkus/pull/35992[PR の] おかげで、loom-unit 拡張機能が `@QuarkusTest` に統合され、よりシンプルな開発環境を提供できるようになります。次のリリース（3.5.x）ではQuarkusの一部となる予定です。"
