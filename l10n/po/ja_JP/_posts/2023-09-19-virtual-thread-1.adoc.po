# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-15 08:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr "cescoffier"

#. type: YAML Front Matter: date
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:1
#, fuzzy, no-wrap
msgid "2023-09-19"
msgstr "2023-09-19"

#. type: YAML Front Matter: layout
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:1
#, fuzzy, no-wrap
msgid "What do virtual threads change when building concurrent applications with Quarkus."
msgstr "Quarkusで並行アプリケーションを構築する場合、仮想スレッドによって何が変わるのでしょうか。"

#. type: YAML Front Matter: tags
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:1
#, fuzzy, no-wrap
msgid "virtual-threads"
msgstr "仮想スレッド"

#. type: YAML Front Matter: title
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:1
#, fuzzy, no-wrap
msgid "When Quarkus meets Virtual Threads"
msgstr "クアルカスとバーチャル・スレッドの出会い"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:13
#, fuzzy
msgid "Java 21 offers a new feature that will reshape the development of concurrent applications in Java.  For over two years, the Quarkus team explored integrating this new feature to ease the development of distributed applications, including microservices and event-driven applications."
msgstr "Java 21は、Javaでの並行アプリケーション開発を再構築する新機能を提供する。Quarkusチームは2年以上にわたって、マイクロサービスやイベント駆動型アプリケーションなどの分散アプリケーションの開発を容易にするために、この新機能を統合することを検討してきました。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:17
#, fuzzy
msgid "This blog post is the first part of a series of posts and videos demonstrating how to use virtual threads in Quarkus applications.  The series covers REST, messaging, containers, native compilation, and our plans for the future.  But first, let's look at virtual threads, what they change, and what you should know about them."
msgstr "このブログ記事は、Quarkusアプリケーションで仮想スレッドを使用する方法を示す一連の投稿とビデオの最初の部分です。このシリーズでは、REST、メッセージング、コンテナ、ネイティブコンパイル、将来の計画について説明します。その前に、仮想スレッドについて、仮想スレッドによって何が変わるのか、仮想スレッドについて知っておくべきことを説明します。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:19
#, fuzzy
msgid "## The Java world before Java 21"
msgstr "Java21以前のJavaの世界\n"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:26
#, fuzzy
msgid "At the beginning of the Java time, Java had _green threads_.  Green threads were user-level threads scheduled by the Java virtual machine (JVM) instead of natively by the underlying operating system (OS).  They emulated multithreaded environments without relying on native OS abilities.  They were managed in user space instead of kernel space, enabling them to work in environments that do not have native thread support.  Green threads were briefly available in Java between 1997 and 2000.  I used green threads; they did not leave me with a fantastic memory."
msgstr "Java時代の初め、Javaには _グリーンスレッドが_ あった。グリーンスレッドは、基盤となるオペレーティング・システム（OS）がネイティブにスケジューリングするのではなく、Java仮想マシン（JVM）がスケジューリングするユーザーレベルのスレッドだった。OSネイティブの能力に依存することなく、マルチスレッド環境をエミュレートしていた。カーネル空間ではなくユーザー空間で管理されるため、ネイティブのスレッドサポートを持たない環境でも動作する。グリーンスレッドは、1997年から2000年にかけてJavaで短期間利用可能だった。私はグリーンスレッドを使ってみたが、素晴らしい記憶を残すことはできなかった。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:32
#, fuzzy
msgid "In Java 1.3, released in 2000, Java made a big step forward and started integrating OS threads.  So, the threads are managed by the operating system.  It is still the model we are using today.  Each time a Java application creates a thread, a platform thread is created, which wraps an OS thread.  So, creating a platform thread creates an OS thread, and **blocking a platform thread blocks an OS thread**."
msgstr "2000年にリリースされたJava 1.3で、Javaは大きく前進し、OSスレッドの統合を開始した。つまり、スレッドはOSによって管理される。これは現在でも使われているモデルだ。Javaアプリケーションがスレッドを作成するたびに、OSスレッドをラップするプラットフォーム・スレッドが作成される。つまり、プラットフォーム・スレッドを作成するとOSスレッドが作成され、 *プラットフォーム・スレッドをブロックするとOSスレッドがブロック* される。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:40
#, fuzzy
msgid "When you use a Java application framework, you rarely create threads yourself.  It is done for you by the framework.  For example, when your application receives an HTTP request, the framework creates or reuses a platform thread (and so an OS thread) and executes the processing on that thread.  The whole processing runs on this thread, and the thread cannot be reused until the processing completes (so the response is sent back).  When the processing executes a blocking I/O operation, like calling another service, writing to the file system, or interacting with a database, the thread is blocked, waiting for the response.  As mentioned above, the OS thread is also blocked while waiting.  When this response is received, the processing continues:"
msgstr "Javaアプリケーション・フレームワークを使う場合、自分でスレッドを作成することはほとんどない。フレームワークが代わりにやってくれるのだ。例えば、アプリケーションがHTTPリクエストを受信すると、フレームワークはプラットフォーム・スレッド（つまりOSスレッド）を作成または再利用し、そのスレッド上で処理を実行する。すべての処理はこのスレッド上で実行され、処理が完了するまで（つまりレスポンスが送り返されるまで）スレッドを再利用することはできません。処理が他のサービスを呼び出したり、ファイルシステムに書き込んだり、データベースとやりとりしたりするようなブロッキングI/O操作を実行する場合、スレッドはブロックされ、応答を待つ。前述したように、OSスレッドも待機中にブロックされる。この応答を受け取ると、処理は続行される："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:41
#, fuzzy, no-wrap
msgid "Threads involved with the imperative model"
msgstr "命令型モデルに関わるスレッド"

#. type: Target for macro image
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:41
#, no-wrap
msgid "imperative-model.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:50
#, fuzzy
msgid "This model has the advantage of being simple to program with.  The code follows an imperative model.  The code is executed sequentially.  It's simple to write, simple to reason about.  For example, the following snippet shows how you receive an HTTP request, call another HTTP service, and return a response with Quarkus.  It follows the sequence diagram from above."
msgstr "このモデルはプログラミングが簡単という利点がある。コードは命令型モデルに従う。コードは順次実行される。書くのも簡単だし、推論するのも簡単だ。例えば、次のスニペットは、QuarkusでHTTPリクエストを受信し、別のHTTPサービスを呼び出し、レスポンスを返す方法を示しています。先ほどのシーケンス図に従っています。"

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:55
#, no-wrap
msgid ""
"@Path(\"/greetings\")\n"
"public class ImperativeApp {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:57
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:110
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:185
#, no-wrap
msgid "  @RestClient RemoteService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:62
#, no-wrap
msgid ""
"  @GET\n"
"  public String process() {\n"
"    // Runs on a worker (platform) thread because the\n"
"    // method uses a synchronous signature\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:67
#, no-wrap
msgid ""
"    // `service` is a rest client, it executes an I/O operation\n"
"    // (send an HTTP request and waits for the response)\n"
"    var response = service.greetings(); // Blocking, it waits for the response\n"
"                                        // The OS thread is also blocked\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:70
#, no-wrap
msgid ""
"    return response.toUpperCase();\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:72
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:201
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:81
#, fuzzy
msgid "But there is a limit to that imperative model.  You can only handle _n_ requests concurrently, with _n_ the number of threads the framework can create.  OS threads are expensive.  They consume memory (around 1 Mb per thread), are expensive to create, use CPU to schedule them… Frameworks use thread pools to allow reusing idle threads, but when the concurrency level exceeds your number of threads, you start pilling up requests, increasing the response time, and, in the worst case, even rejecting requests.  Increasing the thread pool size and, consequently, swelling the memory usage can blow up your Cloud bill and deployment density.  Futhermore, adding more threads may not even improve the concurrency as explained by the https://youtu.be/07V08SB1l8c?t=142[Little Law]."
msgstr "しかし、この命令型モデルには限界がある。同時に処理できるリクエストは _n個まで_ で、 _nは_ フレームワークが作成できるスレッド数だ。OSのスレッドは高価だ。スレッドはメモリを消費し（1スレッドあたり約1MB）、作成にコストがかかり、スケジューリングにCPUを使う......フレームワークはスレッドプールを使って、アイドル状態のスレッドを再利用できるようにするが、同時実行レベルがスレッド数を超えると、リクエストが山積みになり、応答時間が長くなり、最悪の場合はリクエストを拒否することさえある。スレッドプールのサイズを大きくし、その結果、メモリ使用量を増やすと、クラウドの請求書とデプロイメント密度が吹き飛ぶ可能性があります。さらに、スレッドを増やしても、 link:https://youtu.be/07V08SB1l8c?t=142[リトルの] 法則で説明されているように、同時実行性が改善されるとは限りません。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:90
#, fuzzy
msgid "The reactive movement proposed an alternative model to work around that issue.  It promotes the usage of non-blocking I/O and asynchronous development models to use resources (CPU and memory) more efficiently.  With the reactive model, **a single thread can handle multiple concurrent requests**.  So, instead of having a large pool of threads, you have a minimum number of threads (generally equal to the number of CPU cores).  This small amount of threads, often named event loops, handles all your requests.  When a request is received, it calls the processing code on one of these threads.  When the processing needs to execute an I/O operation, instead of using blocking I/O, it schedules the operations and passes a **continuation**.  This continuation is the code to be invoked when the I/O completes, so basically, the rest of the processing:"
msgstr "リアクティブ・ムーブメントは、この問題を回避するための代替モデルを提案した。それは、リソース（CPUとメモリ）をより効率的に使用するために、ノンブロッキングI/Oと非同期開発モデルの使用を促進するものである。リアクティブ・モデルでは、 *1つのスレッドが複数の同時リクエストを処理できる* 。そのため、スレッドの大規模なプールを持つ代わりに、最小数のスレッド（一般にCPUコア数に等しい）を持つことになる。この少量のスレッドは、しばしばイベントループと名付けられ、すべてのリクエストを処理する。リクエストを受け取ると、これらのスレッドの1つで処理コードを呼び出す。処理がI/O処理を実行する必要がある場合、ブロッキングI/Oを使う代わりに、処理をスケジュールし、 *継続を* 渡します。このコンティニュエーションは、I/Oが完了したときに呼び出されるコードで、基本的には残りの処理を行います："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:91
#, fuzzy, no-wrap
msgid "Thread involved with the reactive model"
msgstr "リアクティブ・モデルに関わるスレッド"

#. type: Target for macro image
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:91
#, no-wrap
msgid "reactive-model.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:101
#, fuzzy
msgid "The reactive model is highly efficient, but there is a catch.  As mentioned, you need to write your code as a chain of continuations.  While there are multiple approaches, such as callbacks, futures, reactive programming, or co-routines, it makes the code harder to reason about.  The code must be structured in a way that may not be natural for every developer.  That limits the adoption of this solution.  Also, the code can not only block during I/O operation; it must not execute lengthy processing (what we call monopolization).  The model's efficiency comes from the ability to process many requests concurrently.  If the thread is used for a long time, it does not allow the other requests to be processed, and, as for the imperative model, you start piling up requests."
msgstr "リアクティブ・モデルは非常に効率的だが、キャッチがある。前述したように、コードを継続の連鎖として書く必要がある。コールバック、フューチャー、リアクティブ・プログラミング、コ・ルーチンなど複数のアプローチがあるが、コードを推論するのが難しくなる。コードは、すべての開発者にとって自然ではない方法で構造化されなければならない。そのため、このソリューションの採用には限界がある。また、コードはI/O操作の間だけブロックすることはできず、長時間の処理（私たちが独占と呼ぶもの）を実行してはならない。このモデルの効率性は、多くのリクエストを同時に処理できることに由来する。スレッドが長時間使用されると、他のリクエストを処理することができなくなり、命令型モデルと同様に、リクエストを積み重ねるようになります。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:103
#, fuzzy
msgid "To illustrate the difference between the imperative and reactive model, the following snippet is equivalent to the previous one: it receives an HTTP request, calls another HTTP service, and returns a response. But this time, it uses the Quarkus reactive model."
msgstr "命令型モデルとリアクティブ・モデルの違いを説明するために、次のスニペットは前のものと同じです：HTTPリクエストを受け取り、別のHTTPサービスを呼び出し、レスポンスを返します。しかし今回は、Quarkusのリアクティブモデルを使用しています。"

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:108
#, no-wrap
msgid ""
"@Path(\"/greetings\")\n"
"public class ReactiveApp {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:115
#, no-wrap
msgid ""
"  @GET\n"
"  public Uni<String> process() {\n"
"    // Runs on an event loop (platform) thread because the\n"
"    // method uses a asynchronous signature\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:126
#, no-wrap
msgid ""
"    // `service` is a rest client, it executes an I/O operation\n"
"    // but this time it returns a Uni<String>, so it's not blocking\n"
"    return service.asyncGreetings() // Non-blocking\n"
"        .map(resp -> {\n"
"          // This is the continuation, the code executed once the\n"
"          // response is received\n"
"          return resp.toUpperCase();\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:129
#, fuzzy
msgid "An application with this code handles more concurrent requests and uses less memory than the imperative one, but, the development model is different."
msgstr "このコードを使ったアプリケーションは、命令型のものより多くの同時リクエストを処理し、より少ないメモリーしか使いませんが、開発モデルは異なります。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:134
#, fuzzy
msgid "Most of the time, the reactive and imperative models are opposed.  This does not need to be the case.  Quarkus uses a reactive core and lets you decide if you want to use the reactive or imperative model.  Check the https://quarkus.io/blog/resteasy-reactive-smart-dispatch/['to block or not to block' article] for more details about this ability."
msgstr "たいていの場合、リアクティブ・モデルと命令形モデルは対立する。しかし、その必要はありません。Quarkusはリアクティブコアを使用しており、リアクティブモデルを使用するか、命令型モデルを使用するかを決めることができます。この機能の詳細については、 link:https://quarkus.io/blog/resteasy-reactive-smart-dispatch/['to block or not to block'] の記事を確認してください。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:136
#, fuzzy
msgid "## What do virtual threads change?"
msgstr "仮想スレッドは何を変えるのか？\n"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:139
#, fuzzy
msgid "Java 19 introduced a new type of thread: virtual threads.  In Java 21, this API became generally available."
msgstr "Java 19では、仮想スレッドという新しいタイプのスレッドが導入された。Java 21では、このAPIが一般的に利用できるようになった。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:143
#, fuzzy
msgid "But what are these virtual threads? Virtual threads reuse the idea of the reactive paradigm but allow an imperative development model.  You get the benefits from the reactive and imperative models without the drawbacks!"
msgstr "しかし、この仮想スレッドとは何だろうか？仮想スレッドはリアクティブ・パラダイムのアイデアを再利用し、命令型開発モデルを可能にする。リアクティブモデルと命令型モデルの利点を、欠点なしに得ることができる！"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:148
#, fuzzy
msgid "Like with green threads, virtual threads are managed by the JVM.  Virtual threads occupy less space than platform threads in memory.  Hence, using more virtual threads than platform threads simultaneously becomes possible without blowing up the memory.  Virtual threads are supposed to be disposable entities that we create when we need them; pooling or reusing them for different tasks is discouraged."
msgstr "グリーンスレッドと同様に、仮想スレッドはJVMによって管理される。仮想スレッドは、メモリ内でプラットフォーム・スレッドよりも少ないスペースを占有する。そのため、メモリを消費することなく、プラットフォーム・スレッドよりも多くの仮想スレッドを同時に使用することが可能になる。仮想スレッドは、必要なときに作成する使い捨てのものであり、異なるタスクのためにプールしたり再利用したりすることは推奨されない。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:159
#, fuzzy
msgid "But what does it change? Blocking a virtual thread is, in general, very cheap! There is a pinch of magic that makes virtual thread very appealing.  When your code running on a virtual thread needs to execute an I/O operation, it uses a blocking API.  So, the code waits for the result, as with the imperative model.  However, since the JVM manages virtual threads, no underlying OS thread is blocked when they perform this blocking operation.  The state of the virtual thread is stored in the heap, and another virtual thread can be executed on the same Java platform (carrier) thread, exactly as in the reactive model.  When the I/O operation completes, the virtual thread becomes executable again, and when a carrier thread is available, the state of the virtual thread is restored, and the execution continues.  For the developer, this magic is invisible! You just write synchronous code, and it's executed like proper reactive code without blocking the OS thread."
msgstr "しかし、それで何が変わるのか？バーチャル・スレッドをブロックすることは、一般的に非常に安価である！仮想スレッドを非常に魅力的なものにしている魔法のピンチがある。仮想スレッド上で動作するコードがI/O操作を実行する必要がある場合、ブロッキングAPIを使用する。つまり、コードは命令型モデルと同じように結果を待つ。しかし、JVMは仮想スレッドを管理するので、OSスレッドがこのブロッキング操作を実行するときにブロックされることはない。仮想スレッドの状態はヒープに保存され、リアクティブ・モデルとまったく同じように、同じJavaプラットフォーム（キャリア）のスレッド上で別の仮想スレッドを実行することができる。I/O操作が完了すると、仮想スレッドは再び実行可能になり、キャリア・スレッドが利用可能になると、仮想スレッドの状態が復元され、実行が継続される。開発者にとって、このマジックは目に見えない！同期コードを書くだけで、OSスレッドをブロックすることなく、適切なリアクティブ・コードのように実行される。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:161
#, fuzzy
msgid "Your code runs on top of virtual threads, but under the hood, only a few carrier threads execute them."
msgstr "あなたのコードは仮想スレッドの上で実行されるが、その裏では少数のキャリア・スレッドだけがそれを実行する。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:163
#, fuzzy
msgid "To summarize, virtual threads are:"
msgstr "要約すると、仮想スレッドとは"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:165
#, fuzzy
msgid "Lightweight - you can have a LOT of them"
msgstr "軽量 - たくさん持てる"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:166
#, fuzzy
msgid "Cheap to create - no need to pool them anymore"
msgstr "プールはもう必要ない。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:167
#, fuzzy
msgid "Cheap to block when using blocking operations - blocking a virtual thread does not block the underlying OS thread when executing I/O operations"
msgstr "I/O操作の実行時に仮想スレッドをブロックしても、OSスレッドはブロックされない。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:169
#, fuzzy
msgid "## How can you use virtual threads in Quarkus?"
msgstr "Quarkusで仮想スレッドを使用する方法を教えてください。\n"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:173
#, fuzzy
msgid "Using virtual threads in Quarkus is straightforward.  You only need to use the `@RunOnVirtualThread` annotation.  It indicates to Quarkus to invoke the annotated method on a virtual thread instead of a regular platform thread."
msgstr "Quarkusで仮想スレッドを使用するのは簡単です。 `@RunOnVirtualThread` アノテーションを使用するだけです。このアノテーションは、Quarkusに対して、通常のプラットフォームのスレッドではなく、仮想スレッド上でアノテーションされたメソッドを呼び出すことを示します。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:176
#, fuzzy
msgid "This new strategy extends the _smart dispatch_ explained in the https://quarkus.io/blog/resteasy-reactive-smart-dispatch/['to block or not to block' article]. In addition to the signature, Quarkus now looks for this specific annotation.  If your JVM does not provide virtual thread support, it does fall back to platform threads."
msgstr "この新しい戦略は、 link:https://quarkus.io/blog/resteasy-reactive-smart-dispatch/[「ブロックするかしないか」の記事で] 説明した _スマートディスパッチを_ 拡張したものである。シグネチャに加えて、Quarkusはこの特定のアノテーションを探します。JVMが仮想スレッドサポートを提供していない場合、プラットフォーム・スレッドにフォールバックします。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:178
#, fuzzy
msgid "Let's rewrite the same example using a virtual thread (the full code is available in https://github.com/quarkusio/virtual-threads-demos/tree/main/rest-example[this repository]):"
msgstr "同じ例を仮想スレッドを使って書き直してみよう（完全なコードは link:https://github.com/quarkusio/virtual-threads-demos/tree/main/rest-example[このリポジトリに] ある）："

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:183
#, no-wrap
msgid ""
"@Path(\"/greetings\")\n"
"public class VirtualThreadApp {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:191
#, no-wrap
msgid ""
"  @GET\n"
"  @RunOnVirtualThread\n"
"  public String process() {\n"
"    // Runs on a virtual thread because the\n"
"    // method uses the @RunOnVirtualThread annotation.\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:199
#, no-wrap
msgid ""
"    // `service` is a rest client, it executes an I/O operation\n"
"    var response = service.greetings(); // Blocking, but this time, it \n"
"                                        // does neither block the carrier thread\n"
"                                        // nor the OS thread.\n"
"                                        // Only the virtual thread is blocked.\n"
"\treturn response.toUpperCase();\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:204
#, fuzzy
msgid "It's the code from the first snippet (the imperative one), but its execution model is closer to the reactive one:"
msgstr "これは最初のスニペット（命令型）のコードだが、実行モデルはリアクティブに近い："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:205
#, fuzzy, no-wrap
msgid "Threads involved with virtual threads"
msgstr "仮想スレッドに関わるスレッド"

#. type: Target for macro image
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:205
#, no-wrap
msgid "virtual-thread-model-2.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:213
#, fuzzy
msgid "For every request, a virtual thread is created.  When a carrier thread is idle, the virtual thread is mounted on that carrier thread and executed.  When the virtual thread needs to execute the I/O (the call to the remote service), it only blocks the virtual thread.  The carrier thread is released, and can mount another virtual thread (like the one handling the second request while the I/O from the first one is pending).  When the I/O completes, a carrier thread (not necessarily the same one) restores the blocked virtual thread and continues its execution until the response is ready to be sent back to the client.  The code snippet works as described because the Quarkus REST client is virtual-thread-friendly; we will see exceptions in the next section."
msgstr "リクエストごとに仮想スレッドが生成される。キャリアスレッドがアイドル状態のとき、仮想スレッドはそのキャリアスレッドにマウントされ、実行される。仮想スレッドがI/O（リモートサービスの呼び出し）を実行する必要があるときは、仮想スレッドだけをブロックする。キャリアスレッドは解放され、別の仮想スレッドをマウントできるようになる（最初のスレッドからのI/Oが保留されている間に、2番目のリクエストを処理するスレッドのように）。I/Oが完了すると、キャリアスレッド（同じスレッドである必要はない）がブロックされた仮想スレッドをリストアし、レスポンスがクライアントに送り返す準備ができるまで実行を継続する。Quarkus RESTクライアントは仮想スレッドフレンドリーであるため、このコードスニペットは説明どおりに動作します。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:216
#, fuzzy
msgid "Virtual threads in Quarkus are not limited to HTTP endpoints.  The following snippet shows how you can process Kafka/Pulsar/AMQP messages on virtual threads:"
msgstr "Quarkusの仮想スレッドはHTTPエンドポイントに限定されません。次のスニペットは、仮想スレッドでKafka/Pulsar/AMQPメッセージを処理する方法を示しています："

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:225
#, no-wrap
msgid ""
"@Incoming(\"events\")\n"
"@Transactional\n"
"@RunOnVirtualThread\n"
"public void persistEventInDatabase(Event event) {\n"
"  event.persist(); // Use Hibernate ORM with Panache\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:230
#, fuzzy
msgid "Attentive readers may have seen that the virtual thread integration relies on _reactive_ extensions.  These extensions provide more flexibility (such as the control on which thread the processing is executed) to integrate virtual threads properly and efficiently.  It's important to understand that for the developer, it's invisible (except the `@RunOnVirtualThread` annotation)."
msgstr "注意深い読者なら、仮想スレッドの統合が _リアクティブ_ 拡張に依存していることをご存知だろう。これらの拡張は、仮想スレッドを適切かつ効率的に統合するために、（どのスレッドで処理を実行するかを制御するなど）より柔軟性を提供する。開発者にとっては（ `@RunOnVirtualThread` アノテーションを除いて）目に見えないものであることを理解することが重要だ。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:233
#, fuzzy
msgid "## Five things you need to know before using virtual threads for everything"
msgstr "あらゆることに仮想スレッドを使う前に知っておくべき5つのこと\n"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:238
#, fuzzy
msgid "Well, you probably see this coming.  There is no free lunch.  You need to know a few things before utilizing virtual threads for everything.  These are the reasons why, currently, there is no global switch to run exclusively on virtual threads in Quarkus."
msgstr "まあ、こうなることは予想していただろう。フリーランチはないのだ。すべてのことに仮想スレッドを利用する前に、いくつかのことを知っておく必要があります。現在のところ、Quarkusに仮想スレッドだけで実行するグローバルスイッチがないのは、こうした理由からです。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:240
#, fuzzy
msgid "### 1. Pinning"
msgstr "1.ピン留め"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:244
#, fuzzy
msgid "As described above, when a virtual thread executes a blocking operation, it gets unmounted from the carrier thread, preventing the carrier thread from being blocked.  However, sometimes, the virtual thread cannot be unmounted because its state cannot be stored in the heap.  It happens when the thread holds a monitor lock or has a native call in the stack:"
msgstr "上述したように、仮想スレッドがブロッキング処理を実行すると、キャリア・スレッドからアンマウントされ、キャリア・スレッドがブロックされるのを防ぐことができる。しかし、仮想スレッドの状態をヒープに保存できないために、仮想スレッドをアンマウントできないことがある。これは、スレッドがモニター・ロックを保持しているか、スタックにネイティブ・コールがある場合に発生する："

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:255
#, no-wrap
msgid ""
"Object monitor = new Object();\n"
"//...\n"
"public void aMethodThatPinTheCarrierThread() throws Exception {\n"
"  synchronized(monitor) {\n"
"    Thread.sleep(1000); // The virtual thread cannot be unmounted because it holds a lock, \n"
"                        // so the carrier thread is blocked.\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:258
#, fuzzy
msgid "In this case, the carrier thread is blocked, so the OS thread is blocked:"
msgstr "この場合、キャリア・スレッドはブロックされているので、OSスレッドもブロックされている："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:259
#, fuzzy, no-wrap
msgid "Pinning of the carrier thread"
msgstr "キャリア糸のピン止め"

#. type: Target for macro image
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:259
#, no-wrap
msgid "pinning.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:265
#, fuzzy
msgid "Unfortunately, as of today, lots of Java libraries are pinning the carrier thread.  The Quarkus team and Red Hat, in general, have patched many libraries (such as Narayana (the transaction manager of Quarkus) or Hibernate ORM) to avoid pinning.  However, when you use a library, be careful.  It will take time until all the code gets reworked in a more virtual-thread-friendly way."
msgstr "残念ながら、今日現在、多くのJavaライブラリがキャリアスレッドを固定化しています。QuarkusチームとRed Hatは、一般的に、多くのライブラリ（Narayana（Quarkusのトランザクションマネージャ）やHibernate ORMなど）にパッチを適用し、pinningを回避しています。しかし、ライブラリを使用する際には注意が必要です。すべてのコードがより仮想スレッドに優しい方法で作り直されるまで、時間がかかるだろう。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:267
#, fuzzy
msgid "### 2. Monopolization"
msgstr "2.独占"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:273
#, fuzzy
msgid "As for the reactive model, if the virtual thread executes intensive and long computation, it monopolizes that carrier.  The virtual thread scheduler is not preemptive.  So it cannot interrupt a running thread.  It needs to wait for an I/O or the completion of the computation.  Until then, this carrier thread cannot execute other virtual threads:"
msgstr "リアクティブ・モデルに関しては、仮想スレッドが集中的で長い計算を実行する場合、そのキャリアを独占する。仮想スレッドスケジューラはプリエンプティブではない。そのため、実行中のスレッドに割り込むことはできない。I/Oか計算の完了を待つ必要がある。それまでは、このキャリア・スレッドは他の仮想スレッドを実行できない："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:274
#, fuzzy, no-wrap
msgid "Monopolization of the carrier thread"
msgstr "キャリア・スレッドの独占"

#. type: Target for macro image
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:274
#, no-wrap
msgid "monopolization.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:277
#, fuzzy
msgid "Using a dedicated platform thread pool might be wiser when executing long computations."
msgstr "長い計算を実行する場合は、専用のプラットフォーム・スレッド・プールを使う方が賢明かもしれない。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:279
#, fuzzy
msgid "### 3. Carrier thread pool elasticity"
msgstr "3.キャリア糸プールの弾性"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:281
#, fuzzy
msgid "When there is pinning or monopolization, the JVM may create new carrier threads (as illustrated on the previous picture) to avoid having too many unscheduled virtual threads."
msgstr "ピン留めや独占がある場合、JVMはスケジュールされていない仮想スレッドが増えすぎないように、新しいキャリア・スレッドを作成することがある（前の図に示されているように）。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:287
#, fuzzy
msgid "These creations are creating platform/OS threads.  So, it's expensive and uses memory.  You especially need to pay attention to the second point.  You may hit the memory limit if you run on low resources and your code is not very virtual-thread-friendly, meaning that you should always check for pinning, monopolization, and memory usage.  If you don't, in a container with memory constraints, the application can be killed."
msgstr "これらの作成は、プラットフォーム／OSのスレッドを作成している。だから、コストがかかるし、メモリも使う。特に2番目の点には注意が必要だ。少ないリソースで実行し、コードがあまり仮想スレッドに優しくない場合、メモリ制限にぶつかる可能性があります。つまり、ピン留め、独占、メモリ使用量を常にチェックする必要があります。メモリ制約のあるコンテナでは、そうしないとアプリケーションが強制終了される可能性がある。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:289
#, fuzzy
msgid "### 4. Object pooling"
msgstr "4.オブジェクトプール"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:302
#, fuzzy
msgid "For years, threads were scarce resources.  It was recommended to pool them and reuse them.  This good practice has encouraged the use of thread locals as an object-pooling mechanism.  Like https://github.com/FasterXML/jackson-core/issues/919[Jackson] or Netty, many libraries store expensive objects in thread locals.  These objects can only be accessed by the code running on the thread in which the objects are stored.  Because the number of threads was limited, it capped the number of creation.  Also, because threads were reused, the objects were cached and reused.  Unfortunately, these two assumptions are not valid with virtual threads: You can have a lot of them, they are not reused.  It's even discouraged to pool them.  Thus, libraries utilizing these pooling patterns may underperform when using virtual threads.  You will see many allocations of large objects, as every virtual thread will get its own instance of the object."
msgstr "何年もの間、スレッドは希少資源だった。スレッドをプールして再利用することが推奨されていた。このグッドプラクティスは、オブジェクト・プールのメカニズムとしてスレッド・ローカルの使用を奨励した。 link:https://github.com/FasterXML/jackson-core/issues/919[Jacksonや] Nettyのように、多くのライブラリは高価なオブジェクトをスレッドローカルに格納する。これらのオブジェクトは、オブジェクトが格納されているスレッドで実行されているコードによってのみアクセスできる。スレッド数が制限されているため、作成数に上限がある。また、スレッドは再利用されるため、オブジェクトはキャッシュされて再利用される。残念ながら、仮想スレッドではこの2つの前提が成り立たない：スレッドはたくさんあっても再利用されない。仮想スレッドはたくさんあってもいいし、再利用されることはない。したがって、このようなプール・パターンを利用するライブラリは、仮想スレッドを使用する際にパフォーマンスが低下する可能性がある。すべての仮想スレッドがオブジェクトのインスタンスを取得するため、大きなオブジェクトのアロケーションが多く発生します。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:306
#, fuzzy
msgid "Replacing this pattern is not an easy task.  As an example, this https://github.com/FasterXML/jackson-core/pull/1064[PR] from Mario Fusco proposes an SPI for Jackson.  Quarkus will implement the SPI to provide a virtual-thread-friendly pool mechanism."
msgstr "このパターンを置き換えるのは簡単なことではない。一例として、Mario Fuscoによるこの link:https://github.com/FasterXML/jackson-core/pull/1064[PRは] 、Jackson用のSPIを提案している。QuarkusはこのSPIを実装し、仮想スレッドに優しいプールメカニズムを提供する。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:308
#, fuzzy
msgid "### 5. Stressing thread safety"
msgstr "5.糸の安全性を強調する"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:312
#, fuzzy
msgid "Virtual threads provide a new way to build concurrent applications in Java.  You are not limited by the number of threads in the pool.  You do not have to use asynchronous development models."
msgstr "仮想スレッドは、Javaで並行アプリケーションを構築する新しい方法を提供する。プール内のスレッド数に制限されることはない。非同期開発モデルを使用する必要はありません。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:317
#, fuzzy
msgid "But, before rewriting your application to leverage this new mechanism, ensure the code is thread-safe.  Many libraries and frameworks do not allow concurrent access to some objects.  For example, database connections should not be accessed concurrently.  You must be cautious when you have many virtual threads, especially when using the structured concurrency API (still in preview in Java 21)."
msgstr "しかし、この新しいメカニズムを活用するためにアプリケーションを書き直す前に、コードがスレッドセーフであることを確認してほしい。多くのライブラリやフレームワークは、オブジェクトによっては同時アクセスを許可していない。例えば、データベース接続は同時アクセスすべきではない。特に構造化同時実行API（Java 21ではまだプレビュー中）を使う場合は、多くの仮想スレッドを持つ場合に注意しなければならない。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:320
#, fuzzy
msgid "When using structured concurrency, it becomes easy to run tasks in _parallel_.  However, you must be absolutely sure that these tasks to not access a shared state which do not support concurrent access:"
msgstr "構造化並行処理を使用すると、タスクの _並列_ 実行が容易になる。しかし、これらのタスクが、同時アクセスをサポートしていない共有ステートにアクセスしないことを絶対に確認しなければならない："

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:337
#, no-wrap
msgid ""
"@GET\n"
"@RunOnVirtualThread\n"
"public String structuredConcurrencyExample() throws InterruptedException, ExecutionException {\n"
"    var someState = ... // Must be thread-safe, as multiple virtual thread will access\n"
"                        // it concurrently\n"
"    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n"
"        var task1 = scope.fork(() -> { \n"
"          // Run in another virtual thread\n"
"          return someState.touch();\n"
"        });\n"
"        var task2 = scope.fork(() -> {\n"
"          // Run in another virtual thread\n"
"          return someState.touch(); \n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:339
#, no-wrap
msgid "        scope.join().throwIfFailed();\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:343
#, no-wrap
msgid ""
"        return task1.get() + \"/\" + task2.get();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:348
#, fuzzy
msgid "## Summary and what's next This post described the new kind of thread available in Java 21 and how to use them in Quarkus.  Virtual threads are not a silver bullet, and while they can improve the concurrency, there are a few limitations you need to be aware of:"
msgstr "まとめと今後の課題 この記事では、Java 21で使用できる新しい種類のスレッドと、Quarkusでの使用方法について説明しました。仮想スレッドは銀の弾丸ではなく、並行性を向上させることはできますが、いくつか注意しなければならない制限があります：\n"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:350
#, fuzzy
msgid "Many libraries are pinning the carrier thread; it will take time until the Java world becomes virtual-thread-friendly."
msgstr "Javaの世界が仮想スレッドフレンドリーになるまでには時間がかかるだろう。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:351
#, fuzzy
msgid "Lengthy computations must be analyzed cautiously to avoid monopolization issues."
msgstr "長い計算は、独占の問題を避けるために慎重に分析しなければならない。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:352
#, fuzzy
msgid "The carrier thread pool elasticity may result in high memory usage."
msgstr "キャリア・スレッド・プールの弾力性により、メモリ使用量が多くなる可能性がある。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:353
#, fuzzy
msgid "The thread-local object polling pattern can have terrible consequences on the allocations and memory usage."
msgstr "スレッド・ローカル・オブジェクト・ポーリング・パターンは、割り当てとメモリ使用量にひどい結果をもたらす可能性がある。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:354
#, fuzzy
msgid "Virtual threads do not prevent thread safety issues."
msgstr "仮想スレッドはスレッドセーフの問題を防ぐものではない。"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:357
#, fuzzy
msgid "It is the first part (and the most boring, hopefully) post of a multiple-post series.  Next, we will cover:"
msgstr "この記事は、複数回に分けて掲載するシリーズの第1部（そしてできれば最も退屈な）記事である。次に取り上げるのは"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:359
#, fuzzy
msgid "https://quarkus.io/blog/virtual-threads-2/[How to write a crud application using virtual threads]"
msgstr "link:https://quarkus.io/blog/virtual-threads-2/[仮想スレッドを使った粗悪なアプリケーションの書き方]"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:360
#, fuzzy
msgid "https://quarkus.io/blog/virtual-threads-3/[How to test virtual threads applications]"
msgstr "link:https://quarkus.io/blog/virtual-threads-3/[仮想スレッドアプリケーションのテスト方法]"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:361
#, fuzzy
msgid "https://quarkus.io/blog/virtual-threads-4/[How to process Kafka messages using virtual threads]"
msgstr "link:https://quarkus.io/blog/virtual-threads-4/[仮想スレッドを使用してKafkaメッセージを処理する方法]"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:362
#, fuzzy
msgid "How to build a native executable when using virtual threads (_to be published_)"
msgstr "仮想スレッド使用時のネイティブ実行ファイルのビルド方法 _（公開予定）_"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:363
#, fuzzy
msgid "How to containerize an application using virtual threads (in JVM mode) (_to be published_)"
msgstr "仮想スレッド（JVMモード）を使用してアプリケーションをコンテナ化する方法 _（公開予定）_"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:364
#, fuzzy
msgid "How to containerize an application using virtual threads in native mode (_to be published_)"
msgstr "ネイティブ・モードで仮想スレッドを使用してアプリケーションをコンテナ化する方法 _（公開予定）_"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:365
#, fuzzy
msgid "How to process Kafka messages using virtual threads (_to be published_)"
msgstr "仮想スレッドを使ったKafkaメッセージの処理方法 _（公開予定）_"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:366
#, fuzzy
msgid "What are we exploring to improve the virtual thread support in Quarkus (_to be published_)"
msgstr "Quarkusの仮想スレッドサポートを改善するために模索していること _（公開予定）_"

#. type: Plain text
#: upstream/_posts/2023-09-19-virtual-thread-1.adoc:368
#, fuzzy
msgid "To know more about the virtual thread support in Quarkus, check the https://quarkus.io/guides/virtual-threads[Virtual thread reference guide]."
msgstr "Quarkusの仮想スレッドサポートの詳細については、 link:https://quarkus.io/guides/virtual-threads[仮想スレッドリファレンスガイドを] 参照してください。"

#, fuzzy
#~ msgid "How to test virtual threads applications (_to be published_)"
#~ msgstr "バーチャル・スレッド・アプリケーションのテスト方法 _（公開予定）_"
