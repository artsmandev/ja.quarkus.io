# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-09-18 00:28+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr "cescoffier"

#. type: YAML Front Matter: date
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "2022-09-15"
msgstr "2022-09-15"

#. type: YAML Front Matter: layout
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "Implementing a job queue using Redis list and the Quarkus Redis extension"
msgstr "RedisリストとQuarkus Redisエクステンションを使用したジョブキューの実装"

#. type: YAML Front Matter: tags
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "redis"
msgstr "レディス"

#. type: YAML Front Matter: title
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:1
#, fuzzy, no-wrap
msgid "How to implement a job queue with Redis"
msgstr "Redisでジョブキューを実装する方法"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:14
#, fuzzy
msgid "In https://quarkus.io/blog/redis-api-intro/[how to cache with Redis], we implemented a simple cache backed by Redis. + That's just one use case of Redis.  Redis is also used as a messaging server to implement the processing of background jobs or other kinds of messaging tasks.  This post explores implementing this pattern with Quarkus and the new Redis data source API."
msgstr "link:https://quarkus.io/blog/redis-api-intro/[Redisを使ったキャッシュの] 作り方では、Redisをバックにした簡単なキャッシュを実装しました。+ これはRedisの1つの使用例に過ぎません。Redisは、バックグラウンドジョブやその他の種類のメッセージングタスクの処理を実装するためのメッセージングサーバーとしても使用されます。この記事では、Quarkusと新しいRedisデータソースAPIを使用してこのパターンを実装することを検討します。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:15
#, fuzzy, no-wrap
msgid "Job Queues and Supes!"
msgstr "ジョブキューとスーペル!"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:20
#, fuzzy
msgid "A job queue is a data structure storing _execution_ requests.  Job dispatchers submit the tasks they want to execute in that data structure.  On the other side, job consumers poll the requests and execute them."
msgstr "ジョブキューは、 _実行_ 要求を格納するデータ構造です。ジョブディスパッチャは、実行したいタスクをそのデータ構造に登録します。一方、ジョブコンシューマは、その要求をポーリングして実行します。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:21
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/pattern.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:27
#, fuzzy
msgid "There are plenty of variants of that pattern, so let's focus on the following application.  We have an application managing heroes and villains.  The application offers the possibility to simulate a fight between a random hero and a random villain.  The fight simulation is delegated to _fight simulators_, applications dedicated to that task."
msgstr "このパターンのバリエーションはたくさんあるので、次のアプリケーションに焦点を当てましょう。ヒーローと悪役を管理するアプリケーションがあります。このアプリケーションでは、ランダムなヒーローとランダムな悪役の戦いをシミュレートすることができます。戦闘のシミュレーションは、 _戦闘シミュレータという_ 専用のアプリケーションに委ねられます。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:28
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/application.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:32
#, fuzzy
msgid "In this context, the main application submits the fight request to the job queue.  Then, the fight simulators poll the submitted fight request and execute them."
msgstr "この中で、メイン・アプリケーションは、戦闘要求をジョブ・キューに提出する。そして、戦闘シミュレータは提出された戦闘要求をポーリングして実行する。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:36
#, fuzzy
msgid "The fight outcomes are communicated using another Redis feature: pub/sub communication.  The simulators send the outcome to a _channel_ consumed by the application.  The application then broadcasts these outcomes to a web page."
msgstr "戦いの結果は、Redisのもう一つの機能であるpub/sub通信を利用して伝えられます。シミュレータは、アプリケーションによって消費される _チャネルに_ 結果を送信します。そして、アプリケーションはその結果をウェブページにブロードキャストします。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:40
#, fuzzy
msgid "This post only discusses the interaction with Redis.  The rest of the application is straightforward and just uses RESTEasy Reactive and Hibernate ORM with Panache.  You can find the full code of the application on https://github.com/cescoffier/quarkus-redis-job-queue-demo."
msgstr "この記事では、Redisとのインタラクションについてのみ説明します。アプリケーションの他の部分は単純で、RESTEasy ReactiveとHibernate ORM with Panacheを使用しているだけです。このアプリケーションの完全なコードは https://github.com/cescoffier/quarkus-redis-job-queue-demo  で見ることができます。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:41
#, fuzzy, no-wrap
msgid "Submitting jobs"
msgstr "求人情報の提供"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:45
#, fuzzy
msgid "The first task is to model the job queue.  We are using a https://redis.io/docs/data-types/#lists[Redis list] to store the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightRequest.java[FightRequest]."
msgstr "最初のタスクは、ジョブキューのモデル化です。 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightRequest.java[FightRequestを] 格納するために link:https://redis.io/docs/data-types/#lists[Redisリストを] 使用しています。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:49
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:153
#, no-wrap
msgid "package me.escoffier.quarkus.redis.fight;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:51
#, no-wrap
msgid "public record FightRequest(String id, Hero hero, Villain villain) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:53
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:157
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:57
#, fuzzy
msgid "Redis lists distinguish the left side of the list from the right side of the list.  This distinction allows implementing a FIFO queue where we write on the left side and consume from the right side."
msgstr "Redis のリストは、リストの左側と右側を区別しています。この区別によって、左側から書き込み、右側から消費するFIFOキューを実装することができます。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:60
#, fuzzy
msgid "To manipulate a Redis list, we need the _group of commands_ associated with this data structure.  In the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[SupesService class], we inject the `RedisDataSource` and retrieve the group of commands:"
msgstr "Redis のリストを操作するには、このデータ構造に関連する _コマンド_ 群が必要です。 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[SupesService クラスでは] 、 `RedisDataSource` をインジェクトして、コマンド群を取得します。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:67
#, no-wrap
msgid ""
"public SupesService(RedisDataSource dataSource, ...) {\n"
"    commands = dataSource.list(FightRequest.class);\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:70
#, fuzzy
msgid "Let's now look at the `submitAFight` method:"
msgstr "次に、 `submitAFight` の方法について見てみましょう。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:81
#, no-wrap
msgid ""
"public FightRequest submitAFight() {\n"
"    var hero = Hero.getRandomHero();\n"
"    var villain = Villain.getRandomVillain();\n"
"    var id = UUID.randomUUID().toString();\n"
"    var request = new FightRequest(id, hero, villain);\n"
"    commands.lpush(\"fight-requests\", request);\n"
"    return request;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:85
#, fuzzy
msgid "The `submitAFight` method retrieves the random fighters, computes an id, builds the `FightRequest` instance, and executes the `LPUSH` command.  The `LPUSH` command writes the given item to the left side of the list stored at the given key (`fight-requests`)."
msgstr " `submitAFight` メソッドはランダムファイターを取得し、idを計算し、 `FightRequest` インスタンスを構築し、 `LPUSH` コマンドを実行します。 `LPUSH` コマンドは、与えられたキー( `fight-requests` )に格納されているリストの左側に、与えられた項目を書き込む。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:86
#, fuzzy, no-wrap
msgid "Receiving the job requests"
msgstr "仕事の依頼を受ける"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:90
#, fuzzy
msgid "Let's now look at the other side: the fight simulators.  The simulators poll the `FightRequests` from the Redis list representing our job queue and simulate the fight."
msgstr "では、もう一方の戦闘シミュレータを見てみましょう。シミュレータはジョブキューを表す Redis リストから `FightRequests` をポーリングし、戦闘をシミュレートします。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:94
#, fuzzy
msgid "The simulator is implemented in https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightSimulator.java[`me.escoffier.quarkus.redis.fight.FightSimulator`].  The constructor receives a configured name (to distinguish multiple simulators) and the Redis data source.  It creates the objects to emit the Redis commands to read from a Redis list:"
msgstr "シミュレータの実装は link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/fight-simulator/src/main/java/me/escoffier/quarkus/redis/fight/FightSimulator.java[`me.escoffier.quarkus.redis.fight.FightSimulator`] .コンストラクタは、設定された名前（複数のシミュレータを区別するため）とRedisデータソースを受け取ります。Redisのリストから読み込むためのRedisコマンドを発行するためのオブジェクトを生成します。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:102
#, no-wrap
msgid ""
"public FightSimulator(@ConfigProperty(name = \"simulator-name\") String name, RedisDataSource ds) {\n"
"    this.name = name;\n"
"    this.queue = ds.list(FightRequest.class);\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:109
#, fuzzy
msgid "The simulator polls the fight requests and for each of them simulate the fight.  The implementation is an _infinite_ loop (it only stops when the application is shut down).  In each iteration, it reads the pending `FightRequest` from the right side of the queue with the `BRPOP` command.  If there is no pending request, it restarts from the beginning of the loop.  If it has a request, it simulates the fight:"
msgstr "シミュレータは戦闘要求をポーリングし、そのそれぞれについて戦闘をシミュレートする。実装は _無限_ ループです(アプリケーションがシャットダウンされたときのみ停止します)。各反復で、キューの右側から保留中の `FightRequest` を `BRPOP` コマンドで読み取ります。もし保留中のリクエストがなければ、ループの最初からやり直す。要求がある場合は、戦闘をシミュレートする。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:125
#, no-wrap
msgid ""
"@Override\n"
"public void run() {\n"
"    logger.infof(\"Simulator %s starting\", name);\n"
"    while ((!stopped)) {\n"
"        KeyValue<String, FightRequest> item =\n"
"            queue.brpop(Duration.ofSeconds(1), \"fight-requests\");\n"
"        if (item != null) {\n"
"            var request = item.value();\n"
"            var result = simulate(request);\n"
"            //...\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:134
#, fuzzy
msgid "The `BRPOP` command retrieves and removes the last (right) element of the list.  Unlike the `RPOP`, it waits for a given amount of time (1 second in the code above) if there are no elements in the list.  So, if the list contains an element, it gets it.  Otherwise, it waits up to one second before giving up.  It returns `null` in this case.  The `BRPOP` command returns a `KeyValue` composed of the key of the list and the `FightRequest`.  It uses that structure because you can pass multiple keys, which is convenient when you have lists with priorities."
msgstr " `BRPOP` コマンドは、リストの最後（右）の要素を取得し、削除します。 `RPOP` とは異なり、リストに要素がない場合は指定された時間（上記のコードでは1秒）待機します。つまり、リストに要素がある場合はそれを取得します。そうでない場合は、最大で1秒間待ってからあきらめます。この場合、 `null` を返します。 `BRPOP` コマンドは，リストのキーと `FightRequest` からなる `KeyValue` を返します． この構造を使うのは，複数のキーを渡すことができるからで，優先順位を持つリストがある場合に便利です．"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:139
#, fuzzy
msgid "The `BRPOP` command also avoids spinning indefinitely if the list is empty, as it waits for 1 second during each iteration.  Finally, the `BRPOP` command is _atomic_.  It means that if you have multiple simulators, they cannot retrieve the same item.  It dispatches each item once."
msgstr "また、 `BRPOP` コマンドは、各反復の間に1秒待つので、リストが空の場合、無限にスピンするのを避けることができます。最後に、 `BRPOP` コマンドは _アトミック_ です。つまり、複数のシミュレータがある場合、同じ項目を取得することはできません。各項目は一度だけディスパッチされます。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:140
#, fuzzy, no-wrap
msgid "Sending the fight outcome"
msgstr "試合結果の送信"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:144
#, fuzzy
msgid "The pool loop retrieves the `FightRequests` from the queue and simulates the fights, but how to communicate the results? For this, we use another Redis feature: pub/sub communication."
msgstr "poolループはキューから `FightRequests` を取得し、戦いをシミュレートしますが、その結果をどのように伝達するのでしょうか？そこで、Redisのもう一つの機能であるpub/sub通信を利用します。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:147
#, fuzzy
msgid "In simple words, we are going to send the `FightResult` to a _channel_.  Applications subscribing to that channel will receive the emitted `FightResult`."
msgstr "簡単に言うと、 `FightResult` をある _チャネルに_ 送信することになります。そのチャンネルを購読しているアプリケーションは、発信された `FightResult` を受信します。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:149
#, fuzzy
msgid "A `FightResult` contains the request id, the two fighters, and the name of the winner:"
msgstr " `FightResult` には、リクエストID、2人のファイター、勝者の名前が含まれる。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:155
#, no-wrap
msgid "public record FightResult(String id, Hero hero, Villain villain, String winner) {\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:161
#, fuzzy
msgid "To use Redis _pub/sub_ commands, we need the object associated with this group.  In the `FightSimulator`, we also uses the `pubsub` method to get that object:"
msgstr "Redis の _pub/sub_ コマンドを使用するには、このグループに関連付けられたオブジェクトが必要です。 `FightSimulator` では、そのオブジェクトを取得するために `pubsub` メソッドも使用しています。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:170
#, no-wrap
msgid ""
"public FightSimulator(@ConfigProperty(name = \"simulator-name\") String name, Logger logger, RedisDataSource ds) {\n"
"    this.name = name;\n"
"    this.logger = logger;\n"
"    this.queue = ds.list(FightRequest.class);\n"
"    this.publisher = ds.pubsub(FightResult.class);  // <--- this is it!\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:174
#, fuzzy
msgid "Now, we can use this `publisher` to send the `FightResults`.  After each fight, we call `publisher.publish` to send the `FightResult` instance to the `fight-results` channel:"
msgstr "さて、この `publisher` を使って、 `FightResults` 。各戦闘の後、 `publisher.publish` を呼び出して、 `FightResult` インスタンスを `fight-results` チャンネルに送信します。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:189
#, no-wrap
msgid ""
"@Override\n"
"public void run() {\n"
"    logger.infof(\"Simulator %s starting\", name);\n"
"    while ((!stopped)) {\n"
"        KeyValue<String, FightRequest> item = queue.brpop(Duration.ofSeconds(1), \"fight-requests\");\n"
"        if (item != null) {\n"
"            var request = item.value();\n"
"            var result = simulate(request);\n"
"            publisher.publish(\"fight-results\", result);  // Send the outcome\n"
"           }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:191
#, fuzzy, no-wrap
msgid "Receiving the fight outcome"
msgstr "試合結果の受け取り"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:194
#, fuzzy
msgid "At that point:"
msgstr "その時に"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:196
#, fuzzy
msgid "we submit the fight request into the job queue,"
msgstr "は，戦闘要求をジョブキューに投入する．"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:197
#, fuzzy
msgid "we consume that queue and simulate the fight,"
msgstr "そのキューを消費して、戦闘をシミュレートするのです。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:198
#, fuzzy
msgid "we send the outcome to the `fight-results` channel."
msgstr "その結果を `fight-results` チャンネルに送信します。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:203
#, fuzzy
msgid "So, the only missing piece is the consumption of that channel.  Let's return to the https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[`me.escoffier.quarkus.redis.supes.SupesService`] class.  In the constructor, we also inject the `ReactiveRedisDataSource`, the reactive variant of the Redis data source.  Then, in the constructor code, we subscribe to the `fight-results`."
msgstr "つまり、足りないのはそのチャンネルの消費量だけなのです。に戻りましょう。 link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesService.java[`me.escoffier.quarkus.redis.supes.SupesService`] クラスに戻りましょう。コンストラクタでは、Redisデータソースの反応型である `ReactiveRedisDataSource` もインジェクトします。そして、コンストラクタのコードで、 `fight-results` にサブスクライブしています。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:211
#, no-wrap
msgid ""
"public SupesService(RedisDataSource dataSource, ReactiveRedisDataSource reactiveRedisDataSource) {\n"
"    commands = dataSource.list(FightRequest.class);\n"
"    stream = reactiveRedisDataSource.pubsub(FightResult.class).subscribe(\"fight-results\")\n"
"            .broadcast().toAllSubscribers();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:214
#, fuzzy
msgid "Because we use the reactive data source, this subscription returns a `Multi<FightResult>`, ready to be served by Quarkus and an SSE (see https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.java]):"
msgstr "リアクティブデータソースを使用しているため、このサブスクリプションは、QuarkusとSSE（ link:https://github.com/cescoffier/quarkus-redis-job-queue-demo/blob/main/supes-application/src/main/java/me/escoffier/quarkus/redis/supes/SupesResource.java[SupesResource.javaを] 参照）によって提供される準備ができた、 `Multi<FightResult>` を返します。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:223
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@RestStreamElementType(MediaType.APPLICATION_JSON)\n"
"public Multi<FightResult> fights() {\n"
"    return supes.getFightResults();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:227
#, fuzzy
msgid "`.broadcast().toAllSubscribers()` instructs Quarkus to broadcast all the received `FightResult` to all the connected SSE.  So, the browser filters out unrequested results."
msgstr " `.broadcast().toAllSubscribers()` は、Quarkusに対して、受信したすべての を接続されているすべてのSSEにブロードキャストするように指示します。つまり、ブラウザは要求されていない結果をフィルタリングするわけです。 `FightResult` "

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:228
#, fuzzy, no-wrap
msgid "Running the system"
msgstr "システムの稼動"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:233
#, fuzzy
msgid "The circle is complete! The full code source is available from https://github.com/cescoffier/quarkus-redis-job-queue-demo.  To run the system, open three terminals."
msgstr "円の完成です!全コードソースは https://github.com/cescoffier/quarkus-redis-job-queue-demo  から入手可能です。システムを動かすには、3つのターミナルを開いてください。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:240
#, fuzzy
msgid "First, we start the `supes-application`.  In the first terminal, navigate to the `supes-application` and run `mvn quarkus:dev` Quarkus automatically starts the PostgreSQL and Redis instances (if your machine can run containers).  In the console, hit `h` and then `c`.  It displays the running dev services.  Look for the redis one, and copy the `quarkus.redis.hosts` injected configuration:"
msgstr "まず、 `supes-application` 。最初のターミナルで、 `supes-application` に移動し、 `mvn quarkus:dev` を実行します。Quarkusは自動的にPostgreSQLおよびRedisインスタンスを起動します（マシンでコンテナを実行できる場合）。コンソールで、 `h` 、次に `c` を押します。実行中の開発サービスが表示されます。Redisを探し、 `quarkus.redis.hosts` の注入された設定をコピーします。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:248
#, no-wrap
msgid ""
"redis-client - Up About a minute\n"
"  Container:        348edec50f80/trusting_jennings  docker.io/redis:7-alpine\n"
"  Network:          bridge - 0.0.0.0:53853->6379/tcp\n"
"  Exec command:     docker exec -it 348edec50f80 /bin/bash\n"
"  Injected Config:  quarkus.redis.hosts=redis://localhost:53853\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:253
#, fuzzy
msgid "In the previous snippet, copy: `quarkus.redis.hosts=redis://localhost:53853`.  This is the address of the redis server.  We need to configure to the simulators with that address."
msgstr "先ほどのスニペットで、コピー： `quarkus.redis.hosts=redis://localhost:53853` .これはredisサーバーのアドレスです。このアドレスでシミュレータに設定する必要があります。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:256
#, fuzzy
msgid "If you go to http://localhost:8080, the web page is served.  You can hit the `fights!` button a few times."
msgstr " http://localhost:8080  にアクセスすると、Webページが提供されます。 `fights!` のボタンを何度か押してみてください。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:257
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/screenshot.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:262
#, fuzzy
msgid "The fight won't happen as we have no simulator.  However, the fight requests have been submitted and stored in the list.  So they are not lost."
msgstr "シミュレーターがないため、ファイトは実現しません。しかし、戦いのリクエストは提出され、リストに保存されています。だから、それらは失われることはありません。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:264
#, fuzzy
msgid "Now, in the second terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "ここで、2つ目の端末で、 `fight-simulator` ディレクトリに移動し、実行します。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:269
#, no-wrap
msgid ""
"mvn package\n"
"java -Dsimulator-name=A -Dquarkus.redis.hosts=redis://localhost:53853 -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:272
#, fuzzy, no-wrap
msgid "*IMPORTANT*: update the `quarkus.redis-hosts` with the one copied above.\n"
msgstr " *重要* ：上記でコピーしたものを使って `quarkus.redis-hosts` を更新してください。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:274
#, fuzzy
msgid "As soon as you start it, it processes the pending fight requests:"
msgstr "起動するとすぐに、保留中の戦闘要求を処理します。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:280
#, no-wrap
msgid ""
"2022-09-11 15:31:58,914 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Pakku and Tulon Voidgazer\n"
"2022-09-11 15:31:59,786 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Comet Zuko and Arishem The Judge (Knullified)\n"
"2022-09-11 15:32:01,809 INFO  [me.esc.qua.red.fig.FightSimulator] (Thread-3) Simulator A is going to simulate a fight between Ms. America and Kazumi (Devil Form)\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:283
#, fuzzy
msgid "If you go back to the web page, the winners get a _halo_:"
msgstr "ウェブページに戻ると、受賞者には _後光が差して_ いる。"

#. type: Target for macro image
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:284
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/screenshot-winner.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:287
#, fuzzy
msgid "Now, in the third terminal, navigate to the `fight-simulator` directory, and run:"
msgstr "さて、3つ目の端末で、 `fight-simulator` ディレクトリに移動し、実行します。"

#. type: delimited block -
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:291
#, no-wrap
msgid "java -Dsimulator-name=B -Dquarkus.redis.hosts=redis://localhost:53853 -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:294
#, fuzzy, no-wrap
msgid "*IMPORTANT*: as in the previous command, update the `quarkus.redis-hosts` with the one copied above.\n"
msgstr " *重要* ：前のコマンドと同様に、 `quarkus.redis-hosts` を上記でコピーしたもので更新してください。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:297
#, fuzzy
msgid "Go back to the web page and click on the `fight!` button a few times.  Check the logs of both simulators to see that the fight requests are now dispatched beween the two simulators."
msgstr "ウェブページに戻り、 `fight!` ボタンを数回クリックします。両方のシミュレータのログを確認し、戦闘要求が2つのシミュレータ間で送信されるようになったことを確認します。"

#. type: Title ==
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:298
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:301
#, fuzzy
msgid "This posts explains how you can implement a job queue with Redis and the Quarkus Redis datasource API."
msgstr "この記事では、RedisとQuarkus RedisデータソースAPIを使用して、ジョブキューを実装する方法を説明します。"

#. type: Plain text
#: upstream/_posts/2022-09-15-redis-job-queue.adoc:303
#, fuzzy
msgid "Learn more about the Redis data source API from the https://quarkus.io/guides/redis[Quarkus documentation].  We will publish more content about Redis patterns, so stay tuned!"
msgstr "RedisデータソースAPIの詳細については、 link:https://quarkus.io/guides/redis[Quarkusのドキュメントを] 参照してください。Redisパターンについては、今後もコンテンツを公開していく予定ですので、お楽しみに"
