# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-05-01 01:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "cescoffier"
msgstr "cescoffier"

#. type: YAML Front Matter: date
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, fuzzy, no-wrap
msgid "2022-11-22"
msgstr "2022-11-22"

#. type: YAML Front Matter: layout
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, fuzzy, no-wrap
msgid "How to implement a more reliable job queue with Redis, including fault tolerance, de-duplication, and poison pill."
msgstr "フォールトトレランス、重複排除、ポイズンピルなど、より信頼性の高いジョブキューをRedisで実装する方法。"

#. type: YAML Front Matter: tags
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, fuzzy, no-wrap
msgid "redis"
msgstr "レディス"

#. type: YAML Front Matter: title
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:1
#, fuzzy, no-wrap
msgid "Redis Job Queue - Reloaded"
msgstr "Redisジョブキュー - Reloaded"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:12
#, fuzzy
msgid "In https://quarkus.io/blog/redis-job-queue/[How to implement a job queue with Redis], we explained how to implement a job queue mechanism with Redis and the new Redis API from Quarkus.  The approach explored in that blog post had a significant flaw: if the execution of a job failed, the request was lost and will never be re-attempted."
msgstr "link:https://quarkus.io/blog/redis-job-queue/[Redisでジョブキューを実装する方法] 」では、RedisとQuarkusの新しいRedis APIを使ってジョブキューの仕組みを実装する方法について説明しました。そのブログ記事で検討したアプローチには重大な欠陥がありました。ジョブの実行が失敗した場合、リクエストは失われ、再試行されることはありません。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:14
#, fuzzy
msgid "In this post, we explain how to improve the reliability of the job queue to handle failures, enable retry and use a _dead-letter queue_ to avoid poison pills."
msgstr "この記事では、ジョブキューの信頼性を高めて障害に対応する方法、リトライを有効にする方法、毒薬を避けるために _デッドレターキューを_ 使用する方法について解説しています。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:16
#, fuzzy
msgid "## Recap & Problem"
msgstr "総括と課題\n"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:18
#, fuzzy
msgid "In the https://quarkus.io/blog/redis-job-queue/[previous blog post], we implemented the following system."
msgstr "link:https://quarkus.io/blog/redis-job-queue/[前回のブログ記事で] 、以下のシステムを導入しました。"

#. type: Target for macro image
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:19
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/application.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:24
#, fuzzy
msgid "An application receives _fight requests_ and writes these requests into a Redis list.  Several simulators processed this list.  The outcomes of the _fights_ were communicated using Redis Pub/Sub."
msgstr "あるアプリケーションが _戦闘要求を_ 受け取り、これらの要求をRedisリストに書き込む。複数のシミュレータがこのリストを処理した。 _戦いの_ 結果はRedisのPub/Subを使って伝達された。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:27
#, fuzzy
msgid "The architecture works and ensures that a fight can only be executed once, thanks to the `brpop` command used by the simulator code.  This command pops the item from the queue in an atomic manner and ensure that the other simulators can't process it too."
msgstr "このアーキテクチャは、シミュレータのコードで使用される `brpop` コマンドのおかげで、戦いが一度だけ実行されることを保証します。このコマンドは、アトミックな方法でキューからアイテムをポップし、他のシミュレータがそれを処理できないようにするものです。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:31
#, fuzzy
msgid "However, this architecture has a drawback.  If the processing of the popped fight request fails, the request is lost.  No other simulator would be able to process it, and if the simulator that failed restarts, it will not reprocess the same request."
msgstr "しかし、このアーキテクチャには欠点がある。飛び出した戦闘要求の処理に失敗した場合、その要求は失われる。他のシミュレータでは処理できないし、失敗したシミュレータが再起動しても、同じリクエストを再処理することはないだろう。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:33
#, fuzzy
msgid "## Introducing more queues"
msgstr "より多くのキューを導入する\n"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:37
#, fuzzy
msgid "An approach to handle that problem is to introduce more queues.  In addition to the main queue (the Redis list from the image above), we introduce one queue per simulator.  Thus, each simulator has its private queue."
msgstr "その問題を処理するためのアプローチとして、より多くのキューを導入することがあります。メインキュー（上の画像のRedisリスト）に加えて、シミュレータごとに1つのキューを導入します。このように、各シミュレータはプライベートなキューを持つことになります。"

#. type: Target for macro image
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:38
#, no-wrap
msgid "/assets/images/posts/redis-job-queue/reloaded.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:41
#, fuzzy
msgid "These private queues form a safety net."
msgstr "これらのプライベートキューは、セーフティネットを形成しています。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:43
#, fuzzy
msgid "So, the simulator does use not only the _main queue_ but also its private queue:"
msgstr "つまり、シミュレータは _メインキューだけ_ でなく、そのプライベートキューも使っているのです："

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:48
#, no-wrap
msgid ""
"this.queues = ds.list(FightRequest.class);\n"
"this.queueName = \"queue-\" + name; // the name of the private queue\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:54
#, fuzzy
msgid "When a simulator pops a request from the main queue, it does not process it immediately; it writes it to its private queue.  To achieve this, we cannot use `brpop` and then write to the other queue, as if something wrong happens in between, we would have the same problem.  Instead, we use `blmove,` which pops an element from a list and pushes it into another in an atomic fashion.  Thus, we ensure that multiple simulators cannot consume the same request and that the request cannot be lost."
msgstr "シミュレータがメインキューからリクエストをポップするとき、すぐに処理するのではなく、プライベートキューに書き込みます。これを実現するためには、 `brpop` を使ってからもう一方のキューに書き込むことはできません。その間に何か問題が発生した場合、同じ問題が発生します。その代わりに、 `blmove,` 、リストから要素をポップし、アトミックな方法で別のキューにプッシュします。こうして、複数のシミュレータが同じリクエストを消費することができないようにし、リクエストが失われないようにするのです。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:56
#, fuzzy
msgid "So, we use the following code to move the request from the main queue to the private queue:"
msgstr "そこで、以下のコードでメインキューからプライベートキューにリクエストを移動させます："

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:65
#, no-wrap
msgid ""
"// pop the item at the right side of the 'fight-requests' queue\n"
"// and writes it to the left side of 'queueName'.\n"
"// it returns the moved item or `null` in the entry queue, 'fight-requests',\n"
"// does not have any item, even after the 1-second delay\n"
"var moved = queues.blmove(\"fight-requests\", queueName,  \n"
"        Position.RIGHT, Position.LEFT, Duration.ofSeconds(1));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:68
#, fuzzy
msgid "Now, the simulator does not simulate the requests from the main queue but needs to process the ones added to its private queue."
msgstr "さて、シミュレータはメインキューからのリクエストをシミュレートするのではなく、プライベートキューに追加されたリクエストを処理する必要があります。"

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:79
#, no-wrap
msgid ""
"public void processRequestFromPrivateQueue() {  \n"
"    var request = queues.lindex(queueName, -1);  \n"
"    while (request != null) {  \n"
"        runSimulation(request);  \n"
"        queues.lrem(queueName, 1, request);    \n"
"        request = queues.lindex(\"queue-\" + name, -1);  \n"
"    }  \n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:85
#, fuzzy
msgid "This code is slightly different from the code from the previous blog.  This time, we do not pop.  We get the last item from the queue (index `-1` is the last one), process it, and then remove it from the queue.  We do this until the queue is empty."
msgstr "このコードは、前回のブログのコードと少し違います。今回は、ポップはしません。キューから最後のアイテムを取得し（インデックス `-1` が最後のアイテムです）、それを処理し、キューから削除します。これをキューが空っぽになるまで続けます。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:87
#, fuzzy
msgid "Let's put everything together:"
msgstr "全部まとめてみよう："

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:88
#, fuzzy
msgid "when the simulator starts, it should process the items from its private queue. So, if it crashes, it will retry to process the item."
msgstr "シミュレータが起動したら、プライベートキューからアイテムを処理する必要があります。そのため、もしクラッシュした場合は、アイテムの処理を再試行することになります。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:89
#, fuzzy
msgid "once the private queue is empty, it gets new requests from the main queue. It will not process them directly but re-trigger the processing of the private queue until the queue is empty."
msgstr "プライベートキューが空になると、メインキューから新しいリクエストを受け取ります。それを直接処理するのではなく、キューが空になるまでプライベートキューの処理を再トリガーする。"

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:108
#, no-wrap
msgid ""
"@Override  \n"
"public void run() {  \n"
"  // First, check if we are recovering, and drain the requests from the \n"
"  // simulator's queue  \n"
"  processRequestFromPrivateQueue();  \n"
"  while (! stopped) {  \n"
"    // Simulator's queue drained - poll the main queue  \n"
"    var moved = queues.blmove(\"fight-requests\", queueName,  \n"
"        Position.RIGHT, Position.LEFT, Duration.ofSeconds(1)\n"
"    );  \n"
"    if (moved != null) {  \n"
"      // If an element has been moved, process it  \n"
"      processRequestFromPrivateQueue();  \n"
"    }  \n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:111
#, fuzzy
msgid "## New architecture, new problems"
msgstr "新アーキテクチャ、新問題\n"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:115
#, fuzzy
msgid "That approach fixes the initial problem.  If the processing fails, we retry it (as the request is not removed from the private queue).  That will handle transient failures pretty well."
msgstr "そのアプローチで最初の問題は解決される。処理が失敗した場合は、（リクエストがプライベートキューから削除されないので）再試行します。これで一過性の失敗をかなりうまく処理できるだろう。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:117
#, fuzzy
msgid "However, it also has its own set of drawbacks:"
msgstr "しかし、それなりの欠点もあります："

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:119
#, fuzzy
msgid "_Duplicates_: if the processing succeeds, but the `lrem` fails for any reason (like a network failure), the request will be processed another time as it was not removed from the queue."
msgstr "_重複_ ：処理が成功しても、何らかの理由（ネットワーク障害など）で `lrem` が失敗した場合、リクエストはキューから削除されなかったため、別の機会に処理されます。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:120
#, fuzzy
msgid "_Poison pill_: if a request cannot be processed successfully, it will retry to process it forever."
msgstr "_毒薬_ ：リクエストを正常に処理できない場合、永遠に処理をやり直します。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:122
#, fuzzy
msgid "### De-duplication"
msgstr "デデュープ"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:125
#, fuzzy
msgid "Handling _duplicates_ require having a way to identify the requests uniquely and deduplicate manually.  In other words, if all our requests have a unique id, we can check if that id has already been processed (for example, by storing the processed ids in another list or a hash). If the item has already been processed, ignore it (remove it from the queue) and process it to the next one:"
msgstr "_重複を_ 処理するには、リクエストを一意に識別し、手動で重複排除する方法を持つ必要があります。つまり、すべてのリクエストに一意な ID があれば、その ID がすでに処理されているかどうかをチェックできます (たとえば、処理済みの ID を別のリストやハッシュに保存しておくなど)。すでに処理済みであれば、それを無視して（キューから削除して）、次の処理に回す："

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:138
#, no-wrap
msgid ""
"public void processRequestFromPrivateQueue() {  \n"
"    var request = queues.lindex(queueName, -1);  \n"
"    while (request != null) {  \n"
"        if (! isDuplicate(request)) {\n"
"            runSimulation(request);  \n"
"        }\n"
"        queues.lrem(queueName, 1, request);    \n"
" .      request = queues.lindex(\"queue-\" + name, -1);  \n"
"    }  \n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:141
#, fuzzy
msgid "### Avoiding swallowing the poison pill"
msgstr "ポイズンピルを飲み込まないようにする"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:146
#, fuzzy
msgid "Handling _poison pills_ is more complex.  A _poison pill_ is a request that will always make the processing fails.  It can be because of a bug in the processing code or something unexpected; it will always fail.  Retrying, in this case, will not help; we are not facing a transient issue."
msgstr "_毒薬の_ 扱いはより複雑です。 _毒薬とは_ 、処理を必ず失敗させるリクエストのことです。処理コードのバグや予期せぬことが原因である場合もありますが、必ず失敗します。この場合、再試行しても、一過性の問題に直面しているわけではありません。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:150
#, fuzzy
msgid "So, what can we do? We need to track the number of processing attempts for that request, and if it exceeds a specific number, let's face it: we won't be able to handle the request.  We generally want to send the request to a dead-letter queue (DLQ), i.e., a specific queue storing the unprocessable items:"
msgstr "では、どうすればいいのでしょうか。そのリクエストに対する処理の試行回数を追跡する必要があり、それが特定の回数を超えた場合、正直に言うと、そのリクエストを処理することはできません。一般的には、そのリクエストをデッドレターキュー（DLQ）、つまり処理不能なアイテムを保存している特定のキューに送りたいのです："

#. type: delimited block -
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:167
#, no-wrap
msgid ""
"public void processRequestFromPrivateQueue() {  \n"
"    var request = queues.lindex(queueName, -1);  \n"
"    while (request != null) {  \n"
"        if (counter.incr(counterName) > MAX_ATTEMPT) {  \n"
"            // Give up - it's a poison pill\n"
"            queues.lpush(DLQ, request); // Add to DLQ\n"
"        } else {  \n"
"            runSimulation(request);  \n"
"        }  \n"
"        request = queues.lindex(\"queue-\" + name, -1);  \n"
"        queues.lrem(queueName, 1, request);  \n"
"        counter.set(counterName, 0); // Reset  \n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:170
#, fuzzy
msgid "The counter is a specific Redis integer value that we increment and reset once we succeed or give up."
msgstr "カウンターは特定のRedis整数値で、成功したりあきらめたりしたらインクリメントしてリセットします。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:174
#, fuzzy
msgid "The items from the DLQ are not lost; they are saved for future processing.  These items could be re-added to the main queue (to verify if it was not a transient issue or the bug was fixed).  Another approach requires that a human administrator looks at these requests before re-injecting them into the system; maybe it was just a formatting issue..."
msgstr "DLQからのアイテムは失われるのではなく、将来の処理のために保存されます。これらのアイテムは、メインキューに再追加することができます（一過性の問題でないか、バグが修正されたかを検証するため）。別のアプローチでは、システムに再投入する前に、人間の管理者がこれらのリクエストに目を通す必要があります。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:176
#, fuzzy
msgid "## Summary"
msgstr "概要\n"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:181
#, fuzzy
msgid "This post explores how to improve the job queue we implemented in https://quarkus.io/blog/redis-job-queue/[How to implement a job queue with Redis].  This initial implementation, while simple, would lose requests if the processing fails.  This post proposes another, more complex, architecture to handle that case but also handle duplicates and poison pills.  But, nothing comes for free, and the resulting code is slightly more complex."
msgstr "この記事では、「 link:https://quarkus.io/blog/redis-job-queue/[Redisでジョブキューを実装する方法] 」で実装したジョブキューを改善する方法について検討します。この最初の実装はシンプルですが、処理に失敗するとリクエストを失ってしまいます。この投稿では、このようなケースに対応しつつ、重複や毒薬も処理する、より複雑な別のアーキテクチャを提案します。しかし、タダで手に入るものはありませんし、結果的にコードは若干複雑になります。"

#. type: Plain text
#: upstream/_posts/2022-11-22-redis-job-queue-reloaded.adoc:184
#, fuzzy
msgid "Remember: Redis is a fantastic toolbox.  But, it's a toolbox; you build what you need with it, as it is rarely available out of the box.  That being said, the richness of the Redis commands lets you do many things... (spoiler: we will see some of these things in future posts)."
msgstr "覚えておいてください：Redisは素晴らしいツールボックスです。しかし、それはツールボックスであり、箱から出して使えることはほとんどないため、必要なものを作るのです。とはいえ、Redisコマンドの豊富さによって、さまざまなことができるようになります（ネタバレ：今後の記事でその一部を紹介します）。"
