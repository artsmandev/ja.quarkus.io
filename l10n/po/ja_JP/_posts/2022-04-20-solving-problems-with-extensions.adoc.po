# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-04-29 21:23+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:1
#, no-wrap
msgid "gsmet"
msgstr ""

#. type: YAML Front Matter: date
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:1
#, no-wrap
msgid "2022-04-20"
msgstr ""

#. type: YAML Front Matter: layout
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:1
#, no-wrap
msgid "post"
msgstr ""

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:1
#, fuzzy, no-wrap
msgid "The unique build infrastructure of Quarkus allows you to solve complex issues in a very simple way by developing custom extensions."
msgstr ""
"layout: post\n"
"title: 'クオークス拡張で問題を解く(1/n)'\n"
"date: 2022-04-20\n"
"tags: extensions development-tips\n"
"synopsis: Quarkusのユニークなビルドインフラストラクチャでは、カスタム拡張機能を開発することで、非常にシンプルな方法で複雑な問題を解決することができます」。\n"
"author: gsmet\n"
"---\n"

#. type: YAML Front Matter: tags
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:1
#, no-wrap
msgid "extensions development-tips"
msgstr ""

#. type: YAML Front Matter: title
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:1
#, no-wrap
msgid "Solving problems with Quarkus extensions (1/n)"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:11
#, fuzzy
msgid "This is the first post of what I hope will be a series of several articles showing how you can solve complex problems by leveraging the unique Quarkus build infrastructure and extension framework."
msgstr "この記事は、Quarkus独自のビルドインフラと拡張フレームワークを活用して複雑な問題を解決する方法を紹介する、数回にわたる連載の最初の記事です。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:14
#, fuzzy
msgid "First things first, bootstraping a Quarkus extension is easy: in one command, you can get it scaffolded and get started on the actual implementation.  But that's not the subject of this post!"
msgstr "まず最初に、Quarkus拡張機能のブートストラップは簡単です。1つのコマンドで、雛形ができ、実際の実装に取り掛かることができます。しかし、それはこの記事の主題ではありません!"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:17
#, fuzzy
msgid "An extension, apart from providing some runtime code to your application, also allows to tweak the build of your application and do all sorts of things at the build level.  This is what we will focus on in this series."
msgstr "拡張機能は、アプリケーションにランタイムコードを提供するだけでなく、アプリケーションのビルドを調整し、ビルドレベルであらゆる種類のことを行うことができます。このシリーズでは、この点に焦点を当てます。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:19
#, fuzzy, no-wrap
msgid "**Problem of the day:** to ensure binary compatibility, the Hub4j GitHub API introduces some bridge methods that confuse Mockito and more specifically ByteBuddy and ultimately make our tests unreliable. How can we solve that?\n"
msgstr "*今日の問題:*バイナリ互換性を確保するために、Hub4j GitHub APIは、Mockito、特にByteBuddyを混乱させ、最終的に我々のテストの信頼性を低下させるいくつかのブリッジ・メソッドを導入しています。どうすればそれを解決できるでしょうか？"

#. type: Title ==
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:20
#, fuzzy, no-wrap
msgid "Some context"
msgstr "いくつかの文脈"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:25
#, fuzzy
msgid "You might have heard about https://github.com/quarkiverse/quarkus-github-app[my Quarkus GitHub App extension] that allows you to develop GitHub Apps based on Quarkus at light speed with very little boilerplate (shameless ad: it is awesome!)."
msgstr "link:https://github.com/quarkiverse/quarkus-github-app[Quarkus GitHub Appエクステンションは]、QuarkusをベースにしたGitHubアプリを、ほとんど定型文を使わずに軽快に開発できます（恥知らずな宣伝：素晴らしいです！）。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:30
#, fuzzy
msgid "My dear colleague https://github.com/yrodiere[Yoann Rodière] (he is awesome too!) wrote some test infrastructure for it based on https://site.mockito.org[Mockito] (which uses https://bytebuddy.net/[ByteBuddy] under the hood).  That was all good until we started noticing confusing and non reproducible failures in our tests with Mockito sometimes not actually calling the method we would expect."
msgstr "私の親愛なる同僚である link:https://github.com/yrodiere[Yoann Rodière]（彼も素晴らしい！）は、 link:https://site.mockito.org[Mockito]（これはフードの下で link:https://bytebuddy.net/[ByteBuddyを]使用します）に基づいて、そのためのテストインフラをいくつか書きました。しかし、Mockitoが実際に期待するメソッドを呼び出さないことがあり、テストが混乱したり、再現性のない失敗をしたりすることに気づくまでは、すべて順調でした。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:32
#, fuzzy
msgid "The source of the problem is that, to ensure binary compatibility, the https://github.com/hub4j/github-api[Hub4j GitHub API] we use in Quarkus GitHub App introduces bridge methods in the bytecode."
msgstr "問題の原因は、バイナリ互換性を確保するために、Quarkus GitHub Appで使用している link:https://github.com/hub4j/github-api[Hub4j GitHub APIでは]、バイトコードにブリッジメソッドを導入していることです。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:34
#, fuzzy
msgid "For instance, let's take this method of the `GitHub` class of the GitHub API:"
msgstr "たとえば、GitHub API の `GitHub` クラスのこのメソッドを例に挙げてみましょう。"

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:42
#, no-wrap
msgid ""
"    @WithBridgeMethods(value = GHUser.class)\n"
"    public GHMyself getMyself() throws IOException {\n"
"        client.requireCredential();\n"
"        return setMyself();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:46
#, fuzzy
msgid "Historically, it used to return a `GHUser` but, in newer versions, it returns a `GHMyself`, which broke the binary compatibility."
msgstr "歴史的に見ると、以前は `GHUser` を返していたが、新しいバージョンでは `GHMyself` を返すようになり、バイナリ互換性が壊れた。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:51
#, fuzzy
msgid "To restore it and with the help of the `@WithBridgeMethods` annotation, the GitHub API build will create two methods in the bytecode: one returning `GHMyself` and one returning `GHUser`.  This is very useful if you have compiled your application with an old version of the GitHub API and you just want to use the new version without recompiling your application.  Typically, in the case of Jenkins, you can switch to a new version of the GitHub API without having to recompile all the Jenkins plugins using GitHub API."
msgstr "これを復元するために、 `@WithBridgeMethods` アノテーションの助けを借りて、GitHub API ビルドはバイトコードに 2 つのメソッドを作成します。1 つは `GHMyself` を返し、もう 1 つは `GHUser` を返します。これは、GitHub APIの古いバージョンでアプリケーションをコンパイルしていて、アプリケーションを再コンパイルせずに新しいバージョンを使いたい場合に非常に便利です。一般的にJenkinsの場合、GitHub APIを使用するJenkinsプラグインをすべて再コンパイルすることなく、GitHub APIの新しいバージョンに切り替えることができる。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:53
#, fuzzy
msgid "At the bytecode level, you end up with something equivalent to the following:"
msgstr "バイトコードレベルでは、以下のようなものになります。"

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:60
#, no-wrap
msgid ""
"    public GHMyself getMyself() throws IOException {\n"
"        client.requireCredential();\n"
"        return setMyself();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:64
#, no-wrap
msgid ""
"    public GHUser getMyself() throws IOException {\n"
"        return getMyself(); <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:66
#, fuzzy
msgid "`invokevirtual` of `getMyself()` that returns `GHMyself`"
msgstr "`invokevirtual` を返す の `getMyself()` `GHMyself`"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:68
#, fuzzy
msgid "And if your existing compiled code calls `GHUser getMyself()`, it will still work after the change of return type."
msgstr "また、既存のコンパイル済みコードが `GHUser getMyself()` を呼び出す場合、戻り値の型を変更した後も動作します。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:72
#, fuzzy
msgid "This bridge methods approach solves a real problem and it's not that big of a deal as it's fully transparent for the developer...  except when you start using Mockito due to https://github.com/raphw/byte-buddy/issues/1162[a ByteBuddy issue]: ByteBuddy can get confused if there are several methods with the same signature but different return types."
msgstr "このブリッジ・メソッドのアプローチは実際の問題を解決するもので、開発者にとっては完全に透過的なので、それほど大きな問題ではありません... link:https://github.com/raphw/byte-buddy/issues/1162[ByteBuddyの問題で]Mockitoを使い始める場合を除けば。ByteBuddyは、同じシグネチャで異なる戻り値の型を持つメソッドが複数ある場合、混乱することがあります。"

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:77
#, fuzzy
msgid "ByteBuddy is an amazing library and this blog post should not be seen as a critique of ByteBuddy.  This is an extreme corner case that doesn't happen with standard bytecode."
msgstr "ByteBuddyは素晴らしいライブラリであり、このブログ記事はByteBuddyの批評として見られてはならない。これは標準的なバイトコードでは起きない極端なコーナーケースです。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:80
#, fuzzy
msgid "This issue was causing our tests to be unreliable because sometimes ByteBuddy was choosing the wrong method to apply Mockito magic."
msgstr "この問題は、ByteBuddyがMockitoマジックを適用するために間違った方法を選択することがあり、テストの信頼性を低下させる原因となっていました。"

#. type: Title ==
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:81
#, fuzzy, no-wrap
msgid "How can we work around this?"
msgstr "どうすれば回避できるのか？"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:86
#, fuzzy
msgid "In the case of Quarkus GitHub App, we don't really care about binary compatibility: when upgrading to a new version of the GitHub API, users will rebuild their application."
msgstr "Quarkus GitHub Appの場合、バイナリ互換性はあまり気にしません。GitHub APIの新しいバージョンにアップグレードする場合、ユーザーはアプリケーションを再構築することになります。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:89
#, fuzzy
msgid "So given these bridge methods are problematic, one solution would be to get rid of them."
msgstr "ですから、これらのブリッジ方式が問題であることを考えると、これを廃止することが一つの解決策になると思います。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:91
#, fuzzy
msgid "Obviously, we could fork the GitHub API and avoid generating the bridge methods."
msgstr "もちろん、GitHub API をフォークしてブリッジメソッドを生成しないようにすることもできます。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:94
#, fuzzy
msgid "But forking and maintaining a fork forever is definitely not something we should consider if we can avoid it.  Especially since we want to continue benefiting from all the future improvements of the GitHub API."
msgstr "しかし、フォークして永遠に維持することは、避けられるのであれば絶対に考えるべきことではありません。特に、GitHub API の将来の改良の恩恵を受け続けたいのですから。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:96
#, fuzzy
msgid "So could we somehow keep the library standard but have Quarkus adjust the bytecode when building the application?"
msgstr "そこで、ライブラリは標準のまま、アプリケーションの構築時にQuarkusでバイトコードを調整することはできないでしょうか。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:99
#, fuzzy
msgid "If you are in a rush, the short answer is yes.  Now let's go for the (not so) long answer."
msgstr "急いでいるのなら、短い答えは「イエス」です。では、（そうではない）長い答えに行きましょう。"

#. type: Title ===
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:100
#, fuzzy, no-wrap
msgid "Let's identify the methods"
msgstr "メソッドを特定しよう"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:105
#, fuzzy
msgid "In Quarkus, we can index the annotations with Jandex so, in a perfect world, we would index the GitHub API jar with Jandex (which we already do for other purposes)  and interrogate Jandex to get all the methods annotated with `@WithBridgeMethods`:"
msgstr "Quarkusでは、Jandexでアノテーションのインデックスを作成できます。完璧な世界では、JandexでGitHub API jarのインデックスを作成し（他の目的ですでに行っています）、Jandexに問い合わせて、 `@WithBridgeMethods` でアノテーションされたすべてのメソッドを取得することができます。"

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:110
#, no-wrap
msgid ""
"Collection<AnnotationInstance> withBridgeMethodsAnnotations =\n"
"    index.getAnnotations(DotName.createSimple(WithBridgeMethods.class.getName));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:113
#, fuzzy
msgid "Unfortunately, `@WithBridgeMethods` has a `CLASS` retention policy"
msgstr "残念ながら、 `@WithBridgeMethods` は、 `CLASS` リテンション・ポリシーを採用しています。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:115
#, fuzzy
msgid "which makes perfect sense for its usage - and Jandex only considers annotations with a `RUNTIME` retention policy."
msgstr "というのは、その使い方としては完全に理にかなっています。そして、Jandexは、 `RUNTIME` の保持ポリシーを持つアノテーションだけを考慮します。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:118
#, fuzzy
msgid "This limitation will be alleviated in Jandex 3 but, for the time being, we cannot use Jandex."
msgstr "この制限はJandex 3で緩和される予定ですが、当面はJandexを使用することはできません。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:121
#, fuzzy
msgid "Unfortunately, until then, we don't have many options here: we have to list the methods manually."
msgstr "残念ながら、それまでは、ここに多くの選択肢はありません。手動でメソッドをリストアップするしかないのです。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:123
#, fuzzy
msgid "For more flexibility, we introduced a `BuildItem`:"
msgstr "より柔軟に対応するために、 `BuildItem` を導入しました。"

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:127
#, no-wrap
msgid "public final class GitHubApiClassWithBridgeMethodsBuildItem extends MultiBuildItem {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:130
#, no-wrap
msgid ""
"    private final String className;\n"
"    private final Set<String> methodNames;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:135
#, no-wrap
msgid ""
"    GitHubApiClassWithBridgeMethodsBuildItem(String className, String... methodsWithBridges) {\n"
"        this.className = className;\n"
"        this.methodNames = new HashSet<>(Arrays.asList(methodsWithBridges));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:139
#, no-wrap
msgid ""
"    public String getClassName() {\n"
"        return className;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:144
#, no-wrap
msgid ""
"    public Set<String> getMethodsWithBridges() {\n"
"        return methodNames;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:147
#, fuzzy
msgid "And we will produce a `GitHubApiClassWithBridgeMethodsBuildItem` for each class:"
msgstr "そして、各クラスごとに `GitHubApiClassWithBridgeMethodsBuildItem` を制作します。"

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:151
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:156
#, no-wrap
msgid "// ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:154
#, no-wrap
msgid ""
"classesWithBridgeMethods.produce(new GitHubApiClassWithBridgeMethodsBuildItem(\n"
"        \"org.kohsuke.github.GHPullRequestCommitDetail$Commit\", \"getAuthor\", \"getCommitter\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:160
#, fuzzy
msgid "Once this is done, we are able to consume the `GitHubApiClassWithBridgeMethodsBuildItem` from any Quarkus `@BuildStep` so this list is generally available to the Quarkus build."
msgstr "これが完了すると、どのQuarkus `@BuildStep` からでも、 `GitHubApiClassWithBridgeMethodsBuildItem` を消費できるようになるので、このリストはQuarkusビルドで一般的に利用できるようになります。"

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:164
#, fuzzy
msgid "I won't go into detail on the Quarkus build process but the principle of it is extremely simple:"
msgstr "Quarkusのビルドプロセスの詳細は省きますが、その原理は極めてシンプルです。"

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:166
#, fuzzy
msgid "It is composed of build steps (methods annotated with `@BuildStep`)."
msgstr "ビルドステップ（ `@BuildStep` でアノテーションされたメソッド）で構成されています。"

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:167
#, fuzzy
msgid "A build step can consume build items."
msgstr "ビルドステップはビルドアイテムを消費することができます。"

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:168
#, fuzzy
msgid "A build step produces build items."
msgstr "ビルドステップはビルドアイテムを生成する。"

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:169
#, fuzzy
msgid "Then it is just a matter of resolving the dependencies of the build steps to get to the final result: your application."
msgstr "あとは、ビルドステップの依存関係を解決して、最終結果であるアプリケーションを完成させるだけです。"

#. type: delimited block =
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:171
#, fuzzy
msgid "You can learn more about it in the link:/guides/writing-extensions#build-step-processors[Writing extensions guide]."
msgstr "link:/guides/writing-extensions#build-step-processors[Writing extensionsガイドで]詳しく解説しています。"

#. type: Title ===
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:173
#, fuzzy, no-wrap
msgid "Removing the methods"
msgstr "メソッドの削除"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:176
#, fuzzy
msgid "Now that we have the list of methods handy, the next step is to remove them."
msgstr "これでメソッドのリストが手元に揃ったので、次のステップではメソッドを削除します。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:179
#, fuzzy
msgid "To manipulate bytecode during the build, Quarkus offers the `BytecodeTransformerBuildItem`.  Adjusting the bytecode of a class is just a matter of producing one for the given class."
msgstr "ビルド中にバイトコードを操作するために、Quarkusは `BytecodeTransformerBuildItem` 。 クラスのバイトコードを調整するには、与えられたクラスに対してバイトコードを生成するだけです。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:182
#, fuzzy
msgid "For instance, to remove the bridge methods from our GitHub API methods, we add the following build step to our extension:"
msgstr "たとえば、GitHub API のメソッドからブリッジメソッドを削除するには、次のようなビルド手順をエクステンションに追加します。"

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:189
#, no-wrap
msgid ""
"@BuildStep\n"
"void removeCompatibilityBridgeMethodsFromGitHubApi(\n"
"        BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers, <1>\n"
"        List<GitHubApiClassWithBridgeMethodsBuildItem> gitHubApiClassesWithBridgeMethods) { <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:199
#, no-wrap
msgid ""
"    for (GitHubApiClassWithBridgeMethodsBuildItem gitHubApiClassWithBridgeMethods : gitHubApiClassesWithBridgeMethods) {\n"
"        bytecodeTransformers.produce(new BytecodeTransformerBuildItem.Builder()\n"
"                .setClassToTransform(gitHubApiClassWithBridgeMethods.getClassName())\n"
"                .setVisitorFunction((ignored, visitor) -> new RemoveBridgeMethodsClassVisitor(visitor,\n"
"                        gitHubApiClassWithBridgeMethods.getClassName(),\n"
"                        gitHubApiClassWithBridgeMethods.getMethodsWithBridges()))\n"
"                .build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:201
#, fuzzy
msgid "We are going to produce ``BytecodeTransformerBuildItem``s."
msgstr "`BytecodeTransformerBuildItem`sを制作する予定です。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:202
#, fuzzy
msgid "We consume the previously produced ``GitHubApiClassWithBridgeMethodsBuildItem``s."
msgstr "先に生産された `GitHubApiClassWithBridgeMethodsBuildItem`s を消費するのです。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:204
#, fuzzy
msgid "`RemoveBridgeMethodsClassVisitor` is a classic https://asm.ow2.io[ASM] `ClassVisitor` that will modify the bytecode:"
msgstr "`RemoveBridgeMethodsClassVisitor` は、バイトコードを修正する古典的な link:https://asm.ow2.io[ASMの] `ClassVisitor` 。"

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:208
#, no-wrap
msgid "class RemoveBridgeMethodsClassVisitor extends ClassVisitor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:211
#, no-wrap
msgid ""
"    private final String className;\n"
"    private final Set<String> methodsWithBridges;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:214
#, no-wrap
msgid ""
"    public RemoveBridgeMethodsClassVisitor(ClassVisitor visitor, String className, Set<String> methodsWithBridges) {\n"
"        super(Gizmo.ASM_API_VERSION, visitor);\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:218
#, no-wrap
msgid ""
"        this.className = className;\n"
"        this.methodsWithBridges = methodsWithBridges;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:223
#, no-wrap
msgid ""
"    @Override\n"
"    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n"
"        if (methodsWithBridges.contains(name) && ((access & Opcodes.ACC_BRIDGE) != 0)\n"
"                && ((access & Opcodes.ACC_SYNTHETIC) != 0)) { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:226
#, no-wrap
msgid ""
"            return null; <2>\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:230
#, no-wrap
msgid ""
"        return super.visitMethod(access, name, descriptor, signature, exceptions); <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:232
#, fuzzy
msgid "If the method name matches and the method is a bridge and synthetic method..."
msgstr "メソッド名が一致し、そのメソッドがブリッジと合成メソッドである場合..."

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:233
#, fuzzy
msgid "... we remove it from the bytecode by returning `null`."
msgstr "<li> <p>を返すことで、バイトコードからそれを削除します。 `null` 。</p> </li>"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:234
#, fuzzy
msgid "If not, we just delegate to the superclass method that will incorporate the method in the bytecode."
msgstr "そうでない場合は、バイトコードにそのメソッドを組み込むスーパークラスのメソッドに委ねるだけです。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:236
#, fuzzy
msgid "And that's it!"
msgstr "で、終わり！？"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:240
#, fuzzy
msgid "During the build process, Quarkus will create a class file containing the modified bytecode and will use it instead of the class coming from the GitHub API jar.  Thus the bridge methods we wanted to remove will never be visible to ByteBuddy."
msgstr "ビルドプロセスで、Quarkusは修正されたバイトコードを含むクラスファイルを作成し、GitHub API jarから来るクラスの代わりにそれを使用します。そのため、削除したいブリッジメソッドがByteBuddyから見えることはありません。"

#. type: Title ==
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:241
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:245
#, fuzzy
msgid "At conferences, we often say that Quarkus is doing things differently from other frameworks and that the magic relies in its innovative build process."
msgstr "カンファレンスでは、Quarkusは他のフレームワークとは異なることを行っており、その革新的なビルドプロセスに魔法がかかっているとよく言われます。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:247
#, fuzzy
msgid "This build process is the key to the low memory footprint and fast startup times of Quarkus."
msgstr "このビルドプロセスが、Quarkusのメモリフットプリントの少なさと起動時間の速さの秘訣です。"

#. type: Plain text
#: upstream/_posts/2022-04-20-solving-problems-with-extensions.adoc:249
#, fuzzy, no-wrap
msgid "**But it is also a very powerful tool to customize the build of your applications.**\n"
msgstr "*しかし、アプリケーションのビルドをカスタマイズするための非常に強力なツールでもあるのです。*"

#, fuzzy
#~ msgid "---\n"
#~ msgstr "---\n"
