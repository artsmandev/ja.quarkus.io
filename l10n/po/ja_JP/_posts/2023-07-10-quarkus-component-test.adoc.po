# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-09-10 08:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: author
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:1
#, no-wrap
msgid "mkouba"
msgstr "mkouba"

#. type: YAML Front Matter: date
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:1
#, fuzzy, no-wrap
msgid "2023-07-10"
msgstr "2023-07-10"

#. type: YAML Front Matter: layout
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:1
#, no-wrap
msgid "post"
msgstr "post"

#. type: YAML Front Matter: synopsis
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:1
#, fuzzy, no-wrap
msgid "Quarkus 3.2 introduced an experimental feature to ease the testing of CDI components and mocking of their dependencies."
msgstr "Quarkus 3.2では、CDIコンポーネントのテストと依存関係のモッキングを容易にする実験的な機能が導入されました。"

#. type: YAML Front Matter: tags
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:1
#, fuzzy, no-wrap
msgid "testing"
msgstr "テスト"

#. type: YAML Front Matter: title
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:1
#, fuzzy, no-wrap
msgid "Explore a new way of testing CDI components in Quarkus"
msgstr "QuarkusでCDIコンポーネントをテストする新しい方法を探る"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:21
#, fuzzy
msgid "The Quarkus component model is built on top of CDI.  However, writing unit tests for beans without a running CDI container is often a tedious work.  Without the container services up and running, all the work has to be done manually.  First of all, no dependency injection is performed.  Furthermore, no events are fired and no observers are notified.  Also, interceptors are not applied.  In short, everything needs to be wired together by hand.  But Quarkus can do better, right? Of course, it can! Quarkus 3.2 introduced an experimental feature to ease the testing of CDI components and mocking of their dependencies.  It's a lightweight JUnit 5 extension that does not start a full Quarkus application but merely runs the services needed to make the testing a joyful experience."
msgstr "Quarkusのコンポーネントモデルは、CDIの上に構築されています。しかし、実行中のCDIコンテナなしでBeanのユニットテストを書くのは、しばしば退屈な作業です。コンテナサービスが稼働していないと、すべての作業を手作業で行わなければなりません。まず、依存性注入は行われない。さらに、イベントも発生せず、オブザーバにも通知されません。また、インターセプターも適用されない。要するに、すべてを手作業で配線する必要がある。でも、Quarkusならもっとうまくできるでしょ？もちろん、できます！Quarkus 3.2では、CDIコンポーネントのテストと依存関係のモッキングを容易にする実験的な機能が導入されました。これは軽量なJUnit 5エクステンションで、Quarkusアプリケーションを完全に起動するのではなく、テストを楽しくするために必要なサービスを実行するだけです。"

#. type: Title ==
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:22
#, fuzzy, no-wrap
msgid "A simple example"
msgstr "簡単な例"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:25
#, fuzzy
msgid "First of all, add the `quarkus-junit5-component` module dependency to your project."
msgstr "まず、 `quarkus-junit5-component` モジュールの依存関係をプロジェクトに追加する。"

#. type: Block title
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:27
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:36
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-junit5-component</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:39
#, no-wrap
msgid "Gradle"
msgstr "Gradle"

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:46
#, no-wrap
msgid ""
"dependencies {\n"
"    testImplementation(\"io.quarkus:quarkus-junit5-component\")\n"
"}\n"
msgstr ""

#. type: delimited block *
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:50
#, fuzzy
msgid "Now, imagine that we have a component `Foo` which is an `@ApplicationScoped` CDI bean."
msgstr "ここで、 `@ApplicationScoped` CDI Beanであるコンポーネント `Foo` があるとします。"

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:54
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:57
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:60
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Foo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:63
#, no-wrap
msgid ""
"    @Inject\n"
"    Charlie charlie; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:66
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"bar\") <2>\n"
"    boolean bar; \n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:71
#, no-wrap
msgid ""
"    public String ping() { <3>\n"
"        return bar ? charlie.ping() : \"nok\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:74
#, fuzzy
msgid "<1>\t`Foo` depends on `Charlie` which declares a method `ping()`.  <2>\t`Foo` depends on the config property `bar`."
msgstr ""
"\n"
" `Foo` `ping()` メソッドを宣言している に依存する。 <2> コンフィグプロパティ に依存する。 `Charlie` `Foo` `bar`"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:75
#, fuzzy
msgid "The goal is to test this method which makes use of the `Charlie` dependency and the `bar` config property."
msgstr "目標は、 `Charlie` 依存性と `bar` config プロパティを利用するこのメソッドをテストすることである。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:77
#, fuzzy
msgid "Then, a simple component test looks like this:"
msgstr "すると、単純なコンポーネントテストは次のようになる："

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:81
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:156
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:190
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:232
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:88
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import io.quarkus.test.InjectMock;\n"
"import io.quarkus.test.component.TestConfigProperty;\n"
"import io.quarkus.test.component.QuarkusComponentTest;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.mockito.Mockito;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:92
#, no-wrap
msgid ""
"@QuarkusComponentTest <1>\n"
"@TestConfigProperty(key = \"bar\", value = \"true\") <2>\n"
"public class FooTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:95
#, no-wrap
msgid ""
"    @Inject\n"
"    Foo foo; <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:98
#, no-wrap
msgid ""
"    @InjectMock\n"
"    Charlie charlieMock; <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:105
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPing() {\n"
"        Mockito.when(charlieMock.ping()).thenReturn(\"OK\"); <5>\n"
"        assertEquals(\"OK\", foo.ping());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:107
#, fuzzy
msgid "`@QuarkusComponentTest` registers the `QuarkusComponentTestExtension` that does all the heavy lifting under the hood."
msgstr "`@QuarkusComponentTest` `QuarkusComponentTestExtension` 、ボンネットの中で力仕事をこなす。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:108
#, fuzzy
msgid "`@TestConfigProperty` is used to set the value of a configuration property for the test."
msgstr "`@TestConfigProperty` は、テストの設定プロパティの値を設定するために使用します。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:109
#, fuzzy
msgid "The test injects the tested component. The types of all fields annotated with `@Inject` are considered the component types under test."
msgstr "テストはテスト対象のコンポーネントを注入する。 `@Inject` でアノテーションされたすべてのフィールドの型が、テスト対象のコンポーネント型とみなされます。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:110
#, fuzzy
msgid "The test also injects a mock of `Charlie`, a dependency for which a `@Singleton` bean is registered automatically. The injected reference is an \"unconfigured\" Mockito mock."
msgstr "このテストでは、 `@Singleton` Beanが自動的に登録される依存関係である `Charlie` のモックも注入します。注入された参照は「未構成」のMockitoモックです。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:111
#, fuzzy
msgid "The Mockito API is used to configure the behavior of the injected mock."
msgstr "注入されたモックの動作を設定するには、Mockito APIを使用します。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:115
#, fuzzy
msgid "In this particular test, the only \"real\" component under the test is `org.acme.Foo`.  The `Charlie` dependency is a mock that is created automatically.  And the value of the `bar` configuration property is set with the `@TestConfigProperty` annotation."
msgstr "この特定のテストでは、テスト対象の唯一の「本物の」コンポーネントは `org.acme.Foo` です。 `Charlie` の依存関係は、自動的に作成されるモックです。そして、 `bar` 設定プロパティの値は、 `@TestConfigProperty` アノテーションで設定されます。"

#. type: Title ==
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:116
#, fuzzy, no-wrap
msgid "How does it work?"
msgstr "どのように機能するのか？"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:124
#, fuzzy
msgid "The `QuarkusComponentTestExtension` does several things during the `before all` test phase.  It starts ArC - the CDI container in Quarkus.  It also registers a dedicated configuration object.  The container is then stopped and the config is released during the `after all` test phase.  The fields annotated with `@Inject` and `@InjectMock` are injected after a test instance is created.  Finally, the CDI request context is activated and terminated per each test method."
msgstr "`before all` テストフェーズでは、 `QuarkusComponentTestExtension` がいくつかの処理を行います。ArC（QuarkusのCDIコンテナ）が起動します。また、専用のコンフィギュレーション・オブジェクトが登録されます。その後、 `after all` テストフェーズの間、コンテナは停止され、コンフィグが解放されます。テストインスタンスが作成されると、 `@Inject` と `@InjectMock` でアノテーションされたフィールドが注入されます。最後に、各テストメソッドごとに CDI リクエストコンテキストがアクティブになり、終了します。"

#. type: Title ===
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:125
#, fuzzy, no-wrap
msgid "Tested components"
msgstr "テスト済みコンポーネント"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:130
#, fuzzy
msgid "By default, the types of all fields annotated with `@Inject` are considered component types.  However, you can also specify additional test components: either with the `@QuarkusComponentTest#value()` or programmatically as the arguments of the <<advanced_features,`QuarkusComponentTestExtension(Class<?>...)`>> constructor.  Finally, the static nested classes declared on the test class are components too."
msgstr "デフォルトでは、 `@Inject` でアノテーションされたすべてのフィールドの型がコンポーネント型とみなされます。しかし、追加のテスト・コンポーネントを指定することもできます。 `@QuarkusComponentTest#value()` で指定するか、あるいはプログラムで xref:advanced_features[QuarkusComponentTestExtension(Class<?>…)] コンストラクタの引数として指定します。最後に、テストクラス上で宣言された静的な入れ子クラスもコンポーネントです。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:132
#, fuzzy
msgid "Static nested classed declared on a test class that is annotated with `@QuarkusComponentTest` are excluded from bean discovery when running a regular `@QuarkusTest` in order to prevent unintentional CDI conflicts."
msgstr "`@QuarkusComponentTest` でアノテーションされたテストクラスで宣言された静的入れ子クラスは、意図しない CDI の衝突を防ぐために、通常の `@QuarkusTest` を実行するときに Bean 発見から除外されます。"

#. type: Title ===
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:133
#, fuzzy, no-wrap
msgid "Automatic mocking of unsatisfied dependencies"
msgstr "不満足な依存関係の自動モッキング"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:140
#, fuzzy
msgid "Unlike in regular CDI environments, the test does not fail if a component injects an unsatisfied dependency.  Instead, a mock bean is registered automatically for each combination of required type and qualifiers of an injection point that resolves to an unsatisfied dependency.  The mock bean has the `@Singleton` scope so it’s shared across all injection points with the same required type and qualifiers.  And the injected reference is an unconfigured Mockito mock.  This mock can be injected in the test with `@io.quarkus.test.InjectMock` and configured with the Mockito API."
msgstr "通常の CDI 環境とは異なり、コンポーネントが満足しない依存関係を注入してもテストは失敗しない。その代わりに、満足しない依存関係に解決する注入ポイントの必須型と修飾子の組み合わせごとに、モック Bean が自動的に登録されます。モックBeanは， `@Singleton` スコープをもつので，同じ要求型及び修飾子をもつすべての注入点にわたって共有される。そして、注入された参照は未構成のMockitoモックです。このモックは `@io.quarkus.test.InjectMock` 、Mockito APIで設定することでテストに注入することができます。"

#. type: Title ===
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:141
#, no-wrap
msgid "Configuration"
msgstr "設定"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:146
#, fuzzy
msgid "A dedicated `SmallRyeConfig` is registered during the `before all` test phase.  It’s possible to set the configuration properties with the `@TestConfigProperty` annotation or programmatically with the `QuarkusComponentTestExtension#configProperty(String, String)` method.  If you need to use the default values for missing config properties, then `@QuarkusComponentTest#useDefaultConfigProperties()` and `QuarkusComponentTestExtension#useDefaultConfigProperties()` might come in useful."
msgstr "`before all` テスト・フェーズの間に、専用の `SmallRyeConfig` が登録される。設定プロパティは、 `@TestConfigProperty` アノテーションで設定するか、 `QuarkusComponentTestExtension#configProperty(String, String)` メソッドでプログラム的に設定することができます。設定プロパティのデフォルト値を使用する必要がある場合は、 `@QuarkusComponentTest#useDefaultConfigProperties()` および `QuarkusComponentTestExtension#useDefaultConfigProperties()` を使用すると便利です。"

#. type: Title ==
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:148
#, fuzzy, no-wrap
msgid "Advanced features"
msgstr "高度な機能"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:152
#, fuzzy
msgid "It is possible to configure the `QuarkusComponentTestExtension` programatically.  The simple example above could be rewritten like:"
msgstr "`QuarkusComponentTestExtension` をプログラムで設定することも可能である。上記の単純な例は、次のように書き換えることができる："

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:162
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import io.quarkus.test.InjectMock;\n"
"import io.quarkus.test.component.QuarkusComponentTestExtension;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.mockito.Mockito;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:164
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:199
#, no-wrap
msgid "public class FooTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:168
#, no-wrap
msgid ""
"    @RegisterExtension <1>\n"
"    static final QuarkusComponentTestExtension extension = new QuarkusComponentTestExtension()\n"
"            .configProperty(\"bar\",\"true\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:171
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:211
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:242
#, no-wrap
msgid ""
"    @Inject\n"
"    Foo foo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:174
#, no-wrap
msgid ""
"    @InjectMock\n"
"    Charlie charlieMock;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:181
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPing() {\n"
"        Mockito.when(charlieMock.ping()).thenReturn(\"OK\");\n"
"        assertEquals(\"OK\", foo.ping());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:183
#, fuzzy
msgid "Annotate a `static` field of type `QuarkusComponentTestExtension` with the `@RegisterExtension` annotation and configure the extension programmatically."
msgstr "`QuarkusComponentTestExtension` 型の `static` フィールドに `@RegisterExtension` アノテーションを付け、エクステンションをプログラムで設定する。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:186
#, fuzzy
msgid "Sometimes you need full control over the bean attributes and maybe even configure the default behavior of a mocked dependency.  In this case, the mock configurator API and the `QuarkusComponentTestExtension#mock()` method is the right choice."
msgstr "Bean 属性を完全に制御し、モックされた依存関係のデフォルトの振る舞いを設定する必要がある場合もあるでしょう。この場合、モック設定 API と `QuarkusComponentTestExtension#mock()` メソッドを使うのが正しい選択です。"

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:197
#, no-wrap
msgid ""
"import jakarta.enterprise.context.Dependent;\n"
"import jakarta.inject.Inject;\n"
"import io.quarkus.test.InjectMock;\n"
"import io.quarkus.test.component.QuarkusComponentTestExtension;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.mockito.Mockito;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:208
#, no-wrap
msgid ""
"    @RegisterExtension \n"
"    static final QuarkusComponentTestExtension extension = new QuarkusComponentTestExtension()\n"
"            .configProperty(\"bar\",\"true\")\n"
"            .mock(Charlie.class)\n"
"                .scope(Dependent.class) <1>\n"
"                .createMockitoMock(mock -> {\n"
"                    Mockito.when(mock.pong()).thenReturn(\"BAR\"); <2>\n"
"                });\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:217
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPing() {\n"
"        assertEquals(\"BAR\", foo.ping());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:219
#, fuzzy
msgid "The scope of the mocked bean is `@Dependent`."
msgstr "モックされた Bean のスコープは `@Dependent` です。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:220
#, fuzzy
msgid "Configure the default behavior of the mock."
msgstr "モックのデフォルトの動作を設定する。"

#. type: Title ===
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:221
#, fuzzy, no-wrap
msgid "Mocking CDI interceptors"
msgstr "CDIインターセプターをモックする"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:224
#, fuzzy
msgid "This feature is only available in Quarkus 3.3+."
msgstr "この機能はQuarkus 3.3+でのみ使用できます。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:228
#, fuzzy
msgid "If a tested component class declares an interceptor binding then you might need to mock the interception too.  You can define a mock interceptor class as a static nested class of the test class.  This interceptor class is then automatically discovered"
msgstr "テスト対象のコンポーネントクラスがインターセプター・バインディングを宣言している場合、そのインターセプターもモックする必要があるかもしれません。モック・インターセプタ・クラスを、テスト・クラスの静的ネスト・クラスとして定義することができます。このインターセプタクラスは、自動的に"

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:236
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import io.quarkus.test.component.QuarkusComponentTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:239
#, no-wrap
msgid ""
"@QuarkusComponentTest\n"
"public class FooTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:247
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPing() {\n"
"        assertEquals(\"OK\", foo.ping());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:250
#, no-wrap
msgid ""
"    @ApplicationScoped\n"
"    static class Foo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:255
#, no-wrap
msgid ""
"       @SimpleBinding <1>\n"
"       String ping() {\n"
"         return \"ok\";\n"
"       }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:257
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:261
#, no-wrap
msgid ""
"    @SimpleBinding\n"
"    @Interceptor\n"
"    static class SimpleMockInterceptor {  <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:266
#, no-wrap
msgid ""
"        @AroundInvoke\n"
"        Object aroundInvoke(InvocationContext context) throws Exception {\n"
"            return context.proceed().toString().toUpperCase();\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:269
#, no-wrap
msgid ""
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:271
#, fuzzy
msgid "`@SimpleBinding` is an interceptor binding."
msgstr "`@SimpleBinding` はインターセプター・バインディングである。"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:272
#, fuzzy
msgid "The interceptor class is automatically considered a tested component and therefore used during the test execution."
msgstr "インターセプター・クラスは自動的にテストされたコンポーネントとみなされ、テスト実行中に使用されます。"

#. type: Title ==
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:273
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Plain text
#: upstream/_posts/2023-07-10-quarkus-component-test.adoc:275
#, fuzzy
msgid "In this article, we discussed the possibilities of a new way of testing CDI components in a Quarkus application."
msgstr "この記事では、QuarkusアプリケーションでCDIコンポーネントをテストする新しい方法の可能性について説明しました。"

#, fuzzy
#~ msgid "By default, a new test instance is created for each test method. Therefore, a new CDI container is started for each test method. However, if the test class is annotated with `@org.junit.jupiter.api.TestInstance` and the test instance lifecycle is set to `org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS` then the CDI container will be shared across all test method executions of a given test class."
#~ msgstr "デフォルトでは、テスト・メソッドごとに新しいテスト・インスタンスが作成されます。そのため、テストメソッドごとに新しい CDI コンテナが開始されます。しかし、テストクラスが `@org.junit.jupiter.api.TestInstance` でアノテーションされ、テストインスタンスのライフサイクルが `org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS` に設定されている場合、CDI コンテナは、指定されたテストクラスのすべてのテストメソッド実行で共有されます。"
