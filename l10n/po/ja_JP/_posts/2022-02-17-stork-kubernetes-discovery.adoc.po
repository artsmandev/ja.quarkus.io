# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-02-11 12:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:1
#, fuzzy, no-wrap
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:8
#, fuzzy, no-wrap
msgid ""
"layout: post\n"
"title: 'Kubernetes Service Discovery and Selection with Stork'\n"
"date: 2022-02-17\n"
"tags: extension smallrye-stork\n"
"synopsis: How to configure Smallrye Stork in a client-side microservice for using Kubernetes Service Discovery strategy\n"
"author: aureamunoz\n"
"---\n"
msgstr ""
"layout: post\n"
"title: 'StorkによるKubernetesのサービスディスカバリーと選択'\n"
"date: 2022-02-17\n"
"tags: extension smallrye-stork\n"
"synopsis: Kubernetesのサービスディスカバリー戦略を使用するために、クライアント側のマイクロサービスにSmallrye Storkを設定する方法\n"
"author: aureamunoz\n"
"---\n"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:12
#, fuzzy
msgid "As we already described in the https://quarkus.io/blog/smallrye-stork-intro/[previous post], SmallRye Stork is a service discovery and client-side load-balancing framework that brings out-of-the-box integration with Kubernetes, among others. This post will explain this integration, how to configure Stork in a client-side microservice, and how it differs from the classic Kubernetes service discovery and load-balancing."
msgstr "前回の link:https://quarkus.io/blog/smallrye-stork-intro/[記事]でご紹介したように、SmallRye Storkはサービスディスカバリーとクライアントサイドのロードバランシングのフレームワークで、Kubernetesなどとの統合をすぐに実現します。この記事では、この統合について、クライアントサイドのマイクロサービスにStorkを設定する方法、そして従来のKubernetesのサービスディスカバリーとロードバランシングとの違いについて説明します。"

#. type: Title ==
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:13
#, fuzzy, no-wrap
msgid "Kubernetes service discovery and load balancing"
msgstr "Kubernetesのサービスディスカバリーとロードバランシング"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:16
#, fuzzy
msgid "Kubernetes has built-in service discovery and load balancing."
msgstr "Kubernetesには、サービスディスカバリーとロードバランシングが組み込まれています。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:18
#, fuzzy
msgid "Let's imagine you have an application deployed in Kubernetes and exposing an HTTP API. You declare a Kubernetes service that delegates the calls to your application. This service acts as a proxy in front of a set of pods (often application replicas). When another application calls our HTTP API, it uses DNS to locate the Kubernetes service and uses the resolved address. It's important to understand that it does not locate and call the application instance but the Kubernetes service. This service then delegates the call to the actual application and implements a round-robin when there are multiple replicas."
msgstr "Kubernetesにデプロイされたアプリケーションがあり、HTTP APIを公開しているとします。あなたは、アプリケーションへの呼び出しを委譲するKubernetesサービスを宣言します。このサービスは、一連のポッド（多くの場合、アプリケーションのレプリカ）の前でプロキシとして動作します。他のアプリケーションが私たちのHTTP APIを呼び出すと、DNSを使ってKubernetesサービスを探し出し、解決したアドレスを使用します。ここで重要なのは、アプリケーションのインスタンスを探して呼び出すのではなく、Kubernetesサービスを呼び出すということです。そしてこのサービスは、実際のアプリケーションに呼び出しを委ね、複数のレプリカがある場合はラウンドロビンを実装します。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:19
#, no-wrap
msgid "Kubernetes"
msgstr "Kubernetes"

#. type: Target for macro image
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:19
#, no-wrap
msgid "kubernetes-service-discovery.png"
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:21
#, fuzzy, no-wrap
msgid "What does Stork bring for Kubernetes?"
msgstr "StorkはKubernetesに何をもたらしますか？"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:24
#, fuzzy
msgid "Even though Kubernetes has built-in support for service discovery, sometimes we need more flexibility in the service instance selection. As we have seen, the Kubernetes service implements a round-robin.  With Stork, you can customize the selection."
msgstr "Kubernetesにはサービスディスカバリーのサポートが組み込まれていますが、サービスインスタンスの選択にもっと柔軟性が必要な場合もあります。これまで見てきたように、Kubernetesのサービスはラウンドロビンを実装しています。Storkでは、この選択をカスタマイズすることができます。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:26
#, fuzzy
msgid "Unlike in the previous example, Stork does not use DNS to locate the Kubernetes service. It uses the Kubernetes API to retrieve the set of pods behind a Kubernetes service. Then, you can apply any Stork service selection or even implement your own."
msgstr "前述の例とは異なり、StorkはDNSを使用してKubernetesサービスの位置を特定しません。Kubernetes APIを使用して、Kubernetesサービスの背後にあるポッドのセットを取得します。その後、Storkのサービスセレクションを適用したり、独自のサービスを実装したりすることができます。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:28
#, fuzzy
msgid "The following figure depicts the architecture and how Stork locates and selects the service instance."
msgstr "次の図は、Storkがどのようにしてサービスインスタンスを探し出し、選択するかというアーキテクチャを示しています。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:29
#, fuzzy, no-wrap
msgid "Service"
msgstr "サービス"

#. type: Target for macro image
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:29
#, no-wrap
msgid "service-instances-location.png"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:32
#, fuzzy
msgid "As shown in the architecture above, the Kubernetes rest-service is backed by two pods.  While classic Kubernetes service discovery would ensure that requests to the rest-service are load-balanced across these two pods, Stork retrieves the pods' addresses directly. Thus it can handle the service selection (using a round-robin for now)."
msgstr "上記のアーキテクチャに示すように、Kubernetesのレストサービスは2つのポッドによって支えられています。従来のKubernetesのサービスディスカバリーでは、レストサービスへのリクエストがこの2つのポッドに負荷分散されるようになっていましたが、Storkはポッドのアドレスを直接取得します。これにより、サービスの選択を行うことができます（現在はラウンドロビンを使用しています）。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:34
#, fuzzy
msgid "Note that while applications using Stork do not use the Kubernetes service delegation, they still require a Kubernetes service to discover the backed pods. So, it does not change your Kubernetes deployment."
msgstr "なお、Storkを使用するアプリケーションはKubernetesサービスのデリゲーションを使用しませんが、バックアップされたポッドを発見するためにKubernetesサービスが必要になります。そのため、Kubernetesのデプロイメントを変更することはありません。"

#. type: Title ==
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:36
#, fuzzy, no-wrap
msgid "Configuring and Using Stork Kubernetes Service Discovery"
msgstr "Stork Kubernetes Service Discoveryの設定と使用方法"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:39
#, fuzzy
msgid "On the client-side, our Quarkus application uses the REST Client Reactive to interact with the REST API exposed by the `rest-service`. The Client app uses Stork to discover the rest-service instances. The easiest way to enable Stork is to add the corresponding Jar to the classpath of your project:"
msgstr "クライアント側では、QuarkusアプリケーションがREST Client Reactiveを使用して、 `rest-service` が公開するREST APIと対話します。クライアントアプリは、Storkを使用してレストサービスのインスタンスを検出します。Storkを有効にする最も簡単な方法は、対応するJarをプロジェクトのクラスパスに追加することです。"

#. type: Block title
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:40
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:96
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:47
#, no-wrap
msgid ""
"    <dependency>\n"
"        <groupId>io.smallrye.stork</groupId>\n"
"        <artifactId>smallrye-stork-service-discovery-kubernetes</artifactId>\n"
"    </dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:50
#, fuzzy
msgid "With Stork and the Stork Kubernetes Service Discovery on the classpath, we need to tell Stork how to locate and select the service. To achieve this, we just add `stork.[service-name].[kebab-cased-property-name]` into the Quarkus application configuration. In our case, to configure the rest-service and indicate to Stork that it should use Kubernetes, we add:"
msgstr "クラスパスにStorkとStork Kubernetes Service Discoveryがある状態で、Storkにサービスの位置と選択方法を伝える必要があります。これを実現するには、Quarkusのアプリケーション設定に `stork.[service-name].[kebab-cased-property-name]` を追加するだけです。今回のケースでは、レストサービスを設定し、StorkにKubernetesを使うべきだと示すために、次のように追加します。"

#. type: Block title
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:52
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:108
#, no-wrap
msgid "application.properties"
msgstr "application.properties"

#. type: delimited block -
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:56
#, no-wrap
msgid ""
"stork.rest-service.service-discovery=kubernetes\n"
"stork.rest-service.service-discovery.k8s-namespace=my-namespace\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:59
#, fuzzy
msgid "Note that you can also configure them via annotations, check the `@ServiceDiscoveryType` and `@ServiceDiscoveryAttribute` annotations."
msgstr "なお、これらの設定はアノテーションで行うこともできます。 `@ServiceDiscoveryType` と `@ServiceDiscoveryAttribute` のアノテーションをご覧ください。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:61
#, fuzzy
msgid "We also can limit the service lookup to our namespace. We can also use the `all` value to look for services in all namespaces."
msgstr "また、サービスの検索を自分のネームスペースに限定することもできます。また、 `all` の値を使用して、すべてのネームスペースのサービスを検索することもできます。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:63
#, fuzzy
msgid "There are a few more properties that we can configure to tune the service discovery:"
msgstr "サービスディスカバリーを調整するために、さらにいくつかのプロパティを設定することができます。"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:66
#, no-wrap
msgid "Property"
msgstr "プロパティー"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:68
#, no-wrap
msgid "Description"
msgstr "説明"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:68
#, fuzzy, no-wrap
msgid "stork.service-name.service-discovery.k8s-host"
msgstr "stork.サービス名.サービス発見.k8s-host"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:69
#, fuzzy, no-wrap
msgid "The Kubernetes API url"
msgstr "Kubernetes APIのURL"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:69
#, fuzzy, no-wrap
msgid "stork.service-name.service-discovery.application"
msgstr "コウノトリ.サービス名.サービス-ディスカバリー.アプリケーション"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:70
#, fuzzy, no-wrap
msgid "The name of the target application"
msgstr "対象となるアプリケーションの名前"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:70
#, fuzzy, no-wrap
msgid "stork.service-name.service-discovery.refresh-period"
msgstr "stork.サービス名.サービス-ディスカバリー.リフレッシュ-period"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:71
#, fuzzy, no-wrap
msgid "Service discovery cache refresh period"
msgstr "サービスディスカバリーキャッシュの更新期間"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:71
#, fuzzy, no-wrap
msgid "stork.service-name.service-discovery.secure"
msgstr "コウノトリ.サービス名.サービス-ディスカバリー.セキュア"

#. type: Table
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:73
#, fuzzy, no-wrap
msgid "Use a secure connection (e.g. HTTPS)"
msgstr "安全な接続の使用（例：HTTPS）"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:76
#, fuzzy
msgid "That's how easy it is to have Stork Kubernetes service discovery."
msgstr "これだけ簡単にStork Kubernetesのサービスディスカバリーができるのです。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:78
#, fuzzy
msgid "Once Stork is configured, we need to configure the REST Client to use it. It can be done in the `@RegisterRestClient` annotated interface by adding the `baseUri` attribute with the `stork://` scheme:"
msgstr "Storkを設定したら、それを使用するためにRESTクライアントを設定する必要があります。これは、 `@RegisterRestClient` アノテーションされたインターフェイスで、 `stork://` スキームで `baseUri` 属性を追加することで行うことができます。"

#. type: delimited block -
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:88
#, no-wrap
msgid ""
"@Path(\"/test\")\n"
"@RegisterRestClient(baseUri = \"stork://rest-service\")\n"
"public interface Client {\n"
"@GET\n"
"@Path(\"/\")\n"
"Uni<String> get();\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:90
#, fuzzy, no-wrap
msgid "Customizing the service selection"
msgstr "サービス選択のカスタマイズ"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:93
#, fuzzy
msgid "Now that the service is located, we need to select the _best_ instance. For example, you can use the least-response-time load-balancer implementation. This selection strategy monitors the interactions and selects the fastest instance to improve the response time."
msgstr "サービスの配置が完了したので、 _最適な_インスタンスを選択する必要があります。たとえば、最小応答時間のロードバランサーの実装を利用することができます。この選択戦略は、インタラクションを監視し、応答時間を改善するために最速のインスタンスを選択します。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:95
#, fuzzy
msgid "To achieve this, you need to add the load-balancer implementation on your classpath:"
msgstr "これを実現するためには、クラスパスにロードバランサーの実装を追加する必要があります。"

#. type: delimited block -
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:103
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.stork</groupId>\n"
"    <artifactId>smallrye-stork-load-balancer-response-time</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:106
#, fuzzy
msgid "Then, in the application configuration, add:"
msgstr "そして、アプリケーションの設定で、以下を追加します。"

#. type: delimited block -
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:111
#, no-wrap
msgid "stork.my-service.load-balancer=least-response-time\n"
msgstr ""

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:114
#, fuzzy
msgid "Obviously, you can pick any load-balancing strategy or even implement your own one!"
msgstr "もちろん、任意のロードバランシング戦略を選択することも、独自のロードバランシング戦略を実装することもできます。"

#. type: Title ==
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:115
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:118
#, fuzzy
msgid "This post shows how you can use Stork in a Kubernetes environment to customize the service selection. While Kubernetes offers built-in service discovery and load-balancing, Stork adds another level of flexibility."
msgstr "この記事では、Kubernetes環境でStorkを使用して、サービス選択をカスタマイズする方法を紹介します。Kubernetesにはサービスディスカバリーとロードバランシングが組み込まれていますが、Storkはもう一つのレベルの柔軟性を提供します。"

#. type: Plain text
#: upstream/_posts/2022-02-17-stork-kubernetes-discovery.adoc:119
#, fuzzy
msgid "You can check the code of the example in https://github.com/michalszynkiewicz/rest-client-reactive-stork/tree/kubernetes[this repo] for the client-side, and https://github.com/michalszynkiewicz/configurable-rest-service/tree/kubernetes[this one] for the HTTP service."
msgstr "クライアント側は link:https://github.com/michalszynkiewicz/rest-client-reactive-stork/tree/kubernetes[このレポ]で、HTTPサービス側は link:https://github.com/michalszynkiewicz/configurable-rest-service/tree/kubernetes[このレポ]で、それぞれサンプルのコードを確認できます。"
