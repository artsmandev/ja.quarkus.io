# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2021-11-24 10:04+0000\n"
"PO-Revision-Date: 2021-03-09 22:12+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/writing-extensions.adoc:6
#, fuzzy, no-wrap
#| msgid "Quarkus - Writing Your Own Extension"
msgid "Writing Your Own Extension"
msgstr "独自のエクステンションの作成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:16
msgid "Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services."
msgstr "Quarkusのエクステンションは、コアサービスに開発者向けの新しい動作を追加するもので、ビルド時の拡張とランタイムコンテナという2つの異なる部分から構成されています。拡張部分は、アノテーションやXML記述子の読み込みなど、すべてのメタデータ処理を担当します。この拡張フェーズの出力は、関連するランタイムサービスを直接インスタンス化するためのバイトコードとして記録されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:19
msgid "This means that metadata is only processed once at build time, which both saves on startup time, and also on memory usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM."
msgstr "これは、メタデータがビルド時に一度だけ処理されることを意味し、起動時間の節約と、処理に使用されるクラスなどがランタイムJVMにロードされない（あるいは存在しない）ため、メモリ使用量の節約の両方を実現しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:21
msgid "This is an in-depth documentation, see the link:building-my-first-extension[building my first extension] if you need an introduction."
msgstr "これは、詳細に踏み込むドキュメントです。入門ドキュメントが必要な場合は、 link:building-my-first-extension[初めてのエクステンションの作成]をご覧ください。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:22
#, no-wrap
msgid "Extension philosophy"
msgstr "エクステンション哲学"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:25
msgid "This section is a work in progress and gathers the philosophy under which extensions should be designed and written."
msgstr "このセクションは作業中であり、エクステンションがどのように設計され、どのように書かれるべきかの哲学を記述します。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:26
#, no-wrap
msgid "Why an extension framework"
msgstr "なぜエクステンションフレームワークなのか"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:32
msgid "Quarkus’s mission is to transform your entire application including the libraries it uses, into an artifact that uses significantly less resources than traditional approaches. These can then be used to build native applications using GraalVM.  To do this you need to analyze and understand the full \"closed world\" of the application.  Without the full and complete context, the best that can be achieved is partial and limited generic support.  By using the Quarkus extension approach, we can bring Java applications in line with memory footprint constrained environments like Kubernetes or cloud platforms."
msgstr "Quarkusの使命は、使用するライブラリを含むアプリケーション全体を、従来のアプローチよりも大幅に少ないリソースしか使用しないアーティファクトに変換することです。これらを使用して、GraalVMを使用してネイティブアプリケーションを構築することができます。これを行うためには、アプリケーションの完全な「クローズドワールド」を分析し、理解する必要があります。完全で完璧なコンテキストがなければ、達成可能なものは最高でも部分的で限定的、一般的なサポートです。Quarkusのエクステンションアプローチを使用することで、Kubernetesやクラウドプラットフォームのようなメモリフットプリントに制約のある環境にJavaアプリケーションを合わせることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:35
msgid "The Quarkus extension framework results in significantly improved resource utilization even when GraalVM is not used (e.g. in HotSpot).  Let’s list the actions an extension performs:"
msgstr "Quarkusエクステンションフレームワークは、GraalVMを使用していない場合（HotSpotなど）でも、リソース利用率を大幅に改善します。エクステンションが実行するアクションをリストアップしてみましょう:"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:37
msgid "Gather build time metadata and generate code"
msgstr "ビルド時のメタデータを収集し、コードを生成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:38
msgid "This part has nothing to do with GraalVM, it is how Quarkus starts frameworks “at build time”"
msgstr "この部分はGraalVMとは何の関係もありませんが、Quarkusがフレームワークを\"ビルド時\" に起動する方法です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:39
msgid "The extension framework facilitates reading metadata, scanning classes as well as generating classes as needed"
msgstr "エクステンションフレームワークは、必要に応じてメタデータの読み込み、クラスのスキャン、クラスの生成を容易にします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:40
msgid "A small part of the extension work is executed at runtime via the generated classes, while the bulk of the work is done at build time (called deployment time)"
msgstr "拡張作業のごく一部は生成されたクラスを介して実行時に実行され、作業の大部分はビルド時に行われます (デプロイメント時と呼ばれます)"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:41
msgid "Enforce opinionated and sensible defaults based on the close world view of the application (e.g. an application with no `@Entity` does not need to start Hibernate ORM)"
msgstr "アプリケーションの近い世界観に基づいて、定見に基づいた賢明なデフォルトを強制（例えば、 `@Entity` のないアプリケーションは、Hibernate ORM を起動する必要はありません）"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:42
msgid "An extension hosts Substrate VM code substitution so that libraries can run on GraalVM"
msgstr "エクステンションは Substrate VM のコード置換をホストし、ライブラリを GraalVM 上で実行できるようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:43
msgid "Most changes are pushed upstream to help the underlying library run on GraalVM"
msgstr "ほとんどの変更は、基礎となるライブラリがGraalVM上で動作するようにupstreamにプッシュされます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:44
msgid "Not all changes can be pushed upstream, extensions host Substrate VM substitutions - which is a form of code patching - so that libraries can run"
msgstr "すべての変更をupstreamにプッシュできるわけではないので、エクステンションは Substrate VM 置換をホスト。これはコードパッチの一形態で、ライブラリが実行できるようになっています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:45
msgid "Host Substrate VM code substitution to help dead code elimination based on the application needs"
msgstr "Substrate VMコード置換のホストにより、アプリケーションのニーズに基づいたデッドコードの排除を支援します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:46
msgid "This is application dependant and cannot really be shared in the library itself"
msgstr "これはアプリケーションに依存しており、ライブラリ自体で共有することはできません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:47
msgid "For example, Quarkus optimizes the Hibernate code because it knows it only needs a specific connection pool and cache provider"
msgstr "たとえば、Quarkusは、特定の接続プールとキャッシュプロバイダだけが必要であることを知っているため、Hibernateコードを最適化します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:48
msgid "Send metadata to GraalVM for example classes in need of reflection"
msgstr "メタデータをGraalVMに送信。例えば、リフレクションに必要なクラス"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:49
msgid "This information is not static per library (e.g. Hibernate) but the framework has the semantic knowledge and knows which classes need to have reflection (for example @Entity classes)"
msgstr "この情報はライブラリ(Hibernateなど)ごとに静的ではありませんが、フレームワークはセマンティックな知識を持っており、どのクラスがリフレクションを必要とするかを知っています(例えば@Entityクラスなど)。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:50
#, no-wrap
msgid "Favor build time work over runtime work"
msgstr "ランタイムワークよりもビルドタイムワーク"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:54
msgid "As much as possible favor doing work at build time (deployment part of the extension) as opposed to let the framework do work at startup time (runtime).  The more is done there, the smaller Quarkus applications using that extension will be and the faster they will load."
msgstr "可能な限り、フレームワークに起動時（ランタイム）に作業をさせるのではなく、ビルド時（エクステンションのデプロイメント部分）に作業を行うことをお勧めします。そこでの作業が多いほど、そのエクステンションを使用しているQuarkusアプリケーションは小さくなり、ロードが速くなります。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:55
#, no-wrap
msgid "How to expose configuration"
msgstr "設定を公開する方法"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:59
msgid "Quarkus simplifies the most common usages.  This means that its defaults might be different than the library it integrates."
msgstr "Quarkusは、最も一般的な使用法を簡略化しています。つまり、そのデフォルトは、統合されているライブラリとは異なる場合があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:62
#, fuzzy
#| msgid "To make the simple experience easiest, unify the configuration in `application.properties` via MicroProfile Config.  Avoid library specific configuration files, or at least make them optional: e.g. `persistence.xml` for Hibernate ORM is optional."
msgid "To make the simple experience easiest, unify the configuration in `application.properties` via SmallRye Config.  Avoid library specific configuration files, or at least make them optional: e.g. `persistence.xml` for Hibernate ORM is optional."
msgstr "シンプルな体験を最も簡単にするために、MicroProfile Configを経由して `application.properties` で設定を統一してください。ライブラリ固有の設定ファイルは避けるか、少なくともオプションにしてください: 例: Hibernate ORMの為の `persistence.xml` はオプションです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:67
msgid "Extensions should see the configuration holistically as a Quarkus application instead of focusing on the library experience.  For example `quarkus.database.url` and friends are shared between extensions as defining a database access is a shared task (instead of a `hibernate.` property for example).  The most useful configuration options should be exposed as `quarkus.[extension].` instead of the natural namespace of the library.  Less common properties can live in the library namespace."
msgstr "エクステンションは、ライブラリの体験に焦点を当てるのではなく、Quarkusアプリケーションとして全体的に設定を見るべきです。例えば、データベースアクセスの定義が共有タスクであるように、 `quarkus.database.url` 等々がエクステンション間で共有されます（例えば `hibernate.` プロパティを使用される代わりに）。最も便利な設定オプションは、ライブラリの自然な名前空間ではなく、 `quarkus.[extension].` として公開されるべきです。あまり一般的ではないプロパティは、ライブラリの名前空間に置くことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:71
msgid "To fully enable the close world assumptions that Quarkus can optimize best, it is better to consider configuration options as build time settled vs overridable at runtime.  Of course properties like host, port, password should be overridable at runtime.  But many properties like enable caching or setting the JDBC driver can safely require a rebuild of the application."
msgstr "Quarkusが最適化できる閉じた世界の仮定を完全に有効にするには、ビルド時に設定された設定オプションと実行時にオーバーライド可能な設定オプションのどちらを採用するか検討するべきでしょう。もちろん、ホスト、ポート、パスワードなどのプロパティは、実行時にオーバーライド可能でなければなりません。しかし、キャッシングを有効にしたり、JDBCドライバを設定したりするような多くのプロパティは、アプリケーションの再構築を安全に要求することができます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:72
#, fuzzy, no-wrap
#| msgid "Static Init"
msgid "Static Init Config"
msgstr "スタティック初期化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:75
#, fuzzy
msgid "If the extension provides additional Config Sources and if these are required during Static Init, these must be registered with `StaticInitConfigSourceProviderBuildItem`. Configuration in Static Init does not scan for additional sources to avoid double initialization at application startup time."
msgstr "拡張機能が追加のコンフィグソースを提供し、それらがStatic Init中に必要な場合は、それらを `AdditionalStaticInitConfigSourceProviderBuildItem` に登録する必要があります。Static Initでの設定は、アプリケーション起動時の二重初期化を避けるために、追加のソースをスキャンしません。"

#
#
#
#. === API
#. TODO: Describe where to put APIs
#. I wonder if that content should be in the technical aspects
#. === Substitution and recorders
#. TODO: Describe where Substitutions and recorders should live
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:87
#, no-wrap
msgid "Expose your components via CDI"
msgstr "CDI経由でコンポーネントを公開"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:92
msgid "Since CDI is the central programming model when it comes to component composition, frameworks and extensions should expose their components as beans that are easily consumable by user applications.  For example, Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the connection pool exposes `DataSource` beans etc.  Extensions must register these bean definitions at build time."
msgstr "CDI がコンポーネントの構成に関して中心的なプログラミングモデルであるため、フレームワークやエクステンションはそのコンポーネントを、ユーザアプリケーションが容易に消費できるBeanとして公開しなければなりません。例えば、Hibernate ORM は `EntityManagerFactory` と `EntityManager` の Bean を公開し、コネクションプールは `DataSource` のBeanを公開します。エクステンションは、ビルド時にこれらのBean定義を登録しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:93
#, no-wrap
msgid "Beans backed by classes"
msgstr "クラスに裏付けられたBean"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:96
msgid "An extension can produce an <<cdi-reference.adoc#additional_beans,`AdditionalBeanBuildItem`>> to instruct the container to read a bean definition from a class as if it was part of the original application:"
msgstr "エクステンションは link:cdi-reference.html#additional_beans[`AdditionalBeanBuildItem`] コンテナに、元のアプリケーションの一部であるかのようにクラスからBeanの定義を読み込むように指示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:97
#, no-wrap
msgid "Bean Class Registered by `AdditionalBeanBuildItem`"
msgstr "登録されている Bean クラス `AdditionalBeanBuildItem`"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:102
#, no-wrap
msgid ""
"@Singleton <1>\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:107
#, no-wrap
msgid ""
"   public String echo(String val) {\n"
"      return val;\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:109
msgid "If a bean registered by an `AdditionalBeanBuildItem` does not specify a scope then `@Dependent` is assumed."
msgstr "`AdditionalBeanBuildItem` で登録された Bean がスコープを指定しない場合は `@Dependent` とする。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:111
msgid "All other beans can inject such a bean:"
msgstr "他のすべての Bean は、このような Bean を注入することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:112
#, no-wrap
msgid "Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`"
msgstr "`AdditionalBeanBuildItem` によって構築された Bean をインジェクトするBean"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:117
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:120
#, no-wrap
msgid ""
"    @Inject\n"
"    Echo echo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:127
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello(String foo) {\n"
"        return echo.echo(foo);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:130
msgid "And vice versa - the extension bean can inject application beans and beans provided by other extensions:"
msgstr "また、その逆に、 エクステンション Bean は、他のエクステンションによって提供されるアプリケーション Bean やアプリケーション Bean を注入することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:131
#, no-wrap
msgid "Extension Bean Injection Example"
msgstr "エクステンション Bean インジェクト例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:136
#, no-wrap
msgid ""
"@Singleton\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:139
#, no-wrap
msgid ""
"    @Inject\n"
"    DataSource dataSource;  <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:142
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<List<String>> listsOfStrings; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:145
#, no-wrap
msgid ""
"    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:147
msgid "Inject a bean provided by other extension."
msgstr "他のエクステンションで提供されているBeanをインジェクトします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:148
msgid "Inject all beans matching the type `List<String>`."
msgstr "タイプ `List<String>` に一致するすべてのBeanを注入します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:150
#, no-wrap
msgid "Bean initialization"
msgstr "Beanの初期化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:157
msgid "Some components may require additional initialization based on information collected during augmentation.  The most straightforward solution is to obtain a bean instance and call a method directly from a build step.  However, it is _illegal_ to obtain a bean instance during the augmentation phase.  The reason is that the CDI container is not started yet.  It's started during the <<bootstrap-three-phases,Static init bootstrap phase>>."
msgstr "コンポーネントによっては、拡張中に収集された情報に基づいて、追加の初期化が必要になる場合があります。最も簡単な解決策は、Bean のインスタンスを取得し、ビルドステップから直接メソッドを呼び出すことです。しかし、拡張フェーズ中にBeanインスタンスを取得することは _違反_ です。理由は、CDIコンテナがまだ起動していないからです。CDIコンテナは link:#bootstrap-three-phases[Static initブートストラップフェーズ] の間に起動されています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:159
msgid "`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in any bean. `RUN_TIME` config roots should only be injected after the bootstrap though."
msgstr "`BUILD_AND_RUN_TIME_FIXED` と `RUN_TIME` 設定ルートは、どのBeanにも注入することができます。 `RUN_TIME` 設定ルールは、ブートストラップの後にのみ注入すべきです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:165
msgid "It is possible to invoke a bean method from a <<bytecode-recording,recorder method>> though.  If you need to access a bean in a `@Record(STATIC_INIT)` build step then is must either depend on the `BeanContainerBuildItem` or wrap the logic in a `BeanContainerListenerBuildItem`.  The reason is simple - we need to make sure the CDI container is fully initialized and started.  However, it is safe to expect that the CDI container is fully initialized and running in a `@Record(RUNTIME_INIT)` build step.  You can obtain a reference to the container via `CDI.current()` or Quarkus-specific `Arc.container()`."
msgstr "しかし、 link:#bytecode-recording[recorderメソッド] からBeanメソッドを呼び出すことは可能です。 `@Record(STATIC_INIT)` ビルドステップで Bean にアクセスする必要がある場合は、 `BeanContainerBuildItem` に依存するか、 `BeanContainerListenerBuildItem` でロジックをラップしなければなりません。理由は簡単で、CDIコンテナが完全に初期化されて起動していることを確認する必要があるからです。しかし、CDI コンテナは `@Record(RUNTIME_INIT)` ビルドステップで完全に初期化されて実行されていると思っておいた方が安全です。コンテナへの参照は、 `CDI.current()` またはQuarkus固有の `Arc.container()` ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:167
msgid "Don't forget to make sure the bean state guarantees the visibility, e.g. via the `volatile` keyword."
msgstr "Beanの状態が可視性を保証していることを担保することを忘れないでください。たとえば、`volatile` キーワードです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:171
msgid "There is one significant drawback of this \"late initialization\" approach.  An _uninitialized_ bean may be accessed by other extensions or application components that are instantiated during bootstrap.  We'll cover a more robust solution in the <<synthetic_beans>>."
msgstr "この「遅延初期化」アプローチには、1つの重大な欠点があります。 _初期化されていない_ Beanは、ブートストラップ中にインスタンス化された他のエクステンションやアプリケーションコンポーネントからアクセスされる可能性があります。 link:#synthetic_beans[synthetic_beans]] で、よりロバストな解決策を取り上げます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:172
#, no-wrap
msgid "Default beans"
msgstr "デフォルトのBean"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:177
msgid "A very useful pattern of creating such beans but also giving application code the ability to easily override some of the beans with custom implementations, is to use the `@DefaultBean` that Quarkus provides.  This is best explained with an example."
msgstr "このような Bean を作成しつつ、アプリケーションコードにカスタム実装で Bean の一部を簡単にオーバーライドする機能を与えるという非常に便利なパターンは、Quarkusが提供している `@DefaultBean` を使用することです。これは例を挙げて説明するのが一番です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:179
msgid "Let us assume that the Quarkus extension needs to provide a `Tracer` bean which application code is meant to inject into its own beans."
msgstr "ここでは、Quarkusエクステンションが `Tracer` Bean を提供する必要があると仮定して、アプリケーションコードがそれ自身の Bean に注入することを意味します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:184
#, no-wrap
msgid ""
"@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""
"@Dependent\n"
"public class TracerConfiguration {\n"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:189
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:195
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:202
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:205
msgid "If for example application code wants to use `Tracer`, but also needs to use a custom `Reporter` bean, such a requirement could easily be done using something like:"
msgstr "例えば、アプリケーションコードが `Tracer` を使用したいが、カスタムの `Reporter` Bean を使用する必要がある場合、そのような要件は、次のようなものを使用して簡単に行うことができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:211
#, no-wrap
msgid ""
"@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""
"@Dependent\n"
"public class CustomTracerConfiguration {\n"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:217
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:219
#, no-wrap
msgid "How to Override a Bean Defined by a Library/Quarkus Extension that doesn't use @DefaultBean"
msgstr "DefaultBeanを使用しないライブラリ/Quarkus エクステンションで定義された Bean をオーバーライドする方法"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:224
msgid "Although `@DefaultBean` is the recommended approach, it is also possible for application code to override beans provided by an extension by marking beans as a CDI `@Alternative` and including `@Priority` annotation.  Let's show a simple example.  Suppose we work on an imaginary \"quarkus-parser\" extension and we have a default bean implementation:"
msgstr "`@DefaultBean` が推奨されていますが、CDI `@Alternative` としてBeanをマークし、 `@Priority` アノテーションを含めることで、アプリケーションコードがエクステンションによって提供されるBeanをオーバーライドすることも可能です。簡単な例を示しましょう。架空の\"quarkus-parser\"エクステンションで作業をしていて、デフォルトのBeanの実装を持っているとします。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:229
#, no-wrap
msgid ""
"@Dependent\n"
"class Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:234
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    return expression.split(\"::\");\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:237
msgid "And our extension also consumes this parser:"
msgstr "そして、私たちのエクステンションはこのパーサも消費します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:242
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class ParserService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:245
#, no-wrap
msgid ""
"  @Inject\n"
"  Parser parser;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:248
#, no-wrap
msgid ""
"  //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:251
msgid "Now, if a user or even some other extension needs to override the default implementation of the `Parser` the simplest solution is to use CDI `@Alternative` + `@Priority`:"
msgstr "さて、ユーザーや他のエクステンションが `Parser` のデフォルトの実装を上書きする必要がある場合、最も簡単な解決策は CDI `@Alternative` + `@Priority` を使用することです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:258
#, no-wrap
msgid ""
"@Alternative <1>\n"
"@Priority(1) <2>\n"
"@Singleton\n"
"class MyParser extends Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:263
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    // my super impl...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:265
msgid "`MyParser` is an alternative bean."
msgstr "`MyParser` は代替 Beanです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:266
msgid "Enables the alternative. The priority could be any number to override the default bean but if there are multiple alternatives the highest priority wins."
msgstr "代替 Beanを有効にします。優先度はデフォルトの Bean を上書きするために任意の数値を指定できますが、複数の代替 Bean がある場合は、最も高い優先度のものが優先されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:268
msgid "CDI alternatives are only considered during injection and type-safe resolution. For example the default implementation would still receive observer notifications."
msgstr "CDI の代替 Beanは、インジェクションと型安全解決の間のみ考慮されます。例えば、デフォルトの実装では、オブザーバー通知を受け取ることになります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:270
#, no-wrap
msgid "Synthetic beans"
msgstr "合成Bean"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:275
msgid "Sometimes it is very useful to be able to register a synthetic bean.  Bean attributes of a synthetic bean are not derived from a java class, method or field.  Instead, the attributes are specified by an extension."
msgstr "合成 Beanを登録できると非常に便利なことがあります。合成 Beanのビーン属性は，javaクラス，メソッド，フィールドから派生したものではありません。その代わりに、属性はエクステンションによって指定されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:278
msgid "Since the CDI container does not control the instantiation of a synthetic bean the dependency injection and other services (such as interceptors) are not supported.  In other words, it's up to the extension to provide all required services to a synthetic bean instance."
msgstr "CDIコンテナは合成Beanのインスタンス化を制御しないので、依存性注入や他のサービス(インターセプタなど)はサポートされていません。言い換えれば、合成 Bean のインスタンスに必要なすべてのサービスを提供するのはエクステンション次第ということです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:281
msgid "There are several ways to register a <<cdi-reference.adoc#synthetic_beans,synthetic bean>> in Quarkus.  In this chapter, we will cover a use case that can be used to initialize extension beans in a safe manner (compared to <<bean_init>>)."
msgstr "Quarkusで link:cdi-reference.html#synthetic_beans[合成Bean] を登録する方法はいくつかあります。この章では、（ link:#bean_init[[bean_init]] と比較して）安全な方法でエクステンションBeanを初期化できるユースケースを取り上げます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:283
msgid "The `SyntheticBeanBuildItem` can be used to register a synthetic bean:"
msgstr "`SyntheticBeanBuildItem` で合成 Bean を登録することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:285
msgid "whose instance can be easily produced through a <<bytecode-recording,recorder>>,"
msgstr "そのインスタンスは、 link:#bytecode-recording[レコーダー] を介して簡単に生成することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:286
msgid "to provide a \"context\" bean that holds all the information collected during augmentation so that the real components do not need any \"late initialization\" because they can inject the context bean directly."
msgstr "実際のコンポーネントはコンテキスト Beanを直接注入することができるので\"遅延初期化\"を必要としないように、拡張中に収集されたすべての情報を保持する\"コンテキスト\" Beanを提供します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:287
#, no-wrap
msgid "Instance Produced Through Recorder"
msgstr "レコーダーを通して生成されたインスタンス"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:297
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo(\"parameters are recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:299
msgid "The string value is recorded in the bytecode and used to initialize the instance of `Foo`."
msgstr "文字列の値はバイトコードに記録され、 `Foo` のインスタンス初期化に使用されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:300
#, no-wrap
msgid "\"Context\" Holder"
msgstr "\"コンテキスト\"ホルダー"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:310
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(TestContext.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createContext(\"parameters are recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:312
msgid "The \"real\" components can inject the `TestContext` directly."
msgstr "「本物の」コンポーネントは、 `TestContext` を直接注入することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:313
#, no-wrap
msgid "Some types of extensions"
msgstr "エクステンションのタイプ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:316
msgid "There exist multiple stereotypes of extension, let's list a few."
msgstr "エクステンションの定型的なタイプは複数存在しますが、いくつか挙げてみましょう。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:317
#, no-wrap
msgid "Bare library running"
msgstr "ベアライブラリの実行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:322
msgid "This is the less sophisticated extension.  It consists of a set of patches to make sure a library runs on GraalVM.  If possible, contribute these patches upstream, not in extensions.  Second best is to write Substrate VM substitutions, which are patches applied during native image compilation."
msgstr "これはあまり洗練されていないエクステンションです。これは、ライブラリがGraalVM上で動作するようにするためのパッチのセットで構成されています。可能であれば、これらのパッチはエクステンションの中ではなく、アップストリームで貢献してください。二番目に良いのは、ネイティブイメージのコンパイル時に適用されるパッチである Substrate VM 置換を書くことです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:323
#, no-wrap
msgid "Get a framework running"
msgstr "実行中のフレームワークを取得する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:326
msgid "A framework at runtime typically reads configuration, scan the classpath and classes for metadata (annotations, getters etc), build a metamodel on top of which it runs, find options via the service loader pattern, prepare invocation calls (reflection), proxy interfaces, etc. + These operations should be done at build time and the metamodel be passed to the recorder DSL that will generate classes that will be executed at runtime and boot the framework."
msgstr "実行時のフレームワークは通常、設定を読み込み、クラスパスとクラスをスキャンしてメタデータ(アノテーションやゲッターなど)を探し、その上にメタモデルを構築し、サービスローダパターンを介してオプションを見つけ、実行呼び出し(リフレクション)やプロキシインターフェイスなどを準備します。これらの操作はビルド時に行われ、メタモデルは実行時に実行されるクラスを生成するレコーダDSLに渡され、フレームワークを起動します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:327
#, no-wrap
msgid "Get a CDI portable extension running"
msgstr "CDI ポータブルエクステンションの実行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:332
msgid "The CDI portable extension model is very flexible.  Too flexible to benefit from the build time boot promoted by Quarkus.  Most extension we have seen do not make use of these extreme flexibility capabilities.  The way to port a CDI extension to Quarkus is to rewrite it as a Quarkus extension which will define the various beans at build time (deployment time in extension parlance)."
msgstr "CDIポータブルエクステンションモデルは非常に柔軟性が高いです。Quarkusが推進するビルドタイムブートの恩恵を受けるには、あまりにも柔軟性が高すぎます。私たちが見てきたほとんどのエクステンションは、このような極端な柔軟性の機能を利用していません。CDIエクステンションをQuarkusに移植する方法は、ビルド時（エクステンションの言い方ではデプロイ時）に様々なBeanを定義するQuarkusエクステンションとして書き換えることです。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:333
#, no-wrap
msgid "Technical aspect"
msgstr "技術的な側面"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:336
#, no-wrap
msgid "Three Phases of Bootstrap and Quarkus Philosophy"
msgstr "Bootstrapの3つのフェーズとQuarkusの哲学"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:339
msgid "There are three distinct bootstrap phases of a Quarkus app:"
msgstr "Quarkusアプリには、3つの異なるブートストラップフェーズがあります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:340
#, no-wrap
msgid "Augmentation"
msgstr "拡張"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:345
#, fuzzy
msgid "This is the first phase, and is done by the <<Build Step Processors>>. These processors have access to Jandex annotation information and can parse any descriptors and read annotations, but should not attempt to load any application classes. The output of these build steps is some recorded bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/gizmo), that is used to actually bootstrap the application at runtime. Depending on the `io.quarkus.deployment.annotations.ExecutionTime` value of the `@io.quarkus.deployment.annotations.Record` annotation associated with the build step, the step may be run in a different JVM based on the following two modes."
msgstr "これは最初のフェーズであり、 link:#Build Step Processors[[Build Step Processors]] によって行われます。これらのプロセッサはJandexのアノテーション情報へのアクセス権を持ち、任意の記述子を解析してアノテーションを読み込むことができますが、アプリケーションクラスをロードしようとはしません。これらのビルドステップの出力は、Gizmo(ext/gizmo)と呼ばれるObjectWeb ASMプロジェクトのエクステンションを使用して記録されたバイトコードで、実行時にアプリケーションを実際にブートストラップするために使用されます。ビルドステップに関連付けられた `@io.quarkus.deployment.annotations.Record` アノテーションの `io.quarkus.deployment.annotations.ExecutionTime` の値に応じて、ステップは以下の 2 つのモードに基づいて異なる JVM で実行されます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:346
#, no-wrap
msgid "Static Init"
msgstr "スタティック初期化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:352
#, fuzzy
msgid "If bytecode is recorded with `@Record(STATIC_INIT)` then it will be executed from a static init method on the main class. For a native executable build, this code is executed in a normal JVM as part of the native build process, and any retained objects that are produced in this stage will be directly serialized into the native executable via an image mapped file.  This means that if a framework can boot in this phase then it will have its booted state directly written to the image, and so the boot code does not need to be executed when the image is started."
msgstr "バイトコードが `@Record(STATIC_INIT)` で記録されている場合は、メインクラスの静的 init メソッドから実行されます。ネイティブ実行形式のビルドでは、このコードはネイティブビルドプロセスの一部として通常のJVMで実行され、この段階で生成された保持オブジェクトはイメージマッピングされたファイルを介してネイティブ実行形式に直接シリアライズされます。これは、もしフレームワークがこのフェーズで起動できるならば、その起動状態がイメージに直接書き込まれ、イメージが起動したときに起動コードが実行される必要がないことを意味します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:354
#, fuzzy
msgid "There are some restrictions on what can be done in this stage as the Substrate VM disallows some objects in the native executable. For example you should not attempt to listen on a port or start threads in this phase. In addition, it is disallowed to read run time configuration during static initialization."
msgstr "この段階でできることにはいくつかの制限がありますが、サブストレートVMはネイティブ実行ファイル内のいくつかのオブジェクトを禁止しています。例えば、この段階ではポートをリッスンしようとしたり、スレッドを開始しようとしたりしてはいけません。さらに、静的な初期化中にランタイム設定を読み込むことも禁止されています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:359
#, fuzzy
msgid "In non-native pure JVM mode, there is no real difference between Static and Runtime Init, except that Static Init is always executed first. This mode benefits from the same build phase augmentation as native mode as the descriptor parsing and annotation scanning are done at build time and any associated class/framework dependencies can be removed from the build output jar. In servers like WildFly, deployment related classes such as XML parsers hang around for the life of the application, using up valuable memory. Quarkus aims to eliminate this, so that the only classes loaded at runtime are actually used at runtime."
msgstr "非ネイティブの純粋な JVM モードでは、スタティック Init とランタイム Init の間に実質的な違いはありませんが、スタティック Init が常に最初に実行されます。このモードは、記述子の解析と注釈のスキャンがビルド時に行われ、関連するクラス/フレームワークの依存関係をビルド出力ジャーから削除できるため、ネイティブモードと同じビルドフェーズの拡張の恩恵を受けます。WildFlyのようなサーバーでは、XMLパーサーなどのデプロイメント関連のクラスは、アプリケーションが稼働している間、貴重なメモリを使い果たしてしまいます。Quarkusは、これを排除して、実行時にロードされたクラスだけが実行時に実際に使用されるようにすることを目的としています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:362
#, fuzzy
msgid "As an example, the only reason that a Quarkus application should load an XML parser is if the user is using XML in their application. Any XML parsing of configuration should be done in the Augmentation phase."
msgstr "例として、QuarkusアプリケーションがXMLパーサーをロードする唯一の理由は、ユーザーがアプリケーションでXMLを使用している場合です。設定のXMLパースは、拡張フェーズで行う必要があります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:363
#, no-wrap
msgid "Runtime Init"
msgstr "ランタイム初期化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:367
#, fuzzy
msgid "If bytecode is recorded with `@Record(RUNTIME_INIT)` then it is executed from the application's main method. This code will be run on native executable boot. In general as little code as possible should be executed in this phase, and should be restricted to code that needs to open ports etc."
msgstr "バイトコードが `@Record(RUNTIME_INIT)` で記録されている場合は、アプリケーションのメインメソッドから実行されます。このコードはネイティブの実行可能なブートで実行されます。一般的に、このフェーズで実行されるコードは可能な限り少なくし、ポートなどを開く必要があるコードに限定してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:369
#, fuzzy
msgid "Pushing as much as possible into the `@Record(STATIC_INIT)` phase allows for two different optimizations:"
msgstr "可能な限り `@Record(STATIC_INIT)` フェーズに押し込むことで、2つの異なる最適化が可能になります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:371
#, fuzzy
msgid "In both native executable and pure JVM mode this allows the app to start as fast as possible since processing was done during build time. This also minimizes the classes/native code needed in the application to pure runtime related behaviors."
msgstr "ネイティブ実行形式と純粋なJVMモードの両方で、これにより、処理はビルド時に行われるため、アプリをできるだけ速く起動することができます。これはまた、アプリケーションで必要とされるクラス/ネイティブコードを、純粋なランタイム関連の動作に最小限に抑えます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:374
#, fuzzy
msgid "Another benefit with native executable mode is that Substrate can more easily eliminate features that are not used. If features are directly initialized via bytecode, Substrate can detect that a method is never called and eliminate that method. If config is read at runtime, Substrate cannot reason about the contents of the config and so needs to keep all features in case they are required."
msgstr "ネイティブ実行モードのもう一つの利点は、Substrate が使用されない機能をより簡単に排除できることです。バイトコードを介して機能が直接初期化されている場合、サブストレートはメソッドが決して呼び出されないことを検出し、そのメソッドを削除することができます。実行時に config が読み込まれる場合、Substrate は config の内容を推論することができないため、必要な場合に備えてすべての機能を保持しておく必要があります。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:376
#, fuzzy, no-wrap
msgid "Project setup"
msgstr "プロジェクトの設定"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:379
#, fuzzy
msgid "Your extension project should be setup as a multi-module project with two submodules:"
msgstr "拡張プロジェクトは、2つのサブモジュールを持つマルチモジュールプロジェクトとして設定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:381
#, fuzzy
msgid "A deployment time submodule that handles the build time processing and bytecode recording."
msgstr "ビルド時の処理とバイトコードの記録を行うデプロイメント時間サブモジュールです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:383
#, fuzzy
msgid "A runtime submodule that contains the runtime behavior that will provide the extension behavior in the native executable or runtime JVM."
msgstr "ネイティブ実行ファイルまたはランタイムJVMで拡張動作を提供するランタイム動作を含むランタイムサブモジュール。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:388
#, fuzzy
msgid "Your runtime artifact should depend on `io.quarkus:quarkus-core`, and possibly the runtime artifacts of other Quarkus modules if you want to use functionality provided by them.  Your deployment time module should depend on `io.quarkus:quarkus-core-deployment`, your runtime artifact, and possibly the deployment artifacts of other Quarkus modules if you want to use functionality provided by them."
msgstr "ランタイムアーティファクトは、 `io.quarkus:quarkus-core` に依存する必要があります。また、他のQuarkusモジュールが提供する機能を使用したい場合は、他のQuarkusモジュールのランタイムアーティファクトに依存することもあります。また、ランタイムアーチファクトに含まれるQuarkusエクステンション記述子を生成するために `io.quarkus:quarkus-bootstrap-maven-plugin` を含める必要があります。さらに、 `maven-compiler-plugin` を設定して `quarkus-extension-processor` アノテーションプロセッサを検出する必要があります。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:393
#, fuzzy
msgid "Under no circumstances can the runtime module depend on a deployment artifact. This would result in pulling all the deployment time code into runtime scope, which defeats the purpose of having the split."
msgstr "いかなる場合でも、ランタイムモジュールがデプロイメントアーティファクトに依存することはできません。これは、すべてのディプロイメントタイムコードをランタイムスコープに引き込む結果となり、スプリットの目的が達成されません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:395
#, fuzzy, no-wrap
msgid "Using Maven"
msgstr "Mavenの使用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:399
#, fuzzy
msgid "You will need to include the `io.quarkus:quarkus-bootstrap-maven-plugin` to generate the Quarkus extension descriptor included into the runtime artifact, if you are using the Quarkus parent pom it will automatically inherit the correct configuration.  Furthermore, you'll need to configure the `maven-compiler-plugin` to detect the `quarkus-extension-processor` annotation processor."
msgstr "ランタイムアーティファクトは、 `io.quarkus:quarkus-core` に依存する必要があります。また、他のQuarkusモジュールが提供する機能を使用したい場合は、他のQuarkusモジュールのランタイムアーティファクトに依存することもあります。また、ランタイムアーチファクトに含まれるQuarkusエクステンション記述子を生成するために `io.quarkus:quarkus-bootstrap-maven-plugin` を含める必要があります。さらに、 `maven-compiler-plugin` を設定して `quarkus-extension-processor` アノテーションプロセッサを検出する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:401
#, fuzzy
msgid "You may want to use the `create-extension` mojo of `io.quarkus.platform:quarkus-maven-plugin` to create these Maven modules - see the next section."
msgstr "これらのMavenモジュールを作成するには、 `io.quarkus:quarkus-maven-plugin` の `create-extension` mojo を使用するとよいでしょう - 次のセクションを参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:404
#, fuzzy
msgid "By convention the deployment time artifact has the `-deployment` suffix, and the runtime artifact has no suffix (and is what the end user adds to their project)."
msgstr "慣例では、デプロイメント時間アーティファクトは `-deployment` という接尾辞を持ち、ランタイムアーティファクトは接尾辞を持ちません（エンドユーザーがプロジェクトに追加するものです）。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:414
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-core</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:446
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n"
"            <!-- Executions configuration can be inherited from quarkus-build-parent -->\n"
"            <executions>\n"
"                <execution>\n"
"                    <goals>\n"
"                        <goal>extension-descriptor</goal>\n"
"                    </goals>\n"
"                    <configuration>\n"
"                         <deployment>${project.groupId}:${project.artifactId}-deployment:${project.version}</deployment>\n"
"                   </configuration>\n"
"               </execution>\n"
"           </executions>\n"
"        </plugin>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:449
msgid "The above `maven-compiler-plugin` configuration requires version 3.5+."
msgstr "上記の `maven-compiler-plugin` の設定には、バージョン 3.5+ が必要です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:451
#, fuzzy
msgid "You will also need to configure the `maven-compiler-plugin` of the deployment module to detect the `quarkus-extension-processor` annotation processor."
msgstr "また、デプロイメントモジュールの `maven-compiler-plugin` 、 `quarkus-extension-processor` アノテーションプロセッサを検出するように設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:460
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-core-deployment</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:477
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:479
#, fuzzy, no-wrap
#| msgid "Create new extension modules using Maven"
msgid "Create new Quarkus Core extension modules using Maven"
msgstr "Mavenを使って新しいエクステンションモジュールを作成する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:482
#, fuzzy
msgid "Quarkus provides `create-extension` Maven Mojo to initialize your extension project."
msgstr "Quarkusは、 `create-extension` Maven Mojoを提供し、拡張プロジェクトを初期化します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:484
#, fuzzy
msgid "It will try to auto-detect its options:"
msgstr "オプションを自動検出しようとします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:486
#, fuzzy
msgid "from `quarkus` (Quarkus Core) or `quarkus/extensions` directory, it will use the 'Quarkus Core' extension layout and defaults."
msgstr "`quarkus` (Quarkus Core) または `quarkus/extensions` ディレクトリからアクセスすると、「Quarkus Core」拡張機能のレイアウトとデフォルトが使用されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:487
#, fuzzy
msgid "with `-DgroupId=io.quarkiverse.[extensionId]`, it will use the 'Quarkiverse' extension layout and defaults."
msgstr "`-DgroupId=io.quarkiverse.[extensionId]` を使用すると、'Quarkiverse' 拡張機能のレイアウトとデフォルトを使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:488
#, fuzzy
msgid "in other cases it will use the 'Standalone' extension layout and defaults."
msgstr "それ以外の場合は 'Standalone' 拡張モジュールのレイアウトとデフォルトを使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:489
#, fuzzy
msgid "we may introduce other layout types in the future."
msgstr "将来的には他のレイアウトタイプを紹介するかもしれません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:491
#, fuzzy
msgid "You may not specify any parameter to use the interactive mode: `mvn io.quarkus.platform:quarkus-maven-plugin:{quarkus-version}:create-extension -N`"
msgstr "インタラクティブモードを使用するためのパラメータを指定することはできません。 `mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:493
#, fuzzy
msgid "As and example, let's add a new extension called `my-ext` to the Quarkus source tree:"
msgstr "例として、Quarkusのソースツリーに `my-ext` という新しいエクステンションを追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:501
#, no-wrap
msgid ""
"git clone https://github.com/quarkusio/quarkus.git\n"
"cd quarkus\n"
"mvn io.quarkus.platform:quarkus-maven-plugin:{quarkus-version}:create-extension -N \\\n"
"    -DextensionId=my-ext \\\n"
"    -Dname=\"My Extension\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:504
#, fuzzy
msgid "by default, the `groupId`, `version`, `quarkusVersion`, `namespaceId`, and `namespaceName` will be consistent with other Quarkus core extensions."
msgstr "デフォルトでは、 `groupId`, `version`, `quarkusVersion`, `namespaceId`, `namespaceName` は、他のQuarkusコアの拡張機能と整合性が取れています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:506
#, fuzzy
msgid "The above sequence of commands does the following:"
msgstr "上記の一連のコマンドは以下のようなことを行います。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:508
msgid "Creates four new Maven modules:"
msgstr "4つの新しいMavenモジュールを作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:509
msgid "`quarkus-my-ext-parent` in the `extensions/my-ext` directory"
msgstr "`extensions/my-ext` ディレクトリ内に `quarkus-my-ext-parent`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:510
msgid "`quarkus-my-ext` in the `extensions/my-ext/runtime` directory"
msgstr "`extensions/my-ext/runtime` ディレクトリ内に `quarkus-my-ext`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:511
msgid "`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; a basic `MyExtProcessor` class is generated in this module."
msgstr "`extensions/my-ext/deployment` ディレクトリに `quarkus-my-ext-deployment` ; 基本的な `MyExtProcessor` クラスはこのモジュールで生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:512
msgid "`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/deployment` directory; an empty JAX-RS Resource class and two test classes (for JVM mode and native mode) are generated in this module."
msgstr "`integration-tests/my-ext/deployment` ディレクトリに `quarkus-my-ext-integration-test` ; 空の JAX-RS Resource クラスと 2 つのテストクラス (JVM モードとネイティブモード用) がこのモジュールで生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:513
msgid "Links these three modules where necessary:"
msgstr "必要に応じて、これらの3つのモジュールをリンクします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:514
msgid "`quarkus-my-ext-parent` is added to the `<modules>` of `quarkus-extensions-parent`"
msgstr "`quarkus-my-ext-parent` の `<modules>` に `quarkus-extensions-parent` が追加されます"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:515
msgid "`quarkus-my-ext` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr "QuarkusのBOM（Bill of Materials） `bom/application/pom.xml` の `<dependencyManagement>` に `quarkus-my-ext` が追加されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:516
msgid "`quarkus-my-ext-deployment` is added to the `<dependencyManagement>` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr "QuarkusのBOM（Bill of Materials） `bom/application/pom.xml` の `<dependencyManagement>` に `quarkus-my-ext-deployment` が追加されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:517
msgid "`quarkus-my-ext-integration-test` is added to the `<modules>` of `quarkus-integration-tests-parent`"
msgstr "`quarkus-integration-tests-parent` の `<modules>` に `quarkus-my-ext-integration-test` が追加されます"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:519
#, fuzzy
msgid "You also have to fill the `quarkus-extension.yaml` file that describe your extension inside the runtime module `src/main/resources/META-INF` folder."
msgstr "それは、ランタイムモジュール `src/main/resources/META-INF` フォルダ内にエクステンションを記述する `quarkus-extension.yaml` ファイルを作成することです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:521
#, fuzzy
msgid "This is the `quarkus-extension.yaml` of the `quarkus-agroal` extension, you can use it as an example:"
msgstr "`quarkus-agroal` のエクステンションの `quarkus-extension.yaml` です。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:535
#, no-wrap
msgid ""
"name: \"Agroal - Database connection pool\"\n"
"metadata:\n"
"  keywords:\n"
"  - \"agroal\"\n"
"  - \"database-connection-pool\"\n"
"  - \"datasource\"\n"
"  - \"jdbc\"\n"
"  guide: \"https://quarkus.io/guides/datasource\"\n"
"  categories:\n"
"  - \"data\"\n"
"  status: \"stable\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:540
#, fuzzy
msgid "The `name` parameter of the mojo is optional.  If you do not specify it on the command line, the plugin will derive it from `extensionId` by replacing dashes with spaces and uppercasing each token.  So you may consider omitting explicit `name` in some cases."
msgstr "mojo の `nameBase` パラメータはオプションです。コマンドラインで指定しなかった場合、プラグインはダッシュをスペースに置き換え、各トークンを大文字にすることで `artifactIdBase` からそれを導き出します。そのため、場合によっては明示的な `nameBase` を省略することを検討してもよいでしょう。"

#.  The following link should point to the mojo page once https://github.com/quarkusio/quarkusio.github.io/issues/265 is fixed
#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:543
#, fuzzy
msgid "Please refer to https://github.com/quarkusio/quarkus/blob/{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] for all the available options of the mojo."
msgstr "モジョで利用可能なすべてのオプションについては、 link:https://github.com/quarkusio/quarkus/blob/{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java[CreateExtensionMojo JavaDoc] を参照してください。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:544
#, fuzzy, no-wrap
msgid "Using Gradle"
msgstr "Gradleの使用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:550
#, fuzzy
msgid "You will need to apply the `io.quarkus.extension` plugin in the `runtime` module of your extension project.  The plugin includes the `extensionDescriptor` task that will generate `META-INF/quarkus-extension.properties` and `META-INF/quarkus-extension.yml` files.  The plugin also enables the `io.quarkus:quarkus-extension-processor` annotation processor in both `deployment` and `runtime` modules.  The name of the deployment module can be configured in the plugin by setting the `deploymentArtifact` property. The property is set to `deployment` by default:"
msgstr "拡張プロジェクトの `runtime` モジュールに `io.quarkus.extension` プラグインを適用する必要があります。このプラグインには、 `META-INF/quarkus-extension.properties` ファイルを生成する `extensionDescriptor` タスクが含まれています。また、このプラグインは `deployment` と `runtime` の両方のモジュールで `io.quarkus:quarkus-extension-processor` アノテーションプロセッサを有効にします。デプロイメントモジュールの名前は、プラグインで `deploymentModule` プロパティを設定することで構成できます。このプロパティは、デフォルトでは `deployment` に設定されています。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:557
#, no-wrap
msgid ""
"plugins {\n"
"    id 'java'\n"
"    id 'io.quarkus.extensions'\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:561
#, no-wrap
msgid ""
"quarkusExtension {\n"
"    deploymentArtifact = 'deployment'\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:565
#, no-wrap
msgid ""
"dependencies {\n"
"    implementation platform('io.quarkus:quarkus-bom:{quarkus-version}')\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:570
#, fuzzy
msgid "This plugin is still experimental, it does not validate the extension dependencies as the equivalent Maven plugin does. Unit tests are not supported by the plugin for the moment."
msgstr "このプラグインはまだ実験的なものです。 `META-INF/quarkus-extension.properties` ファイルは生成されますが、 `META-INF/quarkus-extension.yml` ファイルは生成されません。また、同等のMavenプラグインが行うような拡張子の依存関係の検証も行いません。ユニットテストは今のところサポートされていません。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:572
#, fuzzy, no-wrap
msgid "Build Step Processors"
msgstr "ビルドステッププロセッサ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:577
#, fuzzy
msgid "Work is done at augmentation time by _build steps_ which produce and consume _build items_.  The build steps found in the deployment modules that correspond to the extensions in the project build are automatically wired together and executed to produce the final build artifact(s)."
msgstr "作業は、 _ビルドアイテムを_ 生成して消費する _ビルドステップ_ によって拡張時に行われます。プロジェクトビルドのエクステンションに対応するデプロイメントモジュールで見つかったビルドステップは、自動的に配線されて実行され、最終的なビルド成果物が生成されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:578
#, fuzzy, no-wrap
msgid "Build steps"
msgstr "ビルドステップ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:583
#, fuzzy
msgid "A _build step_ is a non-static method which is annotated with the `@io.quarkus.deployment.annotations.BuildStep` annotation.  Each build step may <<consuming-values,consume>> items that are produced by earlier stages, and <<producing-values,produce>> items that can be consumed by later stages. Build steps are normally only run when they produce a build item that is ultimately consumed by another step."
msgstr "_ビルドステップ_ とは、 `@io.quarkus.deployment.annotations.BuildStep` アノテーションが付けられたメソッドのことである。各ビルドステップは、以前のステージで生成されたアイテムを link:#consuming-values[消費し] たり、後のステージで消費可能なアイテムを link:#producing-values[生成し] たりします。ビルドステップは通常、最終的に別のステップで消費されるビルドアイテムを生成する場合にのみ実行されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:586
#, fuzzy
msgid "Build steps are normally placed on plain classes within an extension's deployment module.  The classes are automatically instantiated during the augment process and utilize <<injection,injection>>."
msgstr "ビルドステップは通常、エクステンションのデプロイモジュール内のプレーンクラスに配置されます。クラスは拡張処理の間に自動的にインスタンス化され、 link:#injection[インジェクションを] 利用します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:588
#, fuzzy, no-wrap
msgid "Build items"
msgstr "ビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:594
#, fuzzy
msgid "Build items are concrete, final subclasses of the abstract `io.quarkus.builder.item.BuildItem` class.  Each build item represents some unit of information that must be passed from one stage to another.  The base `BuildItem` class may not itself be directly subclassed; rather, there are abstract subclasses for each of the kinds of build item subclasses that _may_ be created: <<simple-build-items,simple>>, <<multi-build-items,multi>>, and <<empty-build-items,empty>>."
msgstr "ビルド項目は、抽象 `io.quarkus.builder.item.BuildItem` クラスの具体的な最終サブクラスです。各ビルド項目は、ある段階から別の段階に渡される必要のある情報の単位を表します。基底 `BuildItem` クラス自体が直接サブクラス化されているわけではなく、作成される _可能性のある_ ビルド・アイテム・サブクラスの種類（ link:#simple-build-items[単純] 、 link:#multi-build-items[複数] 、 link:#empty-build-items[空] ）ごとに抽象サブクラスが存在します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:596
#, fuzzy
msgid "Think of build items as a way for different extensions to communicate with one another.  For example, a build item can:"
msgstr "ビルド項目は、異なるエクステンションが互いに通信するための方法と考えてください。たとえば、ビルド項目には次のようなものがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:598
#, fuzzy
msgid "expose the fact that a database configuration exists"
msgstr "データベースの設定が存在することを公開します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:599
#, fuzzy
msgid "consume that database configuration (e.g. a connection pool extension or an ORM extension)"
msgstr "データベース設定を消費する (接続プールエクステンションやORMエクステンションなど)"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:601
#, fuzzy
msgid "ask an extension to do work for another extension: e.g. an extension wanting to define a new CDI bean and asking the ArC extension to do so"
msgstr "別のエクステンションに作業を依頼する: 例えば、新しい CDI Bean を定義したいエクステンションが ArC エクステンションにそうするように依頼します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:603
#, fuzzy
msgid "This is a very flexible mechanism."
msgstr "これは非常に柔軟な仕組みです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:606
#, fuzzy
msgid "`BuildItem` instances should be immutable, as the producer/consumer model does not allow for mutation to be correctly ordered. This is not enforced but failure to adhere to this rule can result in race conditions."
msgstr "`BuildItem` インスタンスは不変でなければなりません。プロデューサー/コンシューマーモデルでは突然変異が正しく順序付けられないためです。これは強制されていませんが、このルールを守らないと競合状態になる可能性があります。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:608
#, fuzzy, no-wrap
msgid "Simple build items"
msgstr "シンプルなビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:614
#, fuzzy
msgid "Simple build items are final classes which extend `io.quarkus.builder.item.SimpleBuildItem`.  Simple build items may only be produced by one step in a given build; if multiple steps in a build declare that they produce the same simple build item, an error is raised.  Any number of build steps may consume a simple build item.  A build step which consumes a simple build item will always run _after_ the build step which produced that item."
msgstr "シンプルビルド項目は `io.quarkus.builder.item.SimpleBuildItem` を継承する最終クラスです。ビルド中の複数のステップが同じシンプルなビルド項目を生成すると宣言した場合、エラーが発生します。ビルド中の複数のステップが同じ単純なビルド項目を生成することを宣言すると、エラーが発生します。シンプルビルドアイテムを消費するビルドステップは、常にそのアイテムを生成したビルドステップの _後_ に実行されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:615
#, fuzzy, no-wrap
msgid "Example of a single build item"
msgstr "単品のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:624
#, no-wrap
msgid ""
"/**\n"
" * The build item which represents the Jandex index of the application,\n"
" * and would normally be used by many build steps to find usages\n"
" * of annotations.\n"
" */\n"
"public final class ApplicationIndexBuildItem extends SimpleBuildItem {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:626
#, no-wrap
msgid "    private final Index index;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:630
#, no-wrap
msgid ""
"    public ApplicationIndexBuildItem(Index index) {\n"
"        this.index = index;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:635
#, no-wrap
msgid ""
"    public Index getIndex() {\n"
"        return index;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:639
#, fuzzy, no-wrap
msgid "Multi build items"
msgstr "マルチビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:644
#, fuzzy
msgid "Multiple or \"multi\" build items are final classes which extend `io.quarkus.builder.item.MultiBuildItem`.  Any number of multi build items of a given class may be produced by any number of steps, but any steps which consume multi build items will only run _after_ every step which can produce them has run."
msgstr "マルチビルドアイテムまたは「マルチ」ビルドアイテムは、 `io.quarkus.builder.item.MultiBuildItem` .指定されたクラスのマルチビルドアイテムは、いくつでものステップによって生成することができますが、マルチビルドアイテムを消費するステップは、マルチビルドアイテムを生成できるすべてのステップが実行された _後に_ のみ実行されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:645
#, fuzzy, no-wrap
msgid "Example of a multiple build item"
msgstr "複数のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:651
#, no-wrap
msgid ""
"public final class ServiceWriterBuildItem extends MultiBuildItem {\n"
"    private final String serviceName;\n"
"    private final List<String> implementations;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:661
#, no-wrap
msgid ""
"    public ServiceWriterBuildItem(String serviceName, String... implementations) {\n"
"        this.serviceName = serviceName;\n"
"        // Make sure it's immutable\n"
"        this.implementations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                implementations.clone()\n"
"            )\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:665
#, no-wrap
msgid ""
"    public String getServiceName() {\n"
"        return serviceName;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:670
#, no-wrap
msgid ""
"    public List<String> getImplementations() {\n"
"        return implementations;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:672
#, fuzzy, no-wrap
msgid "Example of multiple build item usage"
msgstr "複数のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:687
#, no-wrap
msgid ""
"/**\n"
" * This build step produces a single multi build item that declares two\n"
" * providers of one configuration-related service.\n"
" */\n"
"@BuildStep\n"
"public ServiceWriterBuildItem registerOneService() {\n"
"    return new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyFirstConfigConverterImpl.class.getName(),\n"
"        MySecondConfigConverterImpl.class.getName()\n"
"    );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:706
#, no-wrap
msgid ""
"/**\n"
" * This build step produces several multi build items that declare multiple\n"
" * providers of multiple configuration-related services.\n"
" */\n"
"@BuildStep\n"
"public void registerSeveralServices(\n"
"    BuildProducer<ServiceWriterBuildItem> providerProducer\n"
") {\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyThirdConfigConverterImpl.class.getName(),\n"
"        MyFourthConfigConverterImpl.class.getName()\n"
"    ));\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        ConfigSource.class.getName(),\n"
"        MyConfigSourceImpl.class.getName()\n"
"    ));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:717
#, no-wrap
msgid ""
"/**\n"
" * This build step aggregates all the produced service providers\n"
" * and outputs them as resources.\n"
" */\n"
"@BuildStep\n"
"public void produceServiceFiles(\n"
"    List<ServiceWriterBuildItem> items,\n"
"    BuildProducer<GeneratedResourceBuildItem> resourceProducer\n"
") throws IOException {\n"
"    // Aggregate all of the providers\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:728
#, no-wrap
msgid ""
"    Map<String, Set<String>> map = new HashMap<>();\n"
"    for (ServiceWriterBuildItem item : items) {\n"
"        String serviceName = item.getName();\n"
"        for (String implName : item.getImplementations()) {\n"
"            map.computeIfAbsent(\n"
"                serviceName,\n"
"                (k, v) -> new LinkedHashSet<>()\n"
"            ).add(implName);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:749
#, no-wrap
msgid ""
"    // Now produce the resource(s) for the SPI files\n"
"    for (Map.Entry<String, Set<String>> entry : map.entrySet()) {\n"
"        String serviceName = entry.getKey();\n"
"        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n"
"            try (OutputStreamWriter w = new OutputStreamWriter(os, StandardCharsets.UTF_8)) {\n"
"                for (String implName : entry.getValue()) {\n"
"                    w.write(implName);\n"
"                    w.write(System.lineSeparator());\n"
"                }\n"
"            }\n"
"            w.flush();\n"
"            resourceProducer.produce(\n"
"                new GeneratedResourceBuildItem(\n"
"                    \"META-INF/services/\" + serviceName,\n"
"                    os.toByteArray()\n"
"                )\n"
"            );\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:752
#, fuzzy, no-wrap
msgid "Empty build items"
msgstr "空のビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:757
#, fuzzy
msgid "Empty build items are final (usually empty) classes which extend `io.quarkus.builder.item.EmptyBuildItem`.  They represent build items that don't actually carry any data, and allow such items to be produced and consumed without having to instantiate empty classes.  They cannot themselves be instantiated."
msgstr "空のビルド項目は `io.quarkus.builder.item.EmptyBuildItem` を拡張した最終的な (通常は空の) クラスです。これは実際にはデータを持たないビルド項目を表し、空のクラスをインスタンス化することなく、そのような項目を生成したり消費したりすることを可能にします。これらはそれ自体をインスタンス化することはできません。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:758
#, fuzzy, no-wrap
msgid "Example of an empty build item"
msgstr "空のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:764
#, no-wrap
msgid ""
"public final class NativeImageBuildItem extends EmptyBuildItem {\n"
"    // empty\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:769
#, fuzzy
msgid "Empty build items can represent \"barriers\" which can impose ordering between steps.  They can also be used in the same way that popular build systems use \"pseudo-targets\", which is to say that the build item can represent a conceptual goal that does not have a concrete representation."
msgstr "空のビルド項目は、ステップ間の順序付けを強制する「障壁」を表すことができます。また、一般的なビルドシステムが「擬似ターゲット」を使用しているのと同じように使用することもできます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:770
#, fuzzy, no-wrap
msgid "Example of usage of an empty build item in a \"pseudo-target\" style"
msgstr "擬似ターゲット」スタイルでの空のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:785
#, no-wrap
msgid ""
"/**\n"
" * Contrived build step that produces the native image on disk.  The main augmentation\n"
" * step (which is run by Maven or Gradle) would be declared to consume this empty item,\n"
" * causing this step to be run.\n"
" */\n"
"@BuildStep\n"
"@Produce(NativeImageBuildItem.class)\n"
"void produceNativeImage() {\n"
"    // ...\n"
"    // (produce the native image)\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:787
#, fuzzy, no-wrap
msgid "Example of usage of an empty build item in a \"barrier\" style"
msgstr "バリア」スタイルでの空のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:799
#, no-wrap
msgid ""
"/**\n"
" * This would always run after {@link #produceNativeImage()} completes, producing\n"
" * an instance of {@code SomeOtherBuildItem}.\n"
" */\n"
"@BuildStep\n"
"@Consume(NativeImageBuildItem.class)\n"
"SomeOtherBuildItem secondBuildStep() {\n"
"    return new SomeOtherBuildItem(\"foobar\");\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:802
#, fuzzy, no-wrap
msgid "Injection"
msgstr "射出成形"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:805
#, fuzzy
msgid "Classes which contain build steps support the following types of injection:"
msgstr "ビルドステップを含むクラスは、以下のタイプのインジェクションをサポートしています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:807
#, fuzzy
msgid "Constructor parameter injection"
msgstr "コンストラクタのパラメータ注入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:808
#, fuzzy
msgid "Field injection"
msgstr "フィールドインジェクション"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:809
#, fuzzy
msgid "Method parameter injection (for build step methods only)"
msgstr "メソッド・パラメータのインジェクション（ビルド・ステップ・メソッドのみ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:812
#, fuzzy
msgid "Build step classes are instantiated and injected for each build step invocation, and are discarded afterwards.  State should only be communicated between build steps by way of build items, even if the steps are on the same class."
msgstr "ビルドステップクラスは、各ビルドステップの呼び出しごとにインスタンス化されて注入され、その後破棄されます。ビルドステップが同じクラス上にある場合でも、ステートはビルドアイテムを介してのみ、ビルドステップ間で通信されるべきです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:815
#, fuzzy
msgid "Final fields are not considered for injection, but can be populated by way of constructor parameter injection if desired.  Static fields are never considered for injection."
msgstr "最終フィールドはインジェクションのために考慮されませんが、必要に応じてコンストラクタのパラメータをインジェクションすることで入力することができます。静的なフィールドはインジェクションのために考慮されることはありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:817
#, fuzzy
msgid "The types of values that can be injected include:"
msgstr "注入できる値の種類には、以下のようなものがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:819
#, fuzzy
msgid "<<build-items,Build items>> produced by previous build steps"
msgstr "前のビルドステップで生成された link:#build-items[アイテムをビルドする]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:820
#, fuzzy
msgid "<<producing-values,Build producers>> to produce items for subsequent build steps"
msgstr "後続のビルドステップのためのアイテムを生産するための link:#producing-values[ビルドプロデューサー]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:821
#, fuzzy
msgid "<<configuration-roots,Configuration root>> types"
msgstr "link:#configuration-roots[設定ルートの] 種類"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:822
#, fuzzy
msgid "Template objects for <<bytecode-recording,bytecode recording>>"
msgstr "link:#bytecode-recording[バイトコード記録] 用テンプレートオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:825
#, fuzzy
msgid "Objects which are injected into a build step method or its class _must not_ be used outside of that method's execution."
msgstr "ビルドステップ・メソッドまたはそのクラスに注入されたオブジェクトは、そのメソッドの実行外で使用してはなり _ませ_ ん。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:828
#, fuzzy
msgid "Injection is resolved at compile time via an annotation processor, and the resulting code does not have permission to inject private fields or invoke private methods."
msgstr "インジェクションはコンパイル時にアノテーション・プロセッサを介して解決され、結果として得られるコードにはプライベート・フィールドを注入したり、プライベート・メソッドを呼び出したりする権限はありません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:830
#, fuzzy, no-wrap
msgid "Producing values"
msgstr "価値観のプロデュース"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:833
#, fuzzy
msgid "A build step may produce values for subsequent steps in several possible ways:"
msgstr "ビルドステップは、いくつかの可能な方法で後続のステップの値を生成することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:835
#, fuzzy
msgid "By returning a <<simple-build-items,simple build item>> or <<multi-build-items,multi build item>> instance"
msgstr "link:#simple-build-items[シンプルなビルドアイテム] または link:#multi-build-items[マルチビルドアイテムの] インスタンスを返すことで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:836
#, fuzzy
msgid "By returning a `List` of a multi build item class"
msgstr "マルチビルドアイテムクラスの `List` を返すことで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:837
#, fuzzy
msgid "By injecting a `BuildProducer` of a simple or multi build item class"
msgstr "シンプルまたはマルチビルドアイテムクラスの `BuildProducer` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:839
#, fuzzy
msgid "By annotating the method with `@io.quarkus.deployment.annotations.Produce`, giving the class name of a <<empty-build-items,empty build item>>"
msgstr "メソッドに `@io.quarkus.deployment.annotations.Produce` をアノテーションすることで、 link:#empty-build-items[空のビルド項目の] クラス名を与えることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:842
#, fuzzy
msgid "If a simple build item is declared on a build step, it _must_ be produced during that build step, otherwise an error will result.  Build producers which are injected into steps _must not_ be used outside of that step."
msgstr "ビルドステップ上で単純なビルド項目が宣言されている場合、そのビルドステップ中に生成する _必要があり_ 、そうしないとエラーになります。ステップに注入されたビルドプロデューサは、そのステップの外で使用しては _いけません_ 。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:848
#, fuzzy
msgid "Note that a `@BuildStep` method will only be called if it produces something that another consumer or the final output requires. If there is no consumer for a particular item then it will not be produced. What is required will depend on the final target that is being produced.  For example, when running in developer mode the final output will not ask for GraalVM-specific build items such as `ReflectiveClassBuildItem`, so methods that only produce these items will not be invoked."
msgstr "`@BuildStep` メソッドは、他の消費者が必要とするものを生成する場合、または最終的な出力が必要とする場合にのみ呼び出されることに注意してください。特定のアイテムの消費者がいない場合、それは生産されません。何が必要かは、生成される最終ターゲットに依存します。例えば、開発者モードで実行している場合、最終出力は `ReflectiveClassBuildItem` のような GraalVM 固有のビルド項目を要求しないため、これらの項目のみを生成するメソッドは呼び出されません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:850
#, fuzzy, no-wrap
msgid "Consuming values"
msgstr "消費する価値観"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:853
#, fuzzy
msgid "A build step may consume values from previous steps in the following ways:"
msgstr "ビルドステップでは、以下の方法で前のステップの値を消費することがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:855
#, fuzzy
msgid "By injecting a <<simple-build-items,simple build item>>"
msgstr "link:#simple-build-items[シンプルなビルド項目を] 注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:856
#, fuzzy
msgid "By injecting an `Optional` of a simple build item class"
msgstr "シンプルなビルド項目クラスの `Optional` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:857
#, fuzzy
msgid "By injecting a `List` of a <<multi-build-items,multi build item>> class"
msgstr "link:#multi-build-items[マルチビルドアイテムクラス] の `List` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:859
#, fuzzy
msgid "By annotating the method with `@io.quarkus.deployment.annotations.Consume`, giving the class name of a <<empty-build-items,empty build item>>"
msgstr "メソッドに `@io.quarkus.deployment.annotations.Consume` をアノテーションすることで、 link:#empty-build-items[空のビルド項目の] クラス名を与えることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:862
#, fuzzy
msgid "Normally it is an error for a step which is included to consume a simple build item that is not produced by any other step.  In this way, it is guaranteed that all of the declared values will be present and non-`null` when a step is run."
msgstr "通常、含まれるステップが他のステップで生成されない単純なビルド項目を消費するのはエラーです。このようにして、ステップが実行されたときに宣言されたすべての値が存在し、 `null` ではないことが保証されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:865
#, fuzzy
msgid "Sometimes a value isn't necessary for the build to complete, but might inform some behavior of the build step if it is present.  In this case, the value can be optionally injected."
msgstr "ビルドを完了させるためには必要のない値ですが、値が存在する場合にはビルドステップの動作に何らかの情報を提供することがあります。この場合、オプションで値を注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:867
#, fuzzy
msgid "Multi build values are always considered _optional_.  If not present, an empty list will be injected."
msgstr "複数のビルド値は常に _オプション_ とみなされます。存在しない場合は、空のリストが注入されます。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:869
#, fuzzy, no-wrap
msgid "Weak value production"
msgstr "弱い価値生産"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:874
#, fuzzy
msgid "Normally a build step is included whenever it produces any build item which is in turn consumed by any other build step.  In this way, only the steps necessary to produce the final artifact(s) are included, and steps which pertain to extensions which are not installed or which only produce build items which are not relevant for the given artifact type are excluded."
msgstr "通常、ビルドステップは、他のビルドステップによって消費されるビルド項目を生成する際には必ず含まれます。このようにして、最終的な成果物を生成するために必要なステップだけが含まれ、インストールされていないエクステンションに関連するステップや、与えられた成果物の種類に関係のないビルド項目を生成するだけのステップは除外される。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:877
#, fuzzy
msgid "For cases where this is not desired behavior, the `@io.quarkus.deployment.annotations.Weak` annotation may be used.  This annotation indicates that the build step should not automatically be included solely on the basis of producing the annotated value."
msgstr "これが望ましい動作ではない場合は、 `@io.quarkus.deployment.annotations.Weak` アノテーションを使用することができます。このアノテーションは、アノテーションされた値を生成することだけに基づいて、ビルドステップを自動的に含めるべきではないことを示しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:878
#, fuzzy, no-wrap
msgid "Example of producing a build item weakly"
msgstr "ビルドアイテムを弱く出す例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:894
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorClassBuildItem.\n"
" */\n"
"@BuildStep\n"
"void createExecutor(\n"
"        @Weak BuildProducer<GeneratedClassBuildItem> classConsumer,\n"
"        BuildProducer<ExecutorClassBuildItem> executorClassConsumer\n"
") {\n"
"        ClassWriter cw = new ClassWriter(Gizmo.ASM_API_VERSION);\n"
"        String className = generateClassThatCreatesExecutor(cw); // <1>\n"
"        classConsumer.produce(new GeneratedClassBuildItem(true, className, cw.toByteArray()));\n"
"        executorClassConsumer.produce(new ExecutorClassBuildItem(className));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:896
#, fuzzy
msgid "This method (not provided in this example) would generate the class using the ASM API."
msgstr "このメソッド（この例では提供されていません）は、ASM APIを使用してクラスを生成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:903
#, fuzzy
msgid "Certain types of build items are generally always consumed, such as generated classes or resources.  An extension might produce a build item along with a generated class to facilitate the usage of that build item.  Such a build step would use the `@Weak` annotation on the generated class build item, while normally producing the other build item.  If the other build item is ultimately consumed by something, then the step would run and the class would be generated.  If nothing consumes the other build item, the step would not be included in the build process."
msgstr "一般的に、生成されたクラスやリソースなど、特定のタイプのビルド項目は常に消費されます。拡張モジュールは、そのビルド項目の使用を容易にするために、 生成されたクラスと一緒にビルド項目を生成するかもしれません。そのようなビルドステップでは、生成されたクラスのビルド項目に `@Weak` アノテーションを使用し、通常は他のビルド項目を生成します。他のビルド項目が最終的に何かによって消費される場合は、ステップが実行され、クラスが生成されます。他のビルド項目が何も消費されなければ、そのステップはビルドプロセスには含まれません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:906
#, fuzzy
msgid "In the example above, `GeneratedClassBuildItem` would only be produced if `ExecutorClassBuildItem` is consumed by some other build step."
msgstr "上記の例では、 `GeneratedClassBuildItem` は、 `ExecutorClassBuildItem` が他のビルドステップで消費された場合にのみ生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:909
#, fuzzy
msgid "Note that when using <<bytecode-recording,bytecode recording>>, the implicitly generated class can be declared to be weak by using the `optional` attribute of the `@io.quarkus.deployment.annotations.Record` annotation."
msgstr "link:#bytecode-recording[バイトコード記録を] 使用する場合、 `@io.quarkus.deployment.annotations.Record` アノテーションの `optional` 属性を使用することで、暗黙的に生成されたクラスを弱いものと宣言することができることに注意してください。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:910
#, fuzzy, no-wrap
msgid "Example of using a bytecode recorder where the generated class is weakly produced"
msgstr "生成されたクラスが弱く生成されるバイトコードレコーダーを使用した例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:922
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorBuildItem.\n"
" */\n"
"@BuildStep\n"
"@Record(value = ExecutionTime.RUNTIME_INIT, optional = true) // <1>\n"
"ExecutorBuildItem createExecutor( // <2>\n"
"        ExecutorTemplate executorTemplate,\n"
"        ThreadPoolConfig threadPoolConfig\n"
") {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:931
#, no-wrap
msgid ""
"    return new ExecutorBuildItem(\n"
"        setupTemplate.setupRunTime(\n"
"            shutdownContextBuildItem,\n"
"            threadPoolConfig,\n"
"            launchModeBuildItem.getLaunchMode()\n"
"        )\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:933
#, fuzzy
msgid "Note the `optional` attribute."
msgstr "`optional` 属性に注意してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:934
#, fuzzy
msgid "This example is using recorder proxies; see the section on <<bytecode-recording,bytecode recording>> for more information."
msgstr "この例では、レコーダーのプロキシを使用しています。詳細については、 link:#bytecode-recording[バイトコード記録の] セクションを参照してください。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:935
#, fuzzy, no-wrap
msgid "Application Archives"
msgstr "アプリケーションアーカイブ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:941
#, fuzzy
msgid "The `@BuildStep` annotation can also register marker files that determine which archives on the class path are considered to be 'Application Archives', and will therefore get indexed. This is done via the `applicationArchiveMarkers`. For example the ArC extension registers `META-INF/beans.xml`, which means that all archives on the class path with a `beans.xml` file will be indexed."
msgstr "`@BuildStep` アノテーションは、クラスパス上のどのアーカイブが「アプリケーションアーカイブ」とみなされてインデックス化されるかを決定するマーカーファイルを登録することもできます。これは `applicationArchiveMarkers` を通して行われます。た と えば ArC エクステンションは `META-INF/beans.xml` を登録します。これは、クラスパス上の `beans.xml` ファイルを持つすべてのアーカイブがインデックス化されることを意味します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:942
#, fuzzy, no-wrap
msgid "Using Thread's Context Class Loader"
msgstr "スレッドのコンテキストクラスローダーの使用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:948
#, fuzzy
msgid "The build step will be run with a TCCL that can load user classes from the deployment in a transformer-safe way.  This class loader only lasts for the life of the augmentation, and is discarded afterwards.  The classes will be loaded again in a different class loader at runtime.  This means that loading a class during augmentation does not stop it from being transformed when running in the development/test mode."
msgstr "ビルドステップは、デプロイメントからユーザークラスをトランスフォーマーセーフな方法でロードできるTCCLを使って実行されます。このクラス・ローダは拡張の期間だけ持続し、その後は破棄されます。クラスは実行時に別のクラス・ローダで再びロードされます。つまり、オーグメンテーション中にクラスをロードしても、開発/テストモードで実行しているときにクラスがトランスフォームされるのを止めることはありません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:949
#, fuzzy, no-wrap
msgid "Adding external JARs to the indexer with IndexDependencyBuildItem"
msgstr "IndexDependencyBuildItemで外部JARをインデクサに追加する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:953
#, fuzzy
msgid "The index of scanned classes will not automatically include your external class dependencies.  To add dependencies, create a `@BuildStep` that produces `IndexDependencyBuildItem` objects, for a `groupId` and `artifactId`."
msgstr "スキャンされたクラスのインデックスには、外部クラスの依存関係は自動的には含まれません。依存関係を追加するには、 `groupId` と `artifactId` に対して `IndexDependencyBuildItem` オブジェクトを生成する `@BuildStep` を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:955
#, fuzzy
msgid "It is important to specify all the required artifacts to be added to the indexer. No artifacts are implicitly added transitively."
msgstr "インデクサーに追加する必要のあるすべてのアーティファクトを指定することが重要です。暗黙的に通過的に追加されるアーティファクトはありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:957
#, fuzzy
msgid "The `Amazon Alexa` extension adds dependent libraries from the Alexa SDK that are used in Jackson JSON transformations, in order for the reflective classes to identified and included at `BUILD_TIME`."
msgstr "`Amazon Alexa` `BUILD_TIME` エクステンションは、Jackson JSON 変換で使用される Alexa SDK からの依存ライブラリを追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:971
#, no-wrap
msgid ""
"   @BuildStep\n"
"    void addDependencies(BuildProducer<IndexDependencyBuildItem> indexDependency) {\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-runtime\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-model\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-lambda-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-servlet-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-dynamodb-persistence-adapter\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-apache-client\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon.alexa\", \"ask-sdk-model-runtime\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:974
#, fuzzy
msgid "With the artifacts added to the `Jandex` indexer, you can now search the index to identify classes implementing an interface, sub-classes of a specific class, or classes with a target annotation."
msgstr "`Jandex` インデクサに追加された成果物により、インターフェイスを実装しているクラス、特定のクラスのサブクラス、ターゲットアノテーションを持つクラスを識別するためにインデックスを検索することができるようになりました。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:977
#, fuzzy
msgid "For example, the `Jackson` extension uses code like below to search for annotations used in JSON deserialization, and add them to the reflective hierarchy for `BUILD_TIME` analysis."
msgstr "例えば、 `Jackson` エクステンションでは、以下のようなコードを使用して、JSON デシリアライゼーションで使用されるアノテーションを検索し、 `BUILD_TIME` 解析用のリフレクティブ階層に追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:982
#, no-wrap
msgid "    DotName JSON_DESERIALIZE = DotName.createSimple(JsonDeserialize.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:984
#, no-wrap
msgid "    IndexView index = combinedIndexBuildItem.getIndex();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:993
#, no-wrap
msgid ""
"    // handle the various @JsonDeserialize cases\n"
"    for (AnnotationInstance deserializeInstance : index.getAnnotations(JSON_DESERIALIZE)) {\n"
"        AnnotationTarget annotationTarget = deserializeInstance.target();\n"
"        if (CLASS.equals(annotationTarget.kind())) {\n"
"            DotName dotName = annotationTarget.asClass().name();\n"
"            Type jandexType = Type.create(dotName, Type.Kind.CLASS);\n"
"            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:995
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:998
#, fuzzy, no-wrap
msgid "Visualizing build step dependencies"
msgstr "ビルドステップの依存関係の可視化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1002
#, fuzzy
msgid "It can occasionally be useful to see a visual representation of the interactions between the various build steps. For such cases, adding `-Djboss.builder.graph-output=build.dot` when building an application will result in the creation of the `build.dot` file in the project's root directory. See link:https://graphviz.org/resources/[this] for a list of software that can open the file and show the actual visual representation."
msgstr "様々なビルドステップ間の相互作用を視覚的に表現することは、時として有用です。そのような場合、アプリケーションのビルド時に `-Djboss.builder.graph-output=build.dot` を追加すると、プロジェクトのルートディレクトリに `build.dot` ファイルが作成されます。このファイルを開いて実際の視覚表現を表示することができるソフトウェアの一覧は link:https://graphviz.org/resources/[こちら]をご覧ください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1004
#, no-wrap
msgid "Configuration"
msgstr "設定"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1009
#, fuzzy
msgid "Configuration in Quarkus is based on SmallRye Config, an implementation of the MicroProfile Config specification.  All of the standard features of MP-Config are supported; in addition, there are several extensions which are made available by the SmallRye Config project as well as by Quarkus itself."
msgstr "Quarkusでの設定は、MicroProfile Config仕様の実装であるSmallRye Configに基づいています。MP-Configの標準機能はすべてサポートされています。さらに、SmallRye ConfigプロジェクトやQuarkus自身が利用できるエクステンションもいくつかあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1011
#, fuzzy
msgid "The value of these properties is configured in a `application.properties` file that follows the MicroProfile config format."
msgstr "これらのプロパティの値は、MicroProfile の設定形式に従う `application.properties` ファイルで設定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1013
#, fuzzy
msgid "Configuration of Quarkus extensions is injection-based, using annotations."
msgstr "Quarkusエクステンションの設定は、アノテーションを使用してインジェクションベースで行われます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1014
#, fuzzy, no-wrap
msgid "Configuration Keys"
msgstr "設定キー"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1017
#, fuzzy
msgid "Leaf configuration keys are mapped to non-`private` fields via the `@io.quarkus.runtime.annotations.ConfigItem` annotation."
msgstr "リーフ構成キーは、 `@io.quarkus.runtime.annotations.ConfigItem` アノテーションを介して `private` 以外のフィールドにマッピングされます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1020
#, fuzzy
msgid "Though the SmallRye Config project is used for implementation, the standard `@ConfigProperty` annotation does not have the same semantics that are needed to support configuration within extensions."
msgstr "実装には SmallRye Config プロジェクトが使用されていますが、標準の `@ConfigProperty` アノテーションは、エクステンション内での設定をサポートするために必要なセマンティクスを持っていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1023
#, fuzzy
msgid "Configuration keys are normally derived from the field names that they are tied to.  This is done by de-camel-casing the name and then joining the segments with hyphens (`-`).  Some examples:"
msgstr "設定キーは通常、関連付けられたフィールド名から派生します。これは、名前を脱キャメル化し、ハイフンでセグメントを結合することで行われます ( `-` )。いくつかの例を示します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1025
#, fuzzy
msgid "`bindAddress` becomes `bind-address`"
msgstr "`bindAddress` になります。 `bind-address`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1026
#, fuzzy
msgid "`keepAliveTime` becomes `keep-alive-time`"
msgstr "`keepAliveTime` になります。 `keep-alive-time`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1027
#, fuzzy
msgid "`requestDNSTimeout` becomes `request-dns-timeout`"
msgstr "`requestDNSTimeout` になります。 `request-dns-timeout`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1029
#, fuzzy
msgid "The name can also be explicitly specified by giving a `name` attribute to the `@ConfigItem` annotation."
msgstr "`@ConfigItem` アノテーションに `name` 属性を与えることで、名前を明示的に指定することもできます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1032
#, fuzzy
msgid "Though it is possible to override the configuration key name using the `name` attribute of `@ConfigItem`, normally this should only be done in cases where (for example) the configuration key name is the same as a Java keyword."
msgstr "`@ConfigItem` の `name` 属性を使って設定キー名を上書きすることは可能ですが、通常は (たとえば) 設定キー名が Java キーワードと同じ場合にのみ行うべきです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1033
#, fuzzy, no-wrap
msgid "Configuration Value types"
msgstr "設定値の種類"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1037
#, fuzzy
msgid "The type of the field with the `@ConfigItem` annotation determines the conversion that is applied to it.  Quarkus extensions may use the full range of configuration types made available by SmallRye Config, which includes:"
msgstr "`@ConfigItem` アノテーションを持つフィールドのタイプによって、そのフィールドに適用される変換が決まります。Quarkusエクステンションでは、SmallRye Configで利用可能な設定タイプのすべてを使用することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1039
#, fuzzy
msgid "All primitive types and primitive wrapper types"
msgstr "すべてのプリミティブ型とプリミティブラッパー型"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1040
#, fuzzy
msgid "`String`"
msgstr "`String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1041
#, fuzzy
msgid "Any type which has a constructor accepting a single argument of type `String` or `CharSequence`"
msgstr "コンストラクタが `String` あるいは型の単一の引数を受け取る型。 `CharSequence`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1042
#, fuzzy
msgid "Any type which has a static method named `of` which accepts a single argument of type `String`"
msgstr "`of` という名前の静的メソッドを持ち、型の単一の引数を受け付ける型。 `String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1043
#, fuzzy
msgid "Any type which has a static method named `valueOf` or `parse` which accepts a single argument of type `CharSequence` or `String`"
msgstr "`valueOf` または `parse` という名前の静的メソッドを持ち、 `CharSequence` または の型の単一の引数を受け取る型。 `String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1044
#, fuzzy
msgid "`java.time.Duration`"
msgstr "`java.time.Duration`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1045
#, fuzzy
msgid "`java.util.regex.Pattern`"
msgstr "`java.util.regex.Pattern`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1046
#, fuzzy
msgid "`java.nio.file.Path`"
msgstr "`java.nio.file.Path`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1047
#, fuzzy
msgid "`io.quarkus.runtime.configuration.MemorySize` to represent data sizes"
msgstr "`io.quarkus.runtime.configuration.MemorySize` データサイズを表現するために"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1048
#, fuzzy
msgid "`java.net.InetSocketAddress`, `java.net.InetAddress` and `org.wildfly.common.net.CidrAddress`"
msgstr "`java.net.InetSocketAddress` , `java.net.InetAddress` `org.wildfly.common.net.CidrAddress`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1049
#, fuzzy
msgid "A `List` or `Optional` of any of the above types"
msgstr "上記のいずれかのタイプの `List` または `Optional`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1050
#, fuzzy
msgid "`OptionalInt`, `OptionalLong`, `OptionalDouble`"
msgstr "`OptionalInt` , `OptionalLong` . `OptionalDouble`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1053
#, fuzzy
msgid "In addition, custom converters may be registered by adding their fully qualified class name in file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`."
msgstr "さらに、カスタムコンバータは、ファイル `META-INF/services/org.eclipse.microprofile.config.spi.Converter` に完全修飾されたクラス名を追加して登録することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1055
#, fuzzy
msgid "Though these implicit converters use reflection, Quarkus will automatically ensure that they are loaded at the appropriate time."
msgstr "これらの暗黙のコンバータは反射を使用しますが、Quarkusは自動的に適切なタイミングでロードされるようにします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1056
#, fuzzy, no-wrap
msgid "Optional Values"
msgstr "オプション値"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1062
#, fuzzy
msgid "If the configuration type is one of the optional types, then empty values are allowed for the configuration key; otherwise, specification of an empty value will result in a configuration error which prevents the application from starting.  This is especially relevant to configuration properties of inherently emptiable values such as `List`, `Set`, and `String`.  Such value types will never be empty; in the event of an empty value, an empty `Optional` is always used."
msgstr "そうでない場合、空の値を指定すると設定エラーとなり、アプリケーションが起動できなくなります。これは特に、 `List` ・ `Set` ・ `String` のような本質的に空の値を持つ設定プロパティに関係します。このような値型は決して空になることはありません。空の値の場合、常に空の `Optional` が使われます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1063
#, fuzzy, no-wrap
msgid "Configuration Default Values"
msgstr "設定のデフォルト値"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1067
#, fuzzy
msgid "A configuration item can be marked to have a default value.  The default value is used when no matching configuration key is specified in the configuration."
msgstr "構成項目には、デフォルト値を持つようにマークを付けることができます。既定値は、構成に一致する構成キーが指定されていない場合に使用されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1070
#, fuzzy
msgid "Configuration items with a primitive type (such as `int` or `boolean`) implicitly use a default value of `0` or `false`.  The sole exception to this rule is the `char` type which does not have an implicit default value."
msgstr "プリミティブ型（ `int` や `boolean` など）を持つ設定項目は、暗黙のうちに `0` や `false` のデフォルト値を使用します。このルールの唯一の例外は、暗黙のデフォルト値を持たない `char` タイプです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1074
#, fuzzy
msgid "A property with a default value is not implicitly optional.  If a non-optional configuration item with a default value is explicitly specified to have an empty value, the application will report a configuration error and will not start.  If it is desired for a property to have a default value and also be optional, it must have an `Optional` type as described above."
msgstr "デフォルト値を持つプロパティは、暗黙のうちにオプションではありません。デフォルト値を持つオプションではない設定項目が空の値を持つように明示的に指定されている場合、アプリケーションは設定エラーを報告し、起動しません。プロパティにデフォルト値を持たせてオプションにしたい場合は、上述のように `Optional` 型を持つ必要があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1075
#, fuzzy, no-wrap
msgid "Configuration Groups"
msgstr "設定グループ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1079
#, fuzzy
msgid "Configuration values are always collected into grouping classes which are marked with the `@io.quarkus.runtime.annotations.ConfigGroup` annotation.  These classes contain a field for each key within its group.  In addition, configuration groups can be nested."
msgstr "設定値は常に `@io.quarkus.runtime.annotations.ConfigGroup` アノテーションでマークされたグループ化クラスに集められます。これらのクラスには、グループ内の各キーのフィールドが含まれています。さらに、設定グループは入れ子にすることができます。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1080
#, fuzzy, no-wrap
msgid "Optional Configuration Groups"
msgstr "オプションの設定グループ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1086
#, fuzzy
msgid "A nested configuration group may be wrapped with an `Optional` type.  In this case, the group is not populated unless one or more properties within that group are specified in the configuration.  If the group is populated, then any required properties in the group must also be specified otherwise a configuration error will be reported and the application will not start."
msgstr "入れ子になっている設定グループは `Optional` 型で包まれている場合があります。この場合、そのグループ内の1つ以上のプロパティが設定で指定されていない限り、そのグループは生成されません。グループが設定されている場合は、そのグループ内の必須プロパティも指定しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1087
#, fuzzy, no-wrap
msgid "Configuration Maps"
msgstr "設定マップ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1092
#, fuzzy
msgid "A `Map` can be used for configuration at any position where a configuration group would be allowed.  The key type of such a map *must* be `String`, and its value may be either a configuration group class or a valid leaf type.  The configuration key segment following the map's key segment will be used as the key for map values."
msgstr "`Map` は、構成グループが許可されている任意の位置で構成に使用できます。このようなマップのキー タイプは `String` である *必要があり* 、その値は構成グループ クラスまたは有効なリーフ タイプのいずれかである *必要* があります。マップのキーセグメントに続く設定キーセグメントが、マップ値のキーとして使用されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1094
#, fuzzy, no-wrap
msgid "Configuration Roots"
msgstr "設定のルーツ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1100
#, fuzzy
msgid "Configuration roots are configuration groups that appear in the root of the configuration tree.  A configuration property's full name is determined by joining the string `quarkus.` with the hyphenated name of the fields that form the path from the root to the leaf field.  For example, if I define a configuration root group called `ThreadPool`, with a nested group in a field named `sizing` that in turn contains a field called `minSize`, the final configuration property will be called `quarkus.thread-pool.sizing.min-size`."
msgstr "構成ルートは、構成ツリーのルートに表示される構成グループです。構成プロパティのフルネームは、文字列 `quarkus.` と、ルートからリーフ フィールドへのパスを形成するフィールドのハイフン名を結合することで決定されます。たとえば、 `ThreadPool` という名前のコンフィギュレーション・ルート・グループを定義すると、 `sizing` という名前のフィールドに `minSize` という名前のフィールドを含む入れ子のグループがあり、最終的なコンフィギュレーション・プロパティは `quarkus.thread-pool.sizing.min-size` と呼ばれるようになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1104
#, fuzzy
msgid "A configuration root's name can be given with the `name` property, or it can be inferred from the class name.  If the latter, then the configuration key will be the class name, minus any `Config` or `Configuration` suffix, broken up by camel-case, lowercased, and re-joined using hyphens (`-`)."
msgstr "設定ルートの名前は `name` プロパティで指定することもできますし、クラス名から推測することもできます。後者の場合、設定キーはクラス名から `Config` や `Configuration` の接尾辞を除いたものとなり、キャメルケースで区切って小文字にし、ハイフン ( `-` ) で再結合されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1110
#, fuzzy
msgid "A configuration root's class name can contain an extra suffix segment for the case where there are configuration roots for multiple <<Configuration Root Phases>>.  Classes which correspond to the `BUILD_TIME` and `BUILD_AND_RUN_TIME_FIXED` may end with `BuildTimeConfig` or `BuildTimeConfiguration`, classes which correspond to the `RUN_TIME` phase may end with `RuntimeConfig`, `RunTimeConfig`, `RuntimeConfiguration` or `RunTimeConfiguration` while classes which correspond to the `BOOTSTRAP` configuration may end with `BootstrapConfig` or `BootstrapConfiguration`."
msgstr "設定ルートのクラス名には、複数の link:#Configuration Root Phases[[設定ルートフェーズ]] に対応する設定ルートがある場合のために、余分なサフィックスセグメントを含めることができます。 `BUILD_TIME` と `BUILD_AND_RUN_TIME_FIXED` に対応するクラスは `BuildTimeConfig` または `BuildTimeConfiguration` で終わるかもしれません。 `RUN_TIME` フェーズに対応するクラスは `RuntimeConfig` , `RunTimeConfig` , `RuntimeConfiguration` , `RunTimeConfiguration` で終わるかもしれませんが、 `BOOTSTRAP` 設定に対応するクラスは `BootstrapConfig` または `BootstrapConfiguration` で終わるかもしれません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1114
#, fuzzy
msgid "Note: The current implementation is still using injection site to determine the root set, so to avoid migration problems, it is recommended that the injection site (field or parameter) have the same name as the configuration root class until this change is complete."
msgstr "注: 現在の実装では、ルートセットを決定するためにインジェクションサイトを使用しているため、移行の問題を避けるために、この変更が完了するまではインジェクションサイト(フィールドまたはパラメータ)に設定ルートクラスと同じ名前を付けることをお勧めします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1115
#, fuzzy, no-wrap
msgid "Configuration Root Phases"
msgstr "設定ルートフェーズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1119
#, fuzzy
msgid "Configuration roots are strictly bound by configuration phase, and attempting to access a configuration root from outside of its corresponding phase will result in an error.  A configuration root dictates when its contained keys are read from configuration, and when they are available to applications.  The phases defined by `io.quarkus.runtime.annotations.ConfigPhase` are as follows:"
msgstr "コンフィギュレーション・ルートはコンフィギュレーション・フェイズに厳密に拘束されており、対応するフェイズの外からコンフィギュレーション・ルートにアクセスしようとするとエラーになります。コンフィギュレーションルートは、その中に含まれる鍵がいつコンフィギュレーションから読み出され、それがアプリケーションから利用可能になるかを決定します。 `io.quarkus.runtime.annotations.ConfigPhase` で定義されているフェーズは以下の通りです。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1123
#, fuzzy, no-wrap
msgid "Phase name"
msgstr "フェーズ名"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1124
#, fuzzy, no-wrap
msgid "Read & avail. at build time"
msgstr "ビルド時に読み込んで利用することができます。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1125
#, fuzzy, no-wrap
msgid "Avail. at run time"
msgstr "実行時に利用可能"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1126
#, fuzzy, no-wrap
msgid "Read during static init"
msgstr "静的なinit時に読み込まれる"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1127
#, fuzzy, no-wrap
msgid "Re-read during startup (native executable)"
msgstr "起動時の再読込（ネイティブ実行ファイル"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1129
#, fuzzy, no-wrap
msgid "Notes"
msgstr "注意事項"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1130
#, fuzzy, no-wrap
msgid "BUILD_TIME"
msgstr "BUILD_TIME"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1131
#: upstream/_guides/writing-extensions.adoc:1138
#: upstream/_guides/writing-extensions.adoc:1139
#: upstream/_guides/writing-extensions.adoc:1146
#: upstream/_guides/writing-extensions.adoc:1148
#: upstream/_guides/writing-extensions.adoc:1153
#: upstream/_guides/writing-extensions.adoc:1154
#: upstream/_guides/writing-extensions.adoc:1155
#, fuzzy, no-wrap
msgid "✓"
msgstr "✓"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1132
#: upstream/_guides/writing-extensions.adoc:1133
#: upstream/_guides/writing-extensions.adoc:1134
#: upstream/_guides/writing-extensions.adoc:1140
#: upstream/_guides/writing-extensions.adoc:1141
#: upstream/_guides/writing-extensions.adoc:1145
#: upstream/_guides/writing-extensions.adoc:1147
#: upstream/_guides/writing-extensions.adoc:1152
#, fuzzy, no-wrap
msgid "✗"
msgstr "✗"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1136
#, fuzzy, no-wrap
msgid "Appropriate for things which affect build."
msgstr "造形に影響を与えるものに適しています。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1137
#, fuzzy, no-wrap
msgid "BUILD_AND_RUN_TIME_FIXED"
msgstr "BUILD_AND_RUN_TIME_FIXED"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1143
#, fuzzy, no-wrap
msgid "Appropriate for things which affect build and must be visible for run time code.  Not read from config at run time."
msgstr "ビルドに影響を与え、実行時のコードが見えるようにしなければならないものに適しています。実行時に設定から読み込まない。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1144
#, fuzzy, no-wrap
msgid "BOOTSTRAP"
msgstr "ブーツストラップ"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1150
#, fuzzy, no-wrap
msgid "Used when runtime configuration needs to be obtained from an external system (like `Consul`), but details of that system need to be configurable (for example Consul's URL). The high level way this works is by using the standard Quarkus config sources (such as properties files, system properties, etc.) and producing `ConfigSourceProvider` objects which are subsequently taken into account by Quarkus when creating the final runtime `Config` object."
msgstr "ランタイム設定を外部システム（ `Consul` など）から取得する必要があるが、そのシステムの詳細を設定可能にする必要がある場合に使用します（ConsulのURLなど）。これは、Quarkusの標準的な設定ソース（プロパティファイル、システムプロパティなど）を使用して、 `ConfigSourceProvider` オブジェクトを作成し、最終的なランタイム `Config` オブジェクトを作成する際にQuarkusによって考慮されます。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1151
#, fuzzy, no-wrap
msgid "RUN_TIME"
msgstr "ランタイム"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1157
#, fuzzy, no-wrap
msgid "Not available at build, read at start in all modes."
msgstr "ビルド時には利用できず、すべてのモードで開始時に読み込まれます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1160
#, fuzzy
msgid "For all cases other than the `BUILD_TIME` case, the configuration root class and all of the configuration groups and types contained therein must be located in, or reachable from, the extension's run time artifact.  Configuration roots of phase `BUILD_TIME` may be located in or reachable from either of the extension's run time or deployment artifacts."
msgstr "`BUILD_TIME` 以外のすべてのケースでは、設定ルートクラスと、そこに含まれるすべての設定グループと型は、エクステンションのランタイム・アーティファクト内にあるか、エクステンションのランタイム・アーティファクトからアクセス可能でなければなりません。フェーズ `BUILD_TIME` の設定ルートは、エクステンションのランタイム・アーティファクトまたはデプロイメント・アーティファクトのいずれかにあるか、またはそこから到達可能なものでなければなりません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1162
#, fuzzy
msgid "_Bootstrap_ configuration steps are executed during runtime-init *before* any of other runtime steps. This means that code executed as part of this step cannot access anything that gets initialized in runtime init steps (runtime synthetic CDI beans being one such example)."
msgstr "_Bootstrap_ 設定ステップは、他のランタイム・ステップより *も前に* ランタイム・initの間に実行されます。これは、このステップの一部として実行されるコードは、ランタイムinitステップで初期化されるものにアクセスできないことを意味します（ランタイム合成CDIビーンズはそのような例の一つです）。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1163
#, fuzzy, no-wrap
msgid "Configuration Example"
msgstr "設定例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1170
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.ConfigItem;\n"
"import io.quarkus.runtime.annotations.ConfigGroup;\n"
"import io.quarkus.runtime.annotations.DefaultConverter\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1173
#, no-wrap
msgid ""
"import java.io.File;\n"
"import java.util.logging.Level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1176
#, no-wrap
msgid ""
"@ConfigGroup <1>\n"
"public class FileConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1182
#, no-wrap
msgid ""
"    /**\n"
"     * Enable logging to a file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"true\")\n"
"    boolean enable;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1188
#, no-wrap
msgid ""
"    /**\n"
"     * The log format.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{1.}] (%t) %s%e%n\")\n"
"    String format;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1194
#, no-wrap
msgid ""
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1200
#, no-wrap
msgid ""
"    /**\n"
"     * The name of the file in which logs will be written.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"application.log\")\n"
"    File path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1202
#: upstream/_guides/writing-extensions.adoc:1410
#: upstream/_guides/writing-extensions.adoc:1996
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1208
#, no-wrap
msgid ""
"/**\n"
" * Logging configuration.\n"
" */\n"
"@ConfigRoot(phase = ConfigPhase.RUN_TIME) <2>\n"
"public class LogConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1210
#, no-wrap
msgid "    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1216
#, no-wrap
msgid ""
"    /**\n"
"     * Configuration properties for the logging file handler.\n"
"     */\n"
"    FileConfig file;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1219
#, no-wrap
msgid ""
"public class LoggingProcessor {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1226
#, no-wrap
msgid ""
"    /**\n"
"     * Logging configuration.\n"
"     */\n"
"    <3>\n"
"    LogConfiguration config;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1230
#, fuzzy
msgid "A configuration property name can be split into segments. For example, a property name like `quarkus.log.file.enable` can be split into the following segments:"
msgstr "構成プロパティ名は、セグメントに分割することができます。例えば、 `quarkus.log.file.enable` のようなプロパティ名は、以下のセグメントに分割することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1232
#, fuzzy
msgid "`quarkus` - a namespace claimed by Quarkus which is a prefix for all `@ConfigRoot` classes,"
msgstr "`quarkus` - Quarkusによって主張された名前空間で、すべての `@ConfigRoot` クラスのプレフィックスです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1233
#, fuzzy
msgid "`log` - a name segment which corresponds to the `LogConfiguration` class annotated with `@ConfigRoot`,"
msgstr "`log` - `@ConfigRoot` でアノテーションされた `LogConfiguration` クラスに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1234
#, fuzzy
msgid "`file` - a name segment which corresponds to the `file` field in this class,"
msgstr "`file` - このクラスの `file` フィールドに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1235
#, fuzzy
msgid "`enabled` - a name segment which corresponds to `enable` field in `FileConfig` class annotated with `@ConfigGroup`."
msgstr "`enabled` - `@ConfigGroup` でアノテーションされた `FileConfig` クラスの `enable` フィールドに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1239
#, fuzzy
msgid "The `FileConfig` class is annotated with `@ConfigGroup` to indicate that this is an aggregate configuration object containing a collection of configurable properties, rather than being a simple configuration key type."
msgstr "`FileConfig` クラスには `@ConfigGroup` というアノテーションが付けられており、これは単純な構成キー型ではなく、構成可能なプロパティのコレクションを含む集約的な構成オブジェクトであることを示しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1244
#, fuzzy
msgid "The `@ConfigRoot` annotation indicates that this object is a configuration root group, in this case one which corresponds to a `log` segment. A class name is used to link configuration root group with the segment from a property name. The `Configuration` part is stripped off from a `LogConfiguration` class name and the remaining `Log` is lowercased to become a `log`. Since all `@ConfigRoot` annotated classes uses `quarkus` as a prefix, this finally becomes `quarkus.log` and represents the properties which names begin with `quarkus.log.*`."
msgstr "`@ConfigRoot` アノテーションは、このオブジェクトが構成ルート・グループであることを示し、この場合は `log` セグメントに対応するものです。クラス名は、プロパティ名からセグメントとコンフィギュレーション・ルート・グループをリンクするために使用されます。 `Configuration` の部分は `LogConfiguration` のクラス名から取り除かれ、残りの `Log` は小文字化されて `log` になります。 `@ConfigRoot` アノテーションされたクラスはすべて `quarkus` をプレフィックスとして使用しているため、最終的に `quarkus.log` となり、 `quarkus.log.*` で始まる名前のプロパティを表します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1246
#, fuzzy
msgid "Here the `LoggingProcessor` injects a `LogConfiguration` instance automatically by detecting the `@ConfigRoot` annotation."
msgstr "ここでは `LoggingProcessor` は `@ConfigRoot` アノテーションを検出して `LogConfiguration` インスタンスを自動的に注入します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1248
#, fuzzy
msgid "A corresponding `application.properties` for the above example could be:"
msgstr "上記の例に対応する `application.properties` は、次のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1254
#, no-wrap
msgid ""
"quarkus.log.file.enable=true\n"
"quarkus.log.file.level=DEBUG\n"
"quarkus.log.file.path=/tmp/debug.log\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1257
#, fuzzy
msgid "Since `format` is not defined in these properties, the default value from `@ConfigItem` will be used instead."
msgstr "これらのプロパティでは `format` が定義されていないので、代わりに `@ConfigItem` のデフォルト値が使用されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1259
#, fuzzy, no-wrap
msgid "Enhanced conversion"
msgstr "強化された変換"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1263
#, fuzzy
msgid "You can use enhanced conversion of a config item by using the `@ConvertWith` annotation which accepts a `Converter` class object.  If the annotation is present on a config item, the implicit or custom built in converter in use will be overridden by the value provided.  To do, see the example below which converts `YES` or `NO` values to `boolean`."
msgstr "`Converter` クラス・オブジェクトを受け付ける `@ConvertWith` アノテーションを使用することで、コンフィグ項目の拡張変換を使用することができます。アノテーションが設定項目に存在する場合、使用中の暗黙の、あるいはカスタムのビルトインコンバータは、提供された値によって上書きされます。これを行うには、 `YES` または `NO` の値を `boolean` に変換する以下の例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1273
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Config item with enhanced converter\n"
"     */\n"
"    @ConvertWith(YesNoConverter.class) // <1>\n"
"    @ConfigItem(defaultValue = \"NO\")\n"
"    Boolean answer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1276
#, no-wrap
msgid "    public static class YesNoConverter implements Converter<Boolean> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1278
#, no-wrap
msgid "        public YesNoConverter() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1284
#, no-wrap
msgid ""
"        @Override\n"
"        public Boolean convert(String s) {\n"
"            if (s == null || s.isEmpty()) {\n"
"                return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1291
#, no-wrap
msgid ""
"            switch (s) {\n"
"                case \"YES\":\n"
"                    return true;\n"
"                case \"NO\":\n"
"                    return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1296
#, no-wrap
msgid ""
"            throw new IllegalArgumentException(\"Unsupported value \" + s + \" given\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1298
#, fuzzy
msgid "Override the default `Boolean` converter and use the provided converter which accepts a `YES` or `NO` config values."
msgstr "デフォルトの `Boolean` コンバータを上書きし、 `YES` または `NO` の設定値を受け付ける提供されたコンバータを使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1301
#, fuzzy
msgid "The corresponding `application.properties` will look like."
msgstr "対応する `application.properties` は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1304
#, no-wrap
msgid "quarkus.some.answer=YES\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1309
msgid "Enum values (config items) are translated to skewed-case (hyphenated) by default. The table below illustrates an enum name and their canonical equivalence:"
msgstr "列挙型の値(設定項目)は、デフォルトではスキュード・ケース(ハイフン付き)に変換されます。以下の表は、列挙型名とその正規の同等表現を示しています。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1311
#, no-wrap
msgid "Java enu"
msgstr "Java enu"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1313
#, no-wrap
msgid "Canonical equivalent"
msgstr "正規の同等表現"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1314
#, no-wrap
msgid "DISCARD"
msgstr "DISCARD"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1316
#, no-wrap
msgid "discard"
msgstr "discard"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1317
#, no-wrap
msgid "READ_UNCOMMITTED"
msgstr "READ_UNCOMMITTED"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1319
#, no-wrap
msgid "read-uncommitted"
msgstr "read-uncommitted"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1320
#, no-wrap
msgid "SIGUSR1"
msgstr "SIGUSR1"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1322
#, no-wrap
msgid "sigusr1"
msgstr "sigusr1"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1323
#, no-wrap
msgid "JavaEnum"
msgstr "JavaEnum"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1325
#, no-wrap
msgid "java-enum"
msgstr "java-enum"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1326
#, no-wrap
msgid "MAKING_LifeDifficult"
msgstr "MAKING_LifeDifficult"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1328
#, no-wrap
msgid "making-life-difficult"
msgstr "making-life-difficult"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1329
#, no-wrap
msgid "YeOldeJBoss"
msgstr "YeOldeJBoss"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1331
#, no-wrap
msgid "ye-olde-jboss"
msgstr "ye-olde-jboss"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1332
#, no-wrap
msgid "camelCaseEnum"
msgstr "camelCaseEnum"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1334
#, no-wrap
msgid "camel-case-enum"
msgstr "camel-case-enum"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1337
msgid "To use the default behaviour which is based on implicit converter or a custom defined one add `@DefaultConverter` annotation to the configuration item"
msgstr "暗黙のコンバータまたはカスタム定義されたコンバータに基づくデフォルトの動作を使用するには、設定項目に `@DefaultConverter` アノテーションを追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1348
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeLogConfig {\n"
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @DefaultConverter // <1>\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1350
msgid "Use the default converter (built in or a custom converter) to convert `Level.class` enum."
msgstr "`Level.class` enum を変換するには、デフォルトのコンバータ（内蔵またはカスタムコンバータ）を使用します。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1353
#, fuzzy, no-wrap
msgid "Conditional Step Inclusion"
msgstr "条件付きステップインクルージョン"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1359
#, fuzzy
msgid "It is possible to only include a given `@BuildStep` under certain conditions.  The `@BuildStep` annotation has two optional parameters: `onlyIf` and `onlyIfNot`.  These parameters can be set to one or more classes which implement `BooleanSupplier`.  The build step will only be included when the method returns `true` (for `onlyIf`) or `false` (for `onlyIfNot`)."
msgstr "特定の条件下では、与えられた `@BuildStep` のみを含めることが可能です。 `@BuildStep` アノテーションには、 `onlyIf` と `onlyIfNot` の 2 つのオプションのパラメータがあります。これらのパラメータは、 `BooleanSupplier` を実装した 1 つ以上のクラスに設定できます。ビルド・ステップは、メソッドが `true` (for `onlyIf` ) または `false` (for `onlyIfNot` ) を返した場合にのみ含まれます。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1362
#, fuzzy
msgid "The condition class can inject <<configuration-roots,configuration roots>> as long as they belong to a build-time phase.  Run time configuration is not available for condition classes."
msgstr "条件クラスは、ビルド時のフェーズに属している限り、 link:#configuration-roots[設定のルートを] 注入することができます。ランタイム設定は条件クラスでは利用できません。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1365
#, fuzzy
msgid "The condition class may also inject a value of type `io.quarkus.runtime.LaunchMode`.  Constructor parameter and field injection is supported."
msgstr "条件クラスは、型 `io.quarkus.runtime.LaunchMode` の値を注入することもできます。コンストラクタのパラメータとフィールドの注入がサポートされています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:1366
#, fuzzy, no-wrap
msgid "An example of a conditional build step"
msgstr "条件付きビルドステップの例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1373
#, no-wrap
msgid ""
"@BuildStep(onlyIf = IsDevMode.class)\n"
"LogCategoryBuildItem enableDebugLogging() {\n"
"    return new LogCategoryBuildItem(\"org.your.quarkus.extension\", Level.DEBUG);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1376
#, no-wrap
msgid ""
"static class IsDevMode implements BooleanSupplier {\n"
"    LaunchMode launchMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1381
#, no-wrap
msgid ""
"    public boolean getAsBoolean() {\n"
"        return launchMode == LaunchMode.DEVELOPMENT;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1385
#, fuzzy
msgid "If you need to make your build step conditional on the presence or absence of another extension, you can use <<capabilities>> for that."
msgstr "他のエクステンションの有無に条件をつけてビルドステップを行う必要がある場合は、 link:#capabilities[[capabilities]を]使用することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1387
#, fuzzy, no-wrap
msgid "Bytecode Recording"
msgstr "バイトコード記録"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1391
#, fuzzy
msgid "One of the main outputs of the build process is recorded bytecode. This bytecode actually sets up the runtime environment. For example, in order to start Undertow, the resulting application will have some bytecode that directly registers all Servlet instances and then starts Undertow."
msgstr "ビルドプロセスの主な出力の一つは、記録されたバイトコードです。このバイトコードは実際にランタイム環境を設定します。例えば、Undertowを起動するために、結果として得られるアプリケーションは、すべてのサーブレットインスタンスを直接登録してUndertowを起動するバイトコードを持つことになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1397
#, fuzzy
msgid "As writing bytecode directly is complex, this is instead done via bytecode recorders. At deployment time, invocations are made on recorder objects that contain the actual runtime logic, but instead of these invocations proceeding as normal they are intercepted and recorded (hence the name). This recording is then used to generate bytecode that performs the same sequence of invocations at runtime. This is essentially a form of deferred execution where invocations made at deployment time get deferred until runtime."
msgstr "バイトコードを直接書くのは複雑なので、代わりにバイトコードレコーダを使って行います。デプロイ時には、実際のランタイムロジックを含むレコーダオブジェクト上で呼び出しが行われますが、これらの呼び出しは通常通りに進行するのではなく、傍受されて記録されます（この名前の由来）。この記録は、実行時に同じシーケンスの呼び出しを実行するバイトコードを生成するために使用されます。これは基本的には繰延実行の一形態で、デプロイ時に行われた呼び出しは実行時まで延期されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1399
#, fuzzy
msgid "Let's look at the classic 'Hello World' type example. To do this the Quarkus way we would create a recorder as follows:"
msgstr "古典的な「Hello World」タイプの例を見てみましょう。これをQuarkusの方法で行うには、次のようにレコーダーを作成します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1404
#, no-wrap
msgid ""
"@Recorder\n"
"class HelloRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1408
#, no-wrap
msgid ""
"  public void sayHello(String name) {\n"
"    System.out.println(\"Hello\" + name);\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1413
#, fuzzy
msgid "And then create a build step that uses this recorder:"
msgstr "そして、このレコーダーを使用するビルドステップを作成します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1421
#, no-wrap
msgid ""
"@Record(RUNTIME_INIT)\n"
"@BuildStep\n"
"public void helloBuildStep(HelloRecorder recorder) {\n"
"    recorder.sayHello(\"World\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1426
#, fuzzy
msgid "When this build step is run nothing is printed to the console. This is because the `HelloRecorder` that is injected is actually a proxy that records all invocations. Instead if we run the resulting Quarkus program we will see 'Hello World' printed to the console."
msgstr "このビルドステップを実行してもコンソールには何も表示されません。これは、注入された `HelloRecorder` が実際にはすべての呼び出しを記録するプロキシだからです。その代わり、結果のQuarkusプログラムを実行すると、コンソールに「Hello World」が表示されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1431
#, fuzzy
msgid "Methods on a recorder can return a value, which must be proxiable (if you want to return a non-proxiable item wrap it in `io.quarkus.runtime.RuntimeValue`). These proxies may not be invoked directly, however they can be passed into other recorder methods. This can be any recorder method, including from other `@BuildStep` methods, so a common pattern is to produce `BuildItem` instances that wrap the results of these recorder invocations."
msgstr "レコーダーのメソッドは値を返すことができますが、その値はプロキシ可能なものでなければなりません (プロキシ不可能な項目を返したい場合は `io.quarkus.runtime.RuntimeValue` でラップしてください)。これらのプロキシは直接呼び出すことはできませんが、他のレコーダのメソッドに渡すことができます。これは、他の `@BuildStep` メソッドからも含めて、どのレコーダ・メソッドでもよいので、これらのレコーダ呼び出しの結果をラップした `BuildItem` インスタンスを生成するのが一般的なパターンです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1435
#, fuzzy
msgid "For instance, in order to make arbitrary changes to a Servlet deployment Undertow has a `ServletExtensionBuildItem`, which is a `MultiBuildItem` that wraps a `ServletExtension` instance. I can return a `ServletExtension` from a recorder in another module, and Undertow will consume it and pass it into the recorder method that starts Undertow."
msgstr "例えば、サーブレットのデプロイメントに任意の変更を加えるために、Undertow には `ServletExtensionBuildItem` があり、 `ServletExtension` インスタンスをラップする `MultiBuildItem` があります。別のモジュールのレコーダから `ServletExtension` を返すと、Undertow はそれを消費して Undertow を起動するレコーダメソッドに渡します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1439
#, fuzzy
msgid "At runtime the bytecode will be invoked in the order it is generated. This means that build step dependencies implicitly control the order that generated bytecode is run. In the example above we know that the bytecode that produces a `ServletExtensionBuildItem` will be run before the bytecode that consumes it."
msgstr "実行時には、バイトコードは生成された順番で呼び出されます。つまり、ビルドステップの依存関係は、生成されたバイトコードが実行される順序を暗黙的に制御することを意味します。上の例では、 `ServletExtensionBuildItem` を生成するバイトコードは、それを消費するバイトコードの前に実行されることがわかっています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1441
#, fuzzy
msgid "The following objects can be passed to recorders:"
msgstr "以下のオブジェクトをレコーダに渡すことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1443
msgid "Primitives"
msgstr "プリミティブ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1444
msgid "String"
msgstr "文字列"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1445
msgid "Class<?> objects"
msgstr "Class<?> オブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1446
#, fuzzy
msgid "Objects returned from a previous recorder invocation"
msgstr "前回のレコーダの呼び出しから返されたオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1447
#, fuzzy
msgid "Objects with a no-arg constructor and getter/setters for all properties (or public fields)"
msgstr "すべてのプロパティ (またはパブリックフィールド) のための、引数なしのコンストラクタとゲッター/セッターを持つオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1448
#, fuzzy
msgid "Objects with a constructor annotated with `@RecordableConstructor` with parameter names that match field names"
msgstr "フィールド名と一致するパラメータ名を持つ `@RecordableConstructor` でアノテーションされたコンストラクタを持つオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1449
#, fuzzy
msgid "Any arbitrary object via the `io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)` mechanism"
msgstr "`io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)` メカニズムを介した任意のオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1450
#, fuzzy
msgid "Arrays, Lists and Maps of the above"
msgstr "上記の配列、リスト、マップ"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1451
#, fuzzy, no-wrap
msgid "Injecting Configuration into Recorders"
msgstr "レコーダーへの設定の注入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1458
#, fuzzy
msgid "Configuration objects with phase `RUNTIME` or `BUILD_AND_RUNTIME_FIXED` can be injected into recorders via constructor injection. Just create a constructor that takes the configuration objects the recorder needs. If the recorder has multiple constructors you can annotate the one you want Quarkus to use with `@Inject`. If the recorder wants to inject runtime config but is also used at static init time then it needs to inject a `RuntimeValue<ConfigObject>`, this value will only be set when the runtime methods are being invoked."
msgstr "フェーズが `RUNTIME` または `BUILD_AND_RUNTIME_FIXED` の構成オブジェクトは、コンストラクタ インジェクションによってレコーダに注入することができます。レコーダーが必要とする設定オブジェクトを受け取るコンストラクタを作成するだけです。レコーダーに複数のコンストラクタがある場合は、Quarkusに使用させたいコンストラクタに `@Inject` で注釈を付けることができます。レコーダーが実行時の設定を注入したいが、静的な初期化時にも使用される場合は、 `RuntimeValue&amp;lt;ConfigObject&amp;gt;` を注入する必要があります。この値は、実行時のメソッドが呼び出されたときにのみ設定されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1459
#, fuzzy, no-wrap
msgid "RecorderContext"
msgstr "RecorderContext"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1465
#, fuzzy
msgid "`io.quarkus.deployment.recording.RecorderContext` provides some convenience methods to enhance bytecode recording, this includes the ability to register creation functions for classes without no-arg constructors, to register an object substitution (basically a transformer from a non-serializable object to a serializable one and vice versa), and to create a class proxy. This interface can be directly injected as a method parameter into any `@Record` method."
msgstr "`io.quarkus.deployment.recording.RecorderContext` はバイトコード記録を強化するための便利なメソッドをいくつか提供しています。これには、no-arg のコンストラクタを使用しないクラスの作成関数の登録、オブジェクト置換の登録（基本的にはシリアライズ可能でないオブジェクトからシリアライズ可能なオブジェクトへの変換、およびその逆）、およびクラスプロキシの作成機能が含まれています。このインターフェイスは、 `@Record` の任意のメソッドにメソッドパラメータとして直接注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1469
#, fuzzy
msgid "Calling `classProxy` with a given class name will create a `Class` that can be passed into recorder methods, and at runtime will be substituted with the class whose name was passed in to `classProxy`. This is basically a convenience to avoid the need to explicitly load classes in the recorders."
msgstr "指定したクラス名で `classProxy` を呼び出すと、レコーダのメソッドに渡すことができる `Class` が作成され、実行時には `classProxy` に渡された名前のクラスで置き換えられます。これは基本的には、レコーダで明示的にクラスをロードする必要がないようにするための便宜的なものです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1470
#, fuzzy, no-wrap
msgid "Printing step execution time"
msgstr "印刷ステップ実行時間"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1475
#, fuzzy
msgid "At times, it can be useful to know how the exact time each startup task (which is the result of each bytecode recording) takes when the application is run.  The simplest way to determine this information is to launch the Quarkus application with the `-Dquarkus.debug.print-startup-times=true` system property.  The output will look something like:"
msgstr "時には、アプリケーションの実行時に各起動タスク（各バイトコードの記録の結果である）がどのくらいの正確な時間を要するかを知ることが有用です。この情報を知る最も簡単な方法は、アプリケーションの実行時に `quarkus.debug.print-startup-times` プロパティを `true` に設定することです。出力は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1488
#, no-wrap
msgid ""
"Build step LoggingResourceProcessor.setupLoggingRuntimeInit completed in: 42ms\n"
"Build step ConfigGenerationBuildStep.checkForBuildTimeConfigChange completed in: 4ms\n"
"Build step SyntheticBeansProcessor.initRuntime completed in: 0ms\n"
"Build step ConfigBuildStep.validateConfigProperties completed in: 1ms\n"
"Build step ResteasyStandaloneBuildStep.boot completed in: 95ms\n"
"Build step VertxHttpProcessor.initializeRouter completed in: 1ms\n"
"Build step VertxHttpProcessor.finalizeRouter completed in: 4ms\n"
"Build step LifecycleEventsBuildStep.startupEvent completed in: 1ms\n"
"Build step VertxHttpProcessor.openSocket completed in: 93ms\n"
"Build step ShutdownListenerBuildStep.setupShutdown completed in: 1ms\n"
msgstr ""

#. TODO: config integration
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1493
#, fuzzy, no-wrap
msgid "Contexts and Dependency Injection"
msgstr "コンテキストと依存性インジェクション"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1495
#, fuzzy, no-wrap
msgid "Extension Points"
msgstr "エクステンションポイント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1500
#, fuzzy
msgid "As a CDI based runtime, Quarkus extensions often make CDI beans available as part of the extension behavior.  However, Quarkus DI solution does not support CDI Portable Extensions.  Instead, Quarkus extensions can make use of various link:cdi-reference[Build Time Extension Points]."
msgstr "CDIベースのランタイムとして、Quarkusのエクステンションでは、エクステンションの動作の一部としてCDIビーンズを利用できるようにすることがよくあります。しかし、Quarkus DIソリューションはCDIポータブルエクステンションをサポートしていません。代わりに、Quarkusのエクステンションは、さまざまな link:cdi-reference[Build Time Extension Pointsを] 利用することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1501
#, fuzzy, no-wrap
msgid "Quarkus Dev UI"
msgstr "Quarkus DEVコンソール"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1504
#, fuzzy
msgid "You can make your extension support the link:dev-ui[Quarkus Dev UI] for a greater developer experience."
msgstr "エクステンションを link:dev-console[Quarkus DEV Console] に対応させて、開発者のエクスペリエンスを向上させることができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1505
#, fuzzy, no-wrap
msgid "Extension-defined endpoints"
msgstr "エクステンションポイント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1509
#, fuzzy
msgid "Your extension can add additional, non-application endpoints to be served alongside endpoints for Health, Metrics, OpenAPI, Swagger UI, etc."
msgstr "拡張機能では、ヘルス、メトリクス、OpenAPI、Swagger UIなどのエンドポイントに加えて、アプリケーション以外のエンドポイントを追加して提供することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1511
#, fuzzy
msgid "Use a `NonApplicationRootPathBuildItem` to define an endpoint:"
msgstr "エンドポイントを定義するには `NonApplicationRootPathBuildItem` を使用します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1522
#, no-wrap
msgid ""
"@BuildStep\n"
"RouteBuildItem myExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {\n"
"    return nonApplicationRootPathBuildItem.routeBuilder()\n"
"                .route(\"custom-endpoint\")\n"
"                .handler(new MyCustomHandler())\n"
"                .displayOnNotFoundPage()\n"
"                .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1527
#, fuzzy
msgid "Note that the path above does not start with a '/', indicating it is a relative path. The above endpoint will be served relative to the configured non-application endpoint root. The non-application endpoint root is `/q` by default, which means the resulting endpoint will be found at `/q/custom-endpoint`."
msgstr "上記のパスは '/' で始まらず、相対パスであることを示していることに注意してください。上記のエンドポイントは、構成された非アプリケーションエンドポイントルートからの相対パスで提供されます。アプリケーション以外のエンドポイントのルートはデフォルトでは `/q` で、結果のエンドポイントは `/q/custom-endpoint`."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1530
#, fuzzy
msgid "Absolute paths are handled differently. If the above called `route(\"/custom-endpoint\")`, the resulting endpoint will be found at `/custom-endpoint`."
msgstr "絶対パスの扱いは異なります。上記で `route(\"/custom-endpoint\")` を呼び出した場合、結果のエンドポイントは `/custom-endpoint`."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1532
#, fuzzy
msgid "If an extension needs nested non-application endpoints:"
msgstr "拡張機能にネストされた非アプリケーションエンドポイントが必要な場合。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1543
#, no-wrap
msgid ""
"@BuildStep\n"
"RouteBuildItem myNestedExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {\n"
"    return nonApplicationRootPathBuildItem.routeBuilder()\n"
"                .nestedRoute(\"custom-endpoint\", \"deep\")\n"
"                .handler(new MyCustomHandler())\n"
"                .displayOnNotFoundPage()\n"
"                .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1546
#, fuzzy
msgid "Given a default non-application endpoint root of `/q`, this will create an endpoint at `/q/custom-endpoint/deep`."
msgstr "`/q` のデフォルトの非アプリケーションエンドポイントルートを指定すると、 `/q/custom-endpoint/deep` にエンドポイントが作成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1549
#, fuzzy
msgid "Absolute paths also have an impact on nested endpoints. If the above called `nestedRoute(\"custom-endpoint\", \"/deep\")`, the resulting endpoint will be found at `/deep`."
msgstr "絶対パスは、入れ子になったエンドポイントにも影響を与えます。上記で `nestedRoute(\"custom-endpoint\", \"/deep\")` を呼び出した場合、結果として得られるエンドポイントは `/deep`."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1552
#, fuzzy
msgid "Refer to the link:all-config#quarkus-vertx-http_quarkus.http.non-application-root-path[Quarkus Vertx HTTP configuration reference] for details on how the non-application root path is configured."
msgstr "アプリケーション以外のルートパスの設定方法の詳細については、『 link:all-config#quarkus-vertx-http_quarkus.http.non-application-root-path[Quarkus Vertx HTTP設定リファレンス]』を参照してください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1553
#, no-wrap
msgid "Extension Health Check"
msgstr "エクステンションヘルスチェック"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1556
msgid "Health checks are provided via the `quarkus-smallrye-health` extension. It provides both liveness and readiness checks capabilities."
msgstr "ヘルスチェックは `quarkus-smallrye-health` のエクステンションを介して提供されます。これは、livenessとreadinessのチェック機能の両方を提供します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1558
msgid "When writing an extension, it's beneficial to provide health checks for the extension, that can be automatically included without the developer needing to write their own."
msgstr "エクステンションを書くときには、開発者が自分で書かなくても自動的に含まれるようにすることができるエクステンションのヘルスチェックを提供することが有益です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1560
msgid "In order to provide a health check, you should do the following:"
msgstr "ヘルスチェックを行うためには、以下のようにしましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1563
msgid "Import the `quarkus-smallrye-health` extension as an **optional** dependency in your runtime module so it will not impact the size of the application if health check is not included."
msgstr "`quarkus-smallrye-health` ヘルスチェックを *オプションの* 依存関係としてランタイムモジュールにインポートすることで、ヘルスチェックが含まれていない場合でもアプリケーションのサイズに影響を与えないようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1565
#, fuzzy
msgid "Create your health check following the link:smallrye-health[SmallRye Health] guide. We advise providing only readiness check for an extension (liveness check is designed to express the fact that an application is up and needs to be lightweight)."
msgstr "link:microprofile-health[Quarkus - MicroProfile Health] ガイドに従って、ヘルスチェックを作成します。エクステンションのレディネスチェックのみを提供することをお勧めします（ライブネスチェックは、アプリケーションが起動していることや軽量化が必要であることを表現するために設計されています）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1566
#, fuzzy
msgid "Import the `quarkus-smallrye-health-spi` library in your deployment module."
msgstr "デプロイメント モジュールに `quarkus-smallrye-health-spi` ライブラリをインポートします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1567
#, fuzzy
msgid "Add a build step in your deployment module that produces a `HealthBuildItem`."
msgstr "デプロイメントモジュールにビルドステップを追加して、 `HealthBuildItem` ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1568
#, fuzzy
msgid "Add a way to disable the extension health check via a config item `quarkus.<extension>.health.enabled` that should be enabled by default."
msgstr "デフォルトで有効になっているはずの設定項目 `quarkus.<extension>.health.enabled` を介して、エクステンションのヘルスチェックを無効にする方法を追加しました。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1570
#, fuzzy
msgid "Following is an example from the Agroal extension that provides a `DataSourceHealthCheck` to validate the readiness of a datasource."
msgstr "以下は、データソースの準備状況を検証するために `DataSourceHealthCheck` を提供する Agroal 拡張モジュールの例です。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1578
#, no-wrap
msgid ""
"@BuildStep\n"
"HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) {\n"
"    return new HealthBuildItem(\"io.quarkus.agroal.runtime.health.DataSourceHealthCheck\",\n"
"            agroalBuildTimeConfig.healthEnabled);\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1580
#, no-wrap
msgid "Extension Metrics"
msgstr "エクステンションメトリクス"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1585
msgid "The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` extension provide support for collecting metrics.  As a compatibility note, the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer library primitives, so the `quarkus-micrometer` extension can be enabled without breaking code that relies on the MP Metrics API.  Note that the metrics emitted by Micrometer are different, see the `quarkus-micrometer` extension documentation for more information."
msgstr "`quarkus-micrometer` エクステンションと `quarkus-smallrye-metrics` エクステンションは、メトリクスを収集するためのサポートを提供します。互換性についての注意点として、 `quarkus-micrometer` エクステンションは MP Metrics API を Micrometer ライブラリのプリミティブに適応させているので、MP Metrics API に依存しているコードを壊すことなく `quarkus-micrometer` エクステンションを有効にすることができます。Micrometer が出力するメトリクスは異なることに注意してください。詳細は `quarkus-micrometer` エクステンションのドキュメントを参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1587
msgid "The compatibility layer for MP Metrics APIs will move to a different extension in the future."
msgstr "MP Metrics API の互換性レイヤは、将来的には別のエクステンションに移行する予定です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1589
#, fuzzy
msgid "There are two broad patterns that extensions can use to interact with an optional metrics extension to add their own metrics:"
msgstr "このような場合、「Element Import」（インポート）は、「Element Import」（インポート）と呼ばれ、「Element Import」（インポート）は、「Element Import」（インポート）と呼ばれます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1591
#, fuzzy
msgid "Consumer pattern: An extension declares a `MetricsFactoryConsumerBuildItem` and uses that to provide a bytecode recorder to the metrics extension. When the metrics extension has initialized, it will iterate over registered consumers to initialize them with a `MetricsFactory`. This factory can be used to declare API-agnostic metrics, which can be a good fit for extensions that provide an instrumentable object for gathering statistics (e.g. Hibernate's `Statistics` class)."
msgstr "コンシューマパターン。エクステンションは `MetricsFactoryConsumerBuildItem` を宣言し、それを使ってメトリクスエクステンションにバイトコード・レコーダを提供します。 `MetricsFactory` このように、このクラスでは、「Element Import」という名前のクラスを使用しています。このファクトリは、API にとらわれないメトリクスを宣言するために使用することができ、統計情報を収集するための計測可能なオブジェクトを提供するエクステンション（Hibernate の `Statistics` クラスなど）に適しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1593
#, fuzzy
msgid "Binder pattern: An extension can opt to use completely different gathering implementations depending on the metrics system. An `Optional<MetricsCapabilityBuildItem> metricsCapability` build step parameter can be used to declare or otherwise initialize API-specific metrics based on the active metrics extension (e.g. \"smallrye-metrics\" or \"micrometer\"). This pattern can be combined with the consumer pattern by using `MetricsFactory::metricsSystemSupported()` to test the active metrics extension within the recorder."
msgstr "バインダーパターン。このような場合には、「Element Import」（要素）は、「Element Import」（要素）と呼ばれ、「Element Import」（要素）は、「Element Import」（要素）と呼ばれます。 `Optional<MetricsCapabilityBuildItem> metricsCapability` ビルドステップパラメータを使用して、アクティブなメトリクス拡張に基づく API 固有のメトリクスを宣言したり、そうでなければ初期化したりすることができます（例：\"smallrye-metrics\"や\"micrometer\"）。このパターンは、 `MetricsFactory::metricsSystemSupported()` を使用して、レコーダ内でアクティブなメトリクス拡張をテストすることで、コンシューマパターンと組み合わせることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1595
#, fuzzy
msgid "Remember that support for metrics is optional. Extensions can use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter in their build step to test for the presence of an enabled metrics extension. Consider using additional configuration to control behavior of metrics. Datasource metrics can be expensive, for example, so additional configuration flags are used enable metrics collection on individual datasources."
msgstr "この図では、「Element Import」（要素）と「Element Import」（要素）の間の関係を説明しています。 `Optional<MetricsCapabilityBuildItem> metricsCapability` この図では、「Element Import」（要素）と「Element Import」（要素）の間の関係を説明します。UML 2.0 コンポジット構造体は、クラス間の相互作用を表すものではありません。例えば、データソース・メトリクスは高価な場合があるため、追加の構成フラグを使用して、個々のデータソースでのメトリクス収集を有効にします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1597
msgid "When adding metrics for your extension, you may find yourself in one of the following situations:"
msgstr "エクステンションのメトリクスを追加するとき、以下のいずれかの状況に陥ることがあります:"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1599
#, fuzzy
msgid "An underlying library used by the extension is using a specific Metrics API directly (either MP Metrics, Micrometer, or some other)."
msgstr "エクステンションで使用される基礎となるライブラリは、特定のメトリクス API を直接使用しています (MP Metrics, Micrometer, または他のもの)。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1600
#, fuzzy
msgid "An underlying library uses its own mechanism for collecting metrics and makes them available at runtime using its own API, e.g. Hibernate's `Statistics` class, or Vert.x `MetricsOptions`."
msgstr "`Statistics` `MetricsOptions` 基礎となるライブラリは、メトリクスを収集するために独自のメカニズムを使用し、独自の API を使用して実行時に利用できるようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1601
#, fuzzy
msgid "An underlying library does not provide metrics (or there is no library at all) and you want to add instrumentation."
msgstr "このような場合には、「インストルメンテーション」を追加する必要があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1602
#, fuzzy, no-wrap
msgid "Case 1: The library uses a metrics library directly"
msgstr "ケース1：ライブラリはメトリクスライブラリを直接使用する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1605
#, fuzzy
msgid "If the library directly uses a metrics API, there are two options:"
msgstr "ライブラリが直接メトリクス API を使用する場合は、2 つのオプションがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1607
#, fuzzy
msgid "Use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter to test which metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\") in your build step, and use that to selectively declare or initialize API-specific beans or build items."
msgstr "`Optional<MetricsCapabilityBuildItem> metricsCapability` パラメータを使用して、ビルドステップでどのメトリクス API がサポートされているか (例: \"smallrye-metrics\" や \"micrometer\" など) をテストし、API 固有のビーンやビルド項目を選択的に宣言または初期化するために使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1609
#, fuzzy
msgid "Create a separate build step that consumes a `MetricsFactory`, and use the `MetricsFactory::metricsSystemSupported()` method within the bytecode recorder to initialize required resources if the desired metrics API is supported (e.g. \"smallrye-metrics\" or \"micrometer\")."
msgstr "`MetricsFactory` を消費する別のビルド・ステップを作成し、バイトコード・レコーダ内で `MetricsFactory::metricsSystemSupported()` メソッドを使用して、必要なメトリクス API がサポートされている場合に必要なリソースを初期化します（例：\"smallrye-metrics\" や \"micrometer\"）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1611
#, fuzzy
msgid "Extensions may need to provide a fallback if there is no active metrics extension or the extension doesn't support the API required by the library."
msgstr "アクティブなメトリクスエクステンションがない場合や、エクステンションがライブラリが必要とする API をサポートしていない場合、エクステンションはフォールバックを提供する必要がある場合があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1612
#, fuzzy, no-wrap
msgid "Case 2: The library provides its own metric API"
msgstr "ケース 2: ライブラリが独自のメトリック API を提供する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1615
#, fuzzy
msgid "There are two examples of a library providing its own metrics API:"
msgstr "独自のメトリクス API を提供するライブラリの例は 2 つあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1617
#, fuzzy
msgid "The extension defines an instrumentable object as Agroal does with `io.agroal.api.AgroalDataSourceMetrics`, or"
msgstr "このエクステンションは、Agroal が `io.agroal.api.AgroalDataSourceMetrics` で行っているように、インストルメント可能なオブジェクトを定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1618
#, fuzzy
msgid "The extension provides its own abstraction of metrics, as Jaeger does with `io.jaegertracing.spi.MetricsFactory`."
msgstr "Jaeger が `io.jaegertracing.spi.MetricsFactory` で行っているように、エクステンションは独自のメトリクスの抽象化を提供します。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1619
#, fuzzy, no-wrap
msgid "Observing instrumentable objects"
msgstr "計装可能な物体の観察"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1622
#, fuzzy
msgid "Let's take the instrumentable object (`io.agroal.api.AgroalDataSourceMetrics`) case first. In this case, you can do the following:"
msgstr "まず、インストルメント可能なオブジェクト ( `io.agroal.api.AgroalDataSourceMetrics` ) の場合を取り上げてみましょう。この場合は以下のようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1624
#, fuzzy
msgid "Define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer. For example, the following creates a `MetricsFactoryConsumerBuildItem` if and only if metrics are enabled both for Agroal generally, and for a datasource specifically:"
msgstr "`MetricsFactoryConsumerBuildItem` `RUNTIME_INIT` または Recorder を使用して コンシューマを定義する を生成する。例えば、以下は、Agroal 一般とデータソースの両方でメトリクスが有効になっている場合にのみ、 を生成します。 `STATIC_INIT` `MetricsFactory` `BuildStep` `MetricsFactoryConsumerBuildItem`"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1633
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void registerMetrics(AgroalMetricsRecorder recorder,\n"
"        DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,\n"
"        BuildProducer<MetricsFactoryConsumerBuildItem> datasourceMetrics,\n"
"        List<AggregatedDataSourceBuildTimeConfigBuildItem> aggregatedDataSourceBuildTimeConfigs) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1645
#, no-wrap
msgid ""
"    for (AggregatedDataSourceBuildTimeConfigBuildItem aggregatedDataSourceBuildTimeConfig : aggregatedDataSourceBuildTimeConfigs) {\n"
"        // Create a MetricsFactory consumer to register metrics for a data source\n"
"        // IFF metrics are enabled globally and for the data source\n"
"        // (they are enabled for each data source by default if they are also enabled globally)\n"
"        if (dataSourcesBuildTimeConfig.metricsEnabled &&\n"
"                aggregatedDataSourceBuildTimeConfig.getJdbcConfig().enableMetrics.orElse(true)) {\n"
"            datasourceMetrics.produce(new MetricsFactoryConsumerBuildItem(\n"
"                    recorder.registerDataSourceMetrics(aggregatedDataSourceBuildTimeConfig.getName())));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1648
#, fuzzy
msgid "The associated recorder should use the provided `MetricsFactory` to register metrics. For Agroal, this means using the `MetricFactory` API to observe `io.agroal.api.AgroalDataSourceMetrics` methods. For example:"
msgstr "関連するレコーダは、提供された `MetricsFactory` を使用してメトリクスを登録する必要があります。Agroal の場合、これは `MetricFactory` API を使用して `io.agroal.api.AgroalDataSourceMetrics` メソッドを観測することを意味します。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1658
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerDataSourceMetrics(String dataSourceName) {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            String tagValue = DataSourceUtil.isDefault(dataSourceName) ? \"default\" : dataSourceName;\n"
"            AgroalDataSourceMetrics metrics = getDataSource(dataSourceName).getMetrics();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1666
#, no-wrap
msgid ""
"            // When using MP Metrics, the builder uses the VENDOR registry by default.\n"
"            metricsFactory.builder(\"agroal.active.count\")\n"
"                    .description(\n"
"                            \"Number of active connections. These connections are in use and not available to be acquired.\")\n"
"                    .tag(\"datasource\", tagValue)\n"
"                    .buildGauge(metrics::activeCount);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1669
#, fuzzy
msgid "The `MetricsFactory` provides a fluid builder for registration of metrics, with the final step constructing gauges or counters based on a `Supplier` or `ToDoubleFunction`. Timers can either wrap `Callable`, `Runnable`, or `Supplier` implementations, or can use a `TimeRecorder` to accumulate chunks of time. The underlying metrics extension will create appropriate artifacts to observe or measure the defined functions."
msgstr "`MetricsFactory` はメトリクスを登録するための流体ビルダーを提供し、最終的なステップでは `Supplier` または `ToDoubleFunction` に基づいてゲージやカウンターを構築します。タイマーは、 `Callable` 、 `Runnable` 、または `Supplier` の実装をラップしたり、 `TimeRecorder` を使用して時間の塊を蓄積したりすることができます。このように、「Element Import」は、「Element Import」と呼ばれています。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1670
#, fuzzy, no-wrap
msgid "Using a Metrics API-specific implementation"
msgstr "メトリクス API 固有の実装を使用する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1673
#, fuzzy
msgid "Using metrics-API specific implementations may be preferred in some cases. Jaeger, for example, defines its own metrics interface, `io.jaegertracing.spi.MetricsFactory`, that it uses to define counters and gauges. A direct mapping from that interface to the metrics system will be the most efficient. In this case, it is important to isolate these specialized implementations and to avoid eager classloading to ensure the metrics API remains an optional, compile-time dependency."
msgstr "メトリクス API 固有の実装を使用することが好ましい場合もあります。たとえば、Jaeger は、カウンタとゲージを定義するために使用する独自のメトリクス・インタフェース（ `io.jaegertracing.spi.MetricsFactory` ）を定義しています。このような場合には、「Element Import」（要素）は、「Element Import」（要素）と呼ばれ、「Element Import」（要素）は「Element Import」（要素）と呼ばれます。この場合は、これらの特殊な実装を分離し、熱心なクラスローディングを避けて、メトリクス API がコンパイル時の依存関係にあるオプションのままであることを確実にすることが重要です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1675
#, fuzzy
msgid "`Optional<MetricsCapabilityBuildItem> metricsCapability` can be used in the build step to selectively control initialization of beans or the production of other build items. The Jaeger extension, for example, can use the following to control initialization of specialized Metrics API adapters:"
msgstr "`Optional<MetricsCapabilityBuildItem> metricsCapability` は、ビーンズの初期化や他のビルド項目の生成を選択的に制御するために、ビルドステップで使用することができます。Jaeger 拡張モジュールでは、例えば、以下のようにして、特殊な Metrics API アダプタの初期化を制御することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1683
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig buildTimeConfig, JaegerConfig jaeger,\n"
"        ApplicationConfig appConfig, Optional<MetricsCapabilityBuildItem> metricsCapability) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1686
#, no-wrap
msgid ""
"    // Indicates that this extension would like the SSL support to be enabled\n"
"    extensionSslNativeSupport.produce(new ExtensionSslNativeSupportBuildItem(Feature.JAEGER.getName()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1700
#, no-wrap
msgid ""
"    if (buildTimeConfig.enabled) {\n"
"        // To avoid dependency creep, use two separate recorder methods for the two metrics systems\n"
"        if (buildTimeConfig.metricsEnabled && metricsCapability.isPresent()) {\n"
"            if (metricsCapability.get().metricsSupported(MetricsFactory.MICROMETER)) {\n"
"                jdr.registerTracerWithMicrometerMetrics(jaeger, appConfig);\n"
"            } else {\n"
"                jdr.registerTracerWithMpMetrics(jaeger, appConfig);\n"
"            }\n"
"        } else {\n"
"            jdr.registerTracerWithoutMetrics(jaeger, appConfig);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1703
#, fuzzy
msgid "A recorder consuming a `MetricsFactory` can use `MetricsFactory::metricsSystemSupported()` can be used to control initialization of metrics objects during bytecode recording in a similar way."
msgstr "`MetricsFactory` を消費するレコーダは、 `MetricsFactory::metricsSystemSupported()` を使用して、バイトコード記録中のメトリクスオブジェクトの初期化を同様の方法で制御することができます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1704
#, no-wrap
msgid "Case 3: It is necessary to collect metrics within the extension code"
msgstr "ケース3：エクステンションコード内でメトリクスを収集する必要がある"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1707
#, fuzzy
msgid "To define your own metrics from scratch, you have two basic options: Use the generic `MetricFactory` builders, or follow the binder pattern, and create instrumentation specific to the enabled metrics extension."
msgstr "この図では、「Element Import Import」という名前を使用して、「Element Import」という名前を定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1709
#, fuzzy
msgid "To use the extension-agnostic `MetricFactory` API, your processor can define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` consumer."
msgstr "エクステンションに依存しない `MetricFactory` API を使用するために、プロセッサは `RUNTIME_INIT` または `STATIC_INIT` Recorder を使用して `MetricsFactory` コンシューマを定義する `MetricsFactoryConsumerBuildItem` を生成する `BuildStep` を定義することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1717
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"MetricsFactoryConsumerBuildItem registerMetrics(MyExtensionRecorder recorder) {\n"
"    return new MetricsFactoryConsumerBuildItem(recorder.registerMetrics());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1720
#, fuzzy
msgid "The associated recorder should use the provided `MetricsFactory` to register metrics, for example"
msgstr "関連するレコーダーは、提供された `MetricsFactory` を使用してメトリクスを登録する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1724
#, no-wrap
msgid "final LongAdder extensionCounter = new LongAdder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1733
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerMetrics() {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            metricsFactory.builder(\"my.extension.counter\")\n"
"                    .buildGauge(extensionCounter::longValue);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1736
#, fuzzy
msgid "Remember that metrics extensions are optional. Keep metrics-related initialization isolated from other setup for your extension, and structure your code to avoid eager imports of metrics APIs. Gathering metrics can also be expensive. Consider using additional extension-specific configuration to control behavior of metrics if the presence/absence of metrics support isn't sufficient."
msgstr "UML 2.0 図では、「Element Import」という名前で、「Element Import」という名前を使用しています。メトリクス関連の初期化は、拡張のための他のセットアップから分離しておき、メトリクス API の熱心なインポートを避けるためにコードを構造化してください。UML 2.0 図では、「UML 2.0」と「UML 2.0」の間には、「UML 2.0」と「UML 2.0」があります。UML 2.0 コンポジット構造体は、「UML 2.0 コンポジット構造体」と呼ばれています。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1737
#, no-wrap
msgid "Customizing JSON handling from an extension"
msgstr "エクステンションからJSON処理をカスタマイズする"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1740
msgid "Extensions often need to register serializers and/or deserializers for types the extension provides."
msgstr "エクステンションはしばしば、エクステンションが提供する型のシリアライザやデシリアライザを登録する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1743
msgid "For this, both Jackson and JSON-B extensions provide a way to register serializer/deserializer from within an extension deployment module."
msgstr "このため、Jackson 拡張モジュールと JSON-B 拡張モジュールの両方で、エクステンション内からシリアライザ/デシリアライザを登録する方法を提供しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1745
msgid "Keep in mind that not everybody will need JSON, so you need to make it optional."
msgstr "すべての人がJSONを必要とするわけではないことを覚えておいてください。そのため、オプションとする必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1748
msgid "If an extension intends to provide JSON related customization, it is strongly advised to provide customization for both Jackson and JSON-B."
msgstr "エクステンションがJSON関連のカスタマイズを提供しようとする場合は、JacksonとJSON-Bの両方のカスタマイズを提供することを強くお勧めします。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1749
#, no-wrap
msgid "Customizing Jackson"
msgstr "Jacksonのカスタマイズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1752
msgid "First, add an *optional* dependency to `quarkus-jackson` on your extension's runtime module."
msgstr "まず、エクステンションのランタイムモジュールに `quarkus-jackson` への *オプションの* 依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1760
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1763
msgid "Then create a serializer or a deserializer (or both) for Jackson, an example of which can be seen in the `mongodb-panache` extension."
msgstr "次に、Jackson 用のシリアライザまたはデシリアライザ (またはその両方) を作成します。 `mongodb-panache` のエクステンションで例を見ることができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1778
#, no-wrap
msgid ""
"public class ObjectIdSerializer extends StdSerializer<ObjectId> {\n"
"    public ObjectIdSerializer() {\n"
"        super(ObjectId.class);\n"
"    }\n"
"    @Override\n"
"    public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)\n"
"            throws IOException {\n"
"        if (objectId != null) {\n"
"            jsonGenerator.writeString(objectId.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1781
#, fuzzy
msgid "Add a dependency to `quarkus-jackson-spi` on your extension's deployment module."
msgstr "`quarkus-jackson-spi` への依存関係をエクステンションのデプロイメントモジュールに追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1788
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1792
#, fuzzy
msgid "Add a build step to your processor to register a Jackson module via the `JacksonModuleBuildItem`.  You need to name your module in a unique way across all Jackson modules."
msgstr "`JacksonModuleBuildItem` を経由して、Jackson モジュールを登録するためのビルドステップをプロセッサに追加してください。モジュールの名前は、すべてのJacksonモジュールに共通するユニークな方法で付ける必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1803
#, no-wrap
msgid ""
"@BuildStep\n"
"JacksonModuleBuildItem registerJacksonSerDeser() {\n"
"    return new JacksonModuleBuildItem.Builder(\"ObjectIdModule\")\n"
"                    .add(io.quarkus.mongodb.panache.jackson.ObjectIdSerializer.class.getName(),\n"
"                            io.quarkus.mongodb.panache.jackson.ObjectIdDeserializer.class.getName(),\n"
"                            ObjectId.class.getName())\n"
"                    .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1806
msgid "The Jackson extension will then use the produced build item to register a module within Jackson automatically."
msgstr "そして、Jackson エクステンションは、生成されたビルドアイテムを使用して、Jackson 内で自動的にモジュールを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1810
#, fuzzy
msgid "If you need more customization capabilities than registering a module, you can produce a CDI bean that implements `io.quarkus.jackson.ObjectMapperCustomizer` via an `AdditionalBeanBuildItem`.  More info about customizing Jackson can be found on the JSON guide link:rest-json#configuring-json-support[Configuring JSON support]"
msgstr "モジュールを登録する以上のカスタマイズ機能が必要な場合は、 `io.quarkus.jackson.ObjectMapperCustomizer` を実装した CDI Bean を `AdditionalBeanBuildItem` を介して作成することができます。Jackson のカスタマイズについての詳細は、JSON ガイドの JS link:rest-json#configuring-json-support[ON サポートの設定] を参照してください。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1811
#, fuzzy, no-wrap
msgid "Customizing JSON-B"
msgstr "JSON-Bのカスタマイズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1813
#, fuzzy
msgid "First, add an *optional* dependency to `quarkus-jsonb` on your extension's runtime module."
msgstr "まず、エクステンションのランタイムモジュールに `quarkus-jsonb` に *オプションの* 依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1821
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1824
#, fuzzy
msgid "Then create a serializer and/or a deserializer for JSON-B, an example of which can be seen in the `mongodb-panache` extension."
msgstr "次に、JSON-B用のシリアライザおよび/またはデシリアライザを作成します。 `mongodb-panache` 拡張モジュールに例があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1835
#, no-wrap
msgid ""
"public class ObjectIdSerializer implements JsonbSerializer<ObjectId> {\n"
"    @Override\n"
"    public void serialize(ObjectId obj, JsonGenerator generator, SerializationContext ctx) {\n"
"        if (obj != null) {\n"
"            generator.write(obj.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1838
#, fuzzy
msgid "Add a dependency to `quarkus-jsonb-spi` on your extension's deployment module."
msgstr "`quarkus-jsonb-spi` への依存関係をエクステンションのデプロイメントモジュールに追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1845
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1848
#, fuzzy
msgid "Add a build step to your processor to register the serializer via the `JsonbSerializerBuildItem`."
msgstr "ビルドステップをプロセッサに追加して、 `JsonbSerializerBuildItem` を経由してシリアライザを登録します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1855
#, no-wrap
msgid ""
"@BuildStep\n"
"JsonbSerializerBuildItem registerJsonbSerializer() {\n"
"    return new JsonbSerializerBuildItem(io.quarkus.mongodb.panache.jsonb.ObjectIdSerializer.class.getName()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1858
#, fuzzy
msgid "The JSON-B extension will then use the produced build item to register your serializer/deserializer automatically."
msgstr "JSON-Bエクステンションは、生成されたビルド項目を使用して、シリアライザ/デシリアライザを自動的に登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1862
#, fuzzy
msgid "If you need more customization capabilities than registering a serializer or a deserializer, you can produce a CDI bean that implements `io.quarkus.jsonb.JsonbConfigCustomizer` via an `AdditionalBeanBuildItem`.  More info about customizing JSON-B can be found on the JSON guide link:rest-json#configuring-json-support[Configuring JSON support]"
msgstr "シリアライザやデシリアライザを登録する以上のカスタマイズ機能が必要な場合は、 `io.quarkus.jsonb.JsonbConfigCustomizer` を実装した CDI Bean を `AdditionalBeanBuildItem` .JSON-B のカスタマイズについての詳細は、JSON ガイドの link:rest-json#configuring-json-support[JSON サポートの設定] に記載されています。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1863
#, fuzzy, no-wrap
msgid "Integrating with Development Mode"
msgstr "エクステンションビーンズとの相互作用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1866
#, fuzzy
msgid "There are various APIS that you can use to integrate with development mode, and to get information about the current state."
msgstr "開発モードとの統合や、現在の状態に関する情報を得るために使用できる様々なAPISがあります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1867
#, fuzzy, no-wrap
msgid "Handling restarts"
msgstr "再起動への対応"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1871
#, fuzzy
msgid "When Quarkus is starting the `io.quarkus.deployment.builditem.LiveReloadBuildItem` is guaranteed to be present that gives information about this start, in particular:"
msgstr "Quarkusの起動時には、特にこの起動に関する情報を与える `io.quarkus.deployment.builditem.LiveReloadBuildItem` が存在することが保証されています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1873
#, fuzzy
msgid "Is this a clean start or a live reload"
msgstr "クリーンスタートなのか、ライブリロードなのか"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1874
#, fuzzy
msgid "If this is a live reload which changed files / classes triggered the reload"
msgstr "ライブリロードで、変更されたファイルやクラスがリロードのきっかけになっている場合"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1877
#, fuzzy
msgid "It also provides a global context map you can use to store information between restarts, without needing to resort to static fields."
msgstr "また、静的なフィールドに頼ることなく、再起動の間に情報を保存するために使用できるグローバルなコンテキストマップを提供しています。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1878
#, fuzzy, no-wrap
#| msgid "Testing hot reload"
msgid "Triggering Live Reload"
msgstr "ホットリロードのテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1883
#, fuzzy
msgid "Live reload is generally triggered by a HTTP request, however not all applications are HTTP applications and some extensions may want to trigger live reload based on other events. To do this you need to implement `io.quarkus.dev.spi.HotReplacementSetup` in your runtime module, and add a `META-INF/services/io.quarkus.dev.spi.HotReplacementSetup` that lists your implementation."
msgstr "しかし、すべてのアプリケーションがHTTPアプリケーションであるとは限らず、エクステンションによっては他のイベントに基づいてライブリロードをトリガしたい場合もあります。これを実現するには、ランタイムモジュールで `io.quarkus.dev.spi.HotReplacementSetup` を実装し、その実装を示す `META-INF/services/io.quarkus.dev.spi.HotReplacementSetup` を追加する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1886
#, fuzzy
msgid "On startup the `setupHotDeployment` method will be called, and you can use the provided `io.quarkus.dev.spi.HotReplacementContext` to initiate a scan for changed files."
msgstr "起動時には `setupHotDeployment` メソッドが呼び出され、提供された `io.quarkus.dev.spi.HotReplacementContext` を使って変更されたファイルのスキャンを開始することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1887
#, no-wrap
msgid "Testing Extensions"
msgstr "エクステンションのテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1894
msgid "Testing of Quarkus extensions should be done with the `io.quarkus.test.QuarkusUnitTest` JUnit 5 extension.  This extension allows for Arquillian-style tests that test specific functionalities.  It is not intended for testing user applications, as this should be done via `io.quarkus.test.junit.QuarkusTest`.  The main difference is that `QuarkusTest` simply boots the application once at the start of the run, while `QuarkusUnitTest` deploys a custom Quarkus application for each test class."
msgstr "Quarkus エクステンションのテストは `io.quarkus.test.QuarkusUnitTest` JUnit 5 拡張モジュールを使用してください。このエクステンションを使用すると、特定の機能をテストする Arquillian スタイルのテストを行うことができます。ユーザーアプリケーションのテストは `io.quarkus.test.junit.QuarkusTest` を経由して行う必要があるため、ユーザーアプリケーションのテストを目的としたものではありません。主な違いは、 `QuarkusTest` は実行開始時にアプリケーションを起動するだけで、 `QuarkusUnitTest` は各テストクラスごとにカスタムの Quarkus アプリケーションを展開するという点です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1897
#, fuzzy
msgid "These tests should be placed in the deployment module, if additional Quarkus modules are required for testing their deployment modules should also be added as test scoped dependencies."
msgstr "これらのテストはデプロイメントモジュールに配置する必要があります。Quarkusモジュールのテストに追加のQuarkusモジュールが必要な場合は、それらのデプロイメントモジュールもテストスコープ付きの依存関係として追加する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1899
#, fuzzy
msgid "Note that `QuarkusUnitTest` is in the `quarkus-junit5-internal` module."
msgstr "`QuarkusUnitTest` は `quarkus-junit5-internal` モジュールの中にあることに注意してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1901
#, fuzzy
msgid "An example test class may look like:"
msgstr "テストクラスの例は次のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1905
#, no-wrap
msgid "package io.quarkus.health.test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1907
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1910
#, no-wrap
msgid ""
"import java.util.ArrayList;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1913
#, no-wrap
msgid ""
"import javax.enterprise.inject.Instance;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1923
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.Liveness;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.asset.EmptyAsset;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1925
#, no-wrap
msgid "import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1927
#, no-wrap
msgid "public class FailingUnitTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1935
#, no-wrap
msgid ""
"    @RegisterExtension                                                                  // <1>\n"
"    static final QuarkusUnitTest config = new QuarkusUnitTest()\n"
"            .setArchiveProducer(() ->\n"
"                    ShrinkWrap.create(JavaArchive.class)                                // <2>\n"
"                            .addClasses(FailingHealthCheck.class)\n"
"                            .addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\")\n"
"            );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1939
#, no-wrap
msgid ""
"    @Inject                                                                             // <3>\n"
"    @Liveness\n"
"    Instance<HealthCheck> checks;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1944
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthServlet() {\n"
"        RestAssured.when().get(\"/q/health\").then().statusCode(503);                       // <4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1955
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthBeans() {\n"
"        List<HealthCheck> check = new ArrayList<>();                                    // <5>\n"
"        for (HealthCheck i : checks) {\n"
"            check.add(i);\n"
"        }\n"
"        assertEquals(1, check.size());\n"
"        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call().getState());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1958
msgid "The `QuarkusUnitTest` extension must be used with a static field. If used with a non-static field, the test application is not started."
msgstr "`QuarkusUnitTest` エクステンションは、静的フィールドと一緒に使用する必要があります。静的でないフィールドで使用した場合、テストアプリケーションは開始されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1959
#, fuzzy
msgid "This producer is used to build the application to be tested. It uses Shrinkwrap to create a JavaArchive to test"
msgstr "このプロデューサーは、テストされるアプリケーションを構築するために使用されます。Shrinkwrap を使用して、テストする JavaArchive を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1960
#, fuzzy
msgid "It is possible to inject beans from our test deployment directly into the test case"
msgstr "テストデプロイメントからテストケースに直接ビーンを注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1961
#, fuzzy
msgid "This method directly invokes the health check Servlet and verifies the response"
msgstr "このメソッドは、ヘルスチェックサーブレットを直接呼び出し、レスポンスを検証します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1962
#, fuzzy
msgid "This method uses the injected health check bean to verify it is returning the expected result"
msgstr "このメソッドは、注入されたヘルスチェック・ビーンを使用して、それが期待された結果を返していることを確認します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1964
#, fuzzy
msgid "If you want to test that an extension properly fails at build time, use the `setExpectedException` method:"
msgstr "ビルド時にエクステンションが適切に失敗するかどうかをテストしたい場合は、 `setExpectedException` メソッドを使用してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1969
#, no-wrap
msgid "package io.quarkus.hibernate.orm;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1977
#, no-wrap
msgid ""
"import io.quarkus.deployment.configuration.ConfigurationError;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1979
#, no-wrap
msgid "public class PersistenceAndQuarkusConfigTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1986
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    static QuarkusUnitTest runner = new QuarkusUnitTest()\n"
"            .setExpectedException(ConfigurationError.class)                     <1>\n"
"            .withApplicationRoot((jar) -> jar\n"
"                    .addAsManifestResource(\"META-INF/some-persistence.xml\", \"persistence.xml\")\n"
"                    .addAsResource(\"application.properties\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1994
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPersistenceAndConfigTest() {\n"
"        // should not be called, deployment exception should happen first:\n"
"        // it's illegal to have Hibernate configuration properties in both the\n"
"        // application.properties and in the persistence.xml\n"
"        Assertions.fail();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1999
msgid "This tells JUnit that the Quarkus deployment should fail with a specific exception"
msgstr "これは、Quarkus のデプロイが特定の例外で失敗することを JUnit に伝えます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2001
#, no-wrap
msgid "Testing hot reload"
msgstr "ホットリロードのテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2005
msgid "It is also possible to write tests that verify an extension works correctly in development mode and can correctly handle updates."
msgstr "開発モードでエクステンションが正しく動作し、アップデートを正しく処理できるかどうかを検証するテストを書くことも可能です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2008
msgid "For most extensions this will just work 'out of the box', however it is still a good idea to have a smoke test to verify that this functionality is working as expected. To test this we use `QuarkusDevModeTest`:"
msgstr "ほとんどのエクステンションでは、これは「箱から出してすぐに」動作しますが、この機能が期待通りに動作しているかどうかを確認するためにスモークテストを行うことをお勧めします。このテストには `QuarkusDevModeTest` を使用します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2013
#, no-wrap
msgid "public class ServletChangeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2024
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    final static QuarkusDevModeTest test = new QuarkusDevModeTest()\n"
"            .setArchiveProducer(new Supplier<JavaArchive>() {\n"
"                @Override\n"
"                public JavaArchive get() {\n"
"                    return ShrinkWrap.create(JavaArchive.class)   <1>\n"
"                            .addClass(DevServlet.class)\n"
"                            .addAsManifestResource(new StringAsset(\"Hello Resource\"), \"resources/file.txt\");\n"
"                }\n"
"            });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2030
#, no-wrap
msgid ""
"    @Test\n"
"    public void testServletChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello World\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2032
#, no-wrap
msgid "        test.modifySourceFile(\"DevServlet.java\", new Function<String, String>() {  <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2038
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return s.replace(\"Hello World\", \"Hello Quarkus\");\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2043
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Quarkus\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2048
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddServlet() throws InterruptedException {\n"
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2050
#, no-wrap
msgid "        test.addSourceFile(NewServlet.class);                                       <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2055
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new Servlet\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2061
#, no-wrap
msgid ""
"    @Test\n"
"    public void testResourceChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Resource\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2063
#, no-wrap
msgid "        test.modifyResourceFile(\"META-INF/resources/file.txt\", new Function<String, String>() { <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2069
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return \"A new resource\";\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2074
#, no-wrap
msgid ""
"        RestAssured.when().get(\"file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new resource\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2077
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddResource() throws InterruptedException {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2080
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2082
#, no-wrap
msgid "        test.addResourceFile(\"META-INF/resources/new.txt\", \"New File\");  <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2086
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"New File\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2089
#, no-wrap
msgid ""
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2093
#, fuzzy
msgid "This starts the deployment, your test can modify it as part of the test suite. Quarkus will be restarted between each test method so every method starts with a clean deployment."
msgstr "これによりデプロイメントが開始され、テストはテストスイートの一部として変更することができます。Quarkusは各テストメソッドの間に再起動されるので、すべてのメソッドはクリーンなデプロイメントから始まります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2096
#, fuzzy
msgid "This method allows you to modify the source of a class file. The old source is passed into the function, and the updated source is returned."
msgstr "このメソッドを使用すると、クラス・ファイルのソースを変更することができます。古いソースが関数に渡され、更新されたソースが返されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2099
#, fuzzy
msgid "This method adds a new class file to the deployment. The source that is used will be the original source that is part of the current project."
msgstr "このメソッドは、新しいクラス ファイルをデプロイメントに追加します。使用されるソースは、現在のプロジェクトの一部であるオリジナルのソースになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2101
msgid "This method modifies a static resource"
msgstr "このメソッドは静的リソースを変更します"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2103
msgid "This method adds a new static resource"
msgstr "このメソッドは新しい静的リソースを追加します"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2104
#, no-wrap
msgid "Native Executable Support"
msgstr "ネイティブ実行ファイルのサポート"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2109
#, fuzzy
msgid "There Quarkus provides a lot of build items that control aspects of the native executable build. This allows for extensions to programmatically perform tasks such as registering classes for reflection or adding static resources to the native executable. Some of these build items are listed below:"
msgstr "Quarkusでは、ネイティブ実行ファイルのビルドの側面を制御する多くのビルド項目を提供しています。これにより、リフレクションのためにクラスを登録したり、ネイティブ実行ファイルに静的リソースを追加したりといったタスクを、エクステンションがプログラムで実行できるようになります。これらのビルド項目の一部を以下に示します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2110
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2112
msgid "Includes static resources into the native executable."
msgstr "ネイティブ実行ファイルに静的なリソースをインクルードします。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2113
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2115
msgid "Includes directory's static resources into the native executable."
msgstr "ディレクトリの静的リソースをネイティブ実行ファイルにインクルードします。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2116
#, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2118
#, fuzzy
msgid "A class that will be reinitialized at runtime by Substrate. This will result in the static initializer running twice."
msgstr "実行時に Substrate によって再初期化されるクラス。これにより、静的イニシャライザが2回実行されることになります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2119
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2121
#, fuzzy
msgid "A system property that will be set at native executable build time."
msgstr "ネイティブ実行ファイルのビルド時に設定されるシステムプロパティです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2122
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2124
#, fuzzy
msgid "Includes a resource bundle in the native executable."
msgstr "ネイティブ実行ファイルにリソースバンドルを含みます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2125
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2127
#, fuzzy
msgid "Registers a class for reflection in Substrate. Constructors are always registered, while methods and fields are optional."
msgstr "Substrateに反映させるためのクラスを登録します。コンストラクタは常に登録され、メソッドとフィールドはオプションです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2128
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2130
#, fuzzy
msgid "A class that will be initialized at runtime rather than build time. This will cause the build to fail if the class is initialized as part of the native executable build process, so care must be taken."
msgstr "ビルド時ではなく実行時に初期化されるクラス。これは、ネイティブの実行可能なビルドプロセスの一部としてクラスが初期化されるとビルドが失敗する原因となるので、注意が必要です。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2131
#, fuzzy, no-wrap
msgid "`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"
msgstr "`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2133
#, fuzzy
msgid "A convenience feature that allows you to control most of the above features from a single build item."
msgstr "1つのビルドアイテムから上記の機能のほとんどをコントロールできる便利な機能です。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2134
#, no-wrap
msgid "`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"
msgstr "`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2136
msgid "Indicates that all charsets should be enabled in native image."
msgstr "ネイティブイメージですべての文字セットを有効にすることを示します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2137
#, no-wrap
msgid "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"
msgstr "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2140
#, fuzzy
#| msgid "A convenient way to tell Quarkus that the extension requires SSL and it should be enabled during native image build.  When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide]."
msgid "A convenient way to tell Quarkus that the extension requires SSL and it should be enabled during native image build.  When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the https://github.com/quarkusio/quarkus/blob/main/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide]."
msgstr "エクステンションがSSLを必要とし、ネイティブイメージのビルド中に有効にする必要があることをQuarkusに伝える便利な方法です。この機能を使用する場合は、 link:https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/native-and-ssl.adoc[ネイティブおよびsslガイド] の、自動的にSSLサポートを提供するエクステンションのリストに、作成したエクステンションを追加することを忘れないでください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2141
#, no-wrap
msgid "IDE support tips"
msgstr "IDE サポートのヒント"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2143
#, no-wrap
msgid "Writing Quarkus extensions in Eclipse"
msgstr "EclipseでQuarkusエクステンションを書く"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2146
msgid "The only particular aspect of writing Quarkus extensions in Eclipse is that APT (Annotation Processing Tool) is required as part of extension builds, which means you need to:"
msgstr "EclipseでQuarkusエクステンションを書く際の唯一の特別な点は、エクステンションのビルドの一部としてAPT（Annotation Processing Tool）が必要であることです。つまり、以下が必要です:"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2148
msgid "Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt"
msgstr "https://marketplace.eclipse.org/content/m2e-apt から `m2e-apt` をインストール"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2149
msgid "Define this property in your `pom.xml`: `<m2e.apt.activation>jdt_apt</m2e.apt.activation>`, although if you rely on `io.quarkus:quarkus-build-parent` you will get it for free."
msgstr "`pom.xml` にこのプロパティを追加します : `<m2e.apt.activation>jdt_apt</m2e.apt.activation>` 。`io.quarkus:quarkus-build-parent` に依存している場合、既に追加済です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2150
#, fuzzy
msgid "If you have the `io.quarkus:quarkus-extension-processor` project open at the same time in your IDE (for example, if you have the Quarkus sources checked out and open in your IDE) you will need to close that project. Otherwise, Eclipse will not invoke the APT plugin that it contains."
msgstr "IDEで `io.quarkus:quarkus-extension-processor` プロジェクトを同時に開いている場合（例えば、QuarkusソースをチェックアウトしてIDEで開いている場合など）、そのプロジェクトを閉じる必要があります。そうしないと、Eclipseはそのプロジェクトに含まれるAPTプラグインを起動しません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2151
#, fuzzy
msgid "If you just closed the extension processor project, be sure to do `Maven > Update Project` on the other projects in order for Eclipse to pick up the extension processor from the Maven repository."
msgstr "拡張プロセッサプロジェクトを閉じたばかりの場合は、EclipseがMavenリポジトリから拡張プロセッサをピックアップするために、他のプロジェクトで `Maven > Update Project` を実行するようにしてください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2152
#, no-wrap
msgid "Troubleshooting / Debugging Tips"
msgstr "トラブルシューティング / デバッグのヒント"

#.  This id was previously used for the "Dump the Generated Classes to the File System" section
#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2156
#, fuzzy, no-wrap
msgid "Inspecting the Generated/Transformed Classes"
msgstr "生成・変換されたクラスの検査"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2160
#, fuzzy
msgid "Quarkus generates a lot of classes during the build phase and in many cases also transforms existing classes.  It is often extremely useful to see the generated bytecode and transformed classes during the development of an extension."
msgstr "Quarkusでは、ビルド段階で多くのクラスが生成され、多くの場合、既存のクラスも変換されます。拡張機能の開発中に、生成されたバイトコードや変換されたクラスを見ることができるのは、非常に便利なことです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2162
#, fuzzy
msgid "If you set the `quarkus.package.fernflower.enabled` property to `true` then Quarkus will download and invoke the https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine[Fernflower decompiler] and dump the result in the `decompiled` directory of the build tool output (`target/decompiled` for Maven for example)."
msgstr "`quarkus.package.fernflower.enabled` プロパティを `true` に設定すると、Quarkusは link:https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine[Fernflowerのデコンパイラ]をダウンロードして起動し、その結果をビルドツールの出力の `decompiled` ディレクトリにダンプします（例えば、Mavenの場合は `target/decompiled` ）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2164
#, fuzzy
msgid "This property only works during a normal production build (i.e. not for dev mode/tests) and when `fast-jar` packaging type is used (the default behavior)."
msgstr "このプロパティは、通常のプロダクションビルド時にのみ機能します（つまり、devモード/テストでは機能しません）。また、 `fast-jar` パッケージングタイプが使用されている場合（デフォルトの動作）には、このプロパティは機能しません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2166
#, fuzzy
msgid "There are also three system properties that allow you to dump the generated/transformed classes to the filesystem and inspect them later, for example via a decompiler in your IDE."
msgstr "また、生成/変換されたクラスをファイルシステムにダンプして、IDEのデコンパイラなどで後から検査することができる3つのシステム・プロパティがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2168
msgid "`quarkus.debug.generated-classes-dir` - to dump the generated classes, such as bean metadata"
msgstr "`quarkus.debug.generated-classes-dir` - Beanのメタデータのような、生成されたクラスをダンプします"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2169
msgid "`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e.g. Panache entities"
msgstr "`quarkus.debug.transformed-classes-dir` - Panache エンティティのような、変換されたクラスをダンプします"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2170
msgid "`quarkus.debug.generated-sources-dir` - to dump the ZIG files; ZIG file is a textual representation of the generated code that is referenced in the stack traces"
msgstr "`quarkus.debug.generated-sources-dir` - ZIG ファイルをダンプします。ZIG ファイルは、スタックトレースで参照される生成コードのテキスト表現です"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2172
#, fuzzy
msgid "These properties are especially useful in the development mode or when running the tests where the generated/transformed classes are only held in memory in a class loader."
msgstr "これらのプロパティは、開発モードや、生成/変換されたクラスがクラス・ローダのメモリにしか保持されないテストを実行するときに特に便利です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2174
#, fuzzy
msgid "For example, you can specify the `quarkus.debug.generated-classes-dir` system property to have these classes written out to disk for inspection in the development mode:"
msgstr "例えば、 `quarkus.debug.generated-classes-dir` system プロパティを指定して、開発モードで検査のためにこれらのクラスをディスクに書き出すようにすることができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2178
#, no-wrap
msgid "./mvnw quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2181
#, fuzzy
msgid "The property value could be either an absolute path, such as `/home/foo/dump` on a Linux machine, or a path relative to the user working directory, i.e. `dump` corresponds to the `{user.dir}/target/dump` in the dev mode and `{user.dir}/dump` when running the tests."
msgstr "`dump` `{user.dir}/target/dump` `{user.dir}/dump` プロパティ値は、Linux マシンの `/home/foo/dump` のような絶対パスか、ユーザの作業ディレクトリからの相対パスのどちらかになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2183
#, fuzzy
msgid "You should see a line in the log for each class written to the directory:"
msgstr "ディレクトリに書き込まれた各クラスのログに一行が表示されるはずです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2187
#, no-wrap
msgid "INFO  [io.qua.run.boo.StartupActionImpl] (main) Wrote /path/to/my/app/target/dump-classes/io/quarkus/arc/impl/ActivateRequestContextInterceptor_Bean.class\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2190
#, fuzzy
msgid "The property is also honored when running tests:"
msgstr "このプロパティは、テストを実行する際にも優先されます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2194
#, no-wrap
msgid "./mvnw clean test -Dquarkus.debug.generated-classes-dir=target/dump-generated-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2197
#, fuzzy
msgid "Analogously, you can use the `quarkus.debug.transformed-classes-dir` and `quarkus.debug.transformed-classes-dir` properties to dump the relevant output."
msgstr "同様に、 `quarkus.debug.transformed-classes-dir` と `quarkus.debug.transformed-classes-dir` プロパティを使用して、関連する出力をダンプすることができます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2198
#, fuzzy, no-wrap
msgid "Multi-module Maven Projects and the Development Mode"
msgstr "マルチモジュールMavenプロジェクトと開発モード"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2203
#, fuzzy
msgid "It's not uncommon to develop an extension in a multi-module Maven project that also contains an \"example\" module.  However, if you want to run the example in the development mode then the `-DnoDeps` system property must be used in order to exclude the local project dependencies.  Otherwise, Quarkus attempts to monitor the extension classes and this may result in weird class loading issues."
msgstr "マルチモジュールのMavenプロジェクトでエクステンションを開発する場合、\"example\"モジュールも含まれていることは珍しくありません。しかし、開発モードで例を実行したい場合は、ローカルプロジェクトの依存関係を除外するために、 `-DnoDeps` システムプロパティを使用する必要があります。そうしないと、Quarkusは拡張クラスを監視しようとするため、奇妙なクラスロードの問題が発生する可能性があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2207
#, no-wrap
msgid "./mvnw compile quarkus:dev -DnoDeps\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2209
#, fuzzy, no-wrap
msgid "Indexer does not include your external dependency"
msgstr "インデクサには、あなたの外部依存関係が含まれていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2212
#, fuzzy
msgid "Remember to add `IndexDependencyBuildItem` artifacts to your `@BuildStep`."
msgstr "`IndexDependencyBuildItem` の成果物を `@BuildStep` に追加することを忘れないでください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2213
#, no-wrap
msgid "Sample Test Extension"
msgstr "サンプルテストエクステンション"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2216
#, fuzzy
msgid "We have an extension that is used to test for regressions in the extension processing. It is located in {quarkus-tree-url}/core/test-extension directory. In this section we touch on some of the tasks an extension author will typically need to perform using the test-extension code to illustrate how the task could be done."
msgstr "エクステンションの処理でリグレッションのテストを行うためのエクステンションを用意しています。これは {quarkus-tree-url}/core/test-extension ディレクトリにあります。このセクションでは、エクステンションの作者がテスト拡張コードを使って実行する必要があるタスクのいくつかに触れ、どのようにタスクが実行できるかを説明します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2217
#, fuzzy, no-wrap
msgid "Features and Capabilities"
msgstr "特徴と機能"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2219
#, no-wrap
msgid "Features"
msgstr "特徴"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2223
#, fuzzy
msgid "A _feature_ represents a functionality provided by an extension.  The name of the feature gets displayed in the log during application bootstrap."
msgstr "_機能は_ 、エクステンションによって提供される機能を表します。機能の名前は、アプリケーションの起動時にログに表示されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2224
#, fuzzy, no-wrap
msgid "Example Startup Lines"
msgstr "スタートアップラインの例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2229
#, no-wrap
msgid ""
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 0.061s.\n"
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, test-extension] <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2231
#, fuzzy
msgid "A list of features installed in the runtime image"
msgstr "ランタイムイメージにインストールされている機能のリスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2233
#, fuzzy
msgid "A feature can be registered in a <<Build Step Processors>> method that produces a `FeatureBuildItem`:"
msgstr "機能を登録できるのは、 link:#Build Step Processors[] `FeatureBuildItem` ."

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2234
#, fuzzy, no-wrap
msgid "TestProcessor#feature()"
msgstr "TestProcessor#feature()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2241
#, no-wrap
msgid ""
"    @BuildStep\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(\"test-extension\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2246
#, fuzzy
msgid "The name of the feature should only contain lowercase characters, words are separated by dash; e.g. `security-jpa`.  An extension should provide at most one feature and the name must be unique.  If multiple extensions register a feature of the same name the build fails."
msgstr "`security-jpa` 機能の名前は小文字のみで、単語はダッシュで区切ってください。1つの拡張モジュールが提供する機能は最大でも1つでなければならず、その名前は一意でなければなりません。複数の拡張モジュールが同じ名前の機能を登録した場合、ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2250
#, fuzzy
msgid "The feature name should also map to a label in the extension's `devtools/common/src/main/filtered/extensions.json` entry so that the feature name displayed by the startup line matches a label that one can used to select the extension when creating a project using the Quarkus maven plugin as shown in this example taken from the link:rest-json[Writing JSON REST Services] guide where the `resteasy-jackson` feature is referenced:"
msgstr "機能名は、 `resteasy-jackson` 機能が参照されている link:rest-json[Writing JSON REST Services] ガイドの例に示されているように、起動時に表示される機能名が、Quarkus mavenプラグインを使用してプロジェクトを作成する際にエクステンションを選択するために使用できるラベルと一致するように、エクステンションの `devtools/common/src/main/filtered/extensions.json` エントリ内のラベルにもマッピングする必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2260
#, no-wrap
msgid ""
"mvn io.quarkus.platform:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy,resteasy-jackson\"\n"
"cd rest-json\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2262
#, fuzzy, no-wrap
msgid "Capabilities"
msgstr "機能"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2268
#, fuzzy
msgid "A _capability_ represents a technical capability that can be queried by other extensions.  An extension may provide multiple capabilities and multiple extensions can provide the same capability.  By default, capabilities are not displayed to users.  Capabilities should be used when checking for the presence of an extension rather than class path based checks."
msgstr "_ケイパビリティ_ は、他のエクステンションから問い合わせ可能な技術的なケイパビリティを表します。1つのエクステンションが複数のケイパビリティを提供し、複数のエクステンションが同じケイパビリティを提供することができます。デフォルトでは、ケイパビリティはユーザーに表示されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2270
#, fuzzy
msgid "Capabilities can be registered in a <<Build Step Processors>> method that produces a `CapabilityBuildItem`:"
msgstr "能力は、 `CapabilityBuildItem` を生成する link:#Build Step Processors[[Build Step Processors]] メソッドに登録することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2271
#, fuzzy, no-wrap
msgid "TestProcessor#capability()"
msgstr "TestProcessor#capability()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2279
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void capabilities(BuildProducer<CapabilityBuildItem> capabilityProducer) {\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-transactions\"));\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-metrics\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2282
#, fuzzy
msgid "Extensions can consume registered capabilities using the `Capabilities` build item:"
msgstr "エクステンションは、 `Capabilities` ビルド項目を使用して登録された機能を消費することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2283
#, fuzzy, no-wrap
msgid "TestProcessor#doSomeCoolStuff()"
msgstr "TestProcessor#doSomeCoolStuff()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2292
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void doSomeCoolStuff(Capabilities capabilities) {\n"
"        if (capabilities.isPresent(Capability.TRANSACTIONS)) {\n"
"          // do something only if JTA transactions are in...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2296
#, fuzzy
msgid "Capabilities should follow the naming conventions of Java packages; e.g. `io.quarkus.security.jpa`.  Capabilities provided by core extensions should be listed in the `io.quarkus.deployment.Capability` enum and their name should always start with the `io.quarkus` prefix."
msgstr "`io.quarkus.security.jpa` 機能はJavaパッケージの命名規則に従うべきです。コアエクステンションによって提供される機能は `io.quarkus.deployment.Capability` enum にリストされ、その名前は常に `io.quarkus` で始まるべきです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2297
#, fuzzy, no-wrap
msgid "Bean Defining Annotations"
msgstr "Bean定義アノテーション"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2299
#, fuzzy
msgid "The CDI layer processes CDI beans that are either explicitly registered or that it discovers based on bean defining annotations as defined in http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[2.5.1. Bean defining annotations]. You can expand this set of annotations to include annotations your extension processes using a `BeanDefiningAnnotationBuildItem` as shown in this `TestProcessor#registerBeanDefinningAnnotations` example:"
msgstr "CDI レイヤは、明示的に登録された CDI ビーン、または link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[2.5.1] で定義されているビーン定義アノテーションに基づいて検出された CDI ビーンを処理する。 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[ビーン] 定義アノテーション。このアノテーションのセットを拡張して、この `TestProcessor#registerBeanDefinningAnnotations` の例に示すように、 `BeanDefiningAnnotationBuildItem` を使用してエクステンションが処理するアノテーションを含めることができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2300
#, fuzzy, no-wrap
msgid "Register a Bean Defining Annotation"
msgstr "Bean定義アノテーションの登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2306
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.jboss.jandex.DotName;\n"
"import io.quarkus.extest.runtime.TestAnnotation;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2310
#, no-wrap
msgid ""
"public final class TestProcessor {\n"
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());\n"
"    static DotName TEST_ANNOTATION_SCOPE = DotName.createSimple(ApplicationScoped.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2312
#: upstream/_guides/writing-extensions.adoc:2338
#, no-wrap
msgid "...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2320
#, no-wrap
msgid ""
"    @BuildStep\n"
"    BeanDefiningAnnotationBuildItem registerX() {\n"
"        <1>\n"
"        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, TEST_ANNOTATION_SCOPE);\n"
"    }\n"
"...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2330
#, no-wrap
msgid ""
"/**\n"
" * Marker annotation for test configuration target beans\n"
" */\n"
"@Target({ TYPE })\n"
"@Retention(RUNTIME)\n"
"@Documented\n"
"@Inherited\n"
"public @interface TestAnnotation {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2336
#, no-wrap
msgid ""
"/**\n"
" * A sample bean\n"
" */\n"
"@TestAnnotation <2>\n"
"public class ConfiguredBean implements IConfigConsumer {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2340
#, fuzzy
msgid "Register the annotation class and CDI default scope using the Jandex `DotName` class."
msgstr "Jandex `DotName` クラスを使用して、アノテーションクラスと CDI デフォルトスコープを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2341
#, fuzzy
msgid "`ConfiguredBean` will be processed by the CDI layer the same as a bean annotated with the CDI standard @ApplicationScoped."
msgstr "`ConfiguredBean` は CDI 標準の @ApplicationScoped でアノテーションされたビーンと同じように CDI レイヤーによって処理されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2342
#, fuzzy, no-wrap
msgid "Parsing Config to Objects"
msgstr "コンフィグをオブジェクトに解析する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2344
#, fuzzy
msgid "One of the main things an extension is likely to do is completely separate the configuration phase of behavior from the runtime phase. Frameworks often do parsing/load of configuration on startup that can be done during build time to both reduce the runtime dependencies on frameworks like xml parsers as well as reducing the startup time the parsing incurs."
msgstr "エクステンションが行う可能性の高い主なことの一つは、動作の設定フェーズをランタイムフェーズから完全に分離することです。フレームワークはしばしば起動時に設定のパース/ロードを行いますが、これはビルド時に行うことができ、xml パーサのようなフレームワークへのランタイム依存を減らし、パースにかかる起動時間を短縮します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2346
#, fuzzy
msgid "An example of parsing a XML config file using JAXB is shown in the `TestProcessor#parseServiceXmlConfig` method:"
msgstr "JAXBを使用してXML設定ファイルを解析する例は、 `TestProcessor#parseServiceXmlConfig` メソッドに示されています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2346
#, fuzzy, no-wrap
msgid "Parsing an XML Configuration into Runtime XmlConfig Instance"
msgstr "XML 設定のランタイム XmlConfig インスタンスへのパース"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2363
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\"); <1>\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <2>\n"
"...\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2366
#, fuzzy
msgid "Look for a config.xml classpath resource"
msgstr "config.xml のクラスパスリソースを探す"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2367
#, fuzzy
msgid "If found, parse using JAXB context for `XmlConfig.class`"
msgstr "見つかった場合は、JAXB コンテキストを使用してパースします。 `XmlConfig.class`"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2371
#, fuzzy
msgid "If there was no /config.xml resource available in the build environment, then a null `RuntimeServiceBuildItem` would be returned and no subsequent logic based on a `RuntimeServiceBuildItem` being produced would execute."
msgstr "ビルド環境で利用可能な /config.xml リソースがない場合は、null `RuntimeServiceBuildItem` が返され、生成された `RuntimeServiceBuildItem` に基づく後続のロジックは実行されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2374
#, fuzzy
msgid "Typically one is loading a configuration to create some runtime component/service as `parseServiceXmlConfig` is doing. We will come back to the rest of the behavior in `parseServiceXmlConfig` in the following <<Manage Non-CDI Service>> section."
msgstr "通常、 `parseServiceXmlConfig` が行っているように、ランタイムコンポーネント/サービスを作成するために設定をロードしています。 `parseServiceXmlConfig` の動作の残りの部分については、次の link:#Manage Non-CDI Service[[非 CDI サービスの管理]] セクションで説明します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2376
#, fuzzy
msgid "If for some reason you need to parse the config and use it in other build steps in an extension processor, you would need to create an `XmlConfigBuildItem` to pass the parsed XmlConfig instance around."
msgstr "何らかの理由でコンフィグを解析して拡張プロセッサの他のビルドステップで使用する必要がある場合は、 `XmlConfigBuildItem` を作成して解析した XmlConfig インスタンスを渡す必要があります。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2380
#, fuzzy
msgid "If you look at the XmlConfig code you will see that it does carry around the JAXB annotations. If you don't want these in the runtime image, you could clone the XmlConfig instance into some POJO object graph and then replace XmlConfig with the POJO class. We will do this in <<Replacing Classes in the Native Image>>."
msgstr "XmlConfig のコードを見ると、JAXB のアノテーションを持ち歩いていることがわかります。ランタイムイメージにこれらのアノテーションを入れたくない場合は、XmlConfig のインスタンスを POJO オブジェクトグラフにクローンして、XmlConfig を POJO クラスに置き換えることができます。これについては link:#Replacing Classes in the Native Image[[ネイティブイメージでクラスを置き換える]] で説明します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2382
#, fuzzy, no-wrap
msgid "Scanning Deployments Using Jandex"
msgstr "Jandexを使用したスキャニング導入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2384
#, fuzzy
msgid "If your extension defines annotations or interfaces that mark beans needing to be processed, you can locate these beans using the Jandex API, a Java annotation indexer and offline reflection library. The following `TestProcessor#scanForBeans` method shows how to find the beans annotated with our `@TestAnnotation` that also implement the `IConfigConsumer` interface:"
msgstr "エクステンションで処理が必要なビーンズをマークするアノテーションやインターフェイスを定義している場合は、Java アノテーションインデクサとオフラインリフレクションライブラリである Jandex API を使用して、これらのビーンズを見つけることができます。次の `TestProcessor#scanForBeans` メソッドは、 `IConfigConsumer` インターフェイスも実装している `@TestAnnotation` でアノテーションされたビーンを見つける方法を示しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2385
#, fuzzy, no-wrap
msgid "Example Jandex Usage"
msgstr "ジャンデックスの使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2390
#, no-wrap
msgid ""
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2413
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    void scanForBeans(TestRecorder recorder, BeanArchiveIndexBuildItem beanArchiveIndex, <1>\n"
"            BuildProducer<TestBeanBuildItem> testBeanProducer) {\n"
"        IndexView indexView = beanArchiveIndex.getIndex(); <2>\n"
"        Collection<AnnotationInstance> testBeans = indexView.getAnnotations(TEST_ANNOTATION); <3>\n"
"        for (AnnotationInstance ann : testBeans) {\n"
"            ClassInfo beanClassInfo = ann.target().asClass();\n"
"            try {\n"
"                boolean isConfigConsumer = beanClassInfo.interfaceNames()\n"
"                        .stream()\n"
"                        .anyMatch(dotName -> dotName.equals(DotName.createSimple(IConfigConsumer.class.getName()))); <4>\n"
"                if (isConfigConsumer) {\n"
"                    Class<IConfigConsumer> beanClass = (Class<IConfigConsumer>) Class.forName(beanClassInfo.name().toString(), false, Thread.currentThread().getContextClassLoader());\n"
"                    testBeanProducer.produce(new TestBeanBuildItem(beanClass)); <5>\n"
"                    log.infof(\"Configured bean: %s\", beanClass);\n"
"                }\n"
"            } catch (ClassNotFoundException e) {\n"
"                log.warn(\"Failed to load bean class\", e);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2415
#, fuzzy
msgid "Depend on a `BeanArchiveIndexBuildItem` to have the build step be run after the deployment has been indexed."
msgstr "デプロイメントがインデックス化された後にビルドステップが実行されるようにするには、 `BeanArchiveIndexBuildItem` に依存します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2416
#, fuzzy
msgid "Retrieve the index."
msgstr "インデックスを取得します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2417
#, fuzzy
msgid "Find all beans annotated with `@TestAnnotation`."
msgstr "`@TestAnnotation` で注釈されたすべての豆を検索する ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2418
#, fuzzy
msgid "Determine which of these beans also has the `IConfigConsumer` interface."
msgstr "これらのビーンズのうち、どのビーンズが `IConfigConsumer` インターフェイスも持っているかを決定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2419
#, fuzzy
msgid "Save the bean class in a `TestBeanBuildItem` for use in a latter RUNTIME_INIT build step that will interact with the bean instances."
msgstr "ビーンクラスを `TestBeanBuildItem` に保存して、後の RUNTIME_INIT ビルドステップでビーンインスタンスと対話するために使用します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2420
#, fuzzy, no-wrap
msgid "Interacting With Extension Beans"
msgstr "エクステンションビーンズとの相互作用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2422
#, fuzzy
msgid "You can use the `io.quarkus.arc.runtime.BeanContainer` interface to interact with your extension beans. The following `configureBeans` methods illustrate interacting with the beans scanned for in the previous section:"
msgstr "`io.quarkus.arc.runtime.BeanContainer` インターフェイスを使用して、拡張ビーンと対話することができます。以下の `configureBeans` メソッドは、前のセクションでスキャンしたビーンとの対話を説明しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2423
#, fuzzy, no-wrap
msgid "Using CDI BeanContainer Interface"
msgstr "CDI BeanContainerインタフェースの使用"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2432
#, no-wrap
msgid ""
"// TestProcessor#configureBeans\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    void configureBeans(TestRecorder recorder, List<TestBeanBuildItem> testBeans, <1>\n"
"            BeanContainerBuildItem beanContainer, <2>\n"
"            TestRunTimeConfig runTimeConfig) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2438
#, no-wrap
msgid ""
"        for (TestBeanBuildItem testBeanBuildItem : testBeans) {\n"
"            Class<IConfigConsumer> beanClass = testBeanBuildItem.getConfigConsumer();\n"
"            recorder.configureBeans(beanContainer.getValue(), beanClass, buildAndRunTimeConfig, runTimeConfig); <3>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2448
#, no-wrap
msgid ""
"// TestRecorder#configureBeans\n"
"    public void configureBeans(BeanContainer beanContainer, Class<IConfigConsumer> beanClass,\n"
"            TestBuildAndRunTimeConfig buildTimeConfig,\n"
"            TestRunTimeConfig runTimeConfig) {\n"
"        log.info(\"Begin BeanContainerListener callback\\n\");\n"
"        IConfigConsumer instance = beanContainer.instance(beanClass); <4>\n"
"        instance.loadConfig(buildTimeConfig, runTimeConfig); <5>\n"
"        log.infof(\"configureBeans, instance=%s\\n\", instance);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2450
#, fuzzy
msgid "Consume the `TestBeanBuildItem`s produced from the scanning build step."
msgstr "スキャンビルドステップで生成された `TestBeanBuildItem` を消費する。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2451
#, fuzzy
msgid "Consume the `BeanContainerBuildItem` to order this build step to run after the CDI bean container has been created."
msgstr "CDI Beanコンテナが作成された後にこのビルドステップを実行するために、 `BeanContainerBuildItem` を消費します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2452
#, fuzzy
msgid "Call the runtime recorder to record the bean interactions."
msgstr "ランタイムレコーダを呼び出して、ビーンのインタラクションを記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2453
#, fuzzy
msgid "Runtime recorder retrieves the bean using its type."
msgstr "ランタイムレコーダは、その型を使用してビーンを取得します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2454
#, fuzzy
msgid "Runtime recorder invokes the `IConfigConsumer#loadConfig(...)` method passing in the configuration objects with runtime information."
msgstr "ランタイム・レコーダは `IConfigConsumer#loadConfig(…)` メソッドを呼び出し、ランタイム情報を含む設定オブジェクトを渡します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2455
#, no-wrap
msgid "Manage Non-CDI Service"
msgstr "非CDIサービスの管理"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2457
#, fuzzy
msgid "A common purpose for an extension is to integrate a non-CDI aware service into the CDI based Quarkus runtime. Step 1 of this task is to load any configuration needed in a STATIC_INIT build step as we did in <<Parsing Config to Objects>>. Now we need to create an instance of the service using the configuration. Let's return to the `TestProcessor#parseServiceXmlConfig` method to see how this can be done."
msgstr "エクステンションの一般的な目的は、CDIを認識しないサービスをCDIベースのQuarkusランタイムに統合することです。このタスクのステップ1では、 link:#Parsing Config to Objects[[Parsing Config to Objects]] で行ったように、STATIC_INITビルドステップで必要な設定をロードします。次に、設定を使用してサービスのインスタンスを作成する必要があります。 `TestProcessor#parseServiceXmlConfig` メソッドに戻って、これがどのようにできるか見てみましょう。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2458
#, no-wrap
msgid "Creating a Non-CDI Service"
msgstr "非CDIサービスの作成"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2478
#, no-wrap
msgid ""
"// TestProcessor#parseServiceXmlConfig\n"
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\");\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);\n"
"            log.info(\"Loaded XmlConfig, creating service\");\n"
"            RuntimeValue<RuntimeXmlConfigService> service = recorder.initRuntimeService(config); //<1>\n"
"            serviceBuildItem = new RuntimeServiceBuildItem(service); //<3>\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2484
#, no-wrap
msgid ""
"// TestRecorder#initRuntimeService\n"
"    public RuntimeValue<RuntimeXmlConfigService> initRuntimeService(XmlConfig config) {\n"
"        RuntimeXmlConfigService service = new RuntimeXmlConfigService(config); //<2>\n"
"        return new RuntimeValue<>(service);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2488
#, no-wrap
msgid ""
"// RuntimeServiceBuildItem\n"
"    final public class RuntimeServiceBuildItem extends SimpleBuildItem {\n"
"    private RuntimeValue<RuntimeXmlConfigService> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2492
#, no-wrap
msgid ""
"    public RuntimeServiceBuildItem(RuntimeValue<RuntimeXmlConfigService> service) {\n"
"        this.service = service;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2497
#, no-wrap
msgid ""
"    public RuntimeValue<RuntimeXmlConfigService> getService() {\n"
"        return service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2499
#, fuzzy
msgid "Call into the runtime recorder to record the creation of the service."
msgstr "ランタイムレコーダーに呼び出して、サービスの作成を記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2500
#, fuzzy
msgid "Using the parsed `XmlConfig` instance, create an instance of `RuntimeXmlConfigService` and wrap it in a `RuntimeValue`. Use a `RuntimeValue` wrapper for non-interface objects that are non-proxiable."
msgstr "解析された `XmlConfig` インスタンスを使用して、 `RuntimeXmlConfigService` のインスタンスを作成し、それを `RuntimeValue` でラップします。 `RuntimeValue` ラッパーは、プロキシ不可能な非インターフェイス・オブジェクトに使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2501
#, fuzzy
msgid "Wrap the return service value in a `RuntimeServiceBuildItem` for use in a RUNTIME_INIT build step that will start the service."
msgstr "サービスを開始する RUNTIME_INIT ビルドステップで使用するために、サービスの戻り値を `RuntimeServiceBuildItem` でラップします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2502
#, no-wrap
msgid "Starting a Service"
msgstr "サービスの開始"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2504
#, fuzzy
msgid "Now that you have recorded the creation of a service during the build phase, you need to record how to start the service at runtime during booting. You do this with a RUNTIME_INIT build step as shown in the `TestProcessor#startRuntimeService` method."
msgstr "ビルドフェーズでのサービスの作成を記録したので、ブート時にランタイムでサービスを起動する方法を記録する必要があります。これを行うには、 `TestProcessor#startRuntimeService` メソッドに示されているように、RUNTIME_INIT ビルドステップを使用します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2505
#, no-wrap
msgid "Starting/Stopping a Non-CDI Service"
msgstr "非CDIサービスの開始/停止"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2521
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem , // <1>\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException { // <2>\n"
"        if (serviceBuildItem != null) {\n"
"            log.info(\"Registering service start\");\n"
"            recorder.startRuntimeService(shutdownContextBuildItem, serviceBuildItem.getService()); // <3>\n"
"        } else {\n"
"            log.info(\"No RuntimeServiceBuildItem seen, check config.xml\");\n"
"        }\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2529
#, no-wrap
msgid ""
"// TestRecorder#startRuntimeService\n"
"    public void startRuntimeService(ShutdownContext shutdownContext, RuntimeValue<RuntimeXmlConfigService> runtimeValue)\n"
"            throws IOException {\n"
"        RuntimeXmlConfigService service = runtimeValue.getValue();\n"
"        service.startService(); //<5>\n"
"        shutdownContext.addShutdownTask(service::stopService); //<6>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2531
msgid "We consume a ShutdownContextBuildItem to register the service shutdown."
msgstr "ShutdownContextBuildItemを消費してサービスのシャットダウンを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2532
#, fuzzy
msgid "We consume the previously initialized service captured in `RuntimeServiceBuildItem`."
msgstr "`RuntimeServiceBuildItem` で取得した初期化済みのサービスを消費します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2533
#, fuzzy
msgid "Call the runtime recorder to record the service start invocation."
msgstr "ランタイムレコーダーを呼び出して、サービス開始時の呼び出しを記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2534
#, fuzzy
msgid "Produce a `ServiceStartBuildItem` to indicate the startup of a service. See <<Startup and Shutdown Events>> for details."
msgstr "サービスの起動を示す `ServiceStartBuildItem` を生成します。詳細は link:#Startup and Shutdown Events[[起動・シャットダウンイベント]] を参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2535
#, fuzzy
msgid "Runtime recorder retrieves the service instance reference and calls its `startService` method."
msgstr "ランタイム レコーダはサービス インスタンス参照を取得し、その `startService` メソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2536
#, fuzzy
msgid "Runtime recorder registers an invocation of the service instance `stopService` method with the Quarkus `ShutdownContext`."
msgstr "ランタイムレコーダーは、サービスインスタンス `stopService` メソッドの呼び出しをQuarkus `ShutdownContext` ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2539
#, fuzzy
msgid "The code for the `RuntimeXmlConfigService` can be viewed here: {quarkus-blob-url}/core/test-extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"
msgstr "`RuntimeXmlConfigService` のコードはこちらで確認できます。{quarkus-blob-url}/core/test-extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2541
#, fuzzy
msgid "The testcase for validating that the `RuntimeXmlConfigService` has started can be found in the `testRuntimeXmlConfigService` test of `ConfiguredBeanTest` and `NativeImageIT`."
msgstr "`RuntimeXmlConfigService` が起動したことを検証するためのテストケースは、 `ConfiguredBeanTest` と `NativeImageIT` の `testRuntimeXmlConfigService` テストにあります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2542
#, no-wrap
msgid "Startup and Shutdown Events"
msgstr "スタートアップとシャットダウンのイベント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2545
#, fuzzy
msgid "The Quarkus container supports startup and shutdown lifecycle events to notify components of the container startup and shutdown. There are CDI events fired that components can observe are illustrated in this example:"
msgstr "Quarkusコンテナは、コンテナの起動とシャットダウンをコンポーネントに通知するための起動とシャットダウンのライフサイクルイベントをサポートしています。この例では、コンポーネントが観察できるCDIイベントが発生しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2546
#, fuzzy, no-wrap
msgid "Observing Container Startup"
msgstr "コンテナ起動の観察"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2551
#, no-wrap
msgid ""
"import io.quarkus.runtime.ShutdownEvent;\n"
"import io.quarkus.runtime.StartupEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2560
#, no-wrap
msgid ""
"public class SomeBean {\n"
"    /**\n"
"     * Called when the runtime has started\n"
"     * @param event\n"
"     */\n"
"    void onStart(@Observes StartupEvent event) { // <1>\n"
"        System.out.printf(\"onStart, event=%s%n\", event);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2569
#, no-wrap
msgid ""
"    /**\n"
"     * Called when the runtime is shutting down\n"
"     * @param event\n"
"    */\n"
"    void onStop(@Observes ShutdownEvent event) { // <2>\n"
"        System.out.printf(\"onStop, event=%s%n\", event);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2571
#, fuzzy
msgid "Observe a `StartupEvent` to be notified the runtime has started."
msgstr "ランタイムが開始されたことを通知するために `StartupEvent` を監視します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2572
#, fuzzy
msgid "Observe a `ShutdownEvent` to be notified when the runtime is going to shutdown."
msgstr "ランタイムがシャットダウンしようとしているときに通知されるように `ShutdownEvent` を監視します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2576
#, fuzzy
msgid "What is the relevance of startup and shutdown events for extension authors? We have already seen the use of a `ShutdownContext` to register a callback to perform shutdown tasks in the <<Starting a Service>> section. These shutdown tasks would be called after a `ShutdownEvent` had been sent."
msgstr "エクステンションの作者にとって、起動イベントとシャットダウンイベントの関連性とは何でしょうか？ link:#Starting a Service[サービスの開始]] セクションで、シャットダウンタスクを実行するためのコールバックを登録するために `ShutdownContext` を使用することをすでに見てきました。これらのシャットダウンタスクは `ShutdownEvent` が送信された後に呼び出されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2582
#, fuzzy
msgid "A `StartupEvent` is fired after all `io.quarkus.deployment.builditem.ServiceStartBuildItem` producers have been consumed.  The implication of this is that if an extension has services that application components would expect to have been started when they observe a `StartupEvent`, the build steps that invoke the runtime code to start those services needs to produce a `ServiceStartBuildItem` to ensure that the runtime code is run before the `StartupEvent` is sent. Recall that we saw the production of a `ServiceStartBuildItem` in the previous section, and it is repeated here for clarity:"
msgstr "`StartupEvent` は、すべての `io.quarkus.deployment.builditem.ServiceStartBuildItem` プロデューサが消費された後に発射されます。このことの意味するところは、エクステンションにアプリケーションコンポーネントが `StartupEvent` を観測したときに開始されたと予想されるサービスがある場合、それらのサービスを開始するためにランタイムコードを呼び出すビルドステップで `ServiceStartBuildItem` を生成して、 `StartupEvent` が送信される前にランタイムコードが実行されるようにする必要があるということです。 `ServiceStartBuildItem` の生成については前のセクションで見たことを思い出してください。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2583
#, fuzzy, no-wrap
msgid "Example of Producing a ServiceStartBuildItem"
msgstr "ServiceStartBuildItemの生成例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2594
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem,\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException {\n"
"...\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2596
#, fuzzy
msgid "Produce a `ServiceStartBuildItem` to indicate that this is a service starting step that needs to run before the `StartupEvent` is sent."
msgstr "`StartupEvent` を送信する前に実行する必要があるサービス開始ステップであることを示すために `ServiceStartBuildItem` を作成します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2597
#, fuzzy, no-wrap
msgid "Register Resources for Use in Native Image"
msgstr "ネイティブイメージで使用するためのリソースを登録する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2599
#, fuzzy
msgid "Not all configuration or resources can be consumed at build time. If you have classpath resources that the runtime needs to access, you need to inform the build phase that these resources need to be copied into the native image. This is done by producing one or more `NativeImageResourceBuildItem` or `NativeImageResourceBundleBuildItem` in the case of resource bundles. Examples of this are shown in this sample `registerNativeImageResources` build step:"
msgstr "ビルド時にすべてのコンフィギュレーションやリソースを消費できるわけではありません。ランタイムがアクセスする必要のあるクラスパスリソースがある場合、そのリソースをネイティブイメージにコピーする必要があることをビルドフェーズで伝える必要があります。これは、リソースバンドルの場合は1つまたは複数の `NativeImageResourceBuildItem` または `NativeImageResourceBundleBuildItem` を生成することによって行われます。この例を `registerNativeImageResources` ビルドステップのサンプルに示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2600
#, fuzzy, no-wrap
msgid "Registering Resources and ResourceBundles"
msgstr "リソースとリソースバンドルの登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2608
#, no-wrap
msgid ""
"public final class MyExtProcessor {\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBuildItem> resource;\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBundleBuildItem> resourceBundle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2612
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources() {\n"
"        resource.produce(new NativeImageResourceBuildItem(\"/security/runtime.keys\")); //<1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2615
#, no-wrap
msgid ""
"        resource.produce(new NativeImageResourceBuildItem(\n"
"                \"META-INF/my-descriptor.xml\")); //<2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2619
#, no-wrap
msgid ""
"        resourceBundle.produce(new NativeImageResourceBuildItem(\"javax.xml.bind.Messages\")); //<3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2621
#, fuzzy
msgid "Indicate that the /security/runtime.keys classpath resource should be copied into native image."
msgstr "クラスパスリソース/security/runtime.keysをネイティブイメージにコピーする必要があることを示しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2622
#, fuzzy
msgid "Indicate that the `META-INF/my-descriptor.xml` resource should be copied into native image"
msgstr "`META-INF/my-descriptor.xml` リソースをネイティブイメージにコピーすることを示す"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2623
#, fuzzy
msgid "Indicate that the \"javax.xml.bind.Messages\" resource bundle should be copied into native image."
msgstr "javax.xml.bind.Messages\"リソースバンドルをネイティブイメージにコピーすることを示します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2624
#, fuzzy, no-wrap
msgid "Service files"
msgstr "サービスファイル"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2628
#, fuzzy
msgid "If you are using `META-INF/services` files you need to register the files as resources so that your native image can find them, but you also need to register each listed class for reflection so they can be instantiated or inspected at run-time:"
msgstr "`META-INF/services` ファイルを使用している場合は、ネイティブイメージがファイルを見つけられるようにリソースとして登録する必要がありますが、リストされている各クラスを反映させるために登録する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2632
#: upstream/_guides/writing-extensions.adoc:2662
#: upstream/_guides/writing-extensions.adoc:2691
#, no-wrap
msgid "public final class MyExtProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2636
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> services) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2641
#, no-wrap
msgid ""
"        // find out all the implementation classes listed in the service files\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                          service);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2649
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be instantiated\n"
"        // in native-image at run-time\n"
"        services.produce(\n"
"            new ServiceProviderBuildItem(io.quarkus.SomeService.class.getName(),\n"
"                                         implementations.toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2655
#, fuzzy
msgid "`ServiceProviderBuildItem` takes a list of service implementation classes as parameters: if you are not reading them from the service file, make sure that they correspond to the service file contents because the service file will still be read and used at run-time. This is not a substitute for writing a service file."
msgstr "`ServiceProviderBuildItem` は、サービス実装クラスのリストをパラメータとして受け取ります。サービスファイルからそれらを読み込まない場合は、サービスファイルの内容と一致していることを確認してください。これはサービスファイルを書く代わりにはなりません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2658
#, fuzzy
msgid "This only registers the implementation classes for instantiation via reflection (you will not be able to inspect its fields and methods). If you need to do that, you can do it this way:"
msgstr "これは反射を介してインスタンス化のための実装クラスを登録するだけです(そのフィールドやメソッドを検査することはできません)。その必要がある場合は、このようにします。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2667
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources(BuildProducer<NativeImageResourceBuildItem> resource,\n"
"                                     BuildProducer<ReflectiveClassBuildItem> reflectionClasses) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2670
#, no-wrap
msgid ""
"        // register the service file so it is visible in native-image\n"
"        resource.produce(new NativeImageResourceBuildItem(service));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2680
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be inspected/instantiated\n"
"        // in native-image at run-time\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                          service);\n"
"        reflectionClasses.produce(\n"
"            new ReflectiveClassBuildItem(true, true, implementations.toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2684
#, fuzzy
msgid "While this is the easiest way to get your services running natively, it's less efficient than scanning the implementation classes at build time and generating code that registers them at static-init time instead of relying on reflection."
msgstr "これはサービスをネイティブに動作させる最も簡単な方法ですが、ビルド時に実装クラスをスキャンして、 リフレクションに頼るのではなくスタティックイット時にそれらを登録するコードを生成するよりも効率的ではありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2687
#, fuzzy
msgid "You can achieve that by adapting the previous build step to use a static-init recorder instead of registering classes for reflection:"
msgstr "反映のためにクラスを登録するのではなく、スタティックイニットレコーダーを使用するように前のビルドステップを適応させることで、これを実現することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2697
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(ExecutionTime.STATIC_INIT)\n"
"    void registerNativeImageResources(RecorderContext recorderContext,\n"
"                                     SomeServiceRecorder recorder) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService.class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2706
#, no-wrap
msgid ""
"        // read the implementation classes\n"
"        Collection<Class<? extends io.quarkus.SomeService>> implementationClasses = new LinkedHashSet<>();\n"
"        Set<String> implementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n"
"                                                                    service);\n"
"        for(String implementation : implementations) {\n"
"            implementationClasses.add((Class<? extends io.quarkus.SomeService>)\n"
"                recorderContext.classProxy(implementation));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2711
#, no-wrap
msgid ""
"        // produce a static-initializer with those classes\n"
"        recorder.configure(implementationClasses);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2714
#, no-wrap
msgid ""
"@Recorder\n"
"public class SomeServiceRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2719
#, no-wrap
msgid ""
"    public void configure(List<Class<? extends io.quarkus.SomeService>> implementations) {\n"
"        // configure our service statically\n"
"        SomeServiceProvider serviceProvider = SomeServiceProvider.instance();\n"
"        SomeServiceBuilder builder = serviceProvider.getSomeServiceBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2729
#, no-wrap
msgid ""
"        List<io.quarkus.SomeService> services = new ArrayList<>(implementations.size());\n"
"        // instantiate the service implementations\n"
"        for (Class<? extends io.quarkus.SomeService> implementationClass : implementations) {\n"
"            try {\n"
"                services.add(implementationClass.getConstructor().newInstance());\n"
"            } catch (Exception e) {\n"
"                throw new IllegalArgumentException(\"Unable to instantiate service \" + implementationClass, e);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2733
#, no-wrap
msgid ""
"        // build our service\n"
"        builder.withSomeServices(implementations.toArray(new io.quarkus.SomeService[0]));\n"
"        ServiceManager serviceManager = builder.build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2738
#, no-wrap
msgid ""
"        // register it\n"
"        serviceProvider.registerServiceManager(serviceManager, Thread.currentThread().getContextClassLoader());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2741
#, no-wrap
msgid "Object Substitution"
msgstr "オブジェクトの置換"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2743
#, fuzzy
msgid "Objects created during the build phase that are passed into the runtime need to have a default constructor in order for them to be created and configured at startup of the runtime from the build time state. If an object does not have a default constructor you will see an error similar to the following during generation of the augmented artifacts:"
msgstr "ビルドフェーズで作成されたオブジェクトでランタイムに渡されるものは、ランタイムの起動時にビルド時の状態から作成され設定されるため、デフォルトのコンストラクタを持っている必要があります。オブジェクトがデフォルト・コンストラクタを持たない場合、拡張成果物の生成時に以下のようなエラーが表示されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2744
#, fuzzy, no-wrap
msgid "DSAPublicKey Serialization Error"
msgstr "DSAPublicKey シリアル化エラー"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2753
#, no-wrap
msgid ""
"\t[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build threw an exception: java.lang.RuntimeException: Unable to serialize objects of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has no default constructor\n"
"\tat io.quarkus.builder.Execution.run(Execution.java:123)\n"
"\tat io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder.java:136)\n"
"\tat io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)\n"
"\tat io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)\n"
"\t... 36 more\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2756
#, fuzzy
msgid "There is a `io.quarkus.runtime.ObjectSubstitution` interface that can be implemented to tell Quarkus how to handle such classes. An example implementation for the `DSAPublicKey` is shown here:"
msgstr "このようなクラスをどのように扱うかをQuarkusに伝えるために実装できる `io.quarkus.runtime.ObjectSubstitution` インターフェイスがあります。 `DSAPublicKey` の実装例をここに示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2757
#, fuzzy, no-wrap
msgid "DSAPublicKeyObjectSubstitution Example"
msgstr "DSAPublicKeyObjectSubstitution の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2761
#, no-wrap
msgid "package io.quarkus.extest.runtime.subst;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2768
#, no-wrap
msgid ""
"import java.security.KeyFactory;\n"
"import java.security.NoSuchAlgorithmException;\n"
"import java.security.interfaces.DSAPublicKey;\n"
"import java.security.spec.InvalidKeySpecException;\n"
"import java.security.spec.X509EncodedKeySpec;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2770
#, no-wrap
msgid "import io.quarkus.runtime.ObjectSubstitution;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2781
#, no-wrap
msgid ""
"public class DSAPublicKeyObjectSubstitution implements ObjectSubstitution<DSAPublicKey, KeyProxy> {\n"
"    private static final Logger log = Logger.getLogger(\"DSAPublicKeyObjectSubstitution\");\n"
"    @Override\n"
"    public KeyProxy serialize(DSAPublicKey obj) { //<1>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.serialize\");\n"
"        byte[] encoded = obj.getEncoded();\n"
"        KeyProxy proxy = new KeyProxy();\n"
"        proxy.setContent(encoded);\n"
"        return proxy;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2791
#, no-wrap
msgid ""
"    @Override\n"
"    public DSAPublicKey deserialize(KeyProxy obj) { //<2>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.deserialize\");\n"
"        byte[] encoded = obj.getContent();\n"
"        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);\n"
"        DSAPublicKey dsaPublicKey = null;\n"
"        try {\n"
"            KeyFactory kf = KeyFactory.getInstance(\"DSA\");\n"
"            dsaPublicKey = (DSAPublicKey) kf.generatePublic(publicKeySpec);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2798
#, no-wrap
msgid ""
"        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return dsaPublicKey;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2800
#, fuzzy
msgid "The serialize method takes the object without a default constructor and creates a `KeyProxy` that contains the information necessary to recreate the `DSAPublicKey`."
msgstr "`DSAPublicKey` serialize メソッドは、デフォルトのコンストラクタを持たないオブジェクトを受け取り、 `KeyProxy` を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2801
#, fuzzy
msgid "The deserialize method uses the `KeyProxy` to recreate the `DSAPublicKey` from its encoded form using the key factory."
msgstr "deserialize メソッドは、 `KeyProxy` を使用して、キーファクトリーを使用してエンコードされた形式から `DSAPublicKey` を再作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2803
#, fuzzy
msgid "An extension registers this substitution by producing an `ObjectSubstitutionBuildItem` as shown in this `TestProcessor#loadDSAPublicKey` fragment:"
msgstr "エクステンションは、この `TestProcessor#loadDSAPublicKey` フラグメントに示すように `ObjectSubstitutionBuildItem` を生成することで、この置換を登録します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2804
#, no-wrap
msgid "Registering an Object Substitution"
msgstr "オブジェクト置換の登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2817
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    PublicKeyBuildItem loadDSAPublicKey(TestRecorder recorder,\n"
"            BuildProducer<ObjectSubstitutionBuildItem> substitutions) throws IOException, GeneralSecurityException {\n"
"...\n"
"        // Register how to serialize DSAPublicKey\n"
"        ObjectSubstitutionBuildItem.Holder<DSAPublicKey, KeyProxy> holder = new ObjectSubstitutionBuildItem.Holder(\n"
"                DSAPublicKey.class, KeyProxy.class, DSAPublicKeyObjectSubstitution.class);\n"
"        ObjectSubstitutionBuildItem keysub = new ObjectSubstitutionBuildItem(holder);\n"
"        substitutions.produce(keysub);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2821
#, no-wrap
msgid ""
"        log.info(\"loadDSAPublicKey run\");\n"
"        return new PublicKeyBuildItem(publicKey);\n"
"    }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2823
#, no-wrap
msgid "Replacing Classes in the Native Image"
msgstr "ネイティブイメージにおいてクラスを置換する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2825
msgid "The Graal SDK supports substitutions of classes in the native image. An example of how one could replace the `XmlConfig/XmlData` classes with versions that have no JAXB annotation dependencies is shown in these example classes:"
msgstr "Graal SDK は、ネイティブイメージ内のクラスの置換をサポートしています。 `XmlConfig/XmlData` のクラスを、JAXB アノテーションに依存しないバージョンのクラスに置き換える方法の例を以下に示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2826
#, no-wrap
msgid "Substitution of XmlConfig/XmlData Classes Example"
msgstr "XmlConfig/XmlDataクラスの置換例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2834
#, no-wrap
msgid ""
"package io.quarkus.extest.runtime.graal;\n"
"import java.util.Date;\n"
"import com.oracle.svm.core.annotate.Substitute;\n"
"import com.oracle.svm.core.annotate.TargetClass;\n"
"import io.quarkus.extest.runtime.config.XmlData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2838
#, no-wrap
msgid ""
"@TargetClass(XmlConfig.class)\n"
"@Substitute\n"
"public final class Target_XmlConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2845
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String address;\n"
"    @Substitute\n"
"    private int port;\n"
"    @Substitute\n"
"    private ArrayList<XData> dataList;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2850
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getAddress() {\n"
"        return address;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2855
#, no-wrap
msgid ""
"    @Substitute\n"
"    public int getPort() {\n"
"        return port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2860
#, no-wrap
msgid ""
"    @Substitute\n"
"    public ArrayList<XData> getDataList() {\n"
"        return dataList;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2871
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlConfig{\" +\n"
"                \"address='\" + address + '\\'' +\n"
"                \", port=\" + port +\n"
"                \", dataList=\" + dataList +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2875
#, no-wrap
msgid ""
"@TargetClass(XmlData.class)\n"
"@Substitute\n"
"public final class Target_XmlData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2882
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String name;\n"
"    @Substitute\n"
"    private String model;\n"
"    @Substitute\n"
"    private Date date;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2887
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2892
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getModel() {\n"
"        return model;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2897
#, no-wrap
msgid ""
"    @Substitute\n"
"    public Date getDate() {\n"
"        return date;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2908
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlData{\" +\n"
"                \"name='\" + name + '\\'' +\n"
"                \", model='\" + model + '\\'' +\n"
"                \", date='\" + date + '\\'' +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:2910
#, no-wrap
msgid "Configuration reference documentation"
msgstr "設定リファレンスドキュメント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2914
msgid "The configuration is an important part of each extension and therefore needs to be properly documented.  Each configuration property should have a proper Javadoc comment."
msgstr "設定は各エクステンションの重要な部分なので、適切に文書化する必要があります。それぞれの設定プロパティには、適切な Javadoc コメントが必要です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2917
msgid "While it is handy to have the documentation available when coding, this configuration documentation must also be available in the extension guides.  The Quarkus build automatically generates the configuration documentation for you based on the Javadoc comments but you need to explicitly include it in your guide."
msgstr "コーディング時にドキュメントを利用できるようにしておくと便利ですが、この設定ドキュメントはエクステンションガイドでも利用できるようにしておく必要があります。Quarkusのビルドでは、Javadocのコメントに基づいて設定ドキュメントが自動的に生成されますが、ガイドに明示的に含める必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2919
msgid "In this section, we will explain everything you need to know about the configuration reference documentation."
msgstr "このセクションでは、設定リファレンスドキュメントについて知っておくべきことをすべて説明します。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2920
#, no-wrap
msgid "Writing the documentation"
msgstr "ドキュメントの書き方"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2923
msgid "For each configuration property, you need to write some Javadoc explaining its purpose."
msgstr "それぞれの設定プロパティに対して、その目的を説明するJavadocを書く必要があります。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2927
msgid "Always make the first sentence meaningful and self-contained as it is included in the summary table."
msgstr "サマリーテーブルに記載されるので、必ず最初の一文に意味を持たせ、自己完結させましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2930
msgid "You can either use standard Javadoc comments or Asciidoc directly as a Javadoc comment."
msgstr "標準のJavadocコメントかAsciidocを直接Javadocコメントとして使うことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2934
msgid "We assume you are familiar with writing Javadoc comments so let's focus on our Asciidoc support.  While standard Javadoc comments are perfectly fine for simple documentation (recommended even), if you want to include tips, source code extracts, lists... Asciidoc comes in handy."
msgstr "ここでは、Javadocのコメントを書くことに慣れていることを前提としているので、Asciidocのサポートに焦点を当ててみましょう。標準的なJavadocのコメントは単純な文書化には完全に適していますが（推奨されています）、もしあなたがTipsやソースコードの抜粋、リストなどを含めたい場合は、Asciidocが便利です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2936
msgid "Here is a typical configuration property commented with Asciidoc:"
msgstr "以下は、Asciidocでコメントされた典型的な設定プロパティです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2953
#, no-wrap
msgid ""
"/**\n"
" * Class name of the Hibernate ORM dialect. The complete list of bundled dialects is available in the\n"
" * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/dialect/package-summary.html[Hibernate ORM JavaDoc].\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Not all the dialects are supported in GraalVM native executables: we currently provide driver extensions for PostgreSQL,\n"
" * MariaDB, Microsoft SQL Server and H2.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"@ConfigItem\n"
"public Optional<String> dialect;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2957
msgid "This is the simple case: you just have to write Asciidoc and mark the comment with the `@asciidoclet` tag.  This tag has two purposes: it is used as a marker for our generation tool but it is also used by the `javadoc` process for proper Javadoc generation."
msgstr "これは簡単なケースです: Asciidoc を書いて、コメントに `@asciidoclet` タグを付ければいいだけです。このタグには2つの目的があります: 生成ツールのマーカーとして使用されますが、 `javadoc` のプロセスで適切な Javadoc 生成のためにも使用されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2959
msgid "Now let's consider a more complicated example:"
msgstr "では、もう少し複雑な例を考えてみましょう。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2997
#, no-wrap
msgid ""
"// @formatter:off\n"
"/**\n"
" * Name of the file containing the SQL statements to execute when Hibernate ORM starts.\n"
" * Its default value differs depending on the Quarkus launch mode:\n"
" *\n"
" * * In dev and test modes, it defaults to `import.sql`.\n"
" *   Simply add an `import.sql` file in the root of your resources directory\n"
" *   and it will be picked up without having to set this property.\n"
" *   Pass `no-file` to force Hibernate ORM to ignore the SQL import file.\n"
" * * In production mode, it defaults to `no-file`.\n"
" *   It means Hibernate ORM won't try to execute any SQL import file by default.\n"
" *   Pass an explicit value to force Hibernate ORM to execute the SQL import file.\n"
" *\n"
" * If you need different SQL statements between dev mode, test (`@QuarkusTest`) and in production, use Quarkus\n"
" * https://quarkus.io/guides/config#configuration-profiles[configuration profiles facility].\n"
" *\n"
" * [source,property]\n"
" * .application.properties\n"
" * ----\n"
" * %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql\n"
" * %test.quarkus.hibernate-orm.sql-load-script = import-test.sql\n"
" * %prod.quarkus.hibernate-orm.sql-load-script = no-file\n"
" * ----\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Quarkus supports `.sql` file with SQL statements or comments spread over multiple lines.\n"
" * Each SQL statement must be terminated by a semicolon.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"// @formatter:on\n"
"@ConfigItem\n"
"public Optional<String> sqlLoadScript;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3000
msgid "A few comments on this one:"
msgstr "これについてのコメントをいくつか。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3006
msgid "Every time you will need the indentation to be respected in the Javadoc comment (think list items spread on multiple lines or indented source code), you will need to disable temporarily the automatic Eclipse formatter (this, even if you don't use Eclipse as the formatter is included in our build).  To do so, use the `// @formatter:off`/`// @formatter:on` markers.  Note the fact that they are separate comments and there is a space after the `//` marker. This is required."
msgstr "Javadocのコメントでインデントを尊重する必要がある場合（複数行にまたがるリスト項目やインデントされたソースコードを考えてみてください）には、Eclipseの自動フォーマッタを一時的に無効にする必要があります（これはEclipseを使用していない場合でも同様です。私たちのビルドにはフォーマッタが含まれている為です）。これを行うには、 `// @formatter:off` / `// @formatter:on` マーカーを使用してください。これらは別々のコメントであり、 `//` マーカーの後にスペースがあることに注意してください。これは必須です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3007
msgid "As you can see, you can use the full power of Asciidoctor (except for the limitation below)"
msgstr "見ての通り、Asciidoctorのフルパワーが使えます（以下の制限を除く）"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:3012
msgid "You cannot use open blocks (`--`) in your Asciidoctor documentation.  All the other types of blocks (source, admonitions...) are supported."
msgstr "Asciidoctor のドキュメントでは、オープンブロック ( `--` ) を使用することはできません。他のすべてのタイプのブロック (ソース、アドミッション...) がサポートされています。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:3019
msgid "By default, the doc generator will use the hyphenated field name as the key of a `java.util.Map` configuration item.  To override this default and have a user friendly key (independent of implementation details), you may use the `io.quarkus.runtime.annotations.ConfigDocMapKey` annotation.  See the following example,"
msgstr "デフォルトでは、doc ジェネレータは `java.util.Map` 設定項目のキーとしてハイフンで囲まれたフィールド名を使用します。このデフォルトを上書きして（実装の詳細とは無関係に）ユーザーフレンドリーなキーを持つためには、 `io.quarkus.runtime.annotations.ConfigDocMapKey` アノテーションを使用することができます。以下の例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3030
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Namespace configuration.\n"
"     */\n"
"    @ConfigItem(name = ConfigItem.PARENT)\n"
"    @ConfigDocMapKey(\"cache-name\") <1>\n"
"    Map<String, CaffeineNamespaceConfig> namespace;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3033
msgid "This will generate a configuration map key named `quarkus.some.\"cache-name\"` instead of `quarkus.some.\"namespace\"`."
msgstr "これにより、 `quarkus.some.\"namespace\"` の代わりに `quarkus.some.\"cache-name\"` という名前の設定マップキーが生成されます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:3035
#, no-wrap
msgid "Writing section documentation"
msgstr "セクションのドキュメントを書く"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:3039
msgid "If you wish to generate configuration section of a given `@ConfigGroup`, Quarkus has got you covered with the `@ConfigDocSection` annotation.  See the code example below:"
msgstr "ある `@ConfigGroup` の設定セクションを生成したい場合は、 `@ConfigDocSection` アノテーションで対応できます。以下のコード例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3048
#, no-wrap
msgid ""
"/**\n"
"* Config group related configuration.\n"
"* Amazing introduction here\n"
"*/\n"
"@ConfigItem\n"
"@ConfigDocSection <1>\n"
"public ConfigGroupConfig configGroup;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3053
#, fuzzy
msgid "This will add a section documentation for the `configGroup` config item in the generated documentation.  Section's title and introduction will be derived from the javadoc of the configuration item. The first sentence from the javadoc is considered as the section title and the remaining sentences used as section introduction.  You can also use the `@asciidoclet` tag as shown above."
msgstr "これは、生成されたドキュメントの中に `configGroup` 設定項目のためのセクションドキュメントを追加します。セクションのタイトルと導入は、設定項目の javadoc から派生します。javadoc の最初の文がセクションのタイトルとみなされ、残りの文がセクションの紹介文として使用されます。上記のように `@asciidoclet` タグを使用することもできます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:3054
#, no-wrap
msgid "Generating the documentation"
msgstr "ドキュメントの生成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3057
msgid "Generating the documentation is easy:"
msgstr "ドキュメントの生成は簡単です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3059
msgid "Running `./mvnw clean install -DskipTests -DskipITs` will do."
msgstr "`./mvnw clean install -DskipTests -DskipITs` を実行すればOKです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3060
msgid "You can either do it globally or in a specific extension directory (e.g. `extensions/mailer`)."
msgstr "グローバルに行うことも、特定のエクステンションディレクトリ ( `extensions/mailer` など) で行うこともできます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3062
msgid "The documentation is generated in the global `target/asciidoc/generated/config/` located at the root of the project."
msgstr "ドキュメントはプロジェクトのルートにあるグローバル `target/asciidoc/generated/config/` で生成されます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:3063
#, no-wrap
msgid "Including the documentation in the extension guide"
msgstr "エクステンションガイドにドキュメントを含める"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3066
msgid "Now that you have generated the configuration reference documentation for your extension, you need to include it in your guide (and review it)."
msgstr "これで、あなたのエクステンションの設定参照ドキュメントが生成されたので、それをガイドに含める必要があります (そして、それをレビューする必要があります)。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3068
msgid "This is simple, include the generated documentation in your guide:"
msgstr "これは簡単で、ガイドで生成されたドキュメントを含めます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3072
#, no-wrap
msgid "\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3075
msgid "If you are interested in including the generated documentation for the config group, you can use the include statement below"
msgstr "設定グループのために生成されたドキュメントを含めたい場合は、以下のinclude文を使用することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3078
#, no-wrap
msgid "\\include::{generated-dir}/config/hyphenated-config-group-class-name-with-runtime-or-deployment-namespace-replaced-by-config-group-namespace.adoc[opts=optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3081
msgid "For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` configuration group will be generated in a file named `quarkus-vertx-http-config-group-form-auth-config.adoc`."
msgstr "例えば、 `io.quarkus.vertx.http.runtime.FormAuthConfig` 設定グループは `quarkus-vertx-http-config-group-form-auth-config.adoc` という名前のファイルに生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3084
msgid "A few recommendations:"
msgstr "幾つかの推奨事項:"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3086
msgid "`opts=optional` is mandatory as we don't want the build to fail if only part of the configuration documentation has been generated"
msgstr "`opts=optional` は、設定ドキュメントの一部しか生成されていない場合にビルドを失敗させたくないので必須です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3089
msgid "The documentation is generated with a title level of 2 (i.e. `==`).  You usually need to adjust it.  It can be done with `leveloffset=+N`."
msgstr "ドキュメントはタイトルレベルが2(例: `==` )で生成されます。通常はこれを調整する必要があります。これは `leveloffset=+N` で行うことが可能です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3092
#, fuzzy
msgid "It is not recommended to include the whole configuration documentation in the middle of your guide as it's heavy.  If you have an `application.properties` extract with your configuration, just do as follows."
msgstr "ガイドの途中に設定ドキュメント全体を入れるのは重いのでお勧めできません。 `application.properties` のエキスが設定と一緒に入っている場合は、以下のようにすればいいだけです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3094
#, fuzzy
msgid "First, include a tip just below your `application.properties` extract:"
msgstr "まず、 `application.properties` のエキスのすぐ下にチップを入れます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3099
#, no-wrap
msgid ""
"[TIP]\n"
"For more information about the extension configuration please refer to the <<configuration-reference, Configuration Reference>>.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3102
msgid "Then, at the end of your documentation, include the extensive documentation:"
msgstr "そして、文書の最後には、エクステンションのドキュメントをインクルードしてください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3106
#, no-wrap
msgid "[[configuration-reference]]\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3106
#, no-wrap
msgid "Configuration Reference"
msgstr "設定リファレンス"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:3109
msgid "\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3112
msgid "Finally, generate the documentation and check it out."
msgstr "最後にドキュメントを生成して確認します。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:3113
#, no-wrap
msgid "Continuous testing of your extension"
msgstr "エクステンションの継続的なテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3118
#, fuzzy
#| msgid "In order to make it easy for extension authors to test their extensions daily against the latest snapshot of Quarkus, Quarkus has introduced the notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README.adoc[README] has all the details on how to set up a GitHub Actions job to take advantage of this capability, while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides an overview of what the process looks like."
msgid "In order to make it easy for extension authors to test their extensions daily against the latest snapshot of Quarkus, Quarkus has introduced the notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/main/README.adoc[README] has all the details on how to set up a GitHub Actions job to take advantage of this capability, while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides an overview of what the process looks like."
msgstr "エクステンションの作者が、Quarkusの最新のスナップショットに対して自分のエクステンションを毎日簡単にテストできるようにするために、QuarkusはエコシステムCIという概念を導入しました。Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README.adoc[README] には、この機能を利用するためのGitHub Actionsジョブの設定方法の詳細がすべて記載されています。"

#, fuzzy
#~ msgid "`BuildStep.applicationArchiveMarkers()` is deprecated and will be removed at some point post Quarkus 1.1. Extensions are encouraged to use `io.quarkus.deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem` instead."
#~ msgstr "`BuildStep.applicationArchiveMarkers()` は非推奨で、Quarkus 1.1以降のある時点で削除される予定です。エクステンションは、代わりに `io.quarkus.deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem` を使用することをお勧めします。"

#~ msgid "Maven setup"
#~ msgstr "Mavenのセットアップ"

#, fuzzy
#~ msgid "Your deployment time module should depend on `io.quarkus:quarkus-core-deployment`, your runtime artifact, and possibly the deployment artifacts of other Quarkus modules if you want to use functionality provided by them.  You will also need to configure the `maven-compiler-plugin` to detect the `quarkus-extension-processor` annotation processor."
#~ msgstr "デプロイメントタイムモジュールは、 `io.quarkus:quarkus-core-deployment` 、ランタイムアーティファクト、および他のQuarkusモジュールが提供する機能を使用する場合は、他のQuarkusモジュールのデプロイメントアーティファクトに依存する必要があります。また、 `quarkus-extension-processor` アノテーションプロセッサを検出するように `maven-compiler-plugin` を設定する必要があります。"

#~ msgid "Dump the Generated Classes to the File System"
#~ msgstr "生成されたクラスをファイルシステムにダンプする"

#~ msgid "During the augmentation phase Quarkus extensions generate new and modify existing classes for various purposes.  Sometimes you need to inspect the generated bytecode to debug or understand an issue.  There are three system properties that allow you to dump the classes to the filesystem:"
#~ msgstr "拡張フェーズでは、Quarkusのエクステンションは、さまざまな目的のために既存のクラスを新規に生成したり変更したりします。デバッグや問題の理解のために、生成されたバイトコードを検査する必要がある場合もあります。クラスをファイルシステムにダンプするための3つのシステムプロパティがあります:"

#~ msgid "The `create-extension` mojo of `io.quarkus:quarkus-maven-plugin` can be used to generate stubs of Maven modules needed for implementing a new Quarkus extension."
#~ msgstr "`io.quarkus:quarkus-maven-plugin` の `create-extension` mojo は、新しい Quarkus エクステンションの実装に必要な Maven モジュールのスタブを生成するために使用できます。"

#, fuzzy
#~ msgid "This mojo can be currently used only for adding extensions to an established source tree hosting multiple extensions in one subdirectory, such as https://github.com/quarkusio/quarkus[Quarkus] or https://github.com/apache/camel-quarkus[Camel Quarkus]. Creating extension projects from scratch is not supported yet."
#~ msgstr "このモジョは、現在のところ、 link:https://github.com/quarkusio/quarkus[Quarkus] や link:https://github.com/apache/camel-quarkus[Camel Quarkus] のように、1つのサブディレクトリに複数のエクステンションをホストする確立されたソースツリーにエクステンションを追加するためにのみ使用できます。ゼロからエクステンションプロジェクトを作成することはまだサポートされていません。"

#, fuzzy
#~ msgid "A Maven build performed immediately after generating the modules should fail due to a `fail()` assertion in one of the test classes."
#~ msgstr "モジュールを生成した直後に実行された Maven ビルドは、テストクラスの 1 つに `fail()` アサーションがあるために失敗します。"

#, fuzzy
#~ msgid "Note that the parameters of the mojo that will be constant for all the extensions added to this source tree are configured in `extensions/pom.xml` so that they do not need to be passed on the command line each time a new extension is added:"
#~ msgstr "このソースツリーに追加されたすべてのエクステンションに対して一定となる mojo のパラメータは `extensions/pom.xml` で設定されているため、新しいエクステンションが追加されるたびにコマンドラインで渡す必要がないことに注意してください。"
