# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2021-04-07 19:11+0000\n"
"PO-Revision-Date: 2021-02-18 21:59+0900\n"
"Last-Translator: Nobuhiro Sue <nobuhiro.sue@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka.adoc:6
#, no-wrap
msgid "Quarkus - Using Apache Kafka with Reactive Messaging"
msgstr "Quarkus - Apache Kafka をリアクティブメッセージングで使用する"

#. type: Plain text
#: upstream/_guides/kafka.adoc:11
#, fuzzy
#| msgid "This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with Apache Kafka."
msgid "This guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka."
msgstr "このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging 利用して Apache Kafka とやりとりする仕組みを説明します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:12
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/kafka.adoc:15
msgid "To complete this guide, you need:"
msgstr "このガイドには、以下が必要です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:17
msgid "less than 15 minutes"
msgstr "15 分未満の時間"

#. type: Plain text
#: upstream/_guides/kafka.adoc:18
msgid "an IDE"
msgstr "IDE"

#. type: Plain text
#: upstream/_guides/kafka.adoc:19
msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 1.8+ がインストールされ、`JAVA_HOME` が適切に設定されていること"

#. type: Plain text
#: upstream/_guides/kafka.adoc:20
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/kafka.adoc:21
msgid "A running Kafka cluster, or Docker Compose to start a development cluster"
msgstr "実行中の Kafka クラスター、または開発クラスターを開始するための Docker Compose"

#. type: Plain text
#: upstream/_guides/kafka.adoc:22
msgid "GraalVM installed if you want to run in native mode."
msgstr "ネイティブモードで実行する場合は、GraalVM がインストールされていること"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka.adoc:23 upstream/_guides/kafka.adoc:31
#, no-wrap
msgid "Architecture"
msgstr "アーキテクチャー"

#. type: Plain text
#: upstream/_guides/kafka.adoc:30
msgid "In this guide, we are going to generate (random) prices in one component.  These prices are written in a Kafka topic (`prices`).  A second component reads from the `prices` Kafka topic and apply some magic conversion to the price.  The result is sent to an in-memory stream consumed by a JAX-RS resource.  The data is sent to a browser using server-sent events."
msgstr "このガイドでは、1 つのコンポーネントでランダムな価格 (price) を生成します。これらの価格は、Kafka トピック (`prices`) に書かれています。2 番目のコンポーネントは `prices` Kafka トピックから読み込み、この価格に変換を適用します。その結果は、JAX-RS リソースによって消費されるインメモリーストリームに送られます。データは、サーバーから送信されたイベントを使用してブラウザーに送信されます。"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:31
#, no-wrap
msgid "kafka-guide-architecture.png"
msgstr "kafka-guide-architecture.png"

#. type: Title ==
#: upstream/_guides/kafka.adoc:33
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/kafka.adoc:37
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "次のセクションで紹介する手順に沿って、段階的にアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:39
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "Git レポジトリーをクローンするか `git clone {quickstarts-clone-url}`、{quickstarts-archive-url}[アーカイブ] をダウンロードします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:41
msgid "The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory]."
msgstr "このソリューションは `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[ディレクトリ] にあります。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:42
#, no-wrap
msgid "Creating the Maven Project"
msgstr "Maven プロジェクトの作成"

#. type: Plain text
#: upstream/_guides/kafka.adoc:45
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:55
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-quickstart \\\n"
"    -DclassName=\"org.acme.kafka.PriceResource\" \\\n"
"    -Dpath=\"/prices\" \\\n"
"    -Dextensions=\"resteasy,smallrye-reactive-messaging-kafka\"\n"
"cd kafka-quickstart\n"
msgstr ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-quickstart \\\n"
"    -DclassName=\"org.acme.kafka.PriceResource\" \\\n"
"    -Dpath=\"/prices\" \\\n"
"    -Dextensions=\"resteasy,smallrye-reactive-messaging-kafka\"\n"
"cd kafka-quickstart\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:58
msgid "This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions."
msgstr "このコマンドにより、Maven プロジェクトが作成され、Reactive Messaging と Kafka コネクターエクステンションをインポートします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:61
msgid "If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:"
msgstr "すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行して、プロジェクトに `smallrye-reactive-messaging-kafka` エクステンションを追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:65
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"smallrye-reactive-messaging-kafka\"\n"
msgstr "./mvnw quarkus:add-extension -Dextensions=\"smallrye-reactive-messaging-kafka\"\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:68
msgid "This will add the following to your `pom.xml`:"
msgstr "これにより、`pom.xml` に以下が追加されます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:75
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"

#. type: Title ==
#: upstream/_guides/kafka.adoc:77
#, no-wrap
msgid "Starting Kafka"
msgstr "Kafka の起動"

#. type: Plain text
#: upstream/_guides/kafka.adoc:81
msgid "Then, we need a Kafka cluster.  You can follow the instructions from the https://kafka.apache.org/quickstart[Apache Kafka web site] or create a `docker-compose.yaml` file with the following content:"
msgstr "次に、Kafka クラスターが必要です。https://kafka.apache.org/quickstart[Apache Kafka の Web サイト] の指示に従うか、以下の内容の `docker-compose.yaml` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:85
#, no-wrap
msgid "version: '2'\n"
msgstr "version: '2'\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:87
#, no-wrap
msgid "services:\n"
msgstr "services:\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:98
#, no-wrap
msgid ""
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
msgstr ""
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:114
#, no-wrap
msgid ""
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
msgstr ""
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:117
msgid "Once created, run `docker-compose up`."
msgstr "作成したら、`docker-compose up` を実行します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:119
msgid "This is a development cluster, do not use in production."
msgstr "これは開発クラスターであり、本番では使用しないでください。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:120
#, no-wrap
msgid "The price generator"
msgstr "価格ジェネレーター"

#. type: Plain text
#: upstream/_guides/kafka.adoc:123
msgid "Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the following content:"
msgstr "以下の内容の `src/main/java/org/acme/kafka/PriceGenerator.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:127 upstream/_guides/kafka.adoc:168
#: upstream/_guides/kafka.adoc:211
#, no-wrap
msgid "package org.acme.kafka;\n"
msgstr "package org.acme.kafka;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:130
#, no-wrap
msgid ""
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""
"import java.time.Duration;\n"
"import java.util.Random;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:132 upstream/_guides/kafka.adoc:175
#: upstream/_guides/kafka.adoc:473
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr "import javax.enterprise.context.ApplicationScoped;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:135
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:142
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random prices every 5 seconds.\n"
" * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceGenerator {\n"
msgstr ""
"/**\n"
" * A bean producing random prices every 5 seconds.\n"
" * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceGenerator {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:144
#, no-wrap
msgid "    private Random random = new Random();\n"
msgstr "    private Random random = new Random();\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:151
#, no-wrap
msgid ""
"    @Outgoing(\"generated-price\")                        // <1>\n"
"    public Multi<Integer> generate() {                  // <2>\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
"                .onOverflow().drop()\n"
"                .map(tick -> random.nextInt(100));\n"
"    }\n"
msgstr ""
"    @Outgoing(\"generated-price\")                        // <1>\n"
"    public Multi<Integer> generate() {                  // <2>\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
"                .onOverflow().drop()\n"
"                .map(tick -> random.nextInt(100));\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:153 upstream/_guides/kafka.adoc:194
#: upstream/_guides/kafka.adoc:492 upstream/_guides/kafka.adoc:662
#: upstream/_guides/kafka.adoc:759
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:155
msgid "Instruct Reactive Messaging to dispatch the items from returned stream to `generated-price`."
msgstr "返されたストリームから `generated-price` にアイテムをディスパッチするように Reactive Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:156
msgid "The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ every 5 seconds."
msgstr "このメソッドは、5 秒ごとにランダムな _価格_ を生成する Mutiny _ストリーム_ (`Multi`) を返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:159
msgid "The method returns a _Reactive Stream_. The generated items are sent to the stream named `generated-price`.  This stream is mapped to Kafka using the `application.properties` file that we will create soon."
msgstr "このメソッドは、_Reactive Stream_ を返します。生成されたアイテムは `generated-price` という名前のストリームに送られます。このストリームは、次に作成する `application.properties` ファイルを使用して Kafka にマッピングされます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:160
#, no-wrap
msgid "The price converter"
msgstr "価格 (price) コンバーター"

#. type: Plain text
#: upstream/_guides/kafka.adoc:164
msgid "The price converter reads the prices from Kafka, and transforms them.  Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the following content:"
msgstr "価格コンバーターは、Kafka から価格を読み込んで変換します。以下の内容の `src/main/java/org/acme/kafka/PriceConverter.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:173
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:182
#, no-wrap
msgid ""
"/**\n"
" * A bean consuming data from the \"prices\" Kafka topic and applying some conversion.\n"
" * The result is pushed to the \"my-data-stream\" stream which is an in-memory stream.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConverter {\n"
msgstr ""
"/**\n"
" * A bean consuming data from the \"prices\" Kafka topic and applying some conversion.\n"
" * The result is pushed to the \"my-data-stream\" stream which is an in-memory stream.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConverter {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:184 upstream/_guides/kafka.adoc:482
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr "    private static final double CONVERSION_RATE = 0.88;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:192
#, no-wrap
msgid ""
"    @Incoming(\"prices\")                                     // <1>\n"
"    @Outgoing(\"my-data-stream\")                             // <2>\n"
"    @Broadcast                                              // <3>\n"
"    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // <4>\n"
"    public double process(int priceInUsd) {\n"
"        return priceInUsd * CONVERSION_RATE;\n"
"    }\n"
msgstr ""
"    @Incoming(\"prices\")                                     // <1>\n"
"    @Outgoing(\"my-data-stream\")                             // <2>\n"
"    @Broadcast                                              // <3>\n"
"    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // <4>\n"
"    public double process(int priceInUsd) {\n"
"        return priceInUsd * CONVERSION_RATE;\n"
"    }\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:196
msgid "Indicates that the method consumes the items from the `prices` topic"
msgstr "このメソッドが `prices` トピックのアイテムを消費することを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:197
msgid "Indicates that the objects returned by the method are sent to the `my-data-stream` stream"
msgstr "このメソッドによって返されたオブジェクトが `my-data-stream` ストリームに送られることを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:198
msgid "Indicates that the item are dispatched to all _subscribers_"
msgstr "アイテムがすべての _サブスクライバー_ に発送されていることを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:199
msgid "Make sure to acknowledge the incoming message"
msgstr "着信メッセージの受け取りを確認してください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:202
msgid "The `process` method is called for every Kafka _record_ from the `prices` topic (configured in the application configuration).  Every result is sent to the `my-data-stream` in-memory stream."
msgstr "`process` メソッドは、`prices` トピック (アプリケーションコンフィグレーションの中で設定) からの Kafka _record_ ごとに呼び出されます。すべての結果は `my-data-stream` インメモリーストリームに送信されます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:203
#, no-wrap
msgid "The price resource"
msgstr "価格リソース"

#. type: Plain text
#: upstream/_guides/kafka.adoc:207
msgid "Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/java/org/acme/kafka/PriceResource.java` file with the following content:"
msgstr "最後に、ストリームを JAX-RSリソース にバインドしてみましょう。以下の内容の `src/main/java/org/acme/kafka/PriceResource.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:214 upstream/_guides/kafka.adoc:608
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
"import org.reactivestreams.Publisher;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:221 upstream/_guides/kafka.adoc:615
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"
msgstr ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:227
#, no-wrap
msgid ""
"/**\n"
" * A simple resource retrieving the in-memory \"my-data-stream\" and sending the items as server-sent events.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""
"/**\n"
" * A simple resource retrieving the in-memory \"my-data-stream\" and sending the items as server-sent events.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:230
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"my-data-stream\") Publisher<Double> prices; // <1>\n"
msgstr ""
"    @Inject\n"
"    @Channel(\"my-data-stream\") Publisher<Double> prices; // <1>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:239
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS) // <2>\n"
"    @SseElementType(\"text/plain\") // <3>\n"
"    public Publisher<Double> stream() { // <4>\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS) // <2>\n"
"    @SseElementType(\"text/plain\") // <3>\n"
"    public Publisher<Double> stream() { // <4>\n"
"        return prices;\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:241
msgid "Injects the `my-data-stream` channel using the `@Channel` qualifier"
msgstr "`@Channel` の修飾子を使って `my-data-stream` チャンネルを注入します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:242
msgid "Indicates that the content is sent using `Server Sent Events`"
msgstr "`Server Sent Events` を使用してコンテンツが送信されたことを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:243
msgid "Indicates that the data contained within the server sent events is of type `text/plain`"
msgstr "サーバーから送信されたイベントに含まれるデータのタイプが `text/plain` であることを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:244
msgid "Returns the stream (_Reactive Stream_)"
msgstr "ストリーム (_Reactive Stream_) を返します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:245
#, no-wrap
msgid "Configuring the Kafka connector"
msgstr "Kafka コネクターの設定"

#. type: Plain text
#: upstream/_guides/kafka.adoc:249
msgid "We need to configure the Kafka connector. This is done in the `application.properties` file.  The keys are structured as follows:"
msgstr "Kafka コネクターを設定する必要があります。これは `application.properties` ファイルで行います。このキーは以下のような構造になっています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:251
msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgstr "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:253
msgid "The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:"
msgstr "`channel-name` セグメントは、`@Incoming` および `@Outgoing` アノテーションで設定された値と一致する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:255
msgid "`generated-price` -> sink in which we write the prices"
msgstr "`generated-price` -> sink (価格の書き込み先)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:256
msgid "`prices` -> source in which we read the prices"
msgstr "`prices` -> source (価格の読み取り先)"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:261
#, no-wrap
msgid ""
"# Configure the SmallRye Kafka connector\n"
"kafka.bootstrap.servers=localhost:9092\n"
msgstr ""
"# Configure the SmallRye Kafka connector\n"
"kafka.bootstrap.servers=localhost:9092\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:267
#, fuzzy, no-wrap
#| msgid ""
#| "# Configure the Kafka sink (we write to it)\n"
#| "mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
#| "mp.messaging.outgoing.generated-price.topic=prices\n"
#| "mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
"mp.messaging.outgoing.generated-price.topic=prices\n"
"mp.messaging.incoming.prices.health-readiness-enabled=false\n"
"mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"
msgstr ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
"mp.messaging.outgoing.generated-price.topic=prices\n"
"mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:271
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka\n"
"mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer\n"
msgstr ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka\n"
"mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:274
msgid "More details about this configuration is available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation. These properties are configured with the prefix `kafka`."
msgstr "この設定の詳細は、Kafka ドキュメントの link:https://kafka.apache.org/documentation/#producerconfigs[Producer 設定] と link:https://kafka.apache.org/documentation/#consumerconfigs[Consumer 設定] のセクションを参照してください。これらのプロパティは、`kafka` という接頭辞で設定されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:276
msgid "What about `my-data-stream`? This is an in-memory stream, not connected to a message broker."
msgstr "`my-data-stream` はどうでしょうか? これはインメモリストリームであり、メッセージブローカーには接続されていません。"

#. type: Block title
#: upstream/_guides/kafka.adoc:278
#, fuzzy, no-wrap
msgid "What is \"mp.messaging.incoming.prices.health-readiness-enabled=false\"?"
msgstr "mp.messaging.incoming.prices.health-readiness-enabled=false」とは何ですか？"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:285
#, fuzzy
msgid "The `health-readiness-enabled` disables the readiness health check.  By default, it verifies that there is an active connection with the broker.  In our case, the connection only happens when we get the first consumer.  This is because the stream is consumed as an SSE, waiting lazily for the first connection to trigger the whole stream.  So, if you are running in an environment only routing traffic to containers that are _ready_ (such as Kubernetes), it would not send traffic to your application, which, as a consequence, will never connect to Kafka and pass the readiness check."
msgstr "`health-readiness-enabled` は、レディネス・ヘルスチェックを無効にします。デフォルトでは、ブローカーとのアクティブな接続があるかどうかを検証します。今回のケースでは、最初のコンシューマを取得したときにのみ接続が発生します。これは、ストリームがSSEとして消費され、最初の接続がストリーム全体のトリガーとなるのをのんびりと待っているからです。そのため、 _準備_ができているコンテナにのみトラフィックをルーティングする環境（Kubernetesなど）で実行している場合、アプリケーションにトラフィックを送らないことになり、結果としてKafkaに接続して準備状況のチェックを通過することはありません。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:287
#, fuzzy
msgid "More details about health reporting is given in <<kafka-health-check>>."
msgstr "ヘルスレポートについての詳細は、 link:#kafka-health-check[[kafka-health-check]]に記載されています。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:289
#, no-wrap
msgid "The HTML page"
msgstr "HTML ページ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:292
msgid "Final touch, the HTML page reading the converted prices using SSE."
msgstr "最後に、SSE を使って変換された価格を読み込む HTML ページです。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:294
msgid "Create the `src/main/resources/META-INF/resources/prices.html` file, with the following content:"
msgstr "以下の内容の `src/main/resources/META-INF/resources/prices.html` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:302
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"<head>\n"
"    <meta charset=\"UTF-8\">\n"
"    <title>Prices</title>\n"
msgstr ""
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"<head>\n"
"    <meta charset=\"UTF-8\">\n"
"    <title>Prices</title>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:310
#, no-wrap
msgid ""
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css\">\n"
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css\">\n"
"</head>\n"
"<body>\n"
"<div class=\"container\">\n"
msgstr ""
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css\">\n"
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css\">\n"
"</head>\n"
"<body>\n"
"<div class=\"container\">\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:325
#, no-wrap
msgid ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
"<script>\n"
"    var source = new EventSource(\"/prices/stream\");\n"
"    source.onmessage = function (event) {\n"
"        document.getElementById(\"content\").innerHTML = event.data;\n"
"    };\n"
"</script>\n"
"</html>\n"
msgstr ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
"<script>\n"
"    var source = new EventSource(\"/prices/stream\");\n"
"    source.onmessage = function (event) {\n"
"        document.getElementById(\"content\").innerHTML = event.data;\n"
"    };\n"
"</script>\n"
"</html>\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:328
msgid "Nothing spectacular here. On each received price, it updates the page."
msgstr "特に目を見張るようなものは何もありません。受信した価格ごとに、ページが更新されます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:329
#, no-wrap
msgid "Get it running"
msgstr "実行"

#. type: Plain text
#: upstream/_guides/kafka.adoc:333
msgid "If you followed the instructions, you should have Kafka running.  Then, you just need to run the application using:"
msgstr "指示に従えば、Kafka が起動しているはずです。あとは、以下でアプリケーションを実行するだけです。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:337
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr "./mvnw quarkus:dev\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:340
msgid "Open `http://localhost:8080/prices.html` in your browser."
msgstr "ブラウザーで `http://localhost:8080/prices.html` を開いてください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:342
msgid "If you started the Kafka broker with docker compose, stop it using `CTRL+C` followed by `docker-compose down`."
msgstr "Kafka ブローカーを docker compose で起動した場合は、`CTRL+C` に続いて `docker-compose down` で停止します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:343
#, no-wrap
msgid "Running Native"
msgstr "ネイティブ実行"

#. type: Plain text
#: upstream/_guides/kafka.adoc:346
msgid "You can build the native executable with:"
msgstr "以下でネイティブ実行ファイルをビルドすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:350
#, no-wrap
msgid "./mvnw package -Pnative\n"
msgstr "./mvnw package -Pnative\n"

#. type: Title ==
#: upstream/_guides/kafka.adoc:352
#, no-wrap
msgid "Imperative usage"
msgstr "命令的な使用法"

#. type: Plain text
#: upstream/_guides/kafka.adoc:355
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "時には、命令的な方法でメッセージを送ることが必要になる場合もあります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:358
msgid "For example, if you need to send a message to a stream, from inside a REST endpoint, when receiving a POST request.  In this case, you cannot use `@Output` because your method has parameters."
msgstr "例えば、POST リクエストを受信したときに、REST エンドポイントの内部からストリームにメッセージを送信する必要があるとします。この場合、メソッドにはパラメーターがあるため、`@Output` を使用することはできません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:360
msgid "For this, you can use an `Emitter`."
msgstr "この場合には `Emitter` が利用できます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:365
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:371
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:374
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:376
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:383
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(price);\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:387
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use `@OnOverflow` to configure back-pressure strategy."
msgstr "`Emitter` の設定は、`@Incoming` と `@Outgoing` が使用する他のストリームの設定と同じ方法で行います。さらに、`@OnOverflow` を使用して、バックプレッシャー戦略を設定することができます。"

#. type: Block title
#: upstream/_guides/kafka.adoc:389
#, no-wrap
msgid "Deprecation"
msgstr "非推奨"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:392
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr "`io.smallrye.reactive.messaging.annotations.Emitter`、`io.smallrye.reactive.messaging.annotations.Channel`、`io.smallrye.reactive.messaging.annotations.OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:394
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:395
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:396
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:398
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr "新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると、`CompletionStage` の完了を返します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:401
#, fuzzy, no-wrap
#| msgid "Kafka Health Check"
msgid "Kafka Health Checks"
msgstr "Kafka のヘルスチェック"

#. type: Plain text
#: upstream/_guides/kafka.adoc:405
#, fuzzy
msgid "Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension."
msgstr "Quarkusは、Kafkaのヘルスチェックをいくつか提供しています。これらのチェックは、 `quarkus-smallrye-health` エクステンションと組み合わせて使用します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:411
#, fuzzy
msgid "When using the `quarkus-kafka` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  That check requires an _admin connection_ with the Kafka broker.  This check is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status."
msgstr "`quarkus-kafka` エクステンションを使用している場合、 `application.properties` で `quarkus.kafka.health.enabled` プロパティを `true` に設定することで、 _レディネス・ヘルスチェック_を有効にすることができます。このチェックでは、 _デフォルトの_Kafkaブローカー（ `kafka.bootstrap.servers` を使用して構成）との相互作用の状態が報告されます。そのチェックには、Kafka ブローカーとの _管理者接続_が必要です。このチェックは、デフォルトでは無効になっています。有効にすると、アプリケーションの `/q/health/ready` エンドポイントにアクセスしたときに、接続検証のステータスに関する情報が得られます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:416
#, fuzzy
msgid "When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides a _liveness_ and _readiness_ check.  The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka.  The _readiness_ check verifies that communication with Kafka is established.  For each channel, you can disable the checks using:"
msgstr "Reactive MessagingとKafkaコネクタを使用する場合、設定された各チャネル（受信または送信）は、 _有効性_と _準備_性のチェックを提供します。 _有効_性チェックでは、Kafkaとの通信中に発生した回復不能な障害を捕捉します。 _準備_完了チェックでは、Kafkaとの通信が確立されていることを確認します。各チャネルでは、以下の方法でチェックを無効にすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:420
#, no-wrap
msgid "# Disable both liveness and readiness checks with `health-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:425
#, no-wrap
msgid ""
"# Incoming channel (receiving records form Kafka)\n"
"mp.messaging.incoming.your-channel.health-enabled=false\n"
"# Outgoing channel (writing records to Kafka)\n"
"mp.messaging.outgoing.your-channel.health-enabled=false\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:427
#, no-wrap
msgid "# Disable only the readiness check with `health-readiness-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:430
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.health-readiness-enabled=false\n"
"mp.messaging.outgoing.your-channel.health-readiness-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:433
#, fuzzy
msgid "You can configure the `bootstrap.servers` for each channel. Defaults is `kafka.bootstrap.servers`."
msgstr "各チャンネルの `bootstrap.servers` を設定することができます。デフォルトは `kafka.bootstrap.servers` です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:437
#, fuzzy
msgid "Reactive Messaging readiness check offers two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in metrics."
msgstr "Reactive Messaging のレディネスチェックには2つのストラテジーがあります。デフォルトの方法では、ブローカーとの間にアクティブな接続が確立されているかどうかを確認します。この方法は、組み込みのメトリクスに基づいているため、邪魔にはなりません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:440
#, fuzzy
msgid "Using the `health-readiness-topic-verification=true` attribute, you can also check the topics used by the application exist in the broker.  Note that, to achieve this, an _admin connection_ is required."
msgstr "`health-readiness-topic-verification=true` 属性を使用すると、アプリケーションが使用するトピックがブローカーに存在することも確認できます。なお、これを行うためには、 _管理者の接続_が必要です。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:441
#, no-wrap
msgid "JSON serialization"
msgstr "JSON シリアライゼーション"

#. type: Plain text
#: upstream/_guides/kafka.adoc:444
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "Quarkus には、JSON Kafka メッセージを扱う機能が組み込まれています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:446
msgid "Imagine we have a `Fruit` pojo as follows:"
msgstr "以下のように `Fruit` の pojo があると想像してみてください。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:450
#, no-wrap
msgid "public class Fruit {\n"
msgstr "public class Fruit {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:453
#, no-wrap
msgid ""
"    public String name;\n"
"    public int price;\n"
msgstr ""
"    public String name;\n"
"    public int price;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:456
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""
"    public Fruit() {\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:462
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:465
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr "そして、Kafka からメッセージを受信して、何らかの価格変換を行い、Kafka にメッセージを送り返すために使いたいと考えています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:471
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:480
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" stream.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" stream.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:490
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:495
msgid "To do this, we will need to setup JSON serialization with Jackson or JSON-B."
msgstr "そのためには、Jackson や JSON-B で JSON シリアライゼーションを設定する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:497
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr "JSON シリアライゼーションが正しく設定されていれば、 `Publisher<Fruit>` や `Emitter<Fruit>` も利用できます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:498
#, no-wrap
msgid "Serializing via Jackson"
msgstr "Jackson によるシリアライゼーション"

#. type: Plain text
#: upstream/_guides/kafka.adoc:501
msgid "First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-resteasy-jackson` extension, this is not needed)."
msgstr "まず、`quarkus-jackson` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jackson` のエクステンションを使用している場合は、これは必要ありません)。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:508
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jackson</artifactId>\n"
"</dependency>\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:512
msgid "There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson, but the corresponding deserializer is generic, so it needs to be subclassed."
msgstr "Jackson によって全ての POJO をシリアルに変換することができる既存の `ObjectMapperSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:514
msgid "So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr "そこで、`ObjectMapperDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:518
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr "package com.acme.fruit.jackson;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:520
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:527
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:530
msgid "Finally, configure your streams to use the Jackson serializer and deserializer."
msgstr "最後に、Jackson シリアライザーとデシリアライザーを使用するようにストリームを設定します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:537
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:542
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:545
msgid "Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo."
msgstr "これで、Kafka メッセージには、Fruit pojo の Jackson によるシリアライズ表現が含まれるようになります。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:546
#, no-wrap
msgid "Serializing via JSON-B"
msgstr "JSON-B によるシリアライズ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:549
msgid "First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed)."
msgstr "まず、`quarkus-jsonb` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jsonb` のエクステンションを使用している場合は不要です)。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:556
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:560
msgid "There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B, but the corresponding deserializer is generic, so it needs to be subclassed."
msgstr "JSON-B によってすべての pojos をシリアライズするために使用できる既存の `JsonbSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:562
msgid "So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr "そこで、一般的な `JsonbDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:566
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr "package com.acme.fruit.jsonb;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:568
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:575
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:579
msgid "If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr "pojo に個別にデシリアライザーを作成したくない場合は、`javax.json.JsonObject` にデシリアライズする汎用の `io.vertx.kafka.client.serialization.JsonObjectDeserializer` を使用することができます。対応するシリアライザーも使用できます。`io.vertx.kafka.client.serialization.JsonObjectSerializer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:581
msgid "Finally, configure your streams to use the JSON-B serializer and deserializer."
msgstr "最後に、JSON-B シリアライザーとデシリアライザーを使用するようにストリームを設定します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:588
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:593
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:596
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo."
msgstr "これで、Kafka のメッセージには、JSON-B でシリアライズされた Fruit pojo の表現が含まれます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:597
#, no-wrap
msgid "Sending JSON Server-Sent Events (SSE)"
msgstr "JSON Server-Sent Events (SSE) の送信"

#. type: Plain text
#: upstream/_guides/kafka.adoc:601
msgid "If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events, as the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`."
msgstr "RESTEasy で JSON Server-Sent Events を送信したい場合は、`@SseElementType` アノテーションを使用してイベントのコンテンツタイプを定義する必要があります。これは、このメソッドが `@Produces(MediaType.SERVER_SENT_EVENTS)` のアノテーションが付くためです。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:603
msgid "The following example shows how to use SSE from a Kafka topic source."
msgstr "次の例は、Kafka トピックソースから SSE を使用する方法を示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:618
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""
"@Path(\"/fruits\")\n"
"public class FruitResource {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:621
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"fruit-out\") Publisher<Fruit> fruits;\n"
msgstr ""
"    @Inject\n"
"    @Channel(\"fruit-out\") Publisher<Fruit> fruits;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:630
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(MediaType.APPLICATION_JSON)\n"
"    public Publisher<Fruit> stream() {\n"
"        return fruits;\n"
"    }\n"
"}\n"
msgstr ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(MediaType.APPLICATION_JSON)\n"
"    public Publisher<Fruit> stream() {\n"
"        return fruits;\n"
"    }\n"
"}\n"

#. type: Title ==
#: upstream/_guides/kafka.adoc:632
#, no-wrap
msgid "Blocking processing"
msgstr "ブロッキング処理"

#. type: Plain text
#: upstream/_guides/kafka.adoc:636
msgid "You often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and cannot be run on the caller thread."
msgstr "Reactive Messaging とデータベースインタラクションなどのブロッキング処理を組み合わせる必要がある状況は少なくありません。そのためには、処理が _ブロックしていて_ 呼び出し元のスレッドで実行できないこと示している `@Blocking` アノテーションを使用する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:638
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "例えば、以下のコードは、Hibernate with Panacheを 使用してデータベースに受信ペイロードを格納する方法を示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:642
#, no-wrap
msgid "package org.acme.panache;\n"
msgstr "package org.acme.panache;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:645
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:648
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"
msgstr ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:651
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:660
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Blocking\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""
"    @Incoming(\"prices\")\n"
"    @Blocking\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:665
msgid "The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr "完全な例は `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[ディレクトリー] にあります。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:669
msgid "There are 2 `@Blocking` annotations:"
msgstr "`@Blocking` アノテーションは 2 つあります。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:671
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:672
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:677
msgid "They have the same effect.  Thus, you can use both.  The first one provides more fine-grain tuning such as the worker pool to use and whether it preserves the order.  The second one, used in also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr "効果はどちらも同じです。したがって、両方を使うことができます。最初のものは、使用するワーカープールや順序を保持するかどうかなど、より細かい調整が可能です。2 番目のものは、Quarkus の他のリアクティブ機能でも使用され、デフォルトのワーカープールを使用し、順序を保持します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:679
#, no-wrap
msgid "Testing a Kafka application"
msgstr "Kafka アプリケーションのテスト"

#. type: Title ===
#: upstream/_guides/kafka.adoc:681
#, no-wrap
msgid "Testing without a broker"
msgstr "ブローカーなしでのテスト"

#. type: Plain text
#: upstream/_guides/kafka.adoc:685
msgid "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr "Kafka ブローカーを起動しなくてもアプリケーションをテストできるのは便利です。これを行うには、Kafka コネクターで管理しているチャンネルを _インメモリー_ に _切り替え_ できます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:687
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:689
msgid "First, add the following dependency to your application:"
msgstr "まず、以下の依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:697
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:700
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "そして、以下のように Quarkus Test Resource を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:704
#, no-wrap
msgid "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:714
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");  // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"queue\");   // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");  // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"queue\");   // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:720
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:722
msgid "Switch the incoming channel \"orders\" (expecting messages from Kafka) to in-memory."
msgstr "(Kafka からのメッセージが想定される) 受信チャンネル \"order\" をインメモリーに切り替えます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:723
msgid "Switch the outgoing channel \"queue\" (writing messages to Kafka) to in-memory."
msgstr "送信チャネル \"キュー\" (Kafka へのメッセージの書き込み) をインメモリーに切り替えます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:724
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "インメモリーチャネルを使用するためのアプリケーション設定に必要なすべてのプロパティを含む `Map` をビルドして返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:725
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "テストが停止したら、`InMemoryConnector` をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:727
msgid "Create a Quarkus Test using the test resource created above:"
msgstr "上記で作成したテストリソースを使用して Quarkus テストを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:733
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"
msgstr ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:736
#, no-wrap
msgid ""
"    @Inject @Any\n"
"    InMemoryConnector connector; // <1>\n"
msgstr ""
"    @Inject @Any\n"
"    InMemoryConnector connector; // <1>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:741
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> orders = connector.source(\"orders\"); // <2>\n"
"        InMemorySink<Beverage> queue = connector.sink(\"queue\");    // <3>\n"
msgstr ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> orders = connector.source(\"orders\"); // <2>\n"
"        InMemorySink<Beverage> queue = connector.sink(\"queue\");    // <3>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:746
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
msgstr ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:748
#, no-wrap
msgid "        orders.send(order);  // <4>\n"
msgstr "        orders.send(order);  // <4>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:750
#, no-wrap
msgid "        await().<List<? extends Message<Beverage>>>until(queue::received, t -> t.size() == 1); // <5>\n"
msgstr "        await().<List<? extends Message<Beverage>>>until(queue::received, t -> t.size() == 1); // <5>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:757
#, no-wrap
msgid ""
"        Beverage queuedBeverage = queue.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"
msgstr ""
"        Beverage queuedBeverage = queue.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:761
msgid "Inject the in-memory connector in your test class."
msgstr "テストクラスにインメモリーコネクタ－を挿入します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:762
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr "受信チャンネルを取得します (`orders`) - テストリソース内でチャンネルがインメモリーに切り替えられている必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:763
msgid "Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource."
msgstr "送信チャネルを取得します (`queue`) - テストリソース内でチャネルがインメモリーに切り替えられている必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:764
msgid "Use the `send` method to send a message to the `orders` channel. So, the application will process this message."
msgstr "`send` メソッドを使用して、`orders` チャンネルにメッセージを送信します。つまり、アプリケーションはこのメッセージを処理します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:765
msgid "Use the `received` method to check the messages produced by the application."
msgstr "アプリケーションが生成するメッセージを確認するには、`received` メソッドを使用します。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:766
#, no-wrap
msgid "Starting Kafka in a test resource"
msgstr "テストリソースでの Kafka の起動"

#. type: Plain text
#: upstream/_guides/kafka.adoc:770
msgid "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr "あるいは、テストリソースで Kafka ブローカを起動することもできます。次のスニペットは、https://www.testcontainers.org/modules/kafka/[Testcontainers] 使用して Kafka ブローカを起動するテストリソースを示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:774
#, no-wrap
msgid "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:776
#, no-wrap
msgid "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr "    private final KafkaContainer kafka = new KafkaContainer();\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:782
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:788
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:790
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr "アプリケーションがこのブローカーに接続するように、Kafka ブートストラップの場所を設定します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:791
#, no-wrap
msgid "Authenticating with OAuth"
msgstr "OAuth での認証"

#. type: Plain text
#: upstream/_guides/kafka.adoc:795
msgid "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr "Kafka ブローカーが認証メカニズムとして OAuth を使用している場合は、この認証プロセスを有効にするために Kafka コンシューマーを設定する必要があります。まず、以下の依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:802
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:806
msgid "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr "この依存関係は、OAuth ワークフローを処理するために必要なコールバックハンドラーを提供します。そして、`application.properties` で追加します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:816
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:819
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr "`oauth.client.id`、`oauth.client.secret`、`oauth.token.endpoint.uri` の値を更新します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:821
msgid "OAuth authentication works for both JVM and native modes."
msgstr "OAuth 認証は JVM とネイティブモードの両方で動作します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:822
#, fuzzy, no-wrap
msgid "Using Snappy"
msgstr "スナッピーの使い方"

#. type: Plain text
#: upstream/_guides/kafka.adoc:825
#, fuzzy
msgid "On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:"
msgstr "_発信_チャンネルでは、 `compression.type` 属性を `snappy` に設定することで、Snappy 圧縮を有効にすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:829
#, no-wrap
msgid "mp.messaging.outgoing.fruit-out.compression.type=snappy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:833
#, fuzzy
msgid "In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:"
msgstr "JVMモードでは、すぐに動作します。しかし、アプリケーションをネイティブな実行ファイルにコンパイルするには、以下のことが必要です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:835
#, fuzzy
msgid "Uses GraalVM 21.+"
msgstr "GraalVM 21.+を使用"

#. type: Plain text
#: upstream/_guides/kafka.adoc:836
#, fuzzy
#| msgid "This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`."
msgid "Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`"
msgstr "この動作を有効にするには、`application.properties` の `quarkus.kafka.health.enabled` プロパティを `true` に設定します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:838
#, fuzzy
msgid "In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts."
msgstr "ネイティブモードでは、Snappyはデフォルトで無効になっています。Snappyを使用するには、ネイティブライブラリを埋め込み、アプリケーションの起動時にそれを解凍する必要があるからです。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:839
#, no-wrap
msgid "Configuration"
msgstr "設定"

#. type: Plain text
#: upstream/_guides/kafka.adoc:843
#, fuzzy
msgid "More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.8/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation].  The most important attributes are listed in the tables below:"
msgstr "SmallRye Reactive Messagingの設定についての詳細は、 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.8/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation]に記載されています。最も重要な属性を以下の表に示します。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:844
#, fuzzy, no-wrap
msgid "Incoming channel configuration (polling from Kafka)"
msgstr "着信チャンネルの設定（Kafkaからのポーリング"

#. type: Plain text
#: upstream/_guides/kafka.adoc:847 upstream/_guides/kafka.adoc:1001
#, fuzzy
msgid "The following attributes are configured using:"
msgstr "を使って、以下の属性を設定します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:851
#, fuzzy, no-wrap
#| msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgid "mp.messaging.incoming.your-channel-name.attribute=value\n"
msgstr "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:854 upstream/_guides/kafka.adoc:1009
#, fuzzy
msgid "Some properties have aliases which can be configured globally:"
msgstr "一部のプロパティには、グローバルに設定可能なエイリアスがあります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:858 upstream/_guides/kafka.adoc:1013
#, no-wrap
msgid "kafka.bootstrap.servers=...\n"
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:860
#, fuzzy, no-wrap
msgid "Incoming Attributes of the 'smallrye-kafka' connector"
msgstr "smallry-kafka」コネクタの着信属性"

#. type: Table
#: upstream/_guides/kafka.adoc:863 upstream/_guides/kafka.adoc:1018
#, fuzzy, no-wrap
msgid "Attribute (_alias_)"
msgstr "アトリビュート _（エイリアス_"

#. type: Table
#: upstream/_guides/kafka.adoc:863 upstream/_guides/kafka.adoc:1018
#, fuzzy, no-wrap
#| msgid "Deprecation"
msgid "Description"
msgstr "非推奨"

#. type: Table
#: upstream/_guides/kafka.adoc:863 upstream/_guides/kafka.adoc:1018
#, fuzzy, no-wrap
msgid "Mandatory"
msgstr "必須"

#. type: Table
#: upstream/_guides/kafka.adoc:865 upstream/_guides/kafka.adoc:1020
#, no-wrap
msgid "Default"
msgstr "デフォルト"

#. type: Table
#: upstream/_guides/kafka.adoc:867 upstream/_guides/kafka.adoc:1026
#, fuzzy, no-wrap
msgid ""
"*bootstrap.servers*\n"
"\n"
"_(kafka.bootstrap.servers)_"
msgstr "*bootstrap.servers*"

#. type: Table
#: upstream/_guides/kafka.adoc:869 upstream/_guides/kafka.adoc:1028
#, fuzzy, no-wrap
msgid ""
"A comma-separated list of host:port to use for establishing the initial connection to the Kafka cluster.\n"
"\n"
"Type: _string_"
msgstr "Kafkaクラスターへの初期接続を確立するために使用するhost:portをカンマで区切ったリスト。"

#. type: Table
#: upstream/_guides/kafka.adoc:869 upstream/_guides/kafka.adoc:873
#: upstream/_guides/kafka.adoc:877 upstream/_guides/kafka.adoc:881
#: upstream/_guides/kafka.adoc:885 upstream/_guides/kafka.adoc:889
#: upstream/_guides/kafka.adoc:893 upstream/_guides/kafka.adoc:897
#: upstream/_guides/kafka.adoc:901 upstream/_guides/kafka.adoc:905
#: upstream/_guides/kafka.adoc:909 upstream/_guides/kafka.adoc:917
#: upstream/_guides/kafka.adoc:926 upstream/_guides/kafka.adoc:930
#: upstream/_guides/kafka.adoc:934 upstream/_guides/kafka.adoc:938
#: upstream/_guides/kafka.adoc:942 upstream/_guides/kafka.adoc:946
#: upstream/_guides/kafka.adoc:950 upstream/_guides/kafka.adoc:954
#: upstream/_guides/kafka.adoc:958 upstream/_guides/kafka.adoc:962
#: upstream/_guides/kafka.adoc:966 upstream/_guides/kafka.adoc:970
#: upstream/_guides/kafka.adoc:974 upstream/_guides/kafka.adoc:978
#: upstream/_guides/kafka.adoc:982 upstream/_guides/kafka.adoc:986
#: upstream/_guides/kafka.adoc:990 upstream/_guides/kafka.adoc:994
#: upstream/_guides/kafka.adoc:1022 upstream/_guides/kafka.adoc:1028
#: upstream/_guides/kafka.adoc:1032 upstream/_guides/kafka.adoc:1036
#: upstream/_guides/kafka.adoc:1040 upstream/_guides/kafka.adoc:1046
#: upstream/_guides/kafka.adoc:1052 upstream/_guides/kafka.adoc:1058
#: upstream/_guides/kafka.adoc:1062 upstream/_guides/kafka.adoc:1068
#: upstream/_guides/kafka.adoc:1074 upstream/_guides/kafka.adoc:1080
#: upstream/_guides/kafka.adoc:1084 upstream/_guides/kafka.adoc:1088
#: upstream/_guides/kafka.adoc:1092 upstream/_guides/kafka.adoc:1096
#: upstream/_guides/kafka.adoc:1100 upstream/_guides/kafka.adoc:1104
#: upstream/_guides/kafka.adoc:1108 upstream/_guides/kafka.adoc:1112
#: upstream/_guides/kafka.adoc:1116 upstream/_guides/kafka.adoc:1120
#: upstream/_guides/kafka.adoc:1124 upstream/_guides/kafka.adoc:1128
#: upstream/_guides/kafka.adoc:1136
#, fuzzy, no-wrap
msgid "false"
msgstr "偽"

#. type: Table
#: upstream/_guides/kafka.adoc:871 upstream/_guides/kafka.adoc:1030
#, fuzzy, no-wrap
msgid "`localhost:9092`"
msgstr "`localhost:9092`"

#. type: Table
#: upstream/_guides/kafka.adoc:871 upstream/_guides/kafka.adoc:1122
#, fuzzy, no-wrap
msgid "*topic*"
msgstr "*トピック*"

#. type: Table
#: upstream/_guides/kafka.adoc:873 upstream/_guides/kafka.adoc:1124
#, fuzzy, no-wrap
msgid ""
"The consumed / populated Kafka topic. If neither this property nor the `topics` properties are set, the channel name is used\n"
"\n"
"Type: _string_"
msgstr "消費/投入されたKafkaトピック。このプロパティも `topics` のプロパティも設定されていない場合は、チャネル名が使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:875 upstream/_guides/kafka.adoc:1082
#, fuzzy, no-wrap
msgid "*health-enabled*"
msgstr "*ヘルス・イネーブル*"

#. type: Table
#: upstream/_guides/kafka.adoc:877 upstream/_guides/kafka.adoc:1084
#, fuzzy, no-wrap
msgid ""
"Whether health reporting is enabled (default) or disabled\n"
"\n"
"Type: _boolean_"
msgstr "ヘルスレポートが有効（デフォルト）か無効か"

#. type: Table
#: upstream/_guides/kafka.adoc:879 upstream/_guides/kafka.adoc:883
#: upstream/_guides/kafka.adoc:895 upstream/_guides/kafka.adoc:899
#: upstream/_guides/kafka.adoc:936 upstream/_guides/kafka.adoc:996
#: upstream/_guides/kafka.adoc:1042 upstream/_guides/kafka.adoc:1060
#: upstream/_guides/kafka.adoc:1086 upstream/_guides/kafka.adoc:1090
#: upstream/_guides/kafka.adoc:1130 upstream/_guides/kafka.adoc:1138
#, fuzzy, no-wrap
msgid "`true`"
msgstr "`true`"

#. type: Table
#: upstream/_guides/kafka.adoc:879 upstream/_guides/kafka.adoc:1086
#, fuzzy, no-wrap
msgid "*health-readiness-enabled*"
msgstr "*ヘルス・レディネス・イネーブル*"

#. type: Table
#: upstream/_guides/kafka.adoc:881 upstream/_guides/kafka.adoc:1088
#, fuzzy, no-wrap
msgid ""
"Whether readiness health reporting is enabled (default) or disabled\n"
"\n"
"Type: _boolean_"
msgstr "レディネスレポートが有効（デフォルト）か無効か"

#. type: Table
#: upstream/_guides/kafka.adoc:883 upstream/_guides/kafka.adoc:1094
#, fuzzy, no-wrap
msgid "*health-readiness-topic-verification*"
msgstr "*ヘルス・レディネス・トピック・ベリフィケーション*"

#. type: Table
#: upstream/_guides/kafka.adoc:885 upstream/_guides/kafka.adoc:1096
#, fuzzy, no-wrap
msgid ""
"Whether the readiness check should verify that topics exist on the broker. Default to false. Enabling it requires an admin connection.\n"
"\n"
"Type: _boolean_"
msgstr "ブローカにトピックが存在するかどうかをレディネスチェックで確認するかどうか。デフォルトはfalseです。これを有効にするには、管理者の接続が必要です。"

#. type: Table
#: upstream/_guides/kafka.adoc:887 upstream/_guides/kafka.adoc:907
#: upstream/_guides/kafka.adoc:932 upstream/_guides/kafka.adoc:948
#: upstream/_guides/kafka.adoc:1098 upstream/_guides/kafka.adoc:1114
#, fuzzy, no-wrap
msgid "`false`"
msgstr "`false`"

#. type: Table
#: upstream/_guides/kafka.adoc:887 upstream/_guides/kafka.adoc:1090
#, fuzzy, no-wrap
msgid "*health-readiness-timeout*"
msgstr "*ヘルスレディネスタイムアウト*"

#. type: Table
#: upstream/_guides/kafka.adoc:889 upstream/_guides/kafka.adoc:1092
#, fuzzy, no-wrap
msgid ""
"During the readiness health check, the connector connects to the broker and retrieves the list of topics. This attribute specifies the maximum duration (in ms) for the retrieval. If exceeded, the channel is considered not-ready.\n"
"\n"
"Type: _long_"
msgstr "準備状態の健全性チェックの間、コネクタはブローカーに接続し、トピックのリストを取得します。この属性では、検索にかかる最大時間（ms）を指定します。これを超えると、チャネルは準備ができていないとみなされます。"

#. type: Table
#: upstream/_guides/kafka.adoc:891 upstream/_guides/kafka.adoc:1094
#, fuzzy, no-wrap
msgid "`2000`"
msgstr "`2000`"

#. type: Table
#: upstream/_guides/kafka.adoc:891 upstream/_guides/kafka.adoc:1126
#, fuzzy, no-wrap
msgid "*tracing-enabled*"
msgstr "*tracing-enabled*"

#. type: Table
#: upstream/_guides/kafka.adoc:893 upstream/_guides/kafka.adoc:1128
#, fuzzy, no-wrap
msgid ""
"Whether tracing is enabled (default) or disabled\n"
"\n"
"Type: _boolean_"
msgstr "トレースを有効（デフォルト）にするか、無効にするか"

#. type: Table
#: upstream/_guides/kafka.adoc:895 upstream/_guides/kafka.adoc:1038
#, fuzzy, no-wrap
msgid "*cloud-events*"
msgstr "*クラウドイベント*"

#. type: Table
#: upstream/_guides/kafka.adoc:897 upstream/_guides/kafka.adoc:1040
#, fuzzy, no-wrap
msgid ""
"Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.\n"
"\n"
"Type: _boolean_"
msgstr "クラウド イベント サポートを有効（デフォルト）または無効にします。 _受信_チャネルで有効にすると、コネクタは受信レコードを分析し、Cloud Event メタデータの作成を試みます。 _発信_側で有効にすると、メッセージに Cloud Event Metadata が含まれている場合、コネクタは発信メッセージを Cloud Event として送信します。"

#. type: Table
#: upstream/_guides/kafka.adoc:899
#, fuzzy, no-wrap
msgid "*topics*"
msgstr "*トピックス*"

#. type: Table
#: upstream/_guides/kafka.adoc:901
#, fuzzy, no-wrap
msgid ""
"A comma-separating list of topics to be consumed. Cannot be used with the `topic` or `pattern` properties\n"
"\n"
"Type: _string_"
msgstr "消費されるトピックのコンマ区切りのリスト。 `topic` または `pattern` のプロパティとは併用できません。"

#. type: Table
#: upstream/_guides/kafka.adoc:903
#, fuzzy, no-wrap
msgid "*pattern*"
msgstr "*パターン*"

#. type: Table
#: upstream/_guides/kafka.adoc:905
#, fuzzy, no-wrap
msgid ""
"Indicate that the `topic` property is a regular expression. Must be used with the `topic` property. Cannot be used with the `topics` property\n"
"\n"
"Type: _boolean_"
msgstr "`topic` プロパティが正規表現であることを示す。 `topic` プロパティと併用する必要があります。 `topics` プロパティとは併用できません。"

#. type: Table
#: upstream/_guides/kafka.adoc:907
#, fuzzy, no-wrap
msgid "*key.deserializer*"
msgstr "*キー・デシリアライザ*"

#. type: Table
#: upstream/_guides/kafka.adoc:909
#, fuzzy, no-wrap
msgid ""
"The deserializer classname used to deserialize the record's key\n"
"\n"
"Type: _string_"
msgstr "レコードのキーをデシリアライズするために使用されるデシリアライザのクラス名"

#. type: Table
#: upstream/_guides/kafka.adoc:911
#, fuzzy, no-wrap
#| msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgid "`org.apache.kafka.common.serialization.StringDeserializer`"
msgstr "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"

#. type: Table
#: upstream/_guides/kafka.adoc:911
#, fuzzy, no-wrap
msgid "*value.deserializer*"
msgstr "*value.deserializer*"

#. type: Table
#: upstream/_guides/kafka.adoc:913
#, fuzzy, no-wrap
msgid ""
"The deserializer classname used to deserialize the record's value\n"
"\n"
"Type: _string_"
msgstr "レコードの値のデシリアライズに使用されるデシリアライザのクラス名"

#. type: Table
#: upstream/_guides/kafka.adoc:913 upstream/_guides/kafka.adoc:1132
#, fuzzy, no-wrap
msgid "true"
msgstr "真"

#. type: Table
#: upstream/_guides/kafka.adoc:915
#, fuzzy, no-wrap
msgid "*fetch.min.bytes*"
msgstr "*フェッチ・ミニ・バイト*"

#. type: Table
#: upstream/_guides/kafka.adoc:917
#, fuzzy, no-wrap
msgid ""
"The minimum amount of data the server should return for a fetch request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive.\n"
"\n"
"Type: _int_"
msgstr "フェッチ・リクエストに対してサーバーが返すべきデータの最小量。デフォルトの1バイトの設定は、1バイトのデータが利用可能になるか、データの到着を待ってフェッチリクエストがタイムアウトするとすぐにフェッチリクエストに応答することを意味します。"

#. type: Table
#: upstream/_guides/kafka.adoc:919 upstream/_guides/kafka.adoc:980
#: upstream/_guides/kafka.adoc:1024
#, fuzzy, no-wrap
msgid "`1`"
msgstr "`1`"

#. type: Table
#: upstream/_guides/kafka.adoc:919
#, fuzzy, no-wrap
msgid "*group.id*"
msgstr "*group.id*"

#. type: Table
#: upstream/_guides/kafka.adoc:926
#, fuzzy, no-wrap
msgid ""
"A unique string that identifies the consumer group the application belongs to.\n"
"\n"
"If not set, defaults to the application name as set by the `quarkus.application.name` configuration property.\n"
"\n"
"If that is not set either, a unique, generated id is used.\n"
"It is recommended to always define a `group.id`, the automatic generation is only a convenient feature for development.\n"
"\n"
"Type: _string_"
msgstr "アプリケーションが所属するコンシューマーグループを識別するための一意の文字列。"

#. type: Table
#: upstream/_guides/kafka.adoc:928
#, fuzzy, no-wrap
msgid "*enable.auto.commit*"
msgstr "*enable.auto.commit*"

#. type: Table
#: upstream/_guides/kafka.adoc:930
#, fuzzy, no-wrap
msgid ""
"If enabled, consumer's offset will be periodically committed in the background by the underlying Kafka client, ignoring the actual processing outcome of the records. It is recommended to NOT enable this setting and let Reactive Messaging handles the commit.\n"
"\n"
"Type: _boolean_"
msgstr "この設定を有効にすると、コンシューマーのオフセットは、レコードの実際の処理結果を無視して、基礎となるKafkaクライアントによってバックグラウンドで定期的にコミットされます。この設定を有効にしないで、Reactive Messaging にコミットを任せることをお勧めします。"

#. type: Table
#: upstream/_guides/kafka.adoc:932
#, fuzzy, no-wrap
msgid "*retry*"
msgstr "*リトライ*"

#. type: Table
#: upstream/_guides/kafka.adoc:934
#, fuzzy, no-wrap
msgid ""
"Whether or not the connection to the broker is re-attempted in case of failure\n"
"\n"
"Type: _boolean_"
msgstr "障害発生時にブローカーへの接続を再試行するかどうか"

#. type: Table
#: upstream/_guides/kafka.adoc:936
#, fuzzy, no-wrap
msgid "*retry-attempts*"
msgstr "*retry-attempts*"

#. type: Table
#: upstream/_guides/kafka.adoc:938
#, fuzzy, no-wrap
msgid ""
"The maximum number of reconnection before failing. -1 means infinite retry\n"
"\n"
"Type: _int_"
msgstr "失敗するまでの最大再接続回数を指定します。1は無限再試行を意味します。"

#. type: Table
#: upstream/_guides/kafka.adoc:940 upstream/_guides/kafka.adoc:1118
#, fuzzy, no-wrap
msgid "`-1`"
msgstr "`-1`"

#. type: Table
#: upstream/_guides/kafka.adoc:940
#, fuzzy, no-wrap
msgid "*retry-max-wait*"
msgstr "*retry-max-wait*"

#. type: Table
#: upstream/_guides/kafka.adoc:942
#, fuzzy, no-wrap
msgid ""
"The max delay (in seconds) between 2 reconnects\n"
"\n"
"Type: _int_"
msgstr "2回の再接続の間の最大遅延時間（秒"

#. type: Table
#: upstream/_guides/kafka.adoc:944
#, fuzzy, no-wrap
msgid "`30`"
msgstr "`30`"

#. type: Table
#: upstream/_guides/kafka.adoc:944
#, fuzzy, no-wrap
msgid "*broadcast*"
msgstr "*ブロードキャスト*"

#. type: Table
#: upstream/_guides/kafka.adoc:946
#, fuzzy, no-wrap
msgid ""
"Whether the Kafka records should be dispatched to multiple consumer\n"
"\n"
"Type: _boolean_"
msgstr "Kafkaのレコードを複数のコンシューマーに配信するかどうか"

#. type: Table
#: upstream/_guides/kafka.adoc:948
#, fuzzy, no-wrap
msgid "*auto.offset.reset*"
msgstr "*auto.offset.reset*"

#. type: Table
#: upstream/_guides/kafka.adoc:950
#, fuzzy, no-wrap
msgid ""
"What to do when there is no initial offset in Kafka.Accepted values are earliest, latest and none\n"
"\n"
"Type: _string_"
msgstr "Kafkaで初期オフセットがない場合の対処法。許容される値はearliest、latest、none。"

#. type: Table
#: upstream/_guides/kafka.adoc:952
#, fuzzy, no-wrap
msgid "`latest`"
msgstr "`latest`"

#. type: Table
#: upstream/_guides/kafka.adoc:952
#, fuzzy, no-wrap
msgid "*failure-strategy*"
msgstr "*失敗戦略*"

#. type: Table
#: upstream/_guides/kafka.adoc:954
#, fuzzy, no-wrap
msgid ""
"Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be `fail` (default), `ignore`, or `dead-letter-queue`\n"
"\n"
"Type: _string_"
msgstr "レコードから生成されたメッセージが否定的に確認された（nack）場合に適用する失敗戦略を指定します。値は、 `fail` （デフォルト）、 `ignore` 、または `dead-letter-queue`"

#. type: Table
#: upstream/_guides/kafka.adoc:956
#, fuzzy, no-wrap
msgid "`fail`"
msgstr "`fail`"

#. type: Table
#: upstream/_guides/kafka.adoc:956
#, fuzzy, no-wrap
msgid "*commit-strategy*"
msgstr "*コミット戦略*"

#. type: Table
#: upstream/_guides/kafka.adoc:958
#, fuzzy, no-wrap
msgid ""
"Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be `latest`, `ignore` or `throttled`. If `enable.auto.commit` is true then the default is `ignore` otherwise it is `throttled`\n"
"\n"
"Type: _string_"
msgstr "レコードから生成されたメッセージが確認されたときに適用するコミットストラテジーを指定します。値は、 `latest` 、 `ignore` 、 `throttled` のいずれかです。 `enable.auto.commit` が真であれば、デフォルトは `ignore` です。 `throttled`"

#. type: Table
#: upstream/_guides/kafka.adoc:960
#, fuzzy, no-wrap
msgid "*throttled.unprocessed-record-max-age.ms*"
msgstr "*throttled.unprocessed-record-max-age.ms*"

#. type: Table
#: upstream/_guides/kafka.adoc:962
#, fuzzy, no-wrap
msgid ""
"While using the `throttled` commit-strategy, specify the max age in milliseconds that an unprocessed message can be before the connector is marked as unhealthy.\n"
"\n"
"Type: _int_"
msgstr "`throttled` commit-strategy を使用している場合は、コネクタが不健全であるとマークされるまでの未処理メッセージの最大経過時間をミリ秒単位で指定します。"

#. type: Table
#: upstream/_guides/kafka.adoc:964
#, fuzzy, no-wrap
msgid "`60000`"
msgstr "`60000`"

#. type: Table
#: upstream/_guides/kafka.adoc:964
#, fuzzy, no-wrap
msgid "*dead-letter-queue.topic*"
msgstr "*dead-letter-queue.topic*"

#. type: Table
#: upstream/_guides/kafka.adoc:966
#, fuzzy, no-wrap
msgid ""
"When the `failure-strategy` is set to `dead-letter-queue` indicates on which topic the record is sent. Defaults is `dead-letter-topic-$channel`\n"
"\n"
"Type: _string_"
msgstr "`failure-strategy` が `dead-letter-queue` に設定されている場合、どのトピックにレコードが送信されるかを示します。デフォルトでは `dead-letter-topic-$channel`"

#. type: Table
#: upstream/_guides/kafka.adoc:968
#, fuzzy, no-wrap
msgid "*dead-letter-queue.key.serializer*"
msgstr "*dead-letter-queue.key.serializer*"

#. type: Table
#: upstream/_guides/kafka.adoc:970
#, fuzzy, no-wrap
msgid ""
"When the `failure-strategy` is set to `dead-letter-queue` indicates the key serializer to use. If not set the serializer associated to the key deserializer is used\n"
"\n"
"Type: _string_"
msgstr "`failure-strategy` が設定されている場合、 `dead-letter-queue` は使用するキーシリアライザを示します。設定されていない場合は、キーデシリアライザに関連付けられたシリアライザが使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:972
#, fuzzy, no-wrap
msgid "*dead-letter-queue.value.serializer*"
msgstr "*dead-letter-queue.value.serializer*"

#. type: Table
#: upstream/_guides/kafka.adoc:974
#, fuzzy, no-wrap
msgid ""
"When the `failure-strategy` is set to `dead-letter-queue` indicates the value serializer to use. If not set the serializer associated to the value deserializer is used\n"
"\n"
"Type: _string_"
msgstr "`failure-strategy` が設定されている場合、 `dead-letter-queue` は、使用する値のシリアライザを示します。設定されていない場合は、値のデシリアライザに関連付けられたシリアライザが使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:976
#, fuzzy, no-wrap
msgid "*partitions*"
msgstr "*パーティション*"

#. type: Table
#: upstream/_guides/kafka.adoc:978
#, fuzzy, no-wrap
msgid ""
"The number of partitions to be consumed concurrently. The connector creates the specified amount of Kafka consumers. It should match the number of partition of the targeted topic\n"
"\n"
"Type: _int_"
msgstr "同時に消費されるパーティションの数です。コネクタは、指定された数のKafkaコンシューマーを作成します。これは、対象となるトピックのパーティション数と一致する必要があります。"

#. type: Table
#: upstream/_guides/kafka.adoc:980
#, fuzzy, no-wrap
msgid "*consumer-rebalance-listener.name*"
msgstr "*consumer-rebalance-listener.name*"

#. type: Table
#: upstream/_guides/kafka.adoc:982
#, fuzzy, no-wrap
msgid ""
"The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener`. If set, this rebalance listener is applied to the consumer.\n"
"\n"
"Type: _string_"
msgstr "`io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` を実装するBeanの `javax.inject.Named` で設定された名前です。設定された場合、このリバランスリスナーはコンシューマーに適用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:984
#, fuzzy, no-wrap
msgid "*key-deserialization-failure-handler*"
msgstr "*キーデシリアライズ失敗ハンドラ*"

#. type: Table
#: upstream/_guides/kafka.adoc:986
#, fuzzy, no-wrap
msgid ""
"The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing keys are delegated to this handler which may provide a fallback value.\n"
"\n"
"Type: _string_"
msgstr "`io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` を実装するBeanの `javax.inject.Named` で設定された名前です。設定されている場合、キーをデシリアライズする際に起こるデシリアライズの失敗は、フォールバック値を提供することができるこのハンドラに委ねられます。"

#. type: Table
#: upstream/_guides/kafka.adoc:988
#, fuzzy, no-wrap
msgid "*value-deserialization-failure-handler*"
msgstr "*バリューデシリアライズ失敗ハンドラ*"

#. type: Table
#: upstream/_guides/kafka.adoc:990
#, fuzzy, no-wrap
msgid ""
"The name set in `javax.inject.Named` of a bean that implements `io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler`. If set, deserialization failure happening when deserializing values are delegated to this handler which may provide a fallback value.\n"
"\n"
"Type: _string_"
msgstr "`io.smallrye.reactive.messaging.kafka.DeserializationFailureHandler` を実装するBeanの `javax.inject.Named` で設定された名前です。設定されている場合、値のデシリアライズがこのハンドラに委ねられているときにデシリアライズの失敗が起こり、フォールバック値が提供されることがあります。"

#. type: Table
#: upstream/_guides/kafka.adoc:992
#, fuzzy, no-wrap
msgid "*graceful-shutdown*"
msgstr "*graceful-shutdown*"

#. type: Table
#: upstream/_guides/kafka.adoc:994
#, fuzzy, no-wrap
msgid ""
"Whether or not a graceful shutdown should be attempted when the application terminates.\n"
"\n"
"Type: _boolean_"
msgstr "アプリケーションの終了時に、グレースフルシャットダウンを行うかどうか。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:998
#, fuzzy, no-wrap
msgid "Outgoing channel configuration (writing to Kafka)"
msgstr "発信チャンネルの設定（Kafkaへの書き込み"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1006
#, fuzzy, no-wrap
#| msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgid "mp.messaging.outgoing.your-channel-name.attribute=value\n"
msgstr "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"

#. type: Block title
#: upstream/_guides/kafka.adoc:1015
#, fuzzy, no-wrap
msgid "Outgoing Attributes of the 'smallrye-kafka' connector"
msgstr "smallry-kafka」コネクタの送信属性"

#. type: Table
#: upstream/_guides/kafka.adoc:1020
#, fuzzy, no-wrap
msgid "*acks*"
msgstr "*アック*"

#. type: Table
#: upstream/_guides/kafka.adoc:1022
#, fuzzy, no-wrap
msgid ""
"The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. Accepted values are: 0, 1, all\n"
"\n"
"Type: _string_"
msgstr "リクエストが完了したとみなす前に、プロデューサーがリーダーに受信を要求する確認応答の数。これは、送信されるレコードの耐久性を制御します。許容される値は0、1、すべて"

#. type: Table
#: upstream/_guides/kafka.adoc:1030
#, fuzzy, no-wrap
msgid "*buffer.memory*"
msgstr "*バッファ・メモリ*"

#. type: Table
#: upstream/_guides/kafka.adoc:1032
#, fuzzy, no-wrap
msgid ""
"The total bytes of memory the producer can use to buffer records waiting to be sent to the server.\n"
"\n"
"Type: _long_"
msgstr "サーバーへの送信待ちのレコードをバッファリングするために、プロデューサーが使用できるメモリの総バイト数です。"

#. type: Table
#: upstream/_guides/kafka.adoc:1034
#, fuzzy, no-wrap
msgid "`33554432`"
msgstr "`33554432`"

#. type: Table
#: upstream/_guides/kafka.adoc:1034
#, fuzzy, no-wrap
msgid "*close-timeout*"
msgstr "*クローズタイムアウト*"

#. type: Table
#: upstream/_guides/kafka.adoc:1036
#, fuzzy, no-wrap
msgid ""
"The amount of milliseconds waiting for a graceful shutdown of the Kafka producer\n"
"\n"
"Type: _int_"
msgstr "Kafkaプロデューサーの緩やかなシャットダウンを待つミリ秒の量"

#. type: Table
#: upstream/_guides/kafka.adoc:1038
#, fuzzy, no-wrap
msgid "`10000`"
msgstr "`10000`"

#. type: Table
#: upstream/_guides/kafka.adoc:1044
#, fuzzy, no-wrap
msgid ""
"*cloud-events-data-content-type*\n"
"\n"
"_(cloud-events-default-data-content-type)_"
msgstr "*クラウド-イベント-データ-コンテンツ-タイプ*"

#. type: Table
#: upstream/_guides/kafka.adoc:1046
#, fuzzy, no-wrap
msgid ""
"Configure the default `datacontenttype` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `datacontenttype` attribute itself\n"
"\n"
"Type: _string_"
msgstr "発信するクラウドイベントのデフォルトの `datacontenttype` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `datacontenttype` 属性を設定していない場合に使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:1050
#, fuzzy, no-wrap
msgid ""
"*cloud-events-data-schema*\n"
"\n"
"_(cloud-events-default-data-schema)_"
msgstr "*クラウド・イベント・データ・スキーマ*"

#. type: Table
#: upstream/_guides/kafka.adoc:1052
#, fuzzy, no-wrap
msgid ""
"Configure the default `dataschema` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `dataschema` attribute itself\n"
"\n"
"Type: _string_"
msgstr "発信するクラウドイベントのデフォルトの `dataschema` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `dataschema` 属性を設定していない場合に使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:1056
#, fuzzy, no-wrap
msgid ""
"*cloud-events-insert-timestamp*\n"
"\n"
"_(cloud-events-default-timestamp)_"
msgstr "*クラウド-イベント-インサート-タイムスタンプ*"

#. type: Table
#: upstream/_guides/kafka.adoc:1058
#, fuzzy, no-wrap
msgid ""
"Whether or not the connector should insert automatically the `time` attribute` into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself\n"
"\n"
"Type: _boolean_"
msgstr "コネクタが、発信するクラウドイベントに `time` 属性` を自動的に挿入するかどうかを指定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `time` 属性自体を構成していない場合に使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:1060
#, fuzzy, no-wrap
msgid "*cloud-events-mode*"
msgstr "*クラウド-イベント-モード*"

#. type: Table
#: upstream/_guides/kafka.adoc:1062
#, fuzzy, no-wrap
msgid ""
"The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record\n"
"\n"
"Type: _string_"
msgstr "クラウドイベントのモード（ `structured` または `binary` （デフォルト））。発信記録にクラウドイベントをどのように書き込むかを示す。"

#. type: Table
#: upstream/_guides/kafka.adoc:1064
#, fuzzy, no-wrap
msgid "`binary`"
msgstr "`binary`"

#. type: Table
#: upstream/_guides/kafka.adoc:1066
#, fuzzy, no-wrap
msgid ""
"*cloud-events-source*\n"
"\n"
"_(cloud-events-default-source)_"
msgstr "*クラウド-イベント-ソース*"

#. type: Table
#: upstream/_guides/kafka.adoc:1068
#, fuzzy, no-wrap
msgid ""
"Configure the default `source` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `source` attribute itself\n"
"\n"
"Type: _string_"
msgstr "発信するクラウドイベントのデフォルトの `source` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `source` 属性を設定していない場合に使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:1072
#, fuzzy, no-wrap
msgid ""
"*cloud-events-subject*\n"
"\n"
"_(cloud-events-default-subject)_"
msgstr "*クラウド-イベント-サブジェクト*"

#. type: Table
#: upstream/_guides/kafka.adoc:1074
#, fuzzy, no-wrap
msgid ""
"Configure the default `subject` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `subject` attribute itself\n"
"\n"
"Type: _string_"
msgstr "発信するクラウドイベントのデフォルトの `subject` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `subject` 属性を設定していない場合に使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:1078
#, fuzzy, no-wrap
msgid ""
"*cloud-events-type*\n"
"\n"
"_(cloud-events-default-type)_"
msgstr "*クラウド-イベント-タイプ*"

#. type: Table
#: upstream/_guides/kafka.adoc:1080
#, fuzzy, no-wrap
msgid ""
"Configure the default `type` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `type` attribute itself\n"
"\n"
"Type: _string_"
msgstr "発信するクラウドイベントのデフォルトの `type` 属性を設定します。 `cloud-events` に `true` を設定する必要があります。この値は、メッセージが `type` 属性を設定していない場合に使用されます。"

#. type: Table
#: upstream/_guides/kafka.adoc:1098
#, fuzzy, no-wrap
msgid "*key*"
msgstr "*キー*"

#. type: Table
#: upstream/_guides/kafka.adoc:1100
#, fuzzy, no-wrap
msgid ""
"A key to used when writing the record\n"
"\n"
"Type: _string_"
msgstr "レコードを書くときに使うキー"

#. type: Table
#: upstream/_guides/kafka.adoc:1102
#, fuzzy, no-wrap
msgid "*key.serializer*"
msgstr "*キー・シリアライザー*"

#. type: Table
#: upstream/_guides/kafka.adoc:1104
#, fuzzy, no-wrap
msgid ""
"The serializer classname used to serialize the record's key\n"
"\n"
"Type: _string_"
msgstr "レコードのキーをシリアル化するために使用されるシリアル化クラス名"

#. type: Table
#: upstream/_guides/kafka.adoc:1106
#, fuzzy, no-wrap
#| msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgid "`org.apache.kafka.common.serialization.StringSerializer`"
msgstr "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"

#. type: Table
#: upstream/_guides/kafka.adoc:1106
#, fuzzy, no-wrap
msgid "*max-inflight-messages*"
msgstr "*max-inflight-messages*"

#. type: Table
#: upstream/_guides/kafka.adoc:1108
#, fuzzy, no-wrap
msgid ""
"The maximum number of messages to be written to Kafka concurrently. It limits the number of messages waiting to be written and acknowledged by the broker. You can set this attribute to `0` remove the limit\n"
"\n"
"Type: _long_"
msgstr "Kafkaに同時に書き込まれるメッセージの最大数。ブローカーが書き込みと確認を待っているメッセージの数を制限します。この属性を `0` に設定することで、制限を取り除くことができます。"

#. type: Table
#: upstream/_guides/kafka.adoc:1110
#, fuzzy, no-wrap
msgid "`1024`"
msgstr "`1024`"

#. type: Table
#: upstream/_guides/kafka.adoc:1110
#, fuzzy, no-wrap
msgid "*merge*"
msgstr "*マージ*"

#. type: Table
#: upstream/_guides/kafka.adoc:1112
#, fuzzy, no-wrap
msgid ""
"Whether the connector should allow multiple upstreams\n"
"\n"
"Type: _boolean_"
msgstr "コネクタが複数のアップストリームを許可するかどうか"

#. type: Table
#: upstream/_guides/kafka.adoc:1114
#, fuzzy, no-wrap
msgid "*partition*"
msgstr "*パーティション*"

#. type: Table
#: upstream/_guides/kafka.adoc:1116
#, fuzzy, no-wrap
msgid ""
"The target partition id. -1 to let the client determine the partition\n"
"\n"
"Type: _int_"
msgstr "ターゲットのパーティションIDをクライアントがパーティションを決定するための-1"

#. type: Table
#: upstream/_guides/kafka.adoc:1118
#, fuzzy, no-wrap
msgid "*retries*"
msgstr "*リトライ*"

#. type: Table
#: upstream/_guides/kafka.adoc:1120
#, fuzzy, no-wrap
msgid ""
"Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error.\n"
"\n"
"Type: _long_"
msgstr "ゼロより大きい値を設定すると、一時的なエラーで送信に失敗したレコードをクライアントが再送信します。"

#. type: Table
#: upstream/_guides/kafka.adoc:1122
#, fuzzy, no-wrap
msgid "`2147483647`"
msgstr "`2147483647`"

#. type: Table
#: upstream/_guides/kafka.adoc:1130
#, fuzzy, no-wrap
msgid "*value.serializer*"
msgstr "*Value.Serializer*"

#. type: Table
#: upstream/_guides/kafka.adoc:1132
#, fuzzy, no-wrap
msgid ""
"The serializer classname used to serialize the payload\n"
"\n"
"Type: _string_"
msgstr "ペイロードのシリアライズに使用されるシリアライザーのクラス名"

#. type: Table
#: upstream/_guides/kafka.adoc:1134
#, fuzzy, no-wrap
msgid "*waitForWriteCompletion*"
msgstr "*waitForWriteCompletion*"

#. type: Table
#: upstream/_guides/kafka.adoc:1136
#, fuzzy, no-wrap
msgid ""
"Whether the client waits for Kafka to acknowledge the written record before acknowledging the message\n"
"\n"
"Type: _boolean_"
msgstr "クライアントがメッセージを確認する前に、Kafkaが書き込まれた記録を確認するのを待つかどうか"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1140
#, no-wrap
msgid "Going further"
msgstr "さらに詳しく"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1144
#, fuzzy
#| msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes MicroProfile Reactive Messaging to build data streaming applications."
msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr "このガイドでは、Quarkus を使用して Kafka とやりとりする方法を示しました。MicroProfile Reactive Messaging を利用して、データストリーミングアプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1145
msgid "If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "詳細は、Quarkus で使用される実装 https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] のドキュメントを確認してください。"

#, fuzzy
#~ msgid ""
#~ "A unique string that identifies the consumer group the application belongs to. If not set, a unique, generated id is used\n"
#~ "\n"
#~ "Type: _string_"
#~ msgstr "アプリケーションが所属するコンシューマグループを識別するための一意の文字列です。設定されていない場合は、生成された一意のIDが使用されます。"

#~ msgid "If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka` can add a readiness health check to validate the connection to the broker. This is disabled by default."
#~ msgstr "`quarkus-smallrye-health` エクステンションを使用している場合、`quarkus-kafka` は、ブローカーへの接続を検証するためにレディネスヘルスチェックを追加することができます。これはデフォルトでは無効になっています。"

#~ msgid "If enabled, when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status."
#~ msgstr "これを有効にすると、アプリケーションの `/q/health/ready` エンドポイントにアクセスしたときに、接続検証ステータスに関する情報が表示されます。"
