# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-02-22 21:13+0000\n"
"PO-Revision-Date: 2022-02-03 23:33+0900\n"
"Last-Translator: Nobuhiro Sue <nobuhiro.sue@gmail.com>\n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka.adoc:6
#, no-wrap
msgid "Apache Kafka Reference Guide"
msgstr "Apache Kafka リファレンスガイド"

#. type: Plain text
#: upstream/_guides/kafka.adoc:16
msgid "This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka."
msgstr "このガイドでは、Quarkus アプリケーションが SmallRye Reactive Messaging を利用して Apache Kafka とやりとりする仕組みを説明します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:17
#, no-wrap
msgid "Introduction"
msgstr "はじめに"

#. type: Plain text
#: upstream/_guides/kafka.adoc:22
msgid "https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.  It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.  Similar to a message queue, or an enterprise messaging platform, it lets you:"
msgstr "link:https://kafka.apache.org[Apache Kafka]は、人気の高いオープンソースの分散型イベントストリーミングプラットフォームです。高性能なデータパイプライン、ストリーミング分析、データ統合、ミッションクリティカルなアプリケーションなどによく利用されています。メッセージキューやエンタープライズメッセージングプラットフォームに似ており、以下のことが可能です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:24
#, no-wrap
msgid "*publish* (write) and *subscribe* to (read) streams of events, called _records_.\n"
msgstr "_レコード_ と呼ばれるイベントのストリームを *発行* （書き込み）したり、 *購読* （読み込み）したりすることができます。\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:25
#, no-wrap
msgid "*store* streams of records durably and reliably inside _topics_.\n"
msgstr "記録のストリームを _トピック_ 内に永続的かつ確実に *保存し*ます。\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:26
#, no-wrap
msgid "*process* streams of records as they occur or retrospectively.\n"
msgstr "記録のストリームを発生時または遡及的に *処理* します。\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:28
msgid "And all this functionality is provided in a distributed, highly scalable, elastic, fault-tolerant, and secure manner."
msgstr "そして、これらの機能はすべて、分散型で、拡張性が高く、弾力性があり、耐障害性があり、安全な方法で提供されます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:29
#, no-wrap
msgid "Quarkus Extension for Apache Kafka"
msgstr "Apache KafkaのためのQuarkus Extension"

#. type: Plain text
#: upstream/_guides/kafka.adoc:33
#, fuzzy
msgid "Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.  Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven."
msgstr "Quarkusは、 link:https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging]フレームワークを通じて、Apache Kafkaのサポートを提供しています。Eclipse MicroProfile Reactive Messaging specification 2.0をベースに、CDIとイベントドリブンの架け橋となる柔軟なプログラミングモデルを提案しています。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:38
#, fuzzy
msgid "This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.  For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka]."
msgstr "このガイドでは、Apache KafkaとSmallRye Reactive Messagingフレームワークについて詳しく説明しています。クイックスタートについては、 link:kafka-reactive-getting-started.html[「Getting Started to SmallRye Reactive Messaging with Apache Kafka]」をご覧ください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:41
#, fuzzy
msgid "You can add the `smallrye-reactive-messaging-kafka` extensions to your project by running the following command in your project base directory:"
msgstr "プロジェクトのベースディレクトリで以下のコマンドを実行することで、 `smallrye-reactive-messaging-kafka` のエクステンションをプロジェクトに追加することができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:46
msgid "This will add the following to your build file:"
msgstr "これにより、 `pom.xml` に以下が追加されます:"

#. type: Block title
#: upstream/_guides/kafka.adoc:48 upstream/_guides/kafka.adoc:1313
#: upstream/_guides/kafka.adoc:1560 upstream/_guides/kafka.adoc:1628
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:54
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"

#. type: Block title
#: upstream/_guides/kafka.adoc:57 upstream/_guides/kafka.adoc:1322
#: upstream/_guides/kafka.adoc:1569 upstream/_guides/kafka.adoc:1638
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:60
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-smallrye-reactive-messaging-kafka\")\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:65
#, fuzzy
msgid "The extension includes `kafka-clients` version 3.1.0 as a transitive dependency and is compatible with Kafka brokers version 2.x."
msgstr "この拡張機能には、 `kafka-clients` バージョン 3.1.0 が推移依存関係として含まれており、Kafka ブローカー バージョン 2.x と互換性があります。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:67
#, no-wrap
msgid "Configuring Smallrye Kafka Connector"
msgstr "Smallrye Kafka コネクターの設定"

#. type: Plain text
#: upstream/_guides/kafka.adoc:70
#, fuzzy
msgid "Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:"
msgstr "SmallryeのReactive Messagingフレームワークは、Apache Kafka、AMQP、Apache Camel、JMS、MQTTなど、さまざまなメッセージングバックエンドをサポートしているため、汎用的な語彙を採用しています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:72
#, fuzzy
msgid "Applications send and receive *messages*. A message wraps a _payload_ and can be extended with some _metadata_. With the Kafka connector, a _message_ corresponds to a Kafka _record_."
msgstr "アプリケーションは、 *メッセージ*を送受信します。メッセージは _ペイロード_を包み、いくつかの _メタデータ_で拡張することができます。Kafka コネクタでは、 _メッセージ_は Kafka _レコード_に対応します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:73
#, fuzzy
msgid "Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Kafka connector maps _channels_ to Kafka _topics_."
msgstr "メッセージは *チャネル*を通過します。アプリケーションコンポーネントは、チャネルに接続してメッセージを公開・消費します。Kafkaコネクターは、 _チャンネル_をKafka _トピック_にマッピングします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:74
#, fuzzy
msgid "Channels are connected to message backends using *connectors*. Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. Each connector is dedicated to a specific messaging technology. For example, the connector dealing with Kafka is named `smallrye-kafka`."
msgstr "チャンネルは、 *コネクタ*を使ってメッセージバックエンドに接続されます。コネクタは、受信メッセージを特定のチャネル（アプリケーションで消費される）にマッピングし、特定のチャネルに送信される送信メッセージを収集するように構成されます。各コネクターは、特定のメッセージング技術に特化しています。たとえば、Kafka を扱うコネクターは `smallrye-kafka` と名付けられています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:76
#, fuzzy
msgid "A minimal configuration for the Kafka connector with an incoming channel looks like the following:"
msgstr "受信チャンネルを持つKafkaコネクタの最小構成は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:81
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:85
#, fuzzy
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.  In dev mode and when running tests, <<kafka-dev-services>> automatically starts a Kafka broker.  When not provided this property defaults to `localhost:9092`."
msgstr "本番用プロファイルのブローカーロケーションを設定します。グローバルに、または `mp.messaging.incoming.$channel.bootstrap.servers` プロパティを使用してチャネルごとに構成することができます。開発モードやテストの実行時には、 link:kafka-dev-services.html[Dev Services for Kafka]は自動的に Kafka ブローカーを起動します。提供されていない場合、このプロパティのデフォルトは `localhost:9092` です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:86
#, fuzzy
msgid "Configure the connector to manage the prices channel. By default the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "価格チャンネルを管理するためのコネクタを設定します。デフォルトでは、トピック名はチャネル名と同じです。トピック属性を設定して、これを上書きすることができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:88
#, fuzzy
msgid "The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details."
msgstr "`%prod` は、アプリケーションがprodモードで実行されている場合にのみ使用されるプロパティであることを示しています（devやtestでは使用されません）。詳細については、 link:config-reference.html#profiles[Profile のドキュメント]を参照してください。"

#. type: Block title
#: upstream/_guides/kafka.adoc:90
#, fuzzy, no-wrap
msgid "Connector auto-attachment"
msgstr "コネクタの自動着脱"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:95
#, fuzzy
msgid "If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer."
msgstr "クラスパス上に単一のコネクタがある場合は、 `connector` 属性の設定を省略することができます。Quarkusは、 _オーファンチャンネル_をクラスパス上にある（一意の）コネクタに自動的に関連付けます。 _オーファンチャンネル_とは、下流の消費者がいない発信チャンネル、または上流の生産者がいない着信チャンネルのことです。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:97
#, fuzzy
msgid "This auto-attachment can be disabled using:"
msgstr "このオートアタッチは、以下の方法で無効にすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:101
#, no-wrap
msgid "quarkus.reactive-messaging.auto-connector-attachment=false\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:104
#, no-wrap
msgid "Receiving messages from Kafka"
msgstr "Kafkaからのメッセージの受信"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:107
#, fuzzy
msgid "Continuing from the previous minimal configuration, your Quarkus application can receive message payload directly:"
msgstr "前述の最小構成と同様に、Quarkusアプリケーションはメッセージのペイロードを直接受け取ることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:111 upstream/_guides/kafka.adoc:1991
#: upstream/_guides/kafka.adoc:2071
#, fuzzy, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:113 upstream/_guides/kafka.adoc:1006
#: upstream/_guides/kafka.adoc:1053 upstream/_guides/kafka.adoc:1076
#: upstream/_guides/kafka.adoc:1217 upstream/_guides/kafka.adoc:2069
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr "import javax.enterprise.context.ApplicationScoped;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:116
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceConsumer {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:121
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    public void consume(double price) {\n"
"        // process your price.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:123 upstream/_guides/kafka.adoc:270
#: upstream/_guides/kafka.adoc:571 upstream/_guides/kafka.adoc:597
#: upstream/_guides/kafka.adoc:725 upstream/_guides/kafka.adoc:1066
#: upstream/_guides/kafka.adoc:1094 upstream/_guides/kafka.adoc:1178
#: upstream/_guides/kafka.adoc:1236 upstream/_guides/kafka.adoc:1623
#: upstream/_guides/kafka.adoc:1703 upstream/_guides/kafka.adoc:1979
#: upstream/_guides/kafka.adoc:2059 upstream/_guides/kafka.adoc:2087
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:126
#, fuzzy
msgid "There are several other ways your application can consume incoming messages:"
msgstr "この他にも、アプリケーションが受信メッセージを利用する方法はいくつかあります。"

#. type: Block title
#: upstream/_guides/kafka.adoc:127
#, fuzzy, no-wrap
msgid "Message"
msgstr "メッセージ"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:139
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consume(Message<Double> msg) {\n"
"    // access record metadata\n"
"    var metadata = msg.getMetadata(IncomingKafkaRecordMetadata.class).orElseThrow();\n"
"    // process the message payload.\n"
"    double price = msg.getPayload();\n"
"    // Acknowledge the incoming message (commit the offset)\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:143
#, fuzzy
msgid "The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.  We'll explore different acknowledgment strategies in <<commit-strategies>>."
msgstr "`Message` タイプでは、消費側のメソッドが受信メッセージのメタデータにアクセスし、確認応答を手動で処理することができます。確認応答の方法については、 link:#commit-strategies[[commit-strategies]]で説明します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:145
#, fuzzy
msgid "If you want to access the Kafka record objects directly, use:"
msgstr "Kafkaのレコードオブジェクトに直接アクセスしたい場合は"

#. type: Block title
#: upstream/_guides/kafka.adoc:146
#, fuzzy, no-wrap
msgid "ConsumerRecord"
msgstr "コンシューマーレコード"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:157
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(ConsumerRecord<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"    String topic = record.topic();\n"
"    int partition = record.partition();\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:161
#, fuzzy
msgid "`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.  Another simpler approach consists in using `Record`:"
msgstr "`ConsumerRecord` は、基盤となる Kafka クライアントが提供するもので、コンシューマー・メソッドに直接注入することができます。もう一つのシンプルな方法は、 `Record` を使用することです。"

#. type: Block title
#: upstream/_guides/kafka.adoc:162
#, fuzzy, no-wrap
msgid "Record"
msgstr "レコード"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:170
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(Record<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:173
#, fuzzy
msgid "`Record` is a simple wrapper around key and payload of the incoming Kafka record."
msgstr "`Record` は、受信したKafkaレコードのキーとペイロードのシンプルなラッパーです。"

#. type: Block title
#: upstream/_guides/kafka.adoc:174
#, fuzzy, no-wrap
msgid "@Channel"
msgstr "＠チャンネル"

#. type: Plain text
#: upstream/_guides/kafka.adoc:177
#, fuzzy
msgid "Alternatively, your application can inject a `Multi` in your bean and subscribe to its events as the following example:"
msgstr "あるいは、次の例のように、アプリケーションがBeanに `Multi` を注入し、そのイベントを購読することもできます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:182
#, fuzzy, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
msgstr ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:189
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"
msgstr ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:192 upstream/_guides/kafka.adoc:806
#: upstream/_guides/kafka.adoc:851 upstream/_guides/kafka.adoc:887
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:196
#, fuzzy, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"prices\")\n"
"    Multi<Double> prices;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:205
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/prices\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(\"text/plain\")\n"
"    public Multi<Double> stream() {\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:209
#, fuzzy
msgid "This is a good example of how to integrate a Kafka consumer with another downstream, in this example exposing it as a Server-Sent Events endpoint."
msgstr "これは、Kafkaコンシューマーを別のダウンストリームと統合する方法の良い例で、この例ではServer-Sent Eventsエンドポイントとして公開しています。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:215
#, fuzzy
msgid "When consuming messages with `@Channel`, the application code is responsible for the subscription.  In the example above, RESTEasy endpoint handles that for you."
msgstr "`@Channel` でメッセージを消費する場合、アプリケーション・コードがサブスクリプションを担当します。上記の例では、RESTEasyのエンドポイントがそれを代行しています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:218
#, fuzzy
msgid "Following types can be injected as channels:"
msgstr "以下のタイプは、チャンネルとして注入することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:222
#, fuzzy, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Double> streamOfPayloads;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:224
#, fuzzy, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Message<Double>> streamOfMessages;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:226
#, fuzzy, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Double> publisherOfPayloads;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:228
#, fuzzy, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Message<Double>> publisherOfMessages;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:233
#, fuzzy
msgid "As with the previous `Message` example, if your injected channel receives payloads (`Multi<T>`), it acknowledges the message automatically, and support multiple subscribers.  If you injected channel receives Message (`Multi<Message<T>>`), you will be responsible for the acknowledgment and broadcasting.  We will explore sending broadcast messages in <<broadcasting-messages-on-multiple-consumers>>."
msgstr "前述の `Message` の例と同様に、注入したチャンネルがペイロード ( `Multi<T>`) を受信した場合、メッセージを自動的に確認し、複数のサブスクライバをサポートします。注入されたチャンネルがメッセージ( `Multi<Message<T>>`)を受信した場合は、確認応答とブロードキャストを担当します。ブロードキャストメッセージの送信については、 link:#broadcasting-messages-on-multiple-consumers[[broadcasting-messages-on-multiple-consumers]]で説明します。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:238
#, fuzzy
msgid "Injecting `@Channel(\"prices\")` or having `@Incoming(\"prices\")` does not automatically configure the application to consume messages from Kafka.  You need to configure an inbound connector with `mp.messaging.incoming.prices\\...` or have an `@Outgoing(\"prices\")` method somewhere in your application (in which case, `prices` will be an in-memory channel)."
msgstr "`@Channel(\"prices\")` をインジェクトしたり `@Incoming(\"prices\")` を持っていても、アプリケーションが自動的に Kafka からのメッセージを消費するようにはなりません。 `mp.messaging.incoming.prices...` でインバウンドコネクターを設定するか、アプリケーションのどこかに `@Outgoing(\"prices\")` メソッドを用意する必要があります（その場合、 `prices` はインメモリーチャンネルになります）。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:241
#, no-wrap
msgid "Blocking processing"
msgstr "ブロッキング処理"

#. type: Plain text
#: upstream/_guides/kafka.adoc:247
#, fuzzy
msgid "Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread."
msgstr "Reactive Messagingは、I/Oスレッド上でメソッドを呼び出します。このトピックの詳細については、 link:quarkus-reactive-architecture.html[Quarkus Reactive Architectureのドキュメント]を参照してください。しかし、Reactive Messagingをデータベースとのやりとりなどのブロック処理と組み合わせる必要があることがよくあります。そのためには、処理が _ブロッキング_であり、呼び出し元のスレッドで実行すべきではないことを示す `@Blocking` アノテーションを使用する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:249
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "例えば、以下のコードは、Hibernate with Panacheを 使用してデータベースに受信ペイロードを格納する方法を示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:254
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:257 upstream/_guides/kafka.adoc:1989
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"
msgstr ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:260
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:268
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:273
msgid "The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr "完全な例は `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[ディレクトリー] にあります。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:277
msgid "There are 2 `@Blocking` annotations:"
msgstr "`@Blocking` アノテーションは 2 つあります。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:279
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:280
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:285
#, fuzzy
msgid "They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr "両者は同じ効果を持っています。したがって、両方を使うことができます。1つ目の方法は、使用するワーカープールや順序を保持するかどうかなど、より細かい調整が可能です。2つ目の方法は、Quarkusの他のリアクティブ機能と併用され、デフォルトのワーカープールを使用し、順序を保持します。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:287
#, fuzzy
msgid "Detailed information on the usage of `@Blocking` annotation can be found in https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging – Handling blocking execution]."
msgstr "`@Blocking` アノテーションの使い方の詳細は、 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/advanced/blocking.html[SmallRye Reactive Messaging - Handling blocking execution]に記載されています。"

#. type: Block title
#: upstream/_guides/kafka.adoc:290
#, fuzzy, no-wrap
msgid "@Transactional"
msgstr "トランザクショナル"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:293
#, fuzzy
msgid "If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`."
msgstr "あなたのメソッドが `@Transactional` でアノテーションされていれば、そのメソッドが `@Blocking` でアノテーションされていなくても、自動的に _ブロッキング_とみなされます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:295
#, no-wrap
msgid "Acknowledgment Strategies"
msgstr "確認戦略"

#. type: Plain text
#: upstream/_guides/kafka.adoc:303
#, fuzzy
msgid "All messages received by a consumer must be acknowledged.  In the absence of acknowledgment, the processing is considered in error.  If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.  If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.  You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`), or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:"
msgstr "コンシューマが受信したすべてのメッセージは、確認されなければなりません。確認応答がない場合、その処理はエラーとみなされます。コンシューマ・メソッドが `Record` またはペイロードを受信した場合、メッセージはメソッドのリターン時にアックされます（ `Strategy.POST_PROCESSING` としても知られています）。コンシューマ・メソッドが別のリアクティブ・ストリームまたは `CompletionStage` を返す場合は、下流のメッセージがアックされたときにメッセージがアックされます。次の例のように、コンシューマ・メソッドで、デフォルトの動作をオーバーライドして、メッセージが到着したときにアックするようにしたり（ `Strategy.PRE_PROCESSING` ）、メッセージをまったくアックしないようにすることもできます（ `Strategy.NONE` ）。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:311
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"@Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING)\n"
"public void process(double price) {\n"
"    // process price\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:315
#, fuzzy
msgid "If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL` and the consumer method is in charge of ack/nack the message."
msgstr "コンシューマ・メソッドが `Message` を受信した場合、確認応答戦略は `Strategy.MANUAL` であり、コンシューマ・メソッドはメッセージの ack/nack を担当します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:323
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> process(Message<Double> msg) {\n"
"    // process price\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:326
#, fuzzy
msgid "As mentioned above, the method can also override the acknowledgment strategy to `PRE_PROCESSING` or `NONE`."
msgstr "上述したように、このメソッドは、確認応答のストラテジーを `PRE_PROCESSING` または `NONE` に上書きすることもできます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:328
#, no-wrap
msgid "Commit Strategies"
msgstr "コミット戦略"

#. type: Plain text
#: upstream/_guides/kafka.adoc:334
#, fuzzy
msgid "When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.  These strategies decide when the consumer offset for a specific topic/partition is committed.  Committing an offset indicates that all previous records have been processed.  It is also the position where the application would restart the processing after a crash recovery or a restart."
msgstr "Kafka レコードから生成されたメッセージが確認されると、コネクタはコミット戦略を呼び出します。これらのストラテジーは、特定のトピック/パーティションのコンシューマ・オフセットをいつコミットするかを決定します。オフセットのコミットは、以前のレコードがすべて処理されたことを示します。また、クラッシュ・リカバリーや再起動後に、アプリケーションが処理を再開する位置でもあります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:337
#, fuzzy
msgid "Committing every offset has performance penalties as Kafka offset management can be slow.  However, not committing the offset often enough may lead to message duplication if the application crashes between two commits."
msgstr "すべてのオフセットをコミットすると、Kafkaのオフセット管理が遅くなることがあるため、パフォーマンス上のペナルティがあります。しかし、オフセットのコミットを頻繁に行わないと、2回のコミットの間にアプリケーションがクラッシュした場合、メッセージの重複が発生する可能性があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:339
#, fuzzy
msgid "The Kafka connector supports three strategies:"
msgstr "Kafkaコネクターは、3つの戦略をサポートしています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:348
#, fuzzy
msgid "`throttled` keeps track of received messages and commits an offset of the latest acked message in sequence (meaning, all previous messages were also acked).  This strategy guarantees at-least-once delivery even if the channel performs asynchronous processing.  The connector tracks the received records and periodically (period specified by `auto.commit.interval.ms`, default: 5000 ms) commits the highest consecutive offset.  The connector will be marked as unhealthy if a message associated with a record is not acknowledged in `throttled.unprocessed-record-max-age.ms` (default: 60000 ms).  Indeed, this strategy cannot commit the offset as soon as a single record processing fails (see <<error-handling>> to configure what happens on failing processing).  If `throttled.unprocessed-record-max-age.ms` is set to less than or equal to `0`, it does not perform any health check verification.  Such a setting might lead to running out of memory if there are \"poison pill\" messages (that are never acked).  This strategy is the default if `enable.auto.commit` is not explicitly set to true."
msgstr "`throttled` は、受信したメッセージを追跡し、順に最新のアックされたメッセージのオフセットをコミットします（つまり、前のメッセージもすべてアックされています）。この戦略により、チャネルが非同期処理を行う場合でも、at-least-once 配信が保証されます。コネクタは受信したレコードを追跡し、定期的に（周期は `auto.commit.interval.ms` で指定、デフォルトは 5000 ミリ秒）、連続した最高のオフセットをコミットします。レコードに関連するメッセージが `throttled.unprocessed-record-max-age.ms` （デフォルト：60000 ms）で確認されない場合、コネクタは不健全であるとマークされます。実際、この戦略では、単一のレコード処理が失敗するとすぐにオフセットをコミットすることはできません（処理が失敗したときに何が起こるかを設定するには、 link:#error-handling[[error-handling]]を参照してください）。 `throttled.unprocessed-record-max-age.ms` が `0` 以下に設定されている場合は、ヘルスチェックの検証を行いません。このような設定をすると、（決してアックされない）「毒薬」のようなメッセージがあった場合に、メモリ不足に陥る可能性があります。 `enable.auto.commit` が明示的に true に設定されていない場合、この戦略がデフォルトとなります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:352
#, fuzzy
msgid "`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).  This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.  This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates."
msgstr "`latest` は、関連するメッセージが確認されると同時に、Kafka コンシューマーが受け取ったレコードオフセットをコミットします（オフセットが以前にコミットされたオフセットよりも大きい場合）。この戦略は、チャネルが非同期処理を行わずにメッセージを処理する場合、at-least-once配信を提供します。この戦略は、オフセットのコミットにコストがかかるため、高負荷環境では使用すべきではありません。ただし、重複のリスクは軽減されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:358
#, fuzzy
msgid "`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.  It delegates the offset commit to the underlying Kafka client.  When `enable.auto.commit` is `true` this strategy **DOES NOT** guarantee at-least-once delivery.  SmallRye Reactive Messaging processes records asynchronously, so offsets may be committed for records that have been polled but not yet processed.  In case of a failure, only records that were not committed yet will be re-processed."
msgstr "`ignore` はコミットを行いません。この戦略は、コンシューマーが `enable.auto.commit` を true にして明示的に構成されている場合のデフォルト戦略です。この戦略は、オフセットのコミットを基礎となる Kafka クライアントに委ねます。 `enable.auto.commit` が `true` の場合、この戦略は at-least-once の配信を保証し *ませ*ん。SmallRyeのReactive Messagingはレコードを非同期に処理するため、ポーリングされたがまだ処理されていないレコードに対してオフセットがコミットされることがあります。障害が発生した場合は、まだコミットされていないレコードのみが再処理されます。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:363
#, fuzzy
msgid "The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.  If high throughput is important for you, and you are not limited by the downstream, we recommend to either:"
msgstr "Kafkaコネクターは、Kafkaの自動コミットが明示的に有効になっていない場合、それを無効にします。この動作は、従来のKafkaコンシューマーとは異なります。高いスループットが重要で、ダウンストリームに制限されない場合は、次のいずれかを推奨します。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:365
#, fuzzy
msgid "use the `throttled` policy,"
msgstr "は、 `throttled` のポリシーを使用します。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:366
#, fuzzy
msgid "or set `enable.auto.commit` to true and annotate the consuming method with `@Acknowledgment(Acknowledgment.Strategy.NONE)`."
msgstr "または、 `enable.auto.commit` を true に設定し、Consuming メソッドに `@Acknowledgment(Acknowledgment.Strategy.NONE)` をアノテートします。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:369
#, no-wrap
msgid "Error Handling Strategies"
msgstr "エラー処理戦略"

#. type: Plain text
#: upstream/_guides/kafka.adoc:372
#, fuzzy
msgid "If a message produced from a Kafka record is nacked, a failure strategy is applied. The Kafka connector supports three strategies:"
msgstr "Kafka レコードから生成されたメッセージがナッキングされた場合、失敗ストラテジーが適用されます。Kafkaコネクターは3つの戦略をサポートしています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:374
#, fuzzy
msgid "`fail`: fail the application, no more records will be processed (default strategy). The offset of the record that has not been processed correctly is not committed."
msgstr "`fail`: アプリケーションを失敗させ、それ以上のレコードは処理されません（デフォルトの戦略）。正しく処理されなかったレコードのオフセットはコミットされません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:375
#, fuzzy
msgid "`ignore`: the failure is logged, but the processing continue. The offset of the record that has not been processed correctly is committed."
msgstr "`ignore`: 失敗が記録されますが、処理は続行されます。正しく処理されなかったレコードのオフセットがコミットされます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:376
#, fuzzy
msgid "`dead-letter-queue`: the offset of the record that has not been processed correctly is committed, but the record is written to a Kafka dead letter topic."
msgstr "`dead-letter-queue`: 正しく処理されなかったレコードのオフセットはコミットされますが、レコードはKafkaのデッドレタートピックに書き込まれます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:378
#, fuzzy
msgid "The strategy is selected using the `failure-strategy` attribute."
msgstr "戦略は `failure-strategy` 属性を使って選択されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:380
#, fuzzy
msgid "In the case of `dead-letter-queue`, you can configure the following attributes:"
msgstr "`dead-letter-queue` の場合は、以下の属性を設定することができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:382
#, fuzzy
msgid "`dead-letter-queue.topic`: the topic to use to write the records not processed correctly, default is `dead-letter-topic-$channel`, with `$channel` being the name of the channel."
msgstr "`dead-letter-queue.topic`: 正しく処理されなかったレコードを書き込むために使用するトピック。デフォルトは `dead-letter-topic-$channel` で、 `$channel` はチャンネルの名前です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:383
#, fuzzy
msgid "`dead-letter-queue.key.serializer`: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer."
msgstr "`dead-letter-queue.key.serializer`: レコードキーをデッドレターキューに書き込む際に使用するシリアライザ。デフォルトでは、キーデシリアライザからシリアライザを推測します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:384
#, fuzzy
msgid "`dead-letter-queue.value.serializer`: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer."
msgstr "`dead-letter-queue.value.serializer`: レコード値をデッドレターキューに書き込む際に使用するシリアライザ。デフォルトでは、値のデシリアライザからシリアライザを推測します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:386
#, fuzzy
msgid "The record written on the dead letter queue contains a set of additional headers about the original record:"
msgstr "デッドレターキューに書き込まれたレコードには、元のレコードに関する一連の追加ヘッダーが含まれています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:388
#, fuzzy, no-wrap
msgid "*dead-letter-reason*: the reason of the failure\n"
msgstr "*dead-letter-reason*: 失敗の理由"

#. type: Plain text
#: upstream/_guides/kafka.adoc:389
#, fuzzy, no-wrap
msgid "*dead-letter-cause*: the cause of the failure if any\n"
msgstr "*dead-letter-cause*: 失敗の原因（もしあれば）。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:390
#, fuzzy, no-wrap
msgid "*dead-letter-topic*: the original topic of the record\n"
msgstr "*dead-letter-topic*: レコードのオリジナルトピック"

#. type: Plain text
#: upstream/_guides/kafka.adoc:391
#, fuzzy, no-wrap
msgid "*dead-letter-partition*: the original partition of the record (integer mapped to String)\n"
msgstr "*dead-letter-partition*: レコードの元のパーティション（Stringにマッピングされた整数）。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:392
#, fuzzy, no-wrap
msgid "*dead-letter-offset*: the original offset of the record (long mapped to String)\n"
msgstr "*dead-letter-offset*: レコードのオリジナルのオフセット（Stringにロングマッピングされています。）"

#. type: Title ====
#: upstream/_guides/kafka.adoc:393
#, fuzzy, no-wrap
msgid "Retrying processing"
msgstr "ブロッキング処理"

#. type: Plain text
#: upstream/_guides/kafka.adoc:396
#, fuzzy
msgid "You can combine Reactive Messaging with https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance], and retry processing if it failed:"
msgstr "Reactive Messagingと link:https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance]を組み合わせて、失敗しても処理をやり直すことができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:404
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"public void consume(String v) {\n"
"   // ... retry if this method throws an exception\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:407
#, fuzzy
msgid "You can configure the delay, the number of retries, the jitter, etc."
msgstr "遅延時間、リトライ回数、ジッターなどを設定できます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:409
#, fuzzy
msgid "If your method returns a `Uni` or `CompletionStage`, you need to add the `@NonBlocking` annotation:"
msgstr "メソッドが `Uni` または `CompletionStage` を返す場合は、 `@NonBlocking` アノテーションを追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:418
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"@NonBlocking\n"
"public Uni<String> consume(String v) {\n"
"   // ... retry if this method throws an exception or the returned Uni produce a failure\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:423
#, fuzzy
msgid "The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.  Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.  See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information."
msgstr "`@NonBlocking` のアノテーションは、SmallRye Fault Tolerance 5.1.0 以前でのみ必要です。SmallRye Fault Tolerance 5.2.0（Quarkus 2.1.0.Final以降で利用可能）からは必要ありません。詳細については、 link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Toleranceのドキュメント]を参照してください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:427
#, fuzzy
msgid "The incoming messages are acknowledged only once the processing completes successfully.  So, it commits the offset after the successful processing.  If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied."
msgstr "受信したメッセージは、処理が正常に完了して初めて確認されます。そのため，処理が成功した後にオフセットをコミットします。リトライを繰り返しても処理が失敗した場合は、メッセージは _ナッキングさ_れ、失敗戦略が適用されます。"

#. type: Title ====
#: upstream/_guides/kafka.adoc:428
#, fuzzy, no-wrap
msgid "Handling Deserialization Failures"
msgstr "デシリアライズ失敗の処理"

#. type: Plain text
#: upstream/_guides/kafka.adoc:432
#, fuzzy
msgid "When a deserialization failure occurs, you can intercept it and provide a failure strategy.  To achieve this, you need to create a bean implementing `DeserializationFailureHandler<T>` interface:"
msgstr "デシリアライズの失敗が発生した場合、それをインターセプトして失敗戦略を提供することができます。これを実現するには、 `DeserializationFailureHandler<T>` インターフェースを実装したBeanを作成する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:439
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"failure-retry\") // Set the name of the failure handler\n"
"public class MyDeserializationFailureHandler\n"
"    implements DeserializationFailureHandler<JsonObject> { // Specify the expected type\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:448
#, no-wrap
msgid ""
"    @Override\n"
"    public JsonObject decorateDeserialization(Uni<JsonObject> deserialization, String topic, boolean isKey,\n"
"            String deserializer, byte[] data, Headers headers) {\n"
"        return deserialization\n"
"                    .onFailure().retry().atMost(3)\n"
"                    .await().atMost(Duration.ofMillis(200));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:451
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (for key or value deserializers)."
msgstr "この失敗ハンドラを使用するには，Beanを `@Identifier` qualifierで公開し，コネクタ構成で属性 `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (キーまたは値のデシリアライザ用)を指定する必要がある。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:454
#, fuzzy
msgid "The handler is called with details of the deserialization, including the action represented as `Uni<T>`.  On the deserialization `Uni` failure strategies like retry, providing a fallback value or applying timeout can be implemented."
msgstr "ハンドラは、 `Uni<T>` として表されるアクションを含むデシリアライゼーションの詳細とともに呼び出されます。デシリアライゼーション `Uni` リトライ、フォールバック値の提供、タイムアウトの適用などの失敗戦略を実装することができます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:455
#, fuzzy, no-wrap
msgid "Consumer Groups"
msgstr "消費者団体"

#. type: Plain text
#: upstream/_guides/kafka.adoc:462
#, fuzzy
msgid "In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.  A topic is divided into a set of partitions.  The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.  Note that each partition is assigned to a single consumer from a group.  However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group."
msgstr "Kafkaでは、コンシューマーグループとは、あるトピックからデータを消費するために協力するコンシューマーの集合を指します。トピックは複数のパーティションに分割されます。トピックのパーティションは、グループ内のコンシューマーに割り当てられ、消費スループットを効果的に拡大することができます。各パーティションは、グループ内の1つのコンシューマに割り当てられます。ただし、パーティションの数がグループ内の消費者の数よりも多い場合は、消費者に複数のパーティションを割り当てることができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:464
#, fuzzy
msgid "Let's explore briefly different producer/consumer patterns and how to implement them using Quarkus:"
msgstr "ここでは、さまざまなProducer/Consumerパターンと、それらをQuarkusで実装する方法について簡単に説明します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:466
#, fuzzy, no-wrap
msgid "*Single consumer thread inside a consumer group*\n"
msgstr "*コンシューマグループ内の単一のコンシューマースレッド*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:470
#, fuzzy
msgid "This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.  Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.  It can also be set using the `kafka.group.id` property."
msgstr "これは、アプリケーションがKafkaトピックを購読する際のデフォルトの動作です。各Kafkaコネクターは、1つのコンシューマースレッドを作成し、1つのコンシューマグループ内に配置します。コンシューマグループIDのデフォルトは、 `quarkus.application.name` 構成プロパティで設定されたアプリケーション名です。また、 `kafka.group.id` プロパティを使用して設定することもできます。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka.adoc:471 upstream/_guides/kafka.adoc:479
#: upstream/_guides/kafka.adoc:486 upstream/_guides/kafka.adoc:494
#, no-wrap
msgid "Architecture,"
msgstr "アーキテクチャー"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:471
#, no-wrap
msgid "kafka-one-app-one-consumer.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:474
#, fuzzy, no-wrap
msgid "*Multiple consumer threads inside a consumer group*\n"
msgstr "*コンシューマグループ内の複数のコンシューマースレッド*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:478
#, fuzzy
msgid "For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.partitions` property.  The partitions of the subscribed topic will be divided among the consumer threads.  Note that if the `partitions` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions."
msgstr "特定のアプリケーション・インスタンスに対して、コンシューマ・グループ内のコンシューマの数は、 `mp.messaging.incoming.$channel.partitions` プロパティを使用して構成できます。サブスクライブされたトピックのパーティションは、各コンシューマースレッドに分割されます。 `partitions` の値がトピックのパーティション数を超える場合、一部のコンシューマースレッドにはパーティションが割り当てられませんのでご注意ください。"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:479
#, no-wrap
msgid "kafka-one-app-two-consumers.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:482
#, fuzzy, no-wrap
msgid "*Multiple consumer applications inside a consumer group*\n"
msgstr "*消費者グループ内の複数の消費者アプリケーション*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:485
#, fuzzy
msgid "Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.  This in turn will divide partitions of the topic among application instances."
msgstr "前述の例と同様に、アプリケーションの複数のインスタンスは、 `mp.messaging.incoming.$channel.group.id` プロパティを介して設定された単一のコンシューマ・グループを購読することができます。また、デフォルトではアプリケーション名が設定されます。これにより、アプリケーションのインスタンス間でトピックのパーティションが分割されます。"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:486
#, no-wrap
msgid "kafka-two-app-one-consumer-group.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:489
#, fuzzy, no-wrap
msgid "*Pub/Sub: Multiple consumer groups subscribed to a topic*\n"
msgstr "*Pub/Sub: 1つのトピックに複数の消費者グループがサブスクライブしている状態*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:493
#, fuzzy
msgid "Lastly different applications can subscribe independently to same topics using different *consumer group ids*.  For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.  Different consumer groups can thus scale independently according to the message consumption requirements."
msgstr "最後に、異なるアプリケーションは、異なる *コンシューマグループID*を使用して、同じトピックを独立して購読できます。例えば、 _orders_というトピックに発行されたメッセージは、 `mp.messaging.incoming.orders.group.id=invoicing` と `mp.messaging.incoming.orders.group.id=shipping` の2つのコンシューマ・アプリケーションで独立して消費することができます。このように、異なるコンシューマグループは、メッセージ消費の要求に応じて独立して拡張することができます。"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:494
#, no-wrap
msgid "kafka-two-app-two-consumer-groups.png"
msgstr ""

#. type: Title ====
#: upstream/_guides/kafka.adoc:496
#, fuzzy, no-wrap
msgid "Consumer Rebalance Listener"
msgstr "コンシューマー・リバランス・リスナー"

#. type: Plain text
#: upstream/_guides/kafka.adoc:503
#, fuzzy
msgid "Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.  This is known as rebalancing the group.  To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.  To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.  A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset."
msgstr "消費者グループ内では、新しいグループメンバーが到着し、古いメンバーが退出すると、各メンバーがパーティションの比例配分を受けられるように、パーティションが再割り当てされます。これを「グループのリバランス」と呼びます。オフセット・コミットと割り当てられたパーティションを自分で処理するには、コンシューマー・リバランシング・リスナーを提供します。これを実現するには、 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` インターフェイスを実装し、 `@Idenfier` 修飾子を付けて CDI Bean として公開します。一般的な使用例としては、 exactly-once セマンティックを実装するためにオフセットを別のデータストアに格納したり、特定のオフセットで処理を開始したりします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:507
#, fuzzy
msgid "The listener is invoked every time the consumer topic/partition assignment changes.  For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.  If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic."
msgstr "このリスナーは、コンシューマのトピック/パーティションの割り当てが変更されるたびに呼び出されます。たとえば、アプリケーションの起動時には、コンシューマに関連付けられたトピック/パーティションの初期セットを使用して、 `partitionsAssigned` コールバックが呼び出されます。その後、このセットが変更されると、 `partitionsRevoked` と `partitionsAssigned` のコールバックが再び呼び出されるので、カスタムロジックを実装することができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:510
#, fuzzy
msgid "Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.  That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier."
msgstr "なお、リバランスリスナーのメソッドはKafkaのポーリングスレッドから呼び出され、完了するまで呼び出し元のスレッドをブロックし *ます*。これは、リバランスプロトコルには同期バリアがあり、リバランスリスナーで非同期コードを使用すると、同期バリアの後に実行される可能性があるためです。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:512
#, fuzzy
msgid "When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and resumes once the rebalance completes."
msgstr "コンシューマからトピックやパーティションが割り当てられたり、取り消されたりすると、メッセージの配信が一時停止し、リバランスが完了すると再開されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:516
#, fuzzy
msgid "If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy), the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.  We also recommend applying the same logic when the application stops."
msgstr "リバランス・リスナーがユーザーに代わってオフセットのコミットを処理する場合（ `NONE` コミット戦略を使用）、リバランス・リスナーはpartitionsRevokedコールバックでオフセットを同期的にコミットする必要があります。また、アプリケーションの停止時にも同様のロジックを適用することをお勧めします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:518
#, fuzzy
msgid "Unlike the `ConsumerRebalanceListener` from Apache Kafka, the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` methods pass the Kafka Consumer and the set of topics/partitions."
msgstr "Apache Kafkaの `ConsumerRebalanceListener` とは異なり、 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` のメソッドは、Kafka Consumerとトピック/パーティションのセットを渡します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:522
#, fuzzy
msgid "In the following example we set-up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).  First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.  We then must configure our inbound connector to use this bean."
msgstr "以下の例では、最大10分前(またはオフセット0)のメッセージに対して常に起動するコンシューマを設定します。まず、 `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` を実装し、 `io.smallrye.common.annotation.Identifier` でアノテーションされたビーンを提供する必要があります。次に、このBeanを使用するように、受信コネクタを構成する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:526 upstream/_guides/kafka.adoc:576
#, no-wrap
msgid "package inbound;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:532
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n"
"import org.apache.kafka.clients.consumer.Consumer;\n"
"import org.apache.kafka.clients.consumer.OffsetAndTimestamp;\n"
"import org.apache.kafka.clients.consumer.TopicPartition;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:538
#, fuzzy, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.util.Collection;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
"import java.util.logging.Logger;\n"
msgstr ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:542
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"rebalanced-example.rebalancer\")\n"
"public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:544
#, no-wrap
msgid "    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:556
#, no-wrap
msgid ""
"    /**\n"
"     * When receiving a list of partitions, will search for the earliest offset within 10 minutes\n"
"     * and seek the consumer to it.\n"
"     *\n"
"     * @param consumer   underlying consumer\n"
"     * @param partitions set of assigned topic partitions\n"
"     */\n"
"    @Override\n"
"    public void onPartitionsAssigned(Consumer<?, ?> consumer, Collection<TopicPartition> partitions) {\n"
"        long now = System.currentTimeMillis();\n"
"        long shouldStartAt = now - 600_000L; //10 minute ago\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:569
#, no-wrap
msgid ""
"        Map<TopicPartition, Long> request = new HashMap<>();\n"
"        for (TopicPartition partition : partitions) {\n"
"            LOGGER.info(\"Assigned \" + partition);\n"
"            request.put(partition, shouldStartAt);\n"
"        }\n"
"        Map<TopicPartition, OffsetAndTimestamp> offsets = consumer.offsetsForTimes(request);\n"
"        for (Map.Entry<TopicPartition, OffsetAndTimestamp> position : offsets.entrySet()) {\n"
"            long target = position.getValue() == null ? 0L : position.getValue().offset();\n"
"            LOGGER.info(\"Seeking position \" + target + \" for \" + position.getKey());\n"
"            consumer.seek(position.getKey(), target);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:580
#, fuzzy, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:584
#, fuzzy, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
msgstr ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:587
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaRebalancedConsumer {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:595
#, no-wrap
msgid ""
"    @Incoming(\"rebalanced-example\")\n"
"    @Acknowledgment(Acknowledgment.Strategy.NONE)\n"
"    public CompletionStage<Void> consume(IncomingKafkaRecord<Integer, String> message) {\n"
"        // We don't need to ACK messages because in this example,\n"
"        // we set offset during consumer rebalance\n"
"        return CompletableFuture.completedFuture(null);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:601
#, fuzzy
msgid "To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"
msgstr "提供されたリスナーを使用するようにインバウンド・コネクターを設定するには、コンシューマー・リバランシング・リスナーの識別子を設定するかのどちらかです。 `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:603
#, fuzzy
msgid "Or have the listener’s name be the same as the group id:"
msgstr "または、リスナーの名前をグループIDと同じにする。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:605
#, fuzzy
msgid "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"
msgstr "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:607
#, fuzzy
msgid "Setting the consumer rebalance listener’s name takes precedence over using the group id."
msgstr "コンシューマのリバランスリスナーの名前を設定すると、グループIDの使用よりも優先されます。"

#. type: Title ====
#: upstream/_guides/kafka.adoc:608
#, fuzzy, no-wrap
msgid "Using unique consumer groups"
msgstr "ユニークな消費者グループの活用"

#. type: Plain text
#: upstream/_guides/kafka.adoc:611
#, fuzzy
msgid "If you want to process all the records from a topic (from its beginning), you need:"
msgstr "あるトピックのすべてのレコードを（その最初から）処理したい場合には"

#. type: Plain text
#: upstream/_guides/kafka.adoc:613
#, fuzzy
msgid "to set `auto.offset.reset = earliest`"
msgstr "を設定することができます。 `auto.offset.reset = earliest`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:614
#, fuzzy
msgid "assign your consumer to a consumer group not used by any other application."
msgstr "他のアプリケーションが使用していないコンシューマーグループにコンシューマーを割り当てる。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:617
#, fuzzy
msgid "Quarkus generates a UUID that changes between two executions (including in dev mode).  So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts."
msgstr "Quarkusは、2つの実行（devモードを含む）の間で変化するUUIDを生成します。そのため、他のコンシューマーが使用していないことが確認でき、アプリケーションが起動するたびに新しい一意のグループIDを受け取ることができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:619
#, fuzzy
msgid "You can use that generated UUID as the consumer group as follows:"
msgstr "その生成されたUUIDを消費者グループとして以下のように使用することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:624
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.auto.offset.reset=earliest\n"
"mp.messaging.incoming.your-channel.group.id=${quarkus.uuid}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:627
#, fuzzy
msgid "If the `group.id` attribute is not set, it defaults the `quarkus.application.name` configuration property."
msgstr "`group.id` 属性が設定されていない場合は、 `quarkus.application.name` 構成プロパティをデフォルトにします。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:628
#, fuzzy, no-wrap
msgid "Receiving Kafka Records in Batches"
msgstr "Kafkaのレコードをバッチで受け取る"

#. type: Plain text
#: upstream/_guides/kafka.adoc:632
#, fuzzy
msgid "By default, incoming methods receive each Kafka record individually.  Under the hood, Kafka consumer clients poll the broker constantly and receive records in batches, presented inside the `ConsumerRecords` container."
msgstr "デフォルトでは、受信メソッドは各Kafkaレコードを個別に受信します。フードの下では、Kafkaコンシューマークライアントがブローカーを常時ポーリングしてレコードをバッチで受信し、 `ConsumerRecords` コンテナ内に表示されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:634
#, fuzzy
msgid "In *batch* mode, your application can receive all the records returned by the consumer *poll* in one go."
msgstr "*バッチ*モードでは、アプリケーションは *コンシューマーポール*から返されたすべてのレコードを一度に受け取ることができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:636
#, fuzzy
msgid "To achieve this you need to specify a compatible container type to receive all the data:"
msgstr "これを実現するには、すべてのデータを受け取るために、互換性のあるコンテナタイプを指定する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:645
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(List<Double> prices) {\n"
"    for (double price : prices) {\n"
"        // process price\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:649
#, fuzzy
msgid "The incoming method can also receive `Message<List<Payload>>`, `KafkaRecordBatch<Key, Payload>` `ConsumerRecords<Key, Payload>` types.  They give access to record details such as offset or timestamp:"
msgstr "incomingメソッドは、 `Message<List<Payload>>`, `KafkaRecordBatch<Key, Payload>` `ConsumerRecords<Key, Payload>` タイプも受け取ることができます。これらのタイプは、オフセットやタイムスタンプなどのレコードの詳細にアクセスできます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:662
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consumeMessage(KafkaRecordBatch<String, Double> records) {\n"
"    for (KafkaRecord<String, Double> record : records) {\n"
"        String payload = record.getPayload();\n"
"        String topic = record.getTopic();\n"
"        // process messages\n"
"    }\n"
"    // ack will commit the latest offsets (per partition) of the batch.\n"
"    return records.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:667
#, fuzzy
msgid "Note that the successful processing of the incoming record batch will commit the latest offsets for each partition received inside the batch.  The configured commit strategy will be applied for these records only."
msgstr "受信したレコードバッチの処理が成功すると、バッチ内で受信した各パーティションの最新のオフセットがコミットされることに注意してください。設定されたコミット戦略は、これらのレコードにのみ適用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:669
#, fuzzy
msgid "Conversely, if the processing throws an exception, all messages are _nacked_, applying the failure strategy for all the records inside the batch."
msgstr "逆に、処理で例外が発生した場合は、すべてのメッセージが _ナッキングさ_れ、バッチ内のすべてのレコードに失敗戦略が適用されます。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:674
#, fuzzy
msgid "Quarkus autodetects batch types for incoming channels and sets batch configuration automatically.  You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batch` property."
msgstr "Quarkusは、入力されるチャンネルのバッチタイプを自動検出し、バッチ構成を自動的に設定します。 `mp.messaging.incoming.$channel.batch` プロパティでバッチモードを明示的に設定することができます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:676
#, fuzzy, no-wrap
msgid "Sending messages to Kafka"
msgstr "Kafkaからのメッセージの受信"

#. type: Plain text
#: upstream/_guides/kafka.adoc:679
#, fuzzy
msgid "Configuration for the Kafka connector outgoing channels is similar to that of incoming:"
msgstr "Kafkaコネクターの発信チャンネルの設定は、着信チャンネルの設定と同様です。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:685
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.outgoing.prices-out.connector=smallrye-kafka <2>\n"
"mp.messaging.outgoing.prices-out.topic=prices <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:690
#, fuzzy
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.  In dev mode and when running tests, <<kafka-dev-services>> automatically starts a Kafka broker.  When not provided, this property defaults to `localhost:9092`."
msgstr "本番用プロファイルのブローカーロケーションを設定します。グローバルに、または `mp.messaging.outgoing.$channel.bootstrap.servers` プロパティを使用してチャネルごとに構成することができます。dev モードおよびテストの実行時には、 link:kafka-dev-services.html[Dev Services for Kafka]は自動的に Kafka ブローカーを起動します。提供されていない場合、このプロパティのデフォルトは `localhost:9092` です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:691
#, fuzzy
msgid "Configure the connector to manage the `prices-out` channel."
msgstr "`prices-out` チャネルを管理するためにコネクタを構成します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:692
#, fuzzy
msgid "By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "デフォルトでは、トピック名はチャンネル名と同じです。これを無効にするには、topic属性を設定します。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:697
#, fuzzy
msgid "Inside application configuration, channel names are unique.  Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`)."
msgstr "アプリケーションの設定内部では、チャネル名は一意です。したがって、同じトピックに受信チャンネルと送信チャンネルを設定する場合は、チャンネル名を別々にする必要があります（本ガイドの例では、 `mp.messaging.incoming.prices` と `mp.messaging.outgoing.prices-out` のように）。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:701
#, fuzzy
msgid "Then, your application can generate messages and publish them to the `prices-out` channel.  It can use `double` payloads as in the following snippet:"
msgstr "その後、アプリケーションはメッセージを生成し、 `prices-out` チャンネルに公開することができます。次のスニペットのように、 `double` ペイロードを使用することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:706
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:710
#, fuzzy, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:713
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaPriceProducer {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:715 upstream/_guides/kafka.adoc:1016
#, fuzzy, no-wrap
msgid "    private final Random random = new Random();\n"
msgstr "    private final KafkaContainer kafka = new KafkaContainer();\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:723
#, no-wrap
msgid ""
"    @Outgoing(\"prices-out\")\n"
"    public Multi<Double> generate() {\n"
"        // Build an infinite stream of random prices\n"
"        // It emits a price every second\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> random.nextDouble());\n"
"    }\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:730
#, fuzzy
msgid "You should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome."
msgstr "`@Incoming` や `@Outgoing` でアノテーションされたメソッドをコードから直接呼び出すべきではありません。これらのメソッドはフレームワークによって呼び出されます。ユーザーコードがこれらを呼び出すことは、期待した結果をもたらさないでしょう。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:734
#, fuzzy
msgid "Note that the `generate` method returns a `Multi<Double>`, which implements the Reactive Streams `Publisher` interface.  This publisher will be used by the framework to generate messages and send them to the configured Kafka topic."
msgstr "`generate` メソッドは、Reactive Streams `Publisher` インターフェースを実装した `Multi<Double>` を返すことに注意してください。このパブリッシャーは、フレームワークがメッセージを生成し、設定された Kafka トピックに送信するために使用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:736
#, fuzzy
msgid "Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.kafka.Record` to send key/value pairs:"
msgstr "ペイロードを返すのではなく、 `io.smallrye.reactive.messaging.kafka.Record` 、キーと値のペアを送ることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:744
#, no-wrap
msgid ""
"@Outgoing(\"out\")\n"
"public Multi<Record<String, Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .map(x -> Record.of(\"my-key\", random.nextDouble()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:747
#, fuzzy
msgid "Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:"
msgstr "ペイロードは、 `org.eclipse.microprofile.reactive.messaging.Message` の中に包み込むことで、書き込まれた記録をよりコントロールすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:760
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Message<Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> Message.of(random.nextDouble())\n"
"                    .addMetadata(OutgoingKafkaRecordMetadata.<String>builder()\n"
"                            .withKey(\"my-key\")\n"
"                            .withTopic(\"my-key-prices\")\n"
"                            .withHeaders(new RecordHeaders().add(\"my-header\", \"value\".getBytes()))\n"
"                            .build()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:765
#, fuzzy
msgid "`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.  One use case is to dynamically select the destination topic of a message.  In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic."
msgstr "`OutgoingKafkaRecordMetadata` では、 `key` 、 `topic` 、 `partition` 、 `timestamp` といった Kafka レコードのメタデータ属性を設定できます。使用例としては、メッセージの送信先トピックを動的に選択する場合があります。この場合、アプリケーションの設定ファイル内でトピックを設定するのではなく、送信メタデータを使ってトピックの名前を設定する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:768
#, fuzzy
msgid "Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.  In this case the producer will use this method as generator to create an infinite stream."
msgstr "Reactive Stream `Publisher` （ `Multi` は `Publisher` の実装）を返すメソッドのシグネチャー以外にも、発信メソッドは単一のメッセージを返すことができます。この場合、プロデューサーはこのメソッドをジェネレーターとして使用し、無限のストリームを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:772
#, no-wrap
msgid "@Outgoing(\"prices-out\") T generate(); // T excluding void\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:774
#, no-wrap
msgid "@Outgoing(\"prices-out\") Message<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:776
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:778
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<Message<T>> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:780
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:782
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<Message<T>> generate();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:784
#, fuzzy, no-wrap
msgid "Sending messages with @Emitter"
msgstr "Emitterでメッセージを送信する"

#. type: Plain text
#: upstream/_guides/kafka.adoc:787
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "時には、命令的な方法でメッセージを送ることが必要になる場合もあります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:790
#, fuzzy
msgid "For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.  In this case, you cannot use `@Outgoing` because your method has parameters."
msgstr "例えば、RESTエンドポイントの内部でPOSTリクエストを受信した際に、ストリームにメッセージを送信する必要がある場合です。この場合、メソッドにパラメータがあるため、 `@Outgoing` は使用できません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:792
msgid "For this, you can use an `Emitter`."
msgstr "この場合には `Emitter` が利用できます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:797 upstream/_guides/kafka.adoc:1889
#: upstream/_guides/kafka.adoc:1937 upstream/_guides/kafka.adoc:2154
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:803 upstream/_guides/kafka.adoc:848
#: upstream/_guides/kafka.adoc:882
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:810
#, fuzzy, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    Emitter<Double> priceEmitter;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:817
#, fuzzy, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        CompletionStage<Void> ack = priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:820
#, fuzzy
msgid "Sending a payload returns a `CompletionStage`, completed when the message is acked. If the message transmission fails, the `CompletionStage` is completed exceptionally with the reason of the nack."
msgstr "ペイロードを送信すると、メッセージがアックされたときに完了する `CompletionStage` が返されます。メッセージの送信が失敗した場合は、例外的に `CompletionStage` が nack の理由とともに完了します。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:824
#, fuzzy
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`."
msgstr "`Emitter` の構成は、 `@Incoming` と `@Outgoing` で使用される他のストリーム構成と同じ方法で行われます。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:833
#, fuzzy
msgid "Using the `Emitter` you are sending messages from your imperative code to reactive messaging.  These messages are stored in a queue until they are sent.  If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.  You can use `@OnOverflow` to configure back-pressure strategy.  It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`."
msgstr "`Emitter` を使用すると、命令型コードからリアクティブ・メッセージングにメッセージを送信します。これらのメッセージは、送信されるまでキューに格納されます。Kafka プロデューサークライアントが、Kafka に送信しようとするメッセージに追いつけない場合、このキューがメモリを圧迫し、メモリ不足になることもあります。 `@OnOverflow` を使ってバックプレッシャー戦略を設定することができます。これにより、キューのサイズ（デフォルトは256）と、バッファサイズに達したときに適用するストラテジーを設定することができます。利用可能なストラテジーは、 `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER`, `NONE` です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:836
#, fuzzy
msgid "With the `Emitter` API, you can also encapsulate the outgoing payload inside `Message<T>`. As with the previous examples, `Message` lets you handle the ack/nack cases differently."
msgstr "`Emitter` APIを使用すると、 `Message<T>` の中に送信ペイロードをカプセル化することもできます。前述の例と同様に、 `Message` では、ack/nackのケースを異なる方法で処理することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:842
#, fuzzy, no-wrap
msgid ""
"import java.util.concurrent.CompletableFuture;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:853
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:868
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(Message.of(price)\n"
"            .withAck(() -> {\n"
"                // Called when the message is acked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            })\n"
"            .withNack(throwable -> {\n"
"                // Called when the message is nacked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            }));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:872
#, fuzzy
msgid "If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni<Void>` from the `send` method.  You can therefore use Mutiny APIs for handling downstream messages and errors."
msgstr "もしReactive Stream APIを使いたいのであれば、 `send` メソッドから `Uni<Void>` を返す `MutinyEmitter` を使うことができます。したがって、下流のメッセージやエラーの処理にMutiny APIを使用することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:876 upstream/_guides/kafka.adoc:2191
#, fuzzy, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:884
#, fuzzy, no-wrap
msgid "import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:891
#, fuzzy, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    MutinyEmitter<Double> priceEmitter;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:900
#, fuzzy, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> addPrice(Double price) {\n"
"        return quoteRequestEmitter.send(price)\n"
"                .map(x -> \"ok\")\n"
"                .onFailure().recoverWithItem(\"ko\");\n"
"    }\n"
"}\n"
msgstr ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:904
#, fuzzy
msgid "It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.  It will only return from the method when the event is acked or nacked by the receiver."
msgstr "`sendAndAwait` メソッドでエミッターへのイベント送信をブロックすることも可能です。イベントが受信者によってアックまたはナッキングされたときにのみ、このメソッドから戻ります。"

#. type: Block title
#: upstream/_guides/kafka.adoc:906
#, no-wrap
msgid "Deprecation"
msgstr "非推奨"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:909
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr "`io.smallrye.reactive.messaging.annotations.Emitter`、`io.smallrye.reactive.messaging.annotations.Channel`、`io.smallrye.reactive.messaging.annotations.OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:911
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:912
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:913
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:915
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr "新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると、`CompletionStage` の完了を返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:918
#, fuzzy
msgid "More information on how to use `Emitter` can be found in https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging – Emitters and Channels]"
msgstr "`Emitter` の使用方法の詳細は、「 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/emitter/emitter.html#_emitter_and_channel[SmallRye Reactive Messaging - Emitters and Channels]」に記載されています。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:919
#, fuzzy, no-wrap
msgid "Write Acknowledgement"
msgstr "確認戦略"

#. type: Plain text
#: upstream/_guides/kafka.adoc:923
#, fuzzy
msgid "When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.  Also, it stores in-memory the records that cannot be written."
msgstr "Kafkaブローカーがレコードを受信した際、設定によっては確認応答に時間がかかる場合があります。また、書き込みができないレコードはメモリに保存されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:926
#, fuzzy
msgid "By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).  You can disable this by setting the `waitForWriteCompletion` attribute to `false`."
msgstr "デフォルトでは、コネクタは処理を続けるために Kafka がレコードを確認するのを待ちます（受信した Message を確認する）。これを無効にするには、 `waitForWriteCompletion` 属性を `false` に設定します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:928
#, fuzzy
msgid "Note that the `acks` attribute has a huge impact on the record acknowledgement."
msgstr "なお、 `acks` 属性は、レコードの確認に大きな影響を与えます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:930
#, fuzzy
msgid "If a record cannot be written, the message is nacked."
msgstr "記録が書けない場合は、メッセージがNGになります。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:931
#, fuzzy, no-wrap
msgid "Backpressure"
msgstr "バックプレッシャー"

#. type: Plain text
#: upstream/_guides/kafka.adoc:935
#, fuzzy
msgid "The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.  The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024."
msgstr "Kafka アウトバウンドコネクターは、Kafka ブローカーへの書き込みを待っているインフライトメッセージの数を監視して、バックプレッシャーを処理します。インフライトメッセージの数は `max-inflight-messages` 属性を使用して設定され、デフォルトは 1024 です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:940
#, fuzzy
msgid "The connector only sends that amount of messages concurrently.  No other messages will be sent until at least one in-flight message gets acknowledged by the broker.  Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.  Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly."
msgstr "コネクタは、その量のメッセージのみを同時に送信します。少なくとも1つの飛行中のメッセージがブローカによって確認されるまで、他のメッセージは送信されません。次に、ブローカーの飛行中のメッセージの1つが確認されると、コネクターは新しいメッセージをKafkaに書き込みます。Kafka の `batch.size` と `linger.ms` を適宜設定してください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:943
#, fuzzy
msgid "You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.  However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`."
msgstr "また、 `max-inflight-messages` を `0` に設定することで、飛行中のメッセージの制限を取り除くことができます。ただし、リクエスト数が `max.in.flight.requests.per.connection` に達すると、Kafka プロデューサがブロックされる可能性があることに注意してください。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:944
#, fuzzy, no-wrap
msgid "Retrying message dispatch"
msgstr "メッセージディスパッチの再試行"

#. type: Plain text
#: upstream/_guides/kafka.adoc:949
#, fuzzy
msgid "When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.  This behavior is controlled by `retries` and `retry.backoff.ms` parameters.  In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters."
msgstr "Kafkaプロデューサーがサーバーからエラーを受け取った場合、それが一過性の回復可能なエラーであれば、クライアントはメッセージのバッチの送信を再試行します。この動作は、 `retries` と `retry.backoff.ms` のパラメータで制御されます。これに加えて、SmallRye Reactive Messagingは、回復可能なエラーの場合、 `retries` と `delivery.timeout.ms` のパラメータに応じて、個々のメッセージを再試行します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:952
#, fuzzy
msgid "Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.  If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer."
msgstr "信頼性の高いシステムでリトライを行うことはベストプラクティスですが、 `max.in.flight.requests.per.connection` パラメータのデフォルトは `5` であり、メッセージの順序は保証されていないことに注意してください。メッセージの順序が必要な場合は、 `max.in.flight.requests.per.connection` を `1` に設定すると、プロデューサーのスループットが制限されますが、一度に 1 つのメッセージ・バッチが送信されるようになります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:954
#, fuzzy
msgid "For applying retry mechanism on processing errors, see the section on <<retrying-processing>>."
msgstr "処理エラーに対するリトライ機構の適用については、 link:#retrying-processing[[retrying-processing]]の項を参照してください。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:955
#, fuzzy, no-wrap
msgid "Handling Serialization Failures"
msgstr "シリアル化の失敗の処理"

#. type: Plain text
#: upstream/_guides/kafka.adoc:959
#, fuzzy
msgid "For Kafka producer client serialization failures are not recoverable, thus the message dispatch is not retried. In these cases you may need to apply a failure strategy for the serializer.  To achieve this, you need to create a bean implementing `SerializationFailureHandler<T>` interface:"
msgstr "Kafkaプロデューサークライアントのシリアライザの障害は回復できないため、メッセージのディスパッチは再試行されません。このような場合には、シリアライザーに障害戦略を適用する必要があります。これを実現するには、 `SerializationFailureHandler<T>` インターフェースを実装したBeanを作成する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:966
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"failure-fallback\") // Set the name of the failure handler\n"
"public class MySerializationFailureHandler\n"
"    implements SerializationFailureHandler<JsonObject> { // Specify the expected type\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:975
#, no-wrap
msgid ""
"    @Override\n"
"    public byte[] decorateSerialization(Uni<byte[]> serialization, String topic, boolean isKey,\n"
"        String serializer, Object data, Headers headers) {\n"
"        return serialization\n"
"                    .onFailure().retry().atMost(3)\n"
"                    .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:978
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (for key or value serializers)."
msgstr "この失敗ハンドラを使用するには，Beanを `@Identifier` 修飾子で公開し，コネクタ構成で属性 `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (キー又は値シリアライザ用)を指定する必要がある。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:981
#, fuzzy
msgid "The handler is called with details of the serialization, including the action represented as `Uni<byte[]>`.  Note that the method must await on the result and return the serialized byte array."
msgstr "ハンドラは、 `Uni<byte[]>` として表されるアクションを含む、シリアライズの詳細とともに呼び出されます。メソッドは、結果を待ち受け、シリアル化されたバイト配列を返さなければならないことに注意してください。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:982
#, fuzzy, no-wrap
msgid "In-memory channels"
msgstr "インメモリ・チャネル"

#. type: Plain text
#: upstream/_guides/kafka.adoc:987
#, fuzzy
msgid "In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.  When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.  Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr "いくつかのユースケースでは、同じアプリケーション内でメッセージを転送するのに、メッセージングパターンを使用すると便利です。チャネルをKafkaのようなメッセージングバックエンドに接続しない場合は、すべてがインメモリーで行われ、ストリームはメソッドを連鎖させて作成されます。各チェーンは依然としてリアクティブ・ストリームであり、バックプレッシャー・プロトコルが適用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:991
#, fuzzy
msgid "The framework verifies that the producer/consumer chain is complete, meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`), it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr "フレームワークは、プロデューサ/コンシューマ・チェーンが完全であることを検証します。つまり、アプリケーションがメモリ内チャネルにメッセージを書き込む場合（ `@Outgoing` のみのメソッドを使用するか、 `Emitter` ）、アプリケーション内からメッセージを消費する必要があります（ `@Incoming` のみのメソッドを使用するか、アンマネージド・ストリームを使用する）。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:993
#, fuzzy, no-wrap
msgid "Broadcasting messages on multiple consumers"
msgstr "複数の消費者にメッセージを流す"

#. type: Plain text
#: upstream/_guides/kafka.adoc:998
#, fuzzy
msgid "By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.  At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.  You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel."
msgstr "デフォルトでは、チャンネルは、 `@Incoming` メソッドまたは `@Channel` リアクティブストリームを使用して、単一のコンシューマにリンクすることができます。アプリケーションの起動時には、チャネルは、単一のコンシューマとプロデューサで、コンシューマとプロデューサのチェーンを形成するように検証されます。チャンネルに `mp.messaging.$channel.broadcast=true` を設定することで、この動作をオーバーライドすることができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1000
#, fuzzy
msgid "In case of in-memory channels, `@Broadcast` annotation can be used on the `@Outgoing` method. For example,"
msgstr "インメモリーチャンネルの場合は、 `@Broadcast` アノテーションを `@Outgoing` メソッドに使用することができます。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1004
#, fuzzy, no-wrap
msgid "import java.util.Random;\n"
msgstr "import java.util.concurrent.CompletionStage;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1009 upstream/_guides/kafka.adoc:1051
#: upstream/_guides/kafka.adoc:1079
#, fuzzy, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1011
#, fuzzy, no-wrap
msgid "import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1014
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MultipleConsumer {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1022
#, no-wrap
msgid ""
"    @Outgoing(\"in-memory-channel\")\n"
"    @Broadcast\n"
"    double generate() {\n"
"        return random.nextDouble();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1027
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    void consumeAndLog(double price) {\n"
"        System.out.println(price);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1034
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    @Outgoing(\"prices2\")\n"
"    double consumeAndSend(double price) {\n"
"        return price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1040
#, fuzzy
msgid "Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.  On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation."
msgstr "逆に、 `mp.messaging.incoming.$channel.merge=true` を設定することで、同じチャンネルの複数のプロデューサーをマージすることができます。 `@Incoming` メソッドでは、 `@Merge` アノテーションを使用して、複数のチャンネルをマージする方法を制御できます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1042
#, fuzzy, no-wrap
msgid "Processing Messages"
msgstr "処理メッセージ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1046
#, fuzzy
msgid "Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.  A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:"
msgstr "データをストリーミングするアプリケーションでは、あるトピックからいくつかのイベントを消費し、それらを処理して、その結果を別のトピックにパブリッシュする必要があることがよくあります。プロセッサメソッドは、 `@Incoming` と `@Outgoing` の両方のアノテーションを使用して簡単に実装できます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1056 upstream/_guides/kafka.adoc:1084
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceProcessor {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1058 upstream/_guides/kafka.adoc:1086
#: upstream/_guides/kafka.adoc:1226
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr "    private static final double CONVERSION_RATE = 0.88;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1064
#, fuzzy, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public double process(double price) {\n"
"        return price * CONVERSION_RATE;\n"
"    }\n"
msgstr ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1070
#, fuzzy
msgid "The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.  Previously mentioned signatures for parameter and return types are also supported, such as `Message<T>`, `Record<K, V>`, etc."
msgstr "`process` メソッドのパラメータは受信メッセージのペイロードであり、戻り値は送信メッセージのペイロードとして使用されます。 `Message<T>`, `Record<K, V>` など、以前に述べたパラメータと戻り値のタイプのシグネチャもサポートされています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1072
#, fuzzy
msgid "You can apply asynchronous stream processing by consuming and returning reactive stream `Multi<T>` type:"
msgstr "リアクティブ・ストリーム `Multi<T>` タイプを消費して返すことで、非同期のストリーム処理を適用できます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1081
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1092
#, fuzzy, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public Multi<Double> process(Multi<Integer> prices) {\n"
"        return prices.filter(p -> p > 100).map(p -> p * CONVERSION_RATE);\n"
"    }\n"
msgstr ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1096
#, fuzzy, no-wrap
msgid "Propagating Record Key"
msgstr "プロパゲーション・レコード・キー"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1099
#, fuzzy
msgid "When processing messages, you can propagate incoming record key to the outgoing record."
msgstr "メッセージを処理する際に、受信レコードのキーを送信レコードに伝搬させることができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1102
#, fuzzy
msgid "Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration, record key propagation produces the outgoing record with the same _key_ as the incoming record."
msgstr "`mp.messaging.outgoing.$channel.propagate-record-key=true` の設定で有効にすると、レコードキープロパゲーションは、受信レコードと同じ _キー_で送信レコードを生成します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1105
#, fuzzy
msgid "If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.  If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used."
msgstr "発信レコードにすでに _キー_がある場合、着信レコードのキーによって上書きされること *はありません*。受信レコードに _NULL_キーがある場合は、 `mp.messaging.outgoing.$channel.key` プロパティが使用されます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1107
#, fuzzy, no-wrap
msgid "Accessing Kafka clients directly"
msgstr "Kafkaクライアントに直接アクセスする"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1111
#, fuzzy
msgid "In rare cases, you may need to access the underlying Kafka clients.  `KafkaClientService` provides thread-safe access to `Producer` and `Consumer`."
msgstr "まれに、基盤となるKafkaクライアントにアクセスする必要がある場合があります。 `KafkaClientService` は、 `Producer` と `Consumer` へのスレッドセーフなアクセスを提供します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1117
#, fuzzy, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
"import javax.inject.Inject;\n"
msgstr ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1119
#, no-wrap
msgid "import org.apache.kafka.clients.producer.ProducerRecord;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1124
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaClientService;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumer;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1127
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceSender {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1130
#, no-wrap
msgid ""
"    @Inject\n"
"    KafkaClientService clientService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1137
#, no-wrap
msgid ""
"    void onStartup(@Observes StartupEvent startupEvent) {\n"
"        KafkaProducer<String, Double> producer = clientService.getProducer(\"generated-price\");\n"
"        producer.runOnSendingThread(client -> client.send(new ProducerRecord<>(\"prices\", 2.4)))\n"
"            .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1142
#, fuzzy
msgid "The `KafkaClientService` is an experimental API and can change in the future."
msgstr "`KafkaClientService` は実験的なAPIであり、将来的に変更される可能性があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1145
#, fuzzy
msgid "You can also get the Kafka configuration injected to your application and create Kafka producer, consumer and admin clients directly:"
msgstr "また、Kafkaの設定をアプリケーションに注入してもらい、Kafkaのプロデューサー、コンシューマー、アドミンクライアントを直接作成することもできます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1152
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.kafka.clients.admin.AdminClient;\n"
"import org.apache.kafka.clients.admin.AdminClientConfig;\n"
"import org.apache.kafka.clients.admin.KafkaAdminClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1158
#, fuzzy, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.inject.Produces;\n"
"import javax.inject.Inject;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
msgstr ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1161
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaClients {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1165
#, no-wrap
msgid ""
"    @Inject\n"
"    @Identifier(\"default-kafka-broker\")\n"
"    Map<String, Object> config;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1176
#, no-wrap
msgid ""
"    @Produces\n"
"    AdminClient getAdmin() {\n"
"        Map<String, Object> copy = new HashMap<>();\n"
"        for (Map.Entry<String, Object> entry : config.entrySet()) {\n"
"            if (AdminClientConfig.configNames().contains(entry.getKey())) {\n"
"                copy.put(entry.getKey(), entry.getValue());\n"
"            }\n"
"        }\n"
"        return KafkaAdminClient.create(copy);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1183
#, fuzzy
msgid "The `default-kafka-broker` configuration map contains all application properties prefixed with `kafka.` or `KAFKA_`.  For more configuration options check out <<kafka-configuration-resolution>>."
msgstr "`default-kafka-broker` 構成マップには、 `kafka.` または `KAFKA_` をプレフィックスとするすべてのアプリケーションプロパティが含まれています。その他の設定オプションについては、 link:#kafka-configuration-resolution[[kafka-configuration-resolution]]をご覧ください。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1185
#, no-wrap
msgid "JSON serialization"
msgstr "JSON シリアライゼーション"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1188
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "Quarkus には、JSON Kafka メッセージを扱う機能が組み込まれています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1190
#, fuzzy
msgid "Imagine we have a `Fruit` data class as follows:"
msgstr "以下のような `Fruit` のデータクラスがあるとします。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1194
#, no-wrap
msgid "public class Fruit {\n"
msgstr "public class Fruit {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1197
#, no-wrap
msgid ""
"    public String name;\n"
"    public int price;\n"
msgstr ""
"    public String name;\n"
"    public int price;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1200
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""
"    public Fruit() {\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1206
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1209
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr "そして、Kafka からメッセージを受信して、何らかの価格変換を行い、Kafka にメッセージを送り返すために使いたいと考えています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1215
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1224
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" channel and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" channel.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1234
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1239
msgid "To do this, we will need to setup JSON serialization with Jackson or JSON-B."
msgstr "そのためには、Jackson や JSON-B で JSON シリアライゼーションを設定する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1241
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr "JSON シリアライゼーションが正しく設定されていれば、 `Publisher<Fruit>` や `Emitter<Fruit>` も利用できます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1243
#, no-wrap
msgid "Serializing via Jackson"
msgstr "Jackson によるシリアライゼーション"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1248
#, fuzzy
msgid "Quarkus has built-in support for JSON serialization and deserialization based on Jackson.  It will also <<serialization-generation, generate>> the serializer and deserializer for you, so you do not have to configure anything.  When generation is disabled, you can use the provided `ObjectMapperSerializer` and `ObjectMapperDeserializer` as explained below."
msgstr "Quarkusには、JacksonをベースにしたJSONのシリアライズとデシリアライズのサポートが組み込まれています。また、シリアライザーとデシリアライザー link:#serialization-generation[を生成し]てくれるので、何も設定する必要がありません。生成が無効の場合は、以下に説明するように、提供されている `ObjectMapperSerializer` 、 `ObjectMapperDeserializer` を使用できます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1251
#, fuzzy
msgid "There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.  You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr "Jacksonを介してすべてのデータオブジェクトをシリアル化するために使用できる既存の `ObjectMapperSerializer` があります。 link:#serialization-autodetection[serialization-autodetection]]を使用したい場合は、空のサブクラスを作成することができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1255
#, fuzzy
msgid "By default, the `ObjectMapperSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "デフォルトでは、 `ObjectMapperSerializer` は null を `\"null\"` String としてシリアライズしますが、これは Kafka の構成プロパティ `json.serialize.null-as-null=true` を設定することでカスタマイズでき、null は `null` としてシリアライズされます。これは、圧縮されたトピックを使用しているときに便利です。 `null` は、圧縮段階でどのメッセージが削除されたかを知るための墓標として使用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1258
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr "対応するデシリアライザクラスをサブクラス化する必要があります。そこで、 `ObjectMapperDeserializer` を継承した `FruitDeserializer` を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1262 upstream/_guides/kafka.adoc:1293
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr "package com.acme.fruit.jackson;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1264 upstream/_guides/kafka.adoc:2018
#: upstream/_guides/kafka.adoc:2104
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1270 upstream/_guides/kafka.adoc:2024
#: upstream/_guides/kafka.adoc:2110
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1273
#, fuzzy
msgid "Finally, configure your channels to use the Jackson serializer and deserializer."
msgstr "最後に、Jacksonのシリアライザーとデシリアライザーを使用するようにチャンネルを設定します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1279
#, fuzzy, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1283
#, fuzzy, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1287
#, fuzzy
msgid "Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.  In this case, the `deserializer` configuration is not necessary as the <<serialization-autodetection>> is enabled by default."
msgstr "これで、Kafkaメッセージには、 `Fruit` データオブジェクトのJacksonシリアライズされた表現が含まれるようになります。この場合、 link:#serialization-autodetection[[serialization-autodetection]]がデフォルトで有効になっているので、 `deserializer` の設定は必要ありません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1289
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a Jackson `TypeReference` denoted the generic collection used."
msgstr "果物のリストをデシリアライズしたい場合は、使用するジェネリックコレクションを示すJackson `TypeReference` を持つデシリアライザを作成する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1297
#, fuzzy, no-wrap
msgid ""
"import java.util.List;\n"
"import com.fasterxml.jackson.core.type.TypeReference;\n"
"import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1305
#, no-wrap
msgid ""
"public class ListOfFruitDeserializer extends ObjectMapperDeserializer<List<Fruit>> {\n"
"    public ListOfFruitDeserializer() {\n"
"        TypeReference<List<Fruit>> listType = new TypeReference<>() {\n"
"        };\n"
"        super(listType);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:1308
#, no-wrap
msgid "Serializing via JSON-B"
msgstr "JSON-B によるシリアライズ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1311
#, fuzzy
msgid "First, you need to include the `quarkus-jsonb` extension."
msgstr "まず、 `quarkus-jsonb` エクステンションを入れる必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1319
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1325
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-jsonb\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1329
#, fuzzy
msgid "There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.  You may create an empty subclass if you want to use <<serialization-autodetection>>."
msgstr "JSON-Bを介してすべてのデータオブジェクトをシリアル化するために使用できる既存の `JsonbSerializer` があります。 link:#serialization-autodetection[serialization-autodetection]]を使用したい場合は、空のサブクラスを作成することができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1333
#, fuzzy
msgid "By default, the `JsonbSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "デフォルトでは、 `JsonbSerializer` は null を `\"null\"` String としてシリアライズしますが、これは Kafka の構成プロパティ `json.serialize.null-as-null=true` を設定することでカスタマイズでき、null を `null` としてシリアライズします。これは、圧縮されたトピックを使用しているときに便利です。 `null` は、圧縮段階でどのメッセージが削除されたかを知るための墓標として使用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1336
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr "対応するデシリアライザクラスをサブクラス化する必要があります。そこで、ジェネリックな `JsonbDeserializer` を継承した `FruitDeserializer` を作ってみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1340
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr "package com.acme.fruit.jsonb;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1342
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1348
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1351
#, fuzzy
msgid "Finally, configure your channels to use the JSON-B serializer and deserializer."
msgstr "最後に、JSON-Bのシリアライザーとデシリアライザーを使用するようにチャンネルを設定します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1358
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1363
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1366
#, fuzzy
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your `Fruit` data object."
msgstr "これで、Kafkaメッセージには、 `Fruit` データオブジェクトのJSON-Bシリアライズ表現が含まれるようになります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1368
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a `Type` denoted the generic collection used."
msgstr "果物のリストをデシリアライズしたい場合は、使用するジェネリックコレクションを示す `Type` を持つデシリアライザを作成する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1376
#, no-wrap
msgid ""
"package com.acme.fruit.jsonb;\n"
"import java.lang.reflect.Type;\n"
"import java.util.ArrayList;\n"
"import java.util.List;\n"
"import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1383
#, no-wrap
msgid ""
"public class ListOfFruitDeserializer extends JsonbDeserializer<List<Fruit>> {\n"
"    public ListOfFruitDeserializer() {\n"
"        Type listType = new ArrayList<MyEntity>() {}.getClass().getGenericSuperclass();\n"
"        super(listType);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1387
#, fuzzy
msgid "If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr "データオブジェクトごとにデシリアライザを作成したくない場合は、汎用の `io.vertx.kafka.client.serialization.JsonObjectDeserializer` を使用すると、 `io.vertx.core.json.JsonObject` にデシリアライズされます。また、対応するシリアライザを使用することもできます： `io.vertx.kafka.client.serialization.JsonObjectSerializer` 。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1388
#, fuzzy, no-wrap
msgid "Avro Serialization"
msgstr "JSON シリアライゼーション"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1391 upstream/_guides/kafka.adoc:1482
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro]."
msgstr "これについては、専用のガイドで説明しています。 link:kafka-schema-registry-avro.html[Using Apache Kafka with Schema Registry and Avro]」に記載されています。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1393
#, fuzzy, no-wrap
msgid "Serializer/deserializer autodetection"
msgstr "シリアライザ/デシリアライザの自動検出"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1397
#, fuzzy
msgid "When using SmallRye Reactive Messaging with Kafka (`io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus can often automatically detect the correct serializer and deserializer class.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr "SmallRye Reactive Messaging with Kafka ( `io.quarkus:quarkus-smallrye-reactive-messaging-kafka`) を使用している場合、Quarkusは多くの場合、正しいシリアライザとデシリアライザのクラスを自動的に検出できます。この自動検出は、 `@Incoming` と `@Outgoing` のメソッドの宣言、および注入された `@Channel`のメソッドに基づいています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1399
#, fuzzy
msgid "For example, if you declare"
msgstr "例えば、次のように宣言します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1406
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Integer> generate() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1409
#, fuzzy
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`."
msgstr "で、 `generated-price` チャンネルが `smallrye-kafka` コネクタを使用していると設定されている場合、Quarkus は自動的に `value.serializer` を Kafka の組み込み `IntegerSerializer` に設定します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1411
#, fuzzy
msgid "Similarly, if you declare"
msgstr "同様に、次のように宣言すると"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1418
#, no-wrap
msgid ""
"@Incoming(\"my-kafka-records\")\n"
"public void consume(KafkaRecord<Long, byte[]> record) {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1421
#, fuzzy
msgid "and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`."
msgstr "で、 `my-kafka-records` チャンネルが `smallrye-kafka` コネクタを使用していると設定されている場合、Quarkusは自動的に `key.deserializer` をKafkaの組み込み `LongDeserializer` に、 `value.deserializer` を `ByteArrayDeserializer` に設定します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1423
#, fuzzy
msgid "Finally, if you declare"
msgstr "最後に、宣言すると"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1429
#, fuzzy, no-wrap
msgid ""
"@Inject\n"
"@Channel(\"price-create\")\n"
"Emitter<Double> priceEmitter;\n"
msgstr "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1432
#, fuzzy
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`."
msgstr "で、 `price-create` チャンネルが `smallrye-kafka` コネクタを使用していると設定されている場合、Quarkus は自動的に `value.serializer` を Kafka の組み込み `DoubleSerializer` に設定します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1434
#, fuzzy
msgid "The full set of types supported by the serializer/deserializer autodetection is:"
msgstr "シリアライザ/デシリアライザの自動検出でサポートされているタイプの完全なセットは次のとおりです。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1436
#, fuzzy
msgid "`short` and `java.lang.Short`"
msgstr "`short` と `java.lang.Short`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1437
#, fuzzy
msgid "`int` and `java.lang.Integer`"
msgstr "`int` と `java.lang.Integer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1438
#, fuzzy
msgid "`long` and `java.lang.Long`"
msgstr "`java.lang.String`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1439
#, fuzzy
msgid "`float` and `java.lang.Float`"
msgstr "`float` と `java.lang.Float`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1440
#, fuzzy
msgid "`double` and `java.lang.Double`"
msgstr "`double` と `java.lang.Double`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1441
#, fuzzy
msgid "`byte[]`"
msgstr "`byte[]`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1442
msgid "`java.lang.String`"
msgstr "`java.lang.String`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1443
#, fuzzy
msgid "`java.util.UUID`"
msgstr "`java.util.UUID`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1444
#, fuzzy
msgid "`java.nio.ByteBuffer`"
msgstr "`java.nio.ByteBuffer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1445
#, fuzzy
msgid "`org.apache.kafka.common.utils.Bytes`"
msgstr "`org.apache.kafka.common.utils`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1446
msgid "`io.vertx.core.buffer.Buffer`"
msgstr "`io.vertx.core.buffer.Buffer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1447
msgid "`io.vertx.core.json.JsonObject`"
msgstr "`io.vertx.core.json.JsonObject`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1448
msgid "`io.vertx.core.json.JsonArray`"
msgstr "`io.vertx.core.json.JsonArray`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1449
#, fuzzy
msgid "classes generated from Avro schemas, as well as Avro `GenericRecord`, if Confluent or Apicurio Registry _serde_ is present"
msgstr "Avro スキーマから生成されたクラス、および Confluent または Apicurio Registry _serde_が存在する場合は Avro `GenericRecord` 。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1450
#, fuzzy
msgid "see xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro] for more information about using Confluent or Apicurio Registry libraries"
msgstr "ConfluentまたはApicurioのレジストリライブラリの使用については、 link:kafka-schema-registry-avro.html[「Using Apache Kafka with Schema Registry and Avro]」を参照してください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1451
#, fuzzy
msgid "classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in <<jackson-serialization>>"
msgstr "`ObjectMapperSerializer` / `ObjectMapperDeserializer` のサブクラスが存在するクラスで、 link:#jackson-serialization[[jackson-serialization]]に記載されています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1452
#, fuzzy
msgid "it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible"
msgstr "技術的には `ObjectMapperSerializer` をサブクラス化する必要はありませんが、その場合は自動検出ができません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1453
#, fuzzy
msgid "classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in <<jsonb-serialization>>"
msgstr "`JsonbSerializer` / `JsonbDeserializer` のサブクラスが存在するクラスで、 link:#jsonb-serialization[[jsonb-serialization]]に記載されている通りです。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1454
#, fuzzy
msgid "it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible"
msgstr "技術的には `JsonbSerializer` をサブクラス化する必要はありませんが、その場合は自動検出ができません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1456
#, fuzzy
msgid "If a serializer/deserializer is set by configuration, it won't be replaced by the autodetection."
msgstr "設定でシリアライザ/デシリアライザが設定されている場合、自動検出では置き換えられません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1459
#, fuzzy
msgid "In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr "シリアライザの自動検出に問題がある場合は、 `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false` を設定することで完全にオフにすることができます。この設定が必要な場合は、 link:https://github.com/quarkusio/quarkus/issues[Quarkusのissue tracker]にバグを提出してください。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1461
#, fuzzy, no-wrap
msgid "JSON Serializer/deserializer generation"
msgstr "JSON シリアライゼーション"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1463
#, fuzzy
msgid "Quarkus automatically generates serializers and deserializers for channels where:"
msgstr "Quarkusは、以下のようなチャンネルのシリアライザとデシリアライザを自動的に生成します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1465
#, fuzzy
msgid "the serializer/deserializer is not configured"
msgstr "シリアライザ/デシリアライザが設定されていない"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1466
#, fuzzy
msgid "the auto-detection did not find a matching serializer/deserializer"
msgstr "自動検出で一致するシリアライザ/デシリアライザが見つからなかった場合"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1468
#, fuzzy
msgid "It uses Jackson underneath."
msgstr "その下にはJacksonが使われています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1470
#, fuzzy
msgid "This generation can be disabled using:"
msgstr "この世代は、以下の方法で無効にすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1474
#, no-wrap
msgid "quarkus.reactive-messaging.kafka.serializer-generation.enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1478
#, fuzzy
msgid "Generation does not support collections such as `List<Fruit>`.  Refer to <<jackson-serialization>> to write your own serializer/deserializer for this case."
msgstr "Generationは、 `List<Fruit>` のようなコレクションをサポートしていません。このような場合は、 link:#jackson-serialization[[jackson-serialization]]を参照して、独自のシリアライザ/デシリアライザを作成してください。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1479
#, fuzzy, no-wrap
msgid "Using Schema Registry"
msgstr "スキーマ・レジストリの使用"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1484
#, fuzzy, no-wrap
msgid "Health Checks"
msgstr "健康診断"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1488
msgid "Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension."
msgstr "Quarkusは、Kafkaのヘルスチェックをいくつか提供しています。これらのチェックは、 `quarkus-smallrye-health` エクステンションと組み合わせて使用します。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1489
#, fuzzy, no-wrap
msgid "Kafka Broker Readiness Check"
msgstr "Kafka Brokerのレディネスチェック"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1494
#, fuzzy
msgid "When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  It requires an _admin connection_ with the Kafka broker, and it is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status."
msgstr "`quarkus-kafka-client` エクステンションを使用している場合、 `application.properties` で `quarkus.kafka.health.enabled` プロパティを `true` に設定することで、 _レディネス・ヘルスチェック_を有効にすることができます。このチェックは、 _デフォルトの_Kafkaブローカー（ `kafka.bootstrap.servers` を使用して構成）との対話の状態を報告します。このチェックには、Kafka ブローカーとの _管理者接続_が必要で、デフォルトでは無効になっています。有効にすると、アプリケーションの `/q/health/ready` エンドポイントにアクセスしたときに、接続検証のステータスに関する情報が得られます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1495
#, fuzzy, no-wrap
msgid "Kafka Reactive Messaging Health Checks"
msgstr "Kafkaリアクティブメッセージングのヘルスチェック"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1497
#, fuzzy
msgid "When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides _startup_, _liveness_ and _readiness_ checks."
msgstr "Reactive MessagingとKafkaコネクタを使用する場合、設定された各チャネル（受信または送信）には、 _起動_、 _有効性_、 _準備状況_のチェックが行われます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1499
#, fuzzy
msgid "The _startup_ check verifies that the communication with Kafka cluster is established."
msgstr "_起動_チェックでは、Kafkaクラスターとの通信が確立されていることを確認します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1500
#, fuzzy
msgid "The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka."
msgstr "_活性度_チェックは、Kafkaとの通信中に発生した回復不能な障害を捕捉します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1501
#, fuzzy
msgid "The _readiness_ check verifies that the Kafka connector is ready to consume/produce messages to the configured Kafka topics."
msgstr "_readiness_checkは、Kafkaコネクタが構成されたKafkaトピックに対してメッセージを消費／生成する準備ができているかどうかを検証します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1503
#, fuzzy
msgid "For each channel, you can disable the checks using:"
msgstr "各チャンネルごとに、チェックを無効にすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1507
#, no-wrap
msgid "# Disable both liveness and readiness checks with `health-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1512
#, no-wrap
msgid ""
"# Incoming channel (receiving records form Kafka)\n"
"mp.messaging.incoming.your-channel.health-enabled=false\n"
"# Outgoing channel (writing records to Kafka)\n"
"mp.messaging.outgoing.your-channel.health-enabled=false\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1514
#, no-wrap
msgid "# Disable only the readiness check with `health-readiness-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1517
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.health-readiness-enabled=false\n"
"mp.messaging.outgoing.your-channel.health-readiness-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1521
#, fuzzy
msgid "You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.  Default is `kafka.bootstrap.servers`."
msgstr "`mp.messaging.incoming|outgoing.$channel.bootstrap.servers` プロパティを使って、各チャンネルの `bootstrap.servers` を設定することができます。デフォルトは `kafka.bootstrap.servers` です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1525
#, fuzzy
msgid "Reactive Messaging _startup_ and _readiness_ checks offer two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in Kafka client metrics."
msgstr "Reactive Messaging の _起動_と _準備_状態のチェックには 2 つの戦略があります。デフォルトの方法では、ブローカーとのアクティブな接続が確立されていることを確認します。この方法は、組み込みのKafkaクライアントメトリクスに基づいているため、邪魔にはなりません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1529
#, fuzzy
msgid "Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.  Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption, and for an outgoing channel checks that the topic used by the producer exist in the broker."
msgstr "`health-topic-verification-enabled=true` 属性を使用して、 _起動_プローブは _admin クライアント_を使用してトピックのリストをチェックします。一方、受信チャンネルの _readyiness_probeは、少なくとも1つのパーティションが消費用に割り当てられているかどうかをチェックし、送信チャンネルでは、producerが使用するトピックがbrokerに存在するかどうかをチェックします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1532
#, fuzzy
msgid "Note that to achieve this, an _admin connection_ is required.  You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration."
msgstr "これを実現するには、 _管理者の接続_が必要であることに注意してください。ブローカへのトピック検証コールのタイムアウトは、 `health-topic-verification-timeout` の設定で調整できます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1533
#, fuzzy, no-wrap
msgid "Kafka Streams"
msgstr "Kafka ストリーム"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1536
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-streams.adoc[Using Apache Kafka Streams]."
msgstr "これについては、専用のガイドで説明しています。 link:kafka-streams.html[Using Apache Kafka Streams]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1537
#, fuzzy, no-wrap
msgid "Using Snappy for message compression"
msgstr "Snappyを使ったメッセージ圧縮"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1540
msgid "On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:"
msgstr "_outgoing_ チャンネルでは、 `compression.type` 属性を `snappy` に設定することで、Snappy 圧縮を有効にすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1544
#, no-wrap
msgid "mp.messaging.outgoing.fruit-out.compression.type=snappy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1548
msgid "In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:"
msgstr "JVMモードでは、変更なしで動作します。しかし、アプリケーションをネイティブ実行可能ファイルにコンパイルするには、以下のことが必要です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1550
msgid "Uses GraalVM 21.+"
msgstr "GraalVM 21.+の使用"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1551
msgid "Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`"
msgstr "`application.properties` に `quarkus.kafka.snappy.enabled=true`を追加"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1553
msgid "In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts."
msgstr "ネイティブモードでは、Snappyはデフォルトで無効になっています。Snappyを使用するには、ネイティブライブラリを埋め込み、アプリケーションの起動時にそれを解凍する必要があるからです。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1554
#, fuzzy, no-wrap
msgid "Authentication with OAuth"
msgstr "OAuthによる認証"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1558
msgid "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr "Kafka ブローカーが認証メカニズムとして OAuth を使用している場合は、この認証プロセスを有効にするために Kafka コンシューマーを設定する必要があります。まず、以下の依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1566
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1572
#, no-wrap
msgid "implementation(\"io.strimzi:kafka-oauth-client\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1576
msgid "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr "この依存関係は、OAuth ワークフローを処理するために必要なコールバックハンドラーを提供します。そして、`application.properties` で追加します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1586
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1588
#, no-wrap
msgid "quarkus.ssl.native=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1591
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr "`oauth.client.id`、`oauth.client.secret`、`oauth.token.endpoint.uri` の値を更新します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1593
#, fuzzy
msgid "OAuth authentication works for both JVM and native modes. Since SSL in not enabled by default in native mode, `quarkus.ssl.native=true` must be added to support JaasClientOauthLoginCallbackHandler, which uses SSL. (See the xref:native-and-ssl.adoc[Using SSL with Native Executables] guide for more details.)"
msgstr "OAuth認証はJVMとネイティブモードの両方で動作します。ネイティブモードではSSLがデフォルトでは有効になっていないため、 `quarkus.ssl.native=true` 、SSLを使用するJaasClientOauthLoginCallbackHandlerをサポートするように追加する必要があります。(詳細は、 link:native-and-ssl.html[Using SSL with Native Execut]ables ガイドを参照してください)。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1594
#, no-wrap
msgid "Testing a Kafka application"
msgstr "Kafka アプリケーションのテスト"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1596
#, no-wrap
msgid "Testing without a broker"
msgstr "ブローカーなしでのテスト"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1600
msgid "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr "Kafka ブローカーを起動しなくてもアプリケーションをテストできるのは便利です。これを行うには、Kafka コネクターで管理しているチャンネルを _インメモリー_ に _切り替え_ できます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1602
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1604
#, fuzzy
msgid "Let's say we want to test the following processor application:"
msgstr "例えば、次のようなプロセッサ・アプリケーションをテストしたいとします。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1609
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class BeverageProcessor {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1621
#, no-wrap
msgid ""
"    @Incoming(\"orders\")\n"
"    @Outgoing(\"beverages\")\n"
"    Beverage process(Order order) {\n"
"        System.out.println(\"Order received \" + order.getProduct());\n"
"        Beverage beverage = new Beverage();\n"
"        beverage.setBeverage(order.getProduct());\n"
"        beverage.setCustomer(order.getCustomer());\n"
"        beverage.setOrderId(order.getOrderId());\n"
"        beverage.setPreparationState(\"RECEIVED\");\n"
"        return beverage;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1626
#, fuzzy
msgid "First, add the following test dependency to your application:"
msgstr "まず、以下のテスト用依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1635
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1641
#, no-wrap
msgid "testImplementation(\"io.smallrye.reactive:smallrye-reactive-messaging-in-memory\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1644
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "そして、以下のように Quarkus Test Resource を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1648
#, no-wrap
msgid "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1658
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");     // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"beverages\");  // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1664
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1666
#, fuzzy
msgid "Switch the incoming channel `orders` (expecting messages from Kafka) to in-memory."
msgstr "受信チャンネル `orders` （Kafkaからのメッセージを期待する）をインメモリーに切り替える。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1667
#, fuzzy
msgid "Switch the outgoing channel `beverages` (writing messages to Kafka) to in-memory."
msgstr "発信チャンネル `beverages` （Kafkaへのメッセージ書き込み）をインメモリーに切り替えます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1668
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "インメモリーチャネルを使用するためのアプリケーション設定に必要なすべてのプロパティを含む `Map` をビルドして返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1669
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "テストが停止したら、`InMemoryConnector` をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1671
msgid "Create a Quarkus Test using the test resource created above:"
msgstr "上記で作成したテストリソースを使用して Quarkus テストを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1677
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"
msgstr ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1680
#, no-wrap
msgid ""
"    @Inject\n"
"    InMemoryConnector connector; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1685
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> ordersIn = connector.source(\"orders\");     // <2>\n"
"        InMemorySink<Beverage> beveragesOut = connector.sink(\"beverages\");  // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1690
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
msgstr ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1692
#, no-wrap
msgid "        ordersIn.send(order);  // <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1694
#, no-wrap
msgid "        await().<List<? extends Message<Beverage>>>until(beveragesOut::received, t -> t.size() == 1); // <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1701
#, no-wrap
msgid ""
"        Beverage queuedBeverage = beveragesOut.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1705
msgid "Inject the in-memory connector in your test class."
msgstr "テストクラスにインメモリーコネクタ－を挿入します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1706
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr "受信チャンネルを取得します (`orders`) - テストリソース内でチャンネルがインメモリーに切り替えられている必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1707
#, fuzzy
msgid "Retrieve the outgoing channel (`beverages`) - the channel must have been switched to in-memory in the test resource."
msgstr "受信チャンネルを取得します (`orders`) - テストリソース内でチャンネルがインメモリーに切り替えられている必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1709
#, fuzzy
msgid "Use the `send` method to send a message to the `orders` channel.  The application will process this message and send a message to `beverages` channel."
msgstr "`send` メソッドを使用して、 `orders` チャンネルにメッセージを送信します。アプリケーションはこのメッセージを処理して、 `beverages` チャンネルにメッセージを送信します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1710
#, fuzzy
msgid "Use the `received` method on `beverages` channel to check the messages produced by the application."
msgstr "`beverages` チャンネルの `received` メソッドを使用して、アプリケーションが生成するメッセージを確認します。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1715
#, fuzzy
msgid "With in-memory channels we were able to test application code processing messages without starting a Kafka broker.  Note that different in-memory channels are independent, and switching channel connector to in-memory does not simulate message delivery between channels configured to the same Kafka topic."
msgstr "インメモリ・チャネルでは，Kafka ブローカーを起動することなく，メッセージを処理するアプリケーション・コードをテストすることができました．なお、異なるインメモリ・チャネルは独立しており、チャネル・コネクターをインメモリに切り替えても、同じKafkaトピックに設定されたチャネル間のメッセージ配信をシミュレートすることはできません。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1717
#, no-wrap
msgid "Starting Kafka in a test resource"
msgstr "テストリソースでの Kafka の起動"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1721
msgid "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr "あるいは、テストリソースで Kafka ブローカを起動することもできます。次のスニペットは、 https://www.testcontainers.org/modules/kafka/[Testcontainers] を使用して Kafka ブローカを起動するテストリソースを示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1725
#, no-wrap
msgid "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1727
#, no-wrap
msgid "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr "    private final KafkaContainer kafka = new KafkaContainer();\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1733
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1739
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"
msgstr ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1741
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr "アプリケーションがこのブローカーに接続するように、Kafka ブートストラップの場所を設定します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1745
#, fuzzy, no-wrap
msgid "Kubernetes Service Bindings"
msgstr "Kubernetesのサービスバインディング"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1750
#, fuzzy
msgid "Quarkus Kafka extension supports xref:deploying-to-kubernetes.adoc[Service Binding Specification for Kubernetes].  You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application."
msgstr "Quarkus Kafka extensionは、 link:deploying-to-kubernetes.html[Service Binding Specification for Kubernetes]をサポートしています。これを有効にするには、アプリケーションに `quarkus-kubernetes-service-binding` 拡張機能を追加します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1752
#, fuzzy
msgid "When running in appropriately configured Kubernetes clusters, Kafka extension will pull its Kafka broker connection configuration from the service binding available inside the cluster, without the need for user configuration."
msgstr "適切に設定されたKubernetesクラスターで実行する場合、Kafka extensionは、ユーザーによる設定を必要とせず、クラスター内で利用可能なサービスバインディングからKafkaブローカー接続設定を引き出します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1753
#, no-wrap
msgid "Execution model"
msgstr "実行モデル"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1758
#, fuzzy
msgid "Reactive Messaging invokes user's methods on an I/O thread.  Thus, by default, the methods must not block.  As described in <<blocking-processing>>, you need to add the `@Blocking` annotation on the method if this method will block the caller thread."
msgstr "Reactive Messaging は、ユーザーのメソッドを I/O スレッドで呼び出します。したがって、デフォルトでは、メソッドはブロックしてはいけません。 link:#blocking-processing[blocking-processing]]で説明したように、このメソッドが呼び出し元のスレッドをブロックする場合は、メソッドに `@Blocking` アノテーションを追加する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1760
#, fuzzy
msgid "See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "このトピックの詳細については、 link:quarkus-reactive-architecture.html[Quarkus Reactive Architectureのドキュメント]を参照してください。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1762
#, no-wrap
msgid "Configuration Reference"
msgstr "設定リファレンス"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1765
#, fuzzy
msgid "More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation]."
msgstr "SmallRye Reactive Messagingの設定についての詳細は、 link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/3.1/kafka/kafka.html[SmallRye Reactive Messaging - Kafka Connector Documentation]に記載されています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1767
#, fuzzy
msgid "The most important attributes are listed in the tables below:"
msgstr "最も重要な属性を以下の表に示します。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1768
#, no-wrap
msgid "Incoming channel configuration (polling from Kafka)"
msgstr "Incoming チャネル設定 (Kafkaからのポーリング)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1771 upstream/_guides/kafka.adoc:1810
msgid "The following attributes are configured using:"
msgstr "以下の属性は以下のように設定します:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1775
#, no-wrap
msgid "mp.messaging.incoming.your-channel-name.attribute=value\n"
msgstr "mp.messaging.incoming.your-channel-name.attribute=value\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1778 upstream/_guides/kafka.adoc:1817
msgid "Some properties have aliases which can be configured globally:"
msgstr "一部のプロパティには、グローバルに設定可能なエイリアスがあります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1782 upstream/_guides/kafka.adoc:1821
#, no-wrap
msgid "kafka.bootstrap.servers=...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1785
#, fuzzy
msgid "You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#consumerconfigs[Kafka consumer]."
msgstr "また、基盤となる link:https://kafka.apache.org/documentation/#consumerconfigs[Kafkaコンシューマー]がサポートする任意のプロパティを渡すこともできます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1787
#, fuzzy
msgid "For example, to configure the `max.poll.records` property, use:"
msgstr "例えば、 `max.poll.records` プロパティを設定するには、次のようにします。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1791
#, fuzzy, no-wrap
msgid "mp.messaging.incoming.[channel].max.poll.records=1000\n"
msgstr "mp.messaging.incoming.your-channel-name.attribute=value\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1794
#, fuzzy
msgid "Some consumer client properties are configured to sensible default values:"
msgstr "一部のコンシューマークライアントプロパティは、常識的なデフォルト値に設定されています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1796 upstream/_guides/kafka.adoc:1826
#, fuzzy
msgid "If not set, `reconnect.backoff.max.ms` is set to `10000` to avoid high load on disconnection."
msgstr "設定されていない場合は、切断時の高負荷を避けるために `reconnect.backoff.max.ms` を `10000` に設定します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1798
#, fuzzy
msgid "If not set, `key.deserializer` is set to `org.apache.kafka.common.serialization.StringDeserializer`."
msgstr "設定されていない場合は、 `key.deserializer` が `org.apache.kafka.common.serialization.StringDeserializer` に設定されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1800
#, fuzzy
msgid "The consumer `client.id` is configured according to the number of clients to create using `mp.messaging.incoming.[channel].partitions` property."
msgstr "コンシューマー `client.id` は、 `mp.messaging.incoming.[channel].partitions` プロパティを使用して作成するクライアントの数に応じて設定されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1802
#, fuzzy
msgid "If a `client.id` is provided, it is used as-is or suffixed with client index if `partitions` property is set."
msgstr "`client.id` が提供されている場合は、そのまま使用され、 `partitions` プロパティが設定されている場合は、クライアントのインデックスがサフィックスとして使用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1803
#, fuzzy
msgid "If a `client.id` is not provided, it is generated as `kafka-consumer-[channel][-index]`."
msgstr "`client.id` が用意されていない場合は、 `kafka-consumer-[channel][-index]` として生成されます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1807
#, no-wrap
msgid "Outgoing channel configuration (writing to Kafka)"
msgstr "outgoingチャンネルの設定（Kafkaへの書き込み)"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1814
#, no-wrap
msgid "mp.messaging.outgoing.your-channel-name.attribute=value\n"
msgstr "mp.messaging.outgoing.your-channel-name.attribute=value\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1824
#, fuzzy
msgid "Some producer client properties are configured to sensible default values:"
msgstr "一部のプロデューサークライアントプロパティは、常識的なデフォルト値に設定されています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1828
#, fuzzy
msgid "If not set, `key.serializer` is set to `org.apache.kafka.common.serialization.StringSerializer`."
msgstr "設定されていない場合は、 `key.serializer` が `org.apache.kafka.common.serialization.StringSerializer` に設定されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1830
#, fuzzy
msgid "If not set, producer `client.id` is generated as `kafka-producer-[channel]`."
msgstr "設定されていない場合、プロデューサー `client.id` は `kafka-producer-[channel]` として生成されます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1834
#, fuzzy, no-wrap
msgid "Kafka Configuration Resolution"
msgstr "Kafkaの設定解決"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1838
#, fuzzy
msgid "Quarkus exposes all Kafka related application properties, prefixed with `kafka.` or `KAFKA_` inside a configuration map with `default-kafka-broker` name.  This configuration is used to establish the connection with the Kafka broker."
msgstr "Quarkusは、 `default-kafka-broker` の名前を持つ設定マップの中で、 `kafka.` または `KAFKA_` の接頭辞を持つ、すべてのKafka関連のアプリケーションプロパティを公開します。この設定は、Kafkaブローカーとの接続を確立するために使用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1840
#, fuzzy
msgid "In addition to this default configuration, you can configure the name of the `Map` producer using the `kafka-configuration` attribute:"
msgstr "このデフォルトの設定に加えて、 `kafka-configuration` 属性を使って `Map` プロデューサーの名前を設定することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1845
#, no-wrap
msgid ""
"mp.messaging.incoming.my-channel.connector=smallrye-kafka\n"
"mp.messaging.incoming.my-channel.kafka-configuration=my-configuration\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1849
#, fuzzy
msgid "In this case, the connector looks for the `Map` associated with the `my-configuration` name.  If `kafka-configuration` is not set, an optional lookup for a `Map` exposed with the channel name (`my-channel` in the previous example) is done."
msgstr "この場合、コネクタは `my-configuration` の名前に関連付けられた `Map` を探します。 `kafka-configuration` が設定されていない場合は、オプションとして、チャネル名で公開されている `Map` を探します（前の例では `my-channel` ）。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1860
#, no-wrap
msgid ""
"@Produces\n"
"@ApplicationScoped\n"
"@Identifier(\"my-configuration\")\n"
"Map<String, Object> outgoing() {\n"
"    return Map.ofEntries(\n"
"            Map.entry(\"value.serializer\", ObjectMapperSerializer.class.getName())\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1863
#, fuzzy
msgid "If `kafka-configuration` is set and no `Map` can be found, the deployment fails."
msgstr "`kafka-configuration` が設定されていて、 `Map` が見つからない場合、デプロイは失敗します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1865
#, fuzzy
msgid "Attribute values are resolved as follows:"
msgstr "属性の値は以下のように解決されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1867
#, fuzzy
msgid "the attribute is set directly on the channel configuration (`mp.messaging.incoming.my-channel.attribute=value`),"
msgstr "の属性は、チャンネル設定で直接設定されます( `mp.messaging.incoming.my-channel.attribute=value`)。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1868
#, fuzzy
msgid "if not set, the connector looks for a `Map` with the channel name or the configured `kafka-configuration` (if set) and the value is retrieved from that `Map`"
msgstr "設定されていない場合、コネクタはチャネル名または設定された `kafka-configuration` (設定されている場合)を持つ `Map` を探し、そこから値を取得します。 `Map`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1869
#, fuzzy
msgid "If the resolved `Map` does not contain the value the default `Map` is used (exposed with the `default-kafka-broker` name)"
msgstr "解決された `Map` に値が含まれていない場合は、デフォルトの `Map` が使用されます（ `default-kafka-broker` の名前で公開されます）。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1870
#, no-wrap
msgid "Integrating with Kafka - Common patterns"
msgstr "Kafkaとの連携 - 一般的なパターン"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1872
#, no-wrap
msgid "Writing to Kafka from an HTTP endpoint"
msgstr "HTTPエンドポイントからKafkaへの書き込み"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1875
#, fuzzy
msgid "To send messages to Kafka from an HTTP endpoint, inject an `Emitter` (or a `MutinyEmitter`) in your endpoint:"
msgstr "HTTPエンドポイントからKafkaにメッセージを送信するには、エンドポイントに `Emitter` (または `MutinyEmitter`)を注入します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1879 upstream/_guides/kafka.adoc:1927
#: upstream/_guides/kafka.adoc:1968 upstream/_guides/kafka.adoc:1986
#: upstream/_guides/kafka.adoc:2016 upstream/_guides/kafka.adoc:2048
#: upstream/_guides/kafka.adoc:2067 upstream/_guides/kafka.adoc:2102
#: upstream/_guides/kafka.adoc:2145 upstream/_guides/kafka.adoc:2186
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1881 upstream/_guides/kafka.adoc:1929
#: upstream/_guides/kafka.adoc:2147
#, no-wrap
msgid "import java.util.concurrent.CompletionStage;\n"
msgstr "import java.util.concurrent.CompletionStage;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1886 upstream/_guides/kafka.adoc:1934
#, no-wrap
msgid ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1892 upstream/_guides/kafka.adoc:1942
#: upstream/_guides/kafka.adoc:2157
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ResourceSendingToKafka {\n"
msgstr ""
"@Path(\"/\")\n"
"public class ResourceSendingToKafka {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1894
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<String> emitter;          // <1>\n"
msgstr "    @Channel(\"kafka\") Emitter<String> emitter;          // <1>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1901
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"
msgstr ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1903
msgid "Inject an `Emitter<String>`"
msgstr "`Emitter<String>` を注入"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1904
msgid "The HTTP method receives the payload and returns a `CompletionStage` completed when the message is written to Kafka"
msgstr "HTTPメソッドはメッセージがKafkaに書き込まれると、ペイロードを受け取り、`CompletionStage` の完了を返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1905
msgid "Send the message to Kafka, the `send` method returns a `CompletionStage`"
msgstr "メッセージをKafkaに送信し、 `send` メソッドは `CompletionStage` を返却します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1908
#, fuzzy
msgid "The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.  The emitter's channel is mapped to a Kafka topic in the `application.properties` file:"
msgstr "エンドポイントは、渡されたペイロード（ `POST` HTTPリクエストから）をエミッターに送信します。エミッターのチャンネルは、 `application.properties` ファイル内の Kafka トピックにマッピングされます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1913
#, no-wrap
msgid ""
"mp.messaging.outgoing.kafka.connector=smallrye-kafka\n"
"mp.messaging.outgoing.kafka.topic=my-topic\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1919
#, fuzzy
msgid "The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.  The `emitter.send` method returns a `CompletionStage<Void>` .  The returned future is completed when the message has been written to Kafka.  If the writing fails, the returned `CompletionStage` is completed exceptionally."
msgstr "エンドポイントは、メソッドの非同期性を示す `CompletionStage` を返します。 `emitter.send` メソッドは `CompletionStage<Void>` を返します。返されたfutureは、メッセージがKafkaに書き込まれた時点で完了します。書き込みに失敗した場合、返された `CompletionStage` は例外的に完了します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1921
#, fuzzy
msgid "If the endpoint does not return a `CompletionStage`, the HTTP response may be written before the message is sent to Kafka, and so failures won't be reported to the user."
msgstr "エンドポイントが `CompletionStage` を返さない場合、メッセージが Kafka に送信される前に HTTP レスポンスが書き込まれる可能性があるため、失敗がユーザーに報告されません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1923
#, fuzzy
msgid "If you need to send a Kafka record, use:"
msgstr "Kafkaのレコードを送信する必要がある場合は、使用します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1939
#, fuzzy, no-wrap
msgid "import io.smallrye.reactive.messaging.kafka.Record;\n"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1944
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Record<String,String>> emitter;  // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1952
#, fuzzy, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) {\n"
"        return emitter.send(Record.of(\"my-key\", payload));    // <2>\n"
"    }\n"
"}\n"
msgstr ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1954
#, fuzzy
msgid "Note the usage of an `Emitter<Record<K, V>>`"
msgstr "の使用に注意してください。 `Emitter<Record<K, V>>`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1955
#, fuzzy
msgid "Create the record using `Record.of(k, v)`"
msgstr "を使ってレコードを作成します。 `Record.of(k, v)`"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1956
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate with Panache"
msgstr "Panacheを用いたHibernateによるKafkaメッセージの永続化"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1959
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate with Panache."
msgstr "Kafkaから受け取ったオブジェクトをデータベースに永続化するには、Hibernate with Panacheを使用することができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1961
#, fuzzy
msgid "If you use Hibernate Reactive, look at <<persisting-kafka-messages-with-hibernate-reactive>>."
msgstr "Hibernate Reactiveを使用している場合は、 link:#persisting-kafka-messages-with-hibernate-reactive[[persisting-kafka-mesages-with-hibernate-reactive]]をご覧ください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1964 upstream/_guides/kafka.adoc:2044
#, fuzzy
msgid "Let's imagine you receive `Fruit` objects.  For simplicity purposes, our `Fruit` class is pretty simple:"
msgstr "`Fruit` のオブジェクトを受け取るとしましょう。わかりやすくするために、 `Fruit` クラスはとてもシンプルなものになっています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1970 upstream/_guides/kafka.adoc:2050
#, no-wrap
msgid "import javax.persistence.Entity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1972
#, no-wrap
msgid "import io.quarkus.hibernate.orm.panache.PanacheEntity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1975 upstream/_guides/kafka.adoc:2055
#, no-wrap
msgid ""
"@Entity\n"
"public class Fruit extends PanacheEntity {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1977 upstream/_guides/kafka.adoc:2057
#, fuzzy, no-wrap
msgid "    public String name;\n"
msgstr ""
"    public String name;\n"
"    public int price;\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1982 upstream/_guides/kafka.adoc:2063
#, fuzzy
msgid "To consume `Fruit` instances stored on a Kafka topic, and persist them into a database, you can use the following approach:"
msgstr "Kafkaトピックに格納された `Fruit` インスタンスを消費し、データベースに永続化するには、次のような方法があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1993
#, fuzzy, no-wrap
msgid "import io.smallrye.common.annotation.Blocking;\n"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1996
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitConsumer {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2003
#, no-wrap
msgid ""
"    @Incoming(\"fruits\")                                     // <1>\n"
"    @Transactional                                          // <2>\n"
"    public void persistFruits(Fruit fruit) {                // <3>\n"
"        fruit.persist();                                    // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2005
#, fuzzy
msgid "Configuring the incoming channel. This channel reads from Kafka."
msgstr "受信チャンネルの設定。このチャンネルはKafkaから読み込みます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2007
#, fuzzy
msgid "As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns.  Quarkus automatically considers the method as _blocking_. Indeed, writing to a database using classic Hibernate is blocking. So, Quarkus calls the method on a worker thread you can block (and not an I/O thread)."
msgstr "データベースに書き込んでいるので、トランザクションの中にいる必要があります。このアノテーションは、新しいトランザクションを開始し、メソッドが戻ってきたときにそれをコミットします。Quarkusは自動的にそのメソッドを _ブロッキング_とみなします。実際、従来のHibernateを使用したデータベースへの書き込みはブロッキングです。そのため、Quarkusはブロック可能なワーカースレッド（I/Oスレッドではない）でメソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2008
#, fuzzy
msgid "The method receives each Fruit. Note that you would need a deserializer to reconstruct the Fruit instances from the Kafka records."
msgstr "このメソッドは、それぞれのFruitを受け取ります。なお、KafkaのレコードからFruitのインスタンスを再構成するには、デシリアライザが必要になります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2009
#, fuzzy
msgid "Persist the received `fruit` object."
msgstr "受信した `fruit` オブジェクトを永続化します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2012
#, fuzzy
msgid "As mentioned in <4>, you need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "<4>で述べたように、レコードから `Fruit` を作成できるデシリアライザが必要です。これはJacksonデシリアライザを使って行うことができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2027 upstream/_guides/kafka.adoc:2113
#, fuzzy
msgid "The associated configuration would be:"
msgstr "関連する構成は次のとおりです。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2032 upstream/_guides/kafka.adoc:2118
#, fuzzy, no-wrap
msgid ""
"mp.messaging.incoming.fruits.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruits.value.deserializer=org.acme.FruitDeserializer\n"
msgstr ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2036 upstream/_guides/kafka.adoc:2122
#, fuzzy
msgid "Check <<jackson-serialization>> for more detail about the usage of Jackson with Kafka.  You can also use Avro."
msgstr "KafkaでのJacksonの使い方については、 link:#jackson-serialization[[jackson-serialization]]を確認してください。Avroを使うこともできます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2038
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate Reactive"
msgstr "Hibernate ReactiveによるKafkaメッセージの永続化"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2041
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate Reactive with Panache."
msgstr "Kafkaから受け取ったオブジェクトをデータベースに永続化するには、Hibernate Reactive with Panacheを使用します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2052
#, no-wrap
msgid "import io.quarkus.hibernate.reactive.panache.PanacheEntity;  // <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2061
#, fuzzy
msgid "Make sure to use the reactive variant"
msgstr "必ずリアクティブ・バリアントを使用してください"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2074
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2077
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitStore {\n"
msgstr ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2085
#, no-wrap
msgid ""
"    @Incoming(\"fruits\")\n"
"    public Uni<Void> persist(Fruit fruit) {\n"
"        return Panache.withTransaction(() ->  // <1>\n"
"            fruit.persist()                   // <2>\n"
"                .map(persisted -> null)       // <3>\n"
"        );\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2089
#, fuzzy
msgid "Instruct Panache to run the given (asynchronous) action in a transaction. The transaction completes when the action completes."
msgstr "トランザクションの中で与えられた(非同期)アクションを実行するようにPanacheに指示します。アクションが完了すると、トランザクションは完了します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2090
#, fuzzy
msgid "Persist the entity. It returns a `Uni<Fruit>`."
msgstr "エンティティを永続化します。これは `Uni<Fruit>` を返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2091
#, fuzzy
msgid "Switch back to a `Uni<Void>`."
msgstr "`Uni<Void>` に切り替えてください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2095
#, fuzzy
msgid "Unlike with _classic_ Hibernate, you can't use `@Transactional`.  Instead, we use `Panache.withTransaction` and persist our entity.  The `map` is used to return a `Uni<Void>` and not a `Uni<Fruit>`."
msgstr "_従来の_Hibernateとは異なり、 `@Transactional` を使用することはできません。代わりに `Panache.withTransaction` を使用して、エンティティを永続化します。 `map` は、 `Uni<Fruit>` ではなく、 `Uni<Void>` を返すために使用されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2098
#, fuzzy
msgid "You need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "レコードから `Fruit` を作成できるデシリアライザが必要です。これはJacksonデシリアライザを使って行うことができます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2123
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate to Kafka"
msgstr "Hibernateが管理するエンティティをKafkaに書き込む"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2126
#, fuzzy
msgid "Let's imagine the following process:"
msgstr "次のようなプロセスを想像してみましょう。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2128
#, fuzzy
msgid "You receive an HTTP request with a payload,"
msgstr "ペイロードを含むHTTPリクエストを受信します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2129
#, fuzzy
msgid "You create an Hibernate entity instance from this payload,"
msgstr "このペイロードからHibernateのエンティティインスタンスを作成します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2130
#, fuzzy
msgid "You persist that entity into a database,"
msgstr "そのエンティティをデータベースに保存します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2131
#, fuzzy
msgid "You send the entity to a Kafka topic"
msgstr "エンティティをKafkaトピックに送信します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2133
#, fuzzy
msgid "If you use Hibernate Reactive, look at <<writing-entities-managed-by-hibernate-reactive-to-kafka>>."
msgstr "Hibernate Reactiveを使用している場合は、 link:#writing-entities-managed-by-hibernate-reactive-to-kafka[[Writing-entities-managed-by-hibernate-reactive-to-kafka]]をご覧ください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2139
#, fuzzy
msgid "Because we write to a database, we must run this method in a transaction.  Yet, sending the entity to Kafka happens asynchronously.  The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.  We must be sure that the transaction is still running until the object is written.  Otherwise, you may access the object outside the transaction, which is not allowed."
msgstr "データベースへの書き込みを行うため、このメソッドはトランザクション内で実行する必要があります。しかし、エンティティのKafkaへの送信は非同期に行われます。操作が完了すると `CompletionStage` （ `MutinyEmitter` を使用している場合は `Uni` ）のレポートが返されます。オブジェクトが書き込まれるまで、トランザクションがまだ実行されていることを確認しなければなりません。そうしないと、トランザクションの外でオブジェクトにアクセスしてしまう可能性があり、それは許されません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2141
#, fuzzy
msgid "To implement this process, you need the following approach:"
msgstr "このプロセスを実行するには、次のようなアプローチが必要です。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2151
#, fuzzy, no-wrap
msgid ""
"import javax.transaction.Transactional;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2159
#, fuzzy, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Fruit> emitter;\n"
msgstr "    @Channel(\"kafka\") Emitter<String> emitter;          // <1>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2168
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Transactional                                                      // <1>\n"
"    public CompletionStage<Void> storeAndSendToKafka(Fruit fruit) {     // <2>\n"
"        fruit.persist();\n"
"        return emitter.send(fruit);                                     // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2170
#, fuzzy
msgid "As we are writing to the database, make sure we run inside a transaction"
msgstr "データベースに書き込んでいるので、トランザクションの中で実行していることを確認してください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2171
#, fuzzy
msgid "The method receives the fruit instance to persist. It returns a `CompletionStage` which is used for the transaction demarcation. The transaction is committed when the return `CompletionStage` completes. In our case, it's when the message is written to Kafka."
msgstr "このメソッドは、永続化するフルーツのインスタンスを受け取ります。このメソッドは、トランザクションの境界に使用される `CompletionStage` を返します。トランザクションがコミットされるのは、 `CompletionStage` が完了したときです。今回の例では、メッセージがKafkaに書き込まれたときです。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2172
#, fuzzy
msgid "Send the managed instance to Kafka. Make sure we wait for the message to complete before closing the transaction."
msgstr "マネージドインスタンスをKafkaに送信します。メッセージが完了するのを待ってから、トランザクションを閉じるようにします。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2174
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate Reactive to Kafka"
msgstr "Hibernate Reactiveで管理されたエンティティをKafkaに書き込む"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2177
#, fuzzy
msgid "To send to Kafka entities managed by Hibernate Reactive, we recommend using:"
msgstr "Hibernate Reactiveで管理されているKafkaのエンティティに送信するには、以下を使用することをお勧めします。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2179
#, fuzzy
msgid "RESTEasy Reactive to serve HTTP requests"
msgstr "HTTPリクエストに対応するRESTEasy Reactive"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2180
#, fuzzy
msgid "A `MutinyEmitter` to send message to a channel, so it can be easily integrated with the Mutiny API exposed by Hibernate Reactive or Hibernate Reactive with Panache."
msgstr "`MutinyEmitter` チャンネルにメッセージを送信するため、Hibernate ReactiveやHibernate Reactive with Panacheで公開されているMutiny APIと簡単に統合することができます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2182
#, fuzzy
msgid "The following example demonstrates how to receive a payload, store it in the database using Hibernate Reactive with Panache, and send the persisted entity to Kafka:"
msgstr "次の例では、ペイロードを受信し、Hibernate Reactive with Panacheを使用してデータベースに格納し、永続化されたエンティティをKafkaに送信する方法を示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2189
#, no-wrap
msgid ""
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2195
#, fuzzy, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2198
#, fuzzy, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2200
#, fuzzy, no-wrap
msgid "    @Channel(\"kafka\") MutinyEmitter<Fruit> emitter;     // <1>\n"
msgstr "    @Channel(\"kafka\") Emitter<String> emitter;          // <1>\n"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2210
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    public Uni<Void> sendToKafka(Fruit fruit) {         // <2>\n"
"        return Panache.withTransaction(() ->            // <3>\n"
"            fruit.<Fruit>persist()\n"
"        )\n"
"            .chain(f -> emitter.send(f));               // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2212
#, fuzzy
msgid "Inject a `MutinyEmitter` which exposes a Mutiny API. It simplifies the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Mutiny APIを公開する `MutinyEmitter` を注入します。これにより、Hibernate Reactive with Panacheが公開するMutiny APIとの統合が簡単になります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2213
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and written to Kafka)."
msgstr "HTTPメソッドはメッセージがKafkaに書き込まれると、ペイロードを受け取り、`CompletionStage` の完了を返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2214
#, fuzzy
msgid "We need to write the entity into the database in a transaction."
msgstr "トランザクションでデータベースにエンティティを書き込む必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2215
#, fuzzy
msgid "Once the persist operation completes, we send the entity to Kafka. The `send` method returns a `Uni<Void>`."
msgstr "persist 操作が完了すると、エンティティを Kafka に送信します。 `send` メソッドは、 `Uni<Void>` を返します。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2217
#, fuzzy, no-wrap
msgid "Streaming Kafka topics as server-sent events"
msgstr "サーバーから送信されたイベントとしてのKafkaトピックのストリーミング"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2220
#, fuzzy
msgid "Streaming a Kafka topic as server-sent events (SSE) is straightforward:"
msgstr "KafkaのトピックをSSE（Server-Sent Event）としてストリーミングすることは簡単です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2222
#, fuzzy
msgid "You inject the channel representing the Kafka topic in your HTTP endpoint"
msgstr "Kafkaトピックを表すチャンネルをHTTPエンドポイントに注入します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2223
#, fuzzy
msgid "You return that channel as a `Publisher` or a `Multi` from the HTTP method"
msgstr "そのチャンネルを、HTTPメソッドで `Publisher` または `Multi` として返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2225
msgid "The following code provides an example:"
msgstr "以下のコードはその一例です。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2230 upstream/_guides/kafka.adoc:2245
#, no-wrap
msgid ""
"@Channel(\"fruits\")\n"
"Multi<Fruit> fruits;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2236
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<Fruit> stream() {\n"
"    return fruits;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2240
#, fuzzy
msgid "Some environment cuts the SSE connection when there is not enough activity.  The workaround consists of sending _ping_ messages (or empty objects) periodically."
msgstr "一部の環境では、十分なアクティビティがない場合にSSEの接続が切断されることがあります。これを回避するには、定期的に _ping_メッセージ（または空のオブジェクト）を送信する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2248
#, no-wrap
msgid ""
"@Inject\n"
"ObjectMapper mapper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2258
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<String> stream() {\n"
"    return Multi.createBy().merging()\n"
"            .streams(\n"
"                    fruits.map(this::toJson),\n"
"                    emitAPeriodicPing()\n"
"            );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2263
#, no-wrap
msgid ""
"Multi<String> emitAPeriodicPing() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(10))\n"
"            .onItem().transform(x -> \"{}\");\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2271
#, no-wrap
msgid ""
"private String toJson(Fruit f) {\n"
"    try {\n"
"        return mapper.writeValueAsString(f);\n"
"    } catch (JsonProcessingException e) {\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2275
#, fuzzy
msgid "The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.  To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds."
msgstr "Kafkaから送られてくるフルーツを送信するだけでなく、定期的にpingを送信する必要があるため、この回避策は少し複雑です。これを実現するために、Kafkaからのストリームと、10秒ごとに `{}` を発信する周期的なストリームをマージします。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:2276
#, no-wrap
msgid "Logging"
msgstr "ロギング"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2279
msgid "To reduce the amount of log written by the Kafka client, Quarkus sets the level of the following log categories to `WARNING`:"
msgstr "Kafkaクライアントによって書き込まれるログの量を減らすために、Quarkusは以下のログカテゴリーのレベルを `WARNING` に設定しています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2281
msgid "`org.apache.kafka.clients`"
msgstr "`org.apache.kafka.clients`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2282
msgid "`org.apache.kafka.common.utils`"
msgstr "`org.apache.kafka.common.utils`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2283
msgid "`org.apache.kafka.common.metrics`"
msgstr "`org.apache.kafka.common.metrics`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2285
msgid "You can override the configuration by adding the following lines to the `application.properties`:"
msgstr "以下の行を `application.properties` に追加することで、設定を上書きすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2291
#, no-wrap
msgid ""
"quarkus.log.category.\"org.apache.kafka.clients\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.utils\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.metrics\".level=INFO\n"
msgstr ""
"quarkus.log.category.\"org.apache.kafka.clients\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.utils\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.metrics\".level=INFO\n"

#. type: Title ==
#: upstream/_guides/kafka.adoc:2293
#, no-wrap
msgid "Going further"
msgstr "さらに詳しく"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2297
msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr "このガイドでは、Quarkus を使用して Kafka とやりとりする方法を示しました。SmallRye Reactive Messaging を利用して、データストリーミングアプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2298
msgid "If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "詳細は、Quarkus で使用される実装 https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] のドキュメントを確認してください。"
