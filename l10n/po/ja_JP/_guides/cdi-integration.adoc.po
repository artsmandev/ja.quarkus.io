# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2023-04-26 14:57+0000\n"
"PO-Revision-Date: 2023-04-08 19:25+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi-integration.adoc:6
#, no-wrap
msgid "CDI Integration Guide"
msgstr "CDI 統合ガイド"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:16
msgid "ArC, the CDI container, is bootstrapped at build time.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API."
msgstr "CDI コンテナーである ArC はビルド時にブートストラップされます。このアプローチの欠点は、CDI Portable Extensionsをサポートできないことです。それにもかかわらず、Quarkus固有のエクステンションAPIを使用して機能を実現することができます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:19
msgid "The container is bootstrapped in multiple phases.  From a high level perspective these phases go as follows:"
msgstr "コンテナーは複数のフェーズでブートストラップされます。高レベルの視点から見ると、これらのフェーズは以下のようになります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:21
msgid "Initialization"
msgstr "初期化"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:22
msgid "Bean discovery"
msgstr "Beanディスカバリ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:23
msgid "Registration of synthetic components"
msgstr "合成コンポーネントの登録"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:24
msgid "Validation"
msgstr "バリデーション"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:31
msgid "In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.  _Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.  Subsequently, the extensions can register _synthetic components_.  Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.  Finally, the _deployment is validated_.  For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers."
msgstr "_初期化_ フェーズでは、準備作業が行われ、カスタムコンテキストが登録されます。その後、コンテナーがすべてのアプリケーションクラスを分析し、Beanを識別し、提供されたメタデータに基づいてそれらをすべて繋ぎ合わせるプロセスがBean _ディスカバリ_ です。その後、エクステンションは _合成コンポーネント_ を登録することができます。これらのコンポーネントの属性はエクステンションによって完全に制御されます。最後に、 _デプロイメントが検証されます_ 。例えば、コンテナーはアプリケーション内のすべての注入ポイントを検証し、与えられた必要な型と修飾子を満たすBeanがない場合はビルドを失敗させます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:33
#, fuzzy
msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In the xref:cdi-reference.adoc#dev-mode[development mode], you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
msgstr "追加のロギングを有効にすることで、ブートストラップに関するより多くの情報を見ることができます。単に `-X` または `--debug` で Maven ビルドを実行し、 `io.quarkus.arc` を含む行を grep してください。 link:cdi-reference.html#dev-mode[開発モードでは] 、 `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` 、2つの特別なエンドポイントも自動的に登録され、JSONフォーマットでいくつかの基本的なデバッグ情報を提供することができます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:36
msgid "Quarkus build steps can produce and consume various build items and hook into each phase.  In the following sections we will describe all the relevant build items and common scenarios."
msgstr "Quarkusのビルドステップでは、さまざまなビルドアイテムを生成したり消費したりして、各フェーズにフックすることができます。以下のセクションでは、関連するすべてのビルド項目と一般的なシナリオについて説明します。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:37
#, no-wrap
msgid "Metadata Sources"
msgstr "メタデータソース"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:44
#, fuzzy
msgid "Classes and annotations are the primary source of bean-level metadata.  The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window=\"_blank\"] which is built from various sources during xref:cdi-reference.adoc#bean_discovery[bean discovery].  However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.  Moreover, extensions can also register xref:synthetic_beans[synthetic components].  This is an important aspect to realize when integrating CDI components in Quarkus."
msgstr "クラスと注釈は、ビーンレベルのメタデータの主要なソースである。初期メタデータは、 _ビーン_ link:cdi-reference.html#bean_discovery[発見] 時に様々なソースから構築される不変の link:https://github.com/wildfly/jandex[Jandex, target=\"_blank\"] インデックスである _ビーンアーカイブインデックスから _読み取られます。しかし，拡張は，ブートストラップの特定の段階で，メタデータを追加，削除又は変換することができる。さらに、エクステンションは link:#synthetic_beans[合成コンポーネントを] 登録することもできます。これは、QuarkusでCDIコンポーネントを統合する際に実現すべき重要な点です。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:47
msgid "This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.  For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored."
msgstr "このようにして、エクステンションは、そうでなければ無視されていたクラスをBeanに変えたり、その逆を行ったりすることができます。例えば、 `@Scheduled` メソッドを宣言するクラスは、たとえそれがBean定義アノテーションでアノテーションされておらず、通常は無視されるようなクラスであっても、常にBeanとして登録されます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:51
#, no-wrap
msgid "Use Case - My Class Is Not Recognized as a Bean"
msgstr "ユースケース - クラスがBeanとして認識されません"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:57
#, fuzzy
msgid "An `UnsatisfiedResolutionException` indicates a problem during xref:cdi.adoc#typesafe_resolution[typesafe resolution].  Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.  There are several reasons why a class is not recognized and also several ways to fix it.  In the first step we should identify the _reason_."
msgstr "`UnsatisfiedResolutionException` は、 link:cdi.html#typesafe_resolution[タイプセーフの解決] 中に問題が発生したことを示しています。クラスパス上に注入可能なクラスがあっても、注入ポイントを満たすことができないことがあります。クラスが認識されない理由はいくつかあり、またそれを解決する方法もいくつかあります。最初のステップでは、その _原因を _特定する必要があります。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:59
#, no-wrap
msgid "_Reason 1_: Class Is Not discovered "
msgstr "_理由1_ :クラスが発見されない"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:64
#, fuzzy
msgid "Quarkus has a xref:cdi-reference.adoc#bean_discovery[simplified discovery].  It might happen that the class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "Quarkusには link:cdi-reference.html#bean_discovery[簡略化された発見が] あります。クラスがアプリケーションのインデックスの一部でないことがあります。例えば、Quarkus拡張機能の _ランタイムモジュールの _クラスは、自動的にインデックスが作成されるわけではありません。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:68
msgid "_Solution_: Use the `AdditionalBeanBuildItem`.  This build item can be used to specify one or more additional classes to be analyzed during the discovery.  Additional bean classes are transparently added to the application index processed by the container."
msgstr "_解決策_ 。 `AdditionalBeanBuildItem` .このビルド項目は、ディスカバリー中に解析する1つ以上の追加クラスを指定するために使用することができます。追加のBean・クラスは、コンテナーによって処理されるアプリケーション・インデックスに透過的に追加されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:70
#, fuzzy
msgid "It is not possible to conditionally enable/disable additional beans via the `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` and `@UnlessBuildProperty` annotations as described in xref:cdi-reference.adoc#enable_build_profile[Enabling Beans for Quarkus Build Profile] and xref:cdi-reference.adoc#enable_build_properties[Enabling Beans for Quarkus Build Properties]. Extensions should inspect the configuration or the current profile and only produce an `AdditionalBeanBuildItem` if really needed."
msgstr "link:cdi-reference.html#enable_build_profile[Quarkus Build ProfileのBeanの有効] 化と link:cdi-reference.html#enable_build_properties[Quarkus Build PropertiesのBeanの有効] 化で説明したように、 `@IfBuildProfile `, `@UnlessBuildProfile `, `@IfBuildProperty `, `@UnlessBuildProperty` アノテーションを使用して追加のBeanを条件付きで有効化/無効化することは不可能です。エクステンションは、構成または現在のプロファイルを検査し、本当に必要な場合にのみ `AdditionalBeanBuildItem` を生成する必要があります。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:71
#, no-wrap
msgid "`AdditionalBeanBuildItem` Example"
msgstr "`AdditionalBeanBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:78
#, no-wrap
msgid ""
"@BuildStep\n"
"AdditionalBeanBuildItem additionalBeans() {\n"
"     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:80
msgid "`AdditionalBeanBuildItem.Builder` can be used for more complex use cases."
msgstr "`AdditionalBeanBuildItem.Builder` は、より複雑なユースケースに使用することができます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:85
#, fuzzy
msgid "Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.  If the container considers them xref:cdi-reference.adoc#remove_unused_beans[unused], they are just ignored.  However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr "`AdditionalBeanBuildItem` を介して追加された Bean クラスは、デフォルトで _削除可能 _である。コンテナがそれらを link:cdi-reference.html#remove_unused_beans[未使用と] みなした場合、それらはただ無視される。しかし、 `AdditionalBeanBuildItem.Builder.setUnremovable()` メソッドを使用すると、このビルド項目を通じて登録されたビーンクラスを決して削除しないようにコンテナに指示することができます。詳細は、「 link:cdi-reference.html#remove_unused_beans[未使用のBeanの削除] 」及び「 link:#unremovable_builditem[_理由3 _：クラスが発見され、Bean定義アノテーションを持つが削除さ] れた」を参照のこと。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:88
msgid "It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.  The default scope is only used if there is no scope declared on the bean class."
msgstr "`AdditionalBeanBuildItem.Builder#setDefaultScope()` からデフォルトのスコープを設定することも可能です。デフォルトのスコープは、Beanクラスにスコープが宣言されていない場合にのみ使用されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:90
#: upstream/_guides/cdi-integration.adoc:132
msgid "If no default scope is specified the `@Dependent` pseudo-scope is used."
msgstr "デフォルトスコープが指定されていない場合は `@Dependent` 擬似スコープが使用されます。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:91
#, no-wrap
msgid "_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation"
msgstr "_理由2_ : クラスは発見されたが、Beanを定義するアノテーションがない"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:96
msgid "In Quarkus, the application is represented by a single bean archive with the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].  Therefore, bean classes that don't have a https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.  Bean defining annotations are declared on the class-level and include scopes, stereotypes and `@Interceptor`."
msgstr "Quarkusでは、アプリケーションは https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery[Bean 検出モード `annotated`, window=\"_blank\"] でアノテーションされた単一の Bean アーカイブで表現されます。したがって、 https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[Bean 定義アノテーション, window=\"_blank\"] を持たない Bean クラスは無視されます。Bean 定義アノテーションはクラスレベルで宣言され、スコープ、ステレオタイプ、 `@Interceptor` を含みます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:98
msgid "_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions."
msgstr "_解決策1_ : `AutoAddScopeBuildItem` の使用。このビルドアイテムを使用すると、特定の条件を満たすクラスにスコープを追加することができます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:99
#, no-wrap
msgid "`AutoAddScopeBuildItem` Example"
msgstr "`AutoAddScopeBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:108
#, no-wrap
msgid ""
"@BuildStep\n"
"AutoAddScopeBuildItem autoAddScope() {\n"
"   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n"
"      .defaultScope(BuiltinScope.SINGLETON) <2>\n"
"      .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:110
msgid "Find all classes annotated with `@Scheduled`."
msgstr "`@Scheduled` でアノテーションされたすべてのクラスを検索"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:111
msgid "Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically."
msgstr "デフォルトのスコープとして `@Singleton` を追加。既にスコープでアノテーションされているクラスは自動的にスキップされます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:113
msgid "_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`."
msgstr "_解決策2_: 特定のアノテーションが付けられたクラスを処理する必要がある場合は、`BeanDefiningAnnotationBuildItem` を介して Bean 定義アノテーションのセットを拡張することができます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:114
#, no-wrap
msgid "`BeanDefiningAnnotationBuildItem` Example"
msgstr "`BeanDefiningAnnotationBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:121
#, no-wrap
msgid ""
"@BuildStep\n"
"BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n"
"   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:123
msgid "Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations."
msgstr "Bean 定義アノテーションのセットに `org.eclipse.microprofile.graphql.GraphQLApi` を追加します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:127
#, fuzzy
msgid "Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.  However, you can change the default behavior.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr "`BeanDefiningAnnotationBuildItem` を介して追加された Bean クラスは，デフォルトでは _削除できない _。すなわち，結果として生じる Bean が未使用とみなされたとしても，削除してはならない。しかし、デフォルトの動作を変更することができる。詳細については， link:cdi-reference.html#remove_unused_beans[未使用のビーンの削除] 及び link:#unremovable_builditem[_理由3 _：クラスが発見され，ビーン定義アノテーションをもつが削除さ] れたも参照。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:130
msgid "It is also possible to specify the default scope.  The default scope is only used if there is no scope declared on the bean class."
msgstr "デフォルトスコープを設定することもできます。デフォルトスコープは、Bean クラスにスコープが宣言されていない場合にのみ使用されます。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:134
#, no-wrap
msgid "_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed"
msgstr "_理由3_: クラスが検出され、Bean 定義のアノテーションがあるが削除されている"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:141
#, fuzzy
msgid "The container attempts to xref:cdi-reference.adoc#remove_unused_beans[remove all unused beans] during the build by default.  This optimization allows for _framework-level dead code elimination_.  In few special cases, it's not possible to correctly identify an unused bean.  In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.  Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
msgstr "コンテナは、デフォルトでビルド中に link:cdi-reference.html#remove_unused_beans[すべての未使用ビーンズを削除] しようとする。この最適化によって， _フレームワークレベルのデッドコード除去が _可能になる。いくつかの特殊なケースでは、未使用のBeanを正しく識別することができません。特に、Quarkusでは、 `CDI.current()` 静的メソッドの使用をまだ検出することができません。拡張機能では、 `UnremovableBeanBuildItem` を生成することで、誤検出の可能性を排除することができます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:142
#, no-wrap
msgid "`UnremovableBeanBuildItem` Example"
msgstr "`UnremovableBeanBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:149
#, no-wrap
msgid ""
"@BuildStep\n"
"UnremovableBeanBuildItem unremovableBeans() {\n"
"   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:151
msgid "Make all classes annotated with `@Startup` unremovable."
msgstr "`@Startup` でアノテーションされたすべてのクラスを削除できないようにする。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:152
#, no-wrap
msgid "Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding"
msgstr "ユースケース - アノテーションが修飾子またはインターセプターバインディングとして認識されない"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:156
msgid "It is likely that the annotation class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "アノテーションクラスがアプリケーションインデックスに含まれていない可能性があります。たとえば、Quarkus エクステンションの _ランタイムモジュール_ のクラスは自動的にインデックス化されません。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:158
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in xref:additional_bean_build_item[_Reason 1_: Class Is Not discovered]."
msgstr "_解決方法_ link:#additional_bean_build_item[_理由1 _：クラスが発見さ] れない」で説明したように、 `AdditionalBeanBuildItem` を使用します。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:160
#, fuzzy, no-wrap
msgid "Use Case - I Need To Transform Annotation Metadata"
msgstr "ユースケース - アノテーションメタデータを変換する必要がある"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:165
#, fuzzy
msgid "In some cases, it's useful to be able to modify the annotation metadata.  Quarkus provides a powerful alternative to https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].  With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
msgstr "場合によっては、注釈のメタデータを変更できると便利です。Quarkusは、次のような強力な代替手段を提供します。 link:https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, target=\"_blank\"] . `AnnotationsTransformerBuildItem` を使えば、Bean クラスに存在するアノテーションを上書きすることが可能です。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:167
msgid "Keep in mind that annotation transformers must be produced _before_ the bean discovery starts."
msgstr "アノテーショントランスフォーマーは、Beanディスカバリが始まる _前に_ 生成されなければならないことを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:170
#, fuzzy
msgid "For example, you might want to add an interceptor binding to a specific bean class.  You can use a convenient builder-like API to create a transformer instance:"
msgstr "例えば、特定のBeanクラスへのインターセプターバインディングを追加したい場合があります。便利なビルダーのような API を使って、トランスフォーマーのインスタンスを作成することができます："

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:172
#, fuzzy
msgid "Builder Example"
msgstr "ビルダー例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:180
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(AnnotationsTransformer.appliedToClass() <1>\n"
"        .whenClass(c -> c.name().toString().equals(\"org.acme.Bar\")) <2>\n"
"        .thenTransform(t -> t.add(MyInterceptorBinding.class))); <3>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:182
#: upstream/_guides/cdi-integration.adoc:207
msgid "The transformer is only applied to classes."
msgstr "トランスフォーマーはクラスにのみ適用されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:183
#, fuzzy
msgid "Only apply the transformation if the class name equals to `org.acme.Bar`."
msgstr "クラス名が `org.acme.Bar` に等しい場合のみ、変換を適用します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:184
#, fuzzy
msgid "Add the `@MyInterceptorBinding` annotation."
msgstr "`@MyInterceptorBinding` のアノテーションを追加します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:186
#, fuzzy
msgid "The example above can be rewritten with an anonymous class:"
msgstr "上の例は、匿名クラスで書き換えることができます："

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:187
#, no-wrap
msgid "`AnnotationsTransformerBuildItem` Example"
msgstr "`AnnotationsTransformerBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:193
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:197
#, no-wrap
msgid ""
"      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n"
"         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n"
"      }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:205
#, no-wrap
msgid ""
"      public void transform(TransformationContext context) {\n"
"         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n"
"            context.transform().add(MyInterceptorBinding.class).done(); <2>\n"
"         }\n"
"      }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:208
msgid "If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`."
msgstr "クラス名が `org.acme.Bar` と同じ場合は、`@MyInterceptorBinding` を追加します。`Transformation#done()` を呼び出すことを忘れないでください。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:210
msgid "Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`."
msgstr "ビルドステップでは、`TransformedAnnotationsBuildItem` を介して、特定のアノテーションターゲットの変換済みアノテーションをクエリーできます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:211
#, no-wrap
msgid "`TransformedAnnotationsBuildItem` Example"
msgstr "`TransformedAnnotationsBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:221
#, no-wrap
msgid ""
"@BuildStep\n"
"void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n"
"   ClassInfo myClazz = ...;\n"
"   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:223
msgid "`TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations."
msgstr "`TransformedAnnotationsBuildItem.getAnnotations()` は、変換された可能性のあるアノテーションのセットを返します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:225
#, fuzzy
msgid "There are other build items specialized in transformation: xref:additional_interceptor_bindings[Use Case - Additional Interceptor Bindings] and xref:injection_point_transformation[Use Case - Injection Point Transformation]."
msgstr "変換に特化したビルド項目は他にもあります： link:#additional_interceptor_bindings[ユースケース - インターセプターバインディングの] 追加」「 link:#injection_point_transformation[ユースケース - インジェクションポイントの変換] 」です。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:226
#, no-wrap
msgid "How to Enable Trace Logging for Annotation Transformers"
msgstr "Annotation TransformerのTrace Loggingを有効にする方法"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:229
msgid "You can set the `TRACE` level for the category `io.quarkus.arc.processor` and try to analyze the log output afterwards."
msgstr " `io.quarkus.arc.processor` のカテゴリーに `TRACE` レベルを設定し、その後、ログ出力の解析を試みてください。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:230
#, no-wrap
msgid "`application.properties` Example"
msgstr "`application.properties` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:235
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.arc.processor\".min-level=TRACE <1>\n"
"quarkus.log.category.\"io.quarkus.arc.processor\".level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:237
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "また、関連するカテゴリーの最小ログレベルを調整する必要があります。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:239
#, no-wrap
msgid "Use Case - Inspect Beans, Observers and Injection Points"
msgstr "ユースケース - Bean、オブザーバー、インジェクションポイントの検査"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:241
#, no-wrap
msgid "_Solution 1_: `BeanDiscoveryFinishedBuildItem`"
msgstr "_解決策1._ `BeanDiscoveryFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:245
msgid "Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.  However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered."
msgstr "`BeanDiscoveryFinishedBuildItem` のコンシューマーは、アプリケーションに登録されているすべてのクラスベースの Bean、オブザーバー、およびインジェクションポイントを簡単に検査できます。ただし、このビルドアイテムは合成コンポーネントが登録される _前_ に作成されるため、合成 Bean とオブザーバーは _含まれません_ 。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:247
msgid "Additionally, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "さらに、`BeanDiscoveryFinishedBuildItem#getBeanResolver()` から返された Bean リゾルバーを使用して、タイプセーフな解決ルールを適用できます。たとえば、必要な型と修飾子の特定の組み合わせを満たす Bean があるかどうかを確認できます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:248
#, no-wrap
msgid "`BeanDiscoveryFinishedBuildItem` Example"
msgstr "`BeanDiscoveryFinishedBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:256
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:258
msgid "The resulting list will not contain `@Named` synthetic beans."
msgstr "結果のリストに `@Named` 合成 Bean は含まれません。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:259
#, no-wrap
msgid "_Solution 2_: `SynthesisFinishedBuildItem`"
msgstr "_解決策2_ : `SynthesisFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:262
msgid "Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered."
msgstr "`SynthesisFinishedBuildItem` のコンシューマーは、アプリケーションに登録されているすべての Bean、オブザーバー、およびインジェクションポイントを簡単に検査できます。このビルドアイテムは合成コンポーネントが登録された _後_ に作成されるため、合成 Bean とオブザーバーも _含まれます_ 。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:264
msgid "Additionally, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "さらに、`SynthesisFinishedBuildItem#getBeanResolver()` から返された Bean リゾルバーを使用して、タイプセーフな解決ルールを適用できます。たとえば、必要な型と修飾子の特定の組み合わせを満たす Bean があるかどうかを確認できます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:265
#, no-wrap
msgid "`SynthesisFinishedBuildItem` Example"
msgstr "`SynthesisFinishedBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:273
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:275
msgid "The resulting list will contain `@Named` synthetic beans."
msgstr "結果のリストには、`@Named` 合成 Bean が含まれます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:277
#, no-wrap
msgid "Use Case - The Need for Synthetic Beans"
msgstr "ユースケース - 合成 Bean の必要性"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:283
msgid "Sometimes it is practical to be able to register a _synthetic bean_.  Bean attributes of a synthetic bean are not derived from a Java class, method or field.  Instead, all the attributes are defined by an extension.  In regular CDI, this could be achieved using the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods."
msgstr "ときには、_合成 Bean_ を登録できると便利な場合もあります。合成 Bean の Bean 属性は、Java クラス、メソッド、またはフィールドから派生したものではありません。代わりに、すべての属性はエクステンションによって定義されます。そうするために、通常の CDI では https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] メソッドを使用できます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:285
msgid "_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`."
msgstr "_解決策_: 合成 Bean を登録する必要がある場合は、`SyntheticBeanBuildItem` を使用します。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:286
#, no-wrap
msgid "`SyntheticBeanBuildItem` Example 1"
msgstr "`SyntheticBeanBuildItem` の例 1"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:296
#, no-wrap
msgid ""
"@BuildStep\n"
"SyntheticBeanBuildItem syntheticBean() {\n"
"   return SyntheticBeanBuildItem.configure(String.class)\n"
"             .qualifiers(AnnotationInstance.builder(MyQualifier.class).build())\n"
"             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n"
"             .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:298
#, fuzzy
msgid "Generate the bytecode of the `jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
msgstr "`jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` の実装のバイトコードを生成する。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:302
msgid "The output of a bean configurator is recorded as bytecode.  Therefore, there are some limitations in how a synthetic bean instance is created at runtime.  You can:"
msgstr "Bean Configurator の出力は、バイトコードとして記録されます。したがって、実行時に合成 Bean インスタンスを作成する方法にはいくつかの制限があります。以下が可能です。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:304
msgid "Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`."
msgstr "`Contextual#create(CreationalContext<T>)` メソッドのバイトコードを、`ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)` を介して直接生成します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:305
#, fuzzy
msgid "Pass a subclass of `io.quarkus.arc.BeanCreator` via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some build-time parameters via `ExtendedBeanConfigurator#param()` and synthetic injection points via `ExtendedBeanConfigurator#addInjectionPoint()`."
msgstr "`ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)` で `io.quarkus.arc.BeanCreator` のサブクラスを渡し、 `ExtendedBeanConfigurator#param()` でビルド時のパラメータを、 `ExtendedBeanConfigurator#addInjectionPoint()` で合成注入点を指定することができる。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:306
#, fuzzy
msgid "Produce the runtime instance through a proxy returned from a xref:writing-extensions.adoc#bytecode-recording[`@Recorder` method] and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)`, `ExtendedBeanConfigurator#runtimeProxy(Object)`, `ExtendedBeanConfigurator#supplier(Supplier<?>)` or `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)`."
msgstr "link:writing-extensions.html#bytecode-recording[`@Recorder` メソッドから] 返されたプロキシでランタイムインスタンスを生成し、 `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>) `, `ExtendedBeanConfigurator#runtimeProxy(Object) `, `ExtendedBeanConfigurator#supplier(Supplier<?>) `, `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)` で設定します。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:307
#, no-wrap
msgid "`SyntheticBeanBuildItem` Example 2"
msgstr "`SyntheticBeanBuildItem` の例 2"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:317
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo()) <2>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:319
msgid "By default, a synthetic bean is initialized during `STATIC_INIT`."
msgstr "デフォルトでは、合成 Bean は `STATIC_INIT` の間に初期化されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:320
msgid "The bean instance is supplied by a value returned from a recorder method."
msgstr "Bean インスタンスは、レコーダーメソッドから返される値によって提供されます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:323
#, fuzzy
msgid "It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.  See the xref:writing-extensions.adoc#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
msgstr "`RUNTIME_INIT` の間に初期化される合成ビーンをマークすることが可能です。 `STATIC_INIT` と `RUNTIME_INIT` の違いについては、「 link:writing-extensions.html#bootstrap-three-phases[Bootstrap の 3 つのフェーズと Quarkus の哲学] 」を参照してください。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:324
#, no-wrap
msgid "`RUNTIME_INIT` `SyntheticBeanBuildItem` Example"
msgstr "`RUNTIME_INIT` `SyntheticBeanBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:335
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .setRuntimeInit() <2>\n"
"                .runtimeValue(recorder.createFoo())\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:337
msgid "The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase."
msgstr "レコーダーは、`ExecutionTime.RUNTIME_INIT` フェーズで実行する必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:338
#: upstream/_guides/cdi-integration.adoc:381
msgid "The bean instance is initialized during `RUNTIME_INIT`."
msgstr "Bean インスタンスは、`RUNTIME_INIT` の間に初期化されます。"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:342
msgid "Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:"
msgstr "`RUNTIME_INIT` の間に初期化された合成 Bean は、`STATIC_INIT` の間にアクセスしてはいけません。runtime-init 合成 Bean にアクセスする `RUNTIME_INIT` ビルドステップは、`SyntheticBeansRuntimeInitBuildItem` を消費します。"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:351
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) \n"
"@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n"
"void accessFoo(TestRecorder recorder) {\n"
"   recorder.foo(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:353
msgid "This build step must be executed after `syntheticBean()` completes."
msgstr "このビルドステップは、`syntheticBean()` の完了後に実行する必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:354
msgid "This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized."
msgstr "このレコーダーメソッドでは `Foo` Bean インスタンスが呼び出されるため、必ずすべての合成 Bean が初期化された後にビルドステップが実行されることを確認する必要があります。"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:357
msgid "It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus."
msgstr "`BeanRegistrationPhaseBuildItem` を使用して合成 Bean を登録することもできます。ただし、エクステンション作成者においては、Quarkus にとってより慣用的な `SyntheticBeanBuildItem` を使用することをお勧めします。"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:358
#, fuzzy, no-wrap
msgid "Synthetic Injection Points"
msgstr "合成樹脂の注入口"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:363
#, fuzzy
msgid "A synthetic bean may register a synthetic injection point via the `ExtendedBeanConfigurator#addInjectionPoint()` method.  This injection point is validated at build time and considered when xref:cdi-reference.adoc#remove_unused_beans[detecting unused beans].  The injected reference is accessible through the `SyntheticCreationalContext#getInjectedReference()` methods at runtime."
msgstr "合成ビーンは， `ExtendedBeanConfigurator#addInjectionPoint()` メソッドによって，合成注入点を登録することができる。この注入点は，構築時に検証され， link:cdi-reference.html#remove_unused_beans[未使用Beanを検出する] ときに考慮される。注入された参照は，実行時に `SyntheticCreationalContext#getInjectedReference()` メソッドを通じてアクセス可能である。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:364
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Build Step Example"
msgstr "合成樹脂の射出ポイント - ビルドステップ例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:369
#, no-wrap
msgid ""
"import org.jboss.jandex.ClassType;\n"
"import org.jboss.jandex.DotName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:379
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class)\n"
"                .scope(Singleton.class)\n"
"                .addInjectionPoint(ClassType.create(DotName.createSimple(Bar.class))) <2>\n"
"                .createWith(recorder.createFoo()) <3>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:382
#, fuzzy
msgid "A synthetic injection point with required type `Bar` was added; this is an equivalent of `@Inject Bar`."
msgstr "必須タイプ `Bar` の合成射出ポイントが追加されました。これは、 `@Inject Bar` と同等です。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:383
#, fuzzy
msgid "The bean instance is created with a function returned from a recorder method."
msgstr "レコーダーメソッドから返される関数でBeanインスタンスが生成されます。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:384
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Recorder Example"
msgstr "合成樹脂の射出点 - レコーダーの例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:389
#, no-wrap
msgid ""
"@Recorder\n"
"public class TestRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:396
#, no-wrap
msgid ""
"   public Function<SyntheticCreationalContext<Foo>, Foo> createFoo() {\n"
"     return (context) -> {\n"
"        return new Foo(context.getInjectedReference(Bar.class)); <1>\n"
"     };\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:398
#, fuzzy
msgid "Pass a contextual reference of `Bar` to the constructor of `Foo`."
msgstr "`Foo` のコンストラクタに `Bar` のコンテキスト参照を渡します。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:400
#, no-wrap
msgid "Use Case - Synthetic Observers"
msgstr "ユースケース - 合成オブザーバー"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:403
#, fuzzy
msgid "Similar to xref:synthetic_beans[synthetic beans], the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
msgstr "link:#synthetic_beans[合成ビーンズと] 同様に，合成オブザーバメソッドの属性は，Javaメソッドから派生するものではない。その代わりに、すべての属性は拡張によって定義される。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:405
msgid "_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`."
msgstr "_解決策_: 合成オブザーバーを登録する必要がある場合は、`ObserverRegistrationPhaseBuildItem` を使用します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:407
msgid "A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "`ObserverRegistrationPhaseBuildItem` を消費するビルドステップでは、常に `ObserverConfiguratorBuildItem` を生成するか、少なくともこのビルドアイテムに `BuildProducer` を 挿入する必要があります。でなければ、無視されるか、間違ったタイミングで処理される可能性があります (例: 正しい CDI ブートストラップフェーズの後)。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:408
#, no-wrap
msgid "`ObserverRegistrationPhaseBuildItem` Example"
msgstr "`ObserverRegistrationPhaseBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:424
#, no-wrap
msgid ""
"@BuildStep\n"
"void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem, \n"
"            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurationRegistry) {\n"
"   observerConfigurationRegistry.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext()\n"
"       .configure()\n"
"       .beanClass(DotName.createSimple(MyBuildStep.class.getName()))\n"
"       .observedType(String.class)\n"
"       .notify(mc -> {\n"
"           // do some gizmo bytecode generation...\n"
"       })));\n"
"   myBuildItem.produce(new MyBuildItem());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:429
msgid "The output of a `ObserverConfigurator` is recorded as bytecode.  Therefore, there are some limitations in how a synthetic observer is invoked at runtime.  Currently, you must generate the bytecode of the method body directly."
msgstr "`ObserverConfigurator` の出力はバイトコードとして記録されます。したがって、実行時に合成オブザーバーを呼び出す方法にはいくつかの制限があります。現時点では、メソッド本体のバイトコードを直接生成する必要があります。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:431
#, no-wrap
msgid "Use Case - I Have a Generated Bean Class"
msgstr "ユースケース - 生成された Bean クラスがある"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:435
msgid "No problem.  You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`."
msgstr "問題ありません。Bean クラスのバイトコードを手動で生成し、その後に `GeneratedClassBuildItem` ではなく `GeneratedBeanBuildItem` を生成してください。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:436
#, no-wrap
msgid "`GeneratedBeanBuildItem` Example"
msgstr "`GeneratedBeanBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:448
#, no-wrap
msgid ""
"@BuildStep\n"
"void generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n"
"    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n"
"    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n"
"                .className(\"org.acme.MyBean\")\n"
"                .build();\n"
"    beanClassCreator.addAnnotation(Singleton.class);\n"
"    beanClassCreator.close(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:450
msgid "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs."
msgstr "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` を使用すると、Gizmo コンストラクトから ``GeneratedBeanBuildItem`` を簡単に作成できます。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:451
msgid "The resulting bean class is something like `public class @Singleton MyBean { }`."
msgstr "結果の Bean クラスは、次のようになります: `public class @Singleton MyBean { }`。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:452
#, no-wrap
msgid "Use Case - I Need to Validate the Deployment"
msgstr "ユースケース - デプロイメントを検証する必要がある"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:455
msgid "Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong."
msgstr "エクステンションは、Bean、オブザーバー、およびインジェクションポイントを検査し、さらに追加の検証を実行して、何か問題がある場合はビルドを失敗にする必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:457
msgid "_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`."
msgstr "_解決策_: エクステンションがデプロイメントを検証する必要がある場合、`ValidationPhaseBuildItem` を使用します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:459
msgid "A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "`ValidationPhaseBuildItem` を消費するビルドステップでは、常に `ValidationErrorBuildItem` を生成するか、少なくともこのビルドアイテムに `BuildProducer` を 挿入する必要があります。でなければ、無視されるか、間違ったタイミングで処理される可能性があります (例: 正しい CDI ブートストラップフェーズの後)。"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:471
#, no-wrap
msgid ""
"@BuildStep\n"
"void validate(ValidationPhaseBuildItem validationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem, \n"
"            BuildProducer<ValidationErrorBuildItem> errors) {\n"
"   if (someCondition) {\n"
"     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:474
msgid "You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method."
msgstr "`ValidationPhaseBuildItem.getContext().beans()` メソッドから返される便利な `BeanStream` を使用して、登録されているすべての Bean を簡単にフィルタリングできます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:476
#, no-wrap
msgid "Use Case - Register a Custom CDI Context"
msgstr "ユースケース - カスタム CDI コンテキストの登録"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:479
msgid "Sometimes extensions need to extend the set of built-in CDI contexts."
msgstr "時々、エクステンションは組み込みCDI コンテキストのセットを拡張する必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:481
msgid "_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`."
msgstr "_解決策_: カスタムコンテキストを登録する必要がある場合は、`ContextRegistrationPhaseBuildItem` を使用します。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:483
msgid "A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "`ContextRegistrationPhaseBuildItem` を消費するビルドステップでは、常に `ContextConfiguratorBuildItem` を生成するか、少なくともこのビルドアイテムに `BuildProducer`を 挿入する必要があります。でなければ、無視されるか、間違ったタイミングで処理される可能性があります (例: 正しい CDI ブートストラップフェーズの後)。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:485
msgid "`ContextRegistrationPhaseBuildItem` Example"
msgstr "`ContextRegistrationPhaseBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:491
#, no-wrap
msgid ""
"@BuildStep\n"
"ContextConfiguratorBuildItem registerContext(ContextRegistrationPhaseBuildItem phase) {\n"
"      return new ContextConfiguratorBuildItem(phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:494
msgid "Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations."
msgstr "さらに、`ContextRegistrationPhaseBuildItem` を介してカスタム CDI コンテキストを登録する各エクステンションは、Bean 定義アノテーションのセットにカスタムスコープアノテーション名を提供するために、`CustomScopeBuildItem` も生成する必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:496
msgid "`CustomScopeBuildItem` Example"
msgstr "`CustomScopeBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:502
#, no-wrap
msgid ""
"@BuildStep\n"
"CustomScopeBuildItem customScope() {\n"
"   return new CustomScopeBuildItem(DotName.createSimple(TransactionScoped.class.getName()));\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:504
#, no-wrap
msgid "What if I Need to Know All the Scopes Used in the Application?"
msgstr "アプリケーションで使用されているすべてのスコープを知る必要がある場合はどうなりますか?"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:507
msgid "_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."
msgstr "_ソリューション_: ビルドステップで `CustomScopeAnnotationsBuildItem` を挿入し、 `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()` などの便利なメソッドを使用できます。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:509
#, no-wrap
msgid "Use Case - Additional Interceptor Bindings"
msgstr "ユースケース - 追加のインターセプターバインディング"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:514
#, fuzzy
msgid "In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@jakarta.interceptor.InterceptorBinding` as an interceptor binding.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.  We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
msgstr "まれに、 `@jakarta.interceptor.InterceptorBinding` でアノテーションされていない既存のアノテーションをインターセプターバインディングとしてプログラム的に登録することが便利な場合があります。これは、CDIが `BeforeBeanDiscovery#addInterceptorBinding()` を使って実現することと似ています。ここでは、これを実現するために `InterceptorBindingRegistrarBuildItem` を使用します。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:515
#, no-wrap
msgid "`InterceptorBindingRegistrarBuildItem` Example"
msgstr "`InterceptorBindingRegistrarBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:527
#, no-wrap
msgid ""
"@BuildStep\n"
"InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n"
"    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n"
"        @Override\n"
"        public List<InterceptorBinding> getAdditionalBindings() {\n"
"            return List.of(InterceptorBinding.of(NotAnInterceptorBinding.class));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:529
#, no-wrap
msgid "Use Case - Additional Qualifiers"
msgstr "使用例 - 追加の修飾子"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:534
#, fuzzy
msgid "Sometimes it might be useful to register an existing annotation that is not annotated with `@jakarta.inject.Qualifier` as a CDI qualifier.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.  We are going to use `QualifierRegistrarBuildItem` to get it done."
msgstr "`@jakarta.inject.Qualifier` でアノテーションされていない既存のアノテーションをCDI修飾語として登録することが有用な場合があります。これは、CDIが `BeforeBeanDiscovery#addQualifier()` を通して実現するものと似ています。私たちは、これを実現するために `QualifierRegistrarBuildItem` を使用するつもりです。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:535
#, no-wrap
msgid "`QualifierRegistrarBuildItem` Example"
msgstr "`QualifierRegistrarBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:548
#, no-wrap
msgid ""
"@BuildStep\n"
"QualifierRegistrarBuildItem addQualifiers() {\n"
"    return new QualifierRegistrarBuildItem(new QualifierRegistrar() {\n"
"        @Override\n"
"        public Map<DotName, Set<String>> getAdditionalQualifiers() {\n"
"            return Collections.singletonMap(DotName.createSimple(NotAQualifier.class.getName()),\n"
"                                        Collections.emptySet());\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:550
#, no-wrap
msgid "Use Case - Additional Stereotypes"
msgstr "使用例 - 追加のステレオタイプ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:555
#, fuzzy
msgid "It is sometimes useful to register an existing annotation that is not annotated with `@jakarta.enterprise.inject.Stereotype` as a CDI stereotype.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addStereotype()`.  We are going to use `StereotypeRegistrarBuildItem` to get it done."
msgstr "`@jakarta.enterprise.inject.Stereotype` でアノテーションされていない既存のアノテーションを、CDI ステレオタイプとして登録することが有用な場合があります。これは、CDI が `BeforeBeanDiscovery#addStereotype()` を使って実現することと似ています。ここでは、 `StereotypeRegistrarBuildItem` を使ってそれを実現することにします。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:556
#, no-wrap
msgid "`StereotypeRegistrarBuildItem` Example"
msgstr "`StereotypeRegistrarBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:568
#, no-wrap
msgid ""
"@BuildStep\n"
"StereotypeRegistrarBuildItem addStereotypes() {\n"
"    return new StereotypeRegistrarBuildItem(new StereotypeRegistrar() {\n"
"        @Override\n"
"        public Set<DotName> getAdditionalStereotypes() {\n"
"            return Collections.singleton(DotName.createSimple(NotAStereotype.class.getName()));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:571
#, fuzzy
msgid "If the newly registered stereotype annotation doesn't have the appropriate meta-annotations, such as scope or interceptor bindings, use an xref:annotations_transformer_build_item[annotation transformation] to add them."
msgstr "新しく登録されたステレオタイプ注釈に、スコープやインターセプターのバインディングなど、適切なメタ注釈がない場合は、 link:#annotations_transformer_build_item[注釈変換を] 使用して追加します。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:573
#, no-wrap
msgid "Use Case - Injection Point Transformation"
msgstr "ユースケース - インジェクションポイントの変換"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:578
msgid "Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.  You can do just that with `InjectionPointTransformerBuildItem`.  The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:"
msgstr "プログラムでインジェクションポイントの修飾子を変更できると便利な場合があります。それは、`InjectionPointTransformerBuildItem` で実行できます。次のサンプルは、修飾子 `MyQualifier` を含むタイプ `Foo` のインジェクションポイント変換を適用する方法を示しています。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:579
#, no-wrap
msgid "`InjectionPointTransformerBuildItem` Example"
msgstr "`InjectionPointTransformerBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:585
#, no-wrap
msgid ""
"@BuildStep\n"
"InjectionPointTransformerBuildItem transformer() {\n"
"    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:589
#, no-wrap
msgid ""
"        public boolean appliesTo(Type requiredType) {\n"
"            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:601
#, no-wrap
msgid ""
"        public void transform(TransformationContext context) {\n"
"            if (context.getQualifiers().stream()\n"
"                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n"
"                context.transform()\n"
"                        .removeAll()\n"
"                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n"
"                        .done();\n"
"            }\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:604
#, fuzzy
msgid "In theory, you can use xref:annotations_transformer_build_item[an `AnnotationsTransformer`] to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
msgstr "理論的には、 link:#annotations_transformer_build_item[`AnnotationsTransformer`] を使用して同じ目標を達成することができます。しかし、 `InjectionPointsTransformer` がこの特定のタスクに適しているいくつかの違いがあります。(1) 注釈変換はビーン発見時にすべてのクラスに適用されますが、 `InjectionPointsTransformer` はビーン発見後に発見された注入ポイントにのみ適用されます。(2) `InjectionPointsTransformer` では、さまざまなタイプの注入ポイント (フィールド、初期化メソッドのパラメータなど) を扱う必要がない。"

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:605
#, no-wrap
msgid "Use Case - Resource Annotations and Injection"
msgstr "ユースケース - リソースアノテーションとインジェクション"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:609
msgid "The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.  An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation."
msgstr "`ResourceAnnotationBuildItem` を使用して、Jakarta EE リソースなどの非 CDI インジェクションポイントを解決できるリソースアノテーションを指定できます。インテグレーターは、対応する `io.quarkus.arc.ResourceReferenceProvider` サービスプロバイダー実装も提供する必要があります。"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:610
#, no-wrap
msgid "`ResourceAnnotationBuildItem` Example"
msgstr "`ResourceAnnotationBuildItem` の例"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:619
#, no-wrap
msgid ""
"@BuildStep\n"
"void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n"
"    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n"
"        MyResourceReferenceProvider.class.getName().getBytes()));\n"
"    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:622
#, no-wrap
msgid "Available Build Time Metadata"
msgstr "利用可能なビルドタイムメタデータ"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:626
msgid "Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.  The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:"
msgstr "`BuildExtension.BuildContext` で動作する上記のエクステンションはいずれも、ビルドタイムに生成される特定のビルドタイムメタデータを利用することができます。 `io.quarkus.arc.processor.BuildExtension.Key` にある組込キーは以下の通りです。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:627
#, no-wrap
msgid "ANNOTATION_STORE"
msgstr "ANNOTATION_STORE"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:628
msgid "Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers"
msgstr "アノテーショントランスフォーマーを適用した後は、すべての`AnnotationTarget`アノテーションに関する情報を保持する `AnnotationStore` が含まれます"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:628
#, no-wrap
msgid "INJECTION_POINTS"
msgstr "INJECTION_POINTS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:629
msgid "`Collection<InjectionPointInfo>` containing all injection points"
msgstr "すべてのインジェクションポイントを含む `Collection<InjectionPointInfo>`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:629
#, no-wrap
msgid "BEANS"
msgstr "BEANS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:630
msgid "`Collection<BeanInfo>` containing all beans"
msgstr "すべての Bean を含む `Collection<BeanInfo>`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:630
#, no-wrap
msgid "REMOVED_BEANS"
msgstr "REMOVED_BEANS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:631
#, fuzzy
msgid "`Collection<BeanInfo>` containing all the removed beans; see xref:cdi-reference.adoc#remove_unused_beans[Removing unused beans] for more information"
msgstr "`Collection<BeanInfo>` 削除されたビーンズを全て含む。詳細は link:cdi-reference.html#remove_unused_beans[未使用ビーンズの削除を] 参照"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:631
#, no-wrap
msgid "OBSERVERS"
msgstr "OBSERVERS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:632
msgid "`Collection<ObserverInfo>` containing all observers"
msgstr "すべてのオブザーバーを含む `Collection<ObserverInfo>`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:632
#, no-wrap
msgid "SCOPES"
msgstr "SCOPES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:633
msgid "`Collection<ScopeInfo>` containing all scopes, including custom ones"
msgstr "カスタムスコープも含め、すべてのスコープを含む `Collection<ScopeInfo>`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:633
#, no-wrap
msgid "QUALIFIERS"
msgstr "QUALIFIERS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:634
msgid "`Map<DotName, ClassInfo>` containing all qualifiers"
msgstr "すべての修飾子を含む `Map<DotName, ClassInfo>`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:634
#, no-wrap
msgid "INTERCEPTOR_BINDINGS"
msgstr "INTERCEPTOR_BINDINGS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:635
msgid "`Map<DotName, ClassInfo>` containing all interceptor bindings"
msgstr "すべてのインターセプターバインディングを含む `Map<DotName, ClassInfo>`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:635
#, no-wrap
msgid "STEREOTYPES"
msgstr "STEREOTYPES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:636
msgid "`Map<DotName, StereotypeInfo>` containing all stereotypes"
msgstr "すべてのステレオタイプを含む `Map<DotName, StereotypeInfo>`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:641
msgid "To get hold of these, simply query the extension context object for given key.  Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.  If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.  Here is a summary of which extensions can access which metadata:"
msgstr "これらのメタデータを取得するには、そのキーのエクステンションコンテキストオブジェクトをクエリするだけ可能です。これらのメタデータはビルドが進むにつれて利用可能になることに注意してください。エクステンションがまだ生成されていないメタデータを取得しようとすると、 `null` が返されます。どのエクステンションがどのメタデータにアクセスできるかをまとめてみました。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:642
#, no-wrap
msgid "AnnotationsTransformer"
msgstr "AnnotationsTransformer"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:643
msgid "Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap"
msgstr "ブートストラップのどのフェーズでもいつでも使えるので、メタデータに頼るべきではありません。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:643
#, no-wrap
msgid "ContextRegistrar"
msgstr "ContextRegistrar"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:644
#: upstream/_guides/cdi-integration.adoc:645
#: upstream/_guides/cdi-integration.adoc:646
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"
msgstr "`ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` . `STEREOTYPES` にアクセスできます。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:644
#, no-wrap
msgid "InjectionPointsTransformer"
msgstr "InjectionPointsTransformer"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:645
#, no-wrap
msgid "ObserverTransformer"
msgstr "ObserverTransformer"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:646
#, no-wrap
msgid "BeanRegistrar"
msgstr "BeanRegistrar"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:647
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "`ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (クラスベースBeanのみ), `OBSERVERS` (クラスベースobserverのみ), `INJECTION_POINTS` にアクセスできます。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:647
#, no-wrap
msgid "ObserverRegistrar"
msgstr "ObserverRegistrar"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:648
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "`ANNOTATION_STORE` , `QUALIFIERS` , `INTERCEPTOR_BINDINGS` , `STEREOTYPES` , `BEANS` , `OBSERVERS` (クラスベースのオブザーバーのみ), `INJECTION_POINTS` にアクセス可能です。"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:648
#, no-wrap
msgid "BeanDeploymentValidator"
msgstr "BeanDeploymentValidator"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:648
msgid "Has access to all build metadata"
msgstr "すべてのビルドメタデータにアクセスできます"

#~ msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
#~ msgstr "追加のロギングを有効にすることで、ブートストラップに関するより多くの情報を見ることができます。`-X` または `--debug` で Maven ビルドを実行し、 `io.quarkus.arc` を含む行を grep するだけです。<<cdi-reference.adoc#dev-mode,開発モード>> では、`quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` を使用することができ、2 つの特別なエンドポイントも自動的に登録され、JSON 形式でいくつかの基本的なデバッグ情報を提供します。"

#~ msgid "Classes and annotations are the primary source of bean-level metadata.  The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window=\"_blank\"] which is built from various sources during <<cdi-reference.adoc#bean_discovery,bean discovery>>.  However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.  Moreover, extensions can also register <<synthetic_beans,synthetic components>>.  This is an important aspect to realize when integrating CDI components in Quarkus."
#~ msgstr "クラスとアノテーションは、Bean レベルのメタデータの主要なソースです。初期のメタデータは、Bean の <<cdi-reference.adoc#bean_discovery,Beanディスカバリ>> 時に様々なソースから構築される不変の link:https://github.com/wildfly/jandex[Jandexインデックス, window=\"_blank\"] である _Beanアーカイブインデックス_ から読み込まれます。しかし、エクステンションは、ブートストラップの特定の段階でメタデータを追加、削除、変換することができます。さらに、エクステンションは <<synthetic_beans,synthetic components>> を登録することもできます。これは、CDI コンポーネントを Quarkus に統合する際に実現すべき重要な側面です。"

#~ msgid "An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.  Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.  There are several reasons why a class is not recognized and also several ways to fix it.  In the first step we should identify the _reason_."
#~ msgstr "`UnsatisfiedResolutionException` は、<<cdi.adoc#typesafe_resolution,タイプセーフ解決>> 時に問題があることを示しています。クラスパス上にインジェクションが可能なクラスがあっても、インジェクションポイントを満たすことができないことがあります。クラスが認識されない理由はいくつかありますが、それを解決する方法もいくつかあります。最初のステップでは、その _理由_ を特定する必要があります。"

#~ msgid "Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.  It might happen that the class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
#~ msgstr "Quarkusには <<cdi-reference.adoc#bean_discovery,簡易ディスカバリ>> があります。クラスがアプリケーションのインデックスに含まれていないことが起こるかもしれません。例えば、Quarkusエクステンションの _ランタイムモジュール_ のクラスは自動的にインデックス化されません。"

#~ msgid "It is not possible to conditionally enable/disable additional beans via the `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` and `@UnlessBuildProperty` annotations as described in <<cdi-reference.adoc#enable_build_profile>> and <<cdi-reference.adoc#enable_build_properties>>. Extensions should inspect the configuration or the current profile and only produce an `AdditionalBeanBuildItem` if really needed."
#~ msgstr "<<cdi-reference.adoc#enable_build_profile>> および <<cdi-reference.adoc#enable_build_properties>> で説明されているように、 `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` および `@UnlessBuildProperty` アノテーションを介して、条件付きで追加のBeanを有効化/無効化することはできません。エクステンションは、設定または現在のプロファイルを検査し、本当に必要な場合にのみ `AdditionalBeanBuildItem` を生成するべきです。"

#~ msgid "Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.  If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.  However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.  See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
#~ msgstr "`AdditionalBeanBuildItem` 経由で追加された Bean クラスは、デフォルトでは _取り外し可能です_ 。コンテナーがそれらを <<cdi-reference.adoc#remove_unused_beans,unused>> とみなした場合、それらはただ無視されます。しかし、 `AdditionalBeanBuildItem.Builder.setUnremovable()` メソッドを使用して、このビルド項目を介して登録されたBeanクラスを絶対に削除しないようにコンテナーに指示することができます。詳細は、<<cdi-reference.adoc#remove_unused_beans,未使用のBeanの削除>> および <<unremovable_builditem>> も参照してください。"

#~ msgid "Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.  However, you can change the default behavior.  See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details."
#~ msgstr "`BeanDefiningAnnotationBuildItem` を介して追加された Bean クラスは、デフォルトでは _削除不可_ です。したがって、結果の Bean は未使用と見なされても削除しないでください。ただし、デフォルトの動作は変更できます。詳細については<<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> および<<unremovable_builditem>> を参照してください。"

#~ msgid "The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.  This optimization allows for _framework-level dead code elimination_.  In few special cases, it's not possible to correctly identify an unused bean.  In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.  Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
#~ msgstr "デフォルトで、コンテナーはビルド時に <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> を試行します。この最適化により、_フレームワークレベルでのデッドコードの排除_ が可能になります。いくつかの特殊なケースでは、未使用の Bean を正しく特定できません。特に、Quarkus はまだ `CDI.current()` 静的メソッドの使用を検出できません。エクステンションは、`UnremovableBeanBuildItem` を生成することで、誤検出の可能性をなくすことができます。"

#~ msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>."
#~ msgstr "_解決策_: <<additional_bean_build_item>> で説明されているとおりに `AdditionalBeanBuildItem` を使用します。"

#~ msgid "Use Case - I Need To Transform Metadata"
#~ msgstr "ユースケース - メタデータを変換する必要があります"

#~ msgid "In some cases, it's useful to be able to modify the metadata.  Quarkus provides a powerful alternative to https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].  With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
#~ msgstr "場合によっては、メタデータを変更できると便利です。Quarkus は、 https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"] の強力な代替手段を提供します。`AnnotationsTransformerBuildItem` を使用すると、Bean クラスに存在するアノテーションをオーバーライドできます。"

#~ msgid "For example, you might want to add an interceptor binding to a specific bean class.  Here is how to do it:"
#~ msgstr "たとえば、特定の Bean クラスにインターセプターバインディングを追加するとします。以下はその方法です。"

#~ msgid "There are other build items specialized in transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>."
#~ msgstr "変換に特化した他のビルドアイテム (<<additional_interceptor_bindings>> および<<injection_point_transformation>>) もあります。"

#~ msgid "Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
#~ msgstr "`javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` 実装の培土コードを生成します。"

#~ msgid "Pass a `io.quarkus.arc.BeanCreator` implementation class via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`."
#~ msgstr "`ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)` を介して `io.quarkus.arc.BeanCreator` 実装クラスを渡し、可能であれば `ExtendedBeanConfigurator#param()` を介していくつかのパラメーターを指定します。"

#~ msgid "Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder` method>> and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`."
#~ msgstr "<<writing-extensions.adoc#bytecode-recording,`@Recorder` メソッド>> から返されたプロキシー経由でランタイムインスタンスを生成し、それを `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` または `ExtendedBeanConfigurator#supplier(Supplier<?>)` 経由で設定します。"

#~ msgid "It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.  See the <<writing-extensions.adoc#bootstrap-three-phases,Three Phases of Bootstrap and Quarkus Philosophy>> for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
#~ msgstr "`RUNTIME_INIT` の間に初期化される合成 Bean をマークできます。`STATIC_INIT` と `RUNTIME_INIT` の違いの詳細については、<<writing-extensions.adoc#bootstrap-three-phases,Three Phases of Bootstrap and Quarkus Philosophy>> を参照してください。"

#~ msgid "Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
#~ msgstr "<<synthetic_beans,synthetic beans>> と同様に、合成オブザーバーメソッドの属性は Java メソッドから派生しません。代わりに、すべての属性がエクステンションによって定義されます。"

#~ msgid "In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.  We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
#~ msgstr "まれに、インターセプターバインディングとし て `@javax.interceptor.InterceptorBinding` でアノテーションが付けられていない既存のアノテーションをプログラムで登録すると便利な場合があります。これは、CDI が `BeforeBeanDiscovery#addInterceptorBinding()` で達成するものと似ています。これを行うには、`InterceptorBindingRegistrarBuildItem` を使用します。"

#~ msgid "Sometimes it might be useful to register an existing annotation that is not annotated with `@javax.inject.Qualifier` as a CDI qualifier.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.  We are going to use `QualifierRegistrarBuildItem` to get it done."
#~ msgstr "時には、 `@javax.inject.Qualifier` でアノテーションされていない既存のアノテーションをCDI修飾子として登録しておくと便利かもしれません。これは CDI が `BeforeBeanDiscovery#addQualifier()` を通して実現していることに似ています。ここでは `QualifierRegistrarBuildItem` を使ってそれを実現しようとしています。"

#~ msgid "It is sometimes useful to register an existing annotation that is not annotated with `@javax.enterprise.inject.Stereotype` as a CDI stereotype.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addStereotype()`.  We are going to use `StereotypeRegistrarBuildItem` to get it done."
#~ msgstr "時には、 `@javax.inject.Qualifier` でアノテーションされていない既存のアノテーションをCDIステレオタイプとして登録しておくと便利かもしれません。これは CDI が `BeforeBeanDiscovery#addQualifier()` を通して実現していることに似ています。ここでは `QualifierRegistrarBuildItem` を使ってそれを実現しようとしています。"

#~ msgid "If the newly registered stereotype annotation doesn't have the appropriate meta-annotations, such as scope or interceptor bindings, use an <<annotations_transformer_build_item,annotation transformation>> to add them."
#~ msgstr "新しく登録されたステレオタイプアノテーションに、スコープやインターセプターのバインディングなどの適切なメタアノテーションがない場合、 link:#annotations_transformer_build_item[アノテーション変換] を使用してそれらを追加します。"

#~ msgid "In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
#~ msgstr "理論的には、<<annotations_transformer_build_item,`AnnotationsTransformer`>> を使用して同じ目標を達成できます。ただし、次の多少の違いがあるため、このタスクには `InjectionPointsTransformer` の方が適しています。その違いとは次のとおりです。(1) アノテーショントランスフォーマーは Bean 検出中にすべてのクラスに適用されますが、`InjectionPointsTransformer` は Bean 検出後に検出されたインジェクションポイントにのみ適用されます。(2) `InjectionPointsTransformer` を使用すると、さまざまなタイプのインジェクションポイント (フィールド、初期化メソッドのパラメーターなど) を処理する必要がありません。"

#~ msgid "`Collection<BeanInfo>` containing all the removed beans; see <<cdi-reference.adoc#remove_unused_beans,Removing unused beans>> for more information"
#~ msgstr "削除されたすべての Bean を含む `Collection<BeanInfo>`。詳細については <<cdi-reference.adoc#remove_unused_beans,Removing unused beans>> を参照してください。"
