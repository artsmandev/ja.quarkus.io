# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2023-04-30 20:50+0900\n"
"PO-Revision-Date: 2023-04-08 21:43+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cache.adoc:6
#, no-wrap
msgid "Application Data Caching"
msgstr "アプリケーションデータのキャッシング"

#. type: Plain text
#: upstream/_guides/cache.adoc:13
msgid "In this guide, you will learn how to enable application data caching in any CDI managed bean of your Quarkus application."
msgstr "このガイドでは、QuarkusアプリケーションのCDI管理されたBeanでアプリケーションデータのキャッシングを有効にする方法について説明します。"

#. type: Title ==
#: upstream/_guides/cache.adoc:16
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Title ==
#: upstream/_guides/cache.adoc:20
#, no-wrap
msgid "Scenario"
msgstr "シナリオ"

#. type: Plain text
#: upstream/_guides/cache.adoc:25
msgid "Let's imagine you want to expose in your Quarkus application a REST API that allows users to retrieve the weather forecast for the next three days.  The problem is that you have to rely on an external meteorological service which only accepts requests for one day at a time and takes forever to answer.  Since the weather forecast is updated once every twelve hours, caching the service responses would definitely improve your API performances."
msgstr "Quarkusアプリケーションで、ユーザーが今後3日間の天気予報を取得できるREST APIを公開したいとします。問題は、一度に1日分のリクエストしか受け付けず、応答に時間がかかる外部の気象サービスに依存しなければならないことです。天気予報は12時間に一度更新されるので、サービスのレスポンスをキャッシュすればAPIのパフォーマンスは間違いなく向上します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:27
msgid "We'll do that using a single Quarkus annotation."
msgstr "これをQuarkusの単一のアノテーションを使用して行います。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:33
#, fuzzy
msgid "In this guide, we use the default Quarkus Cache backend (Caffeine).  You can use Redis instead.  Refer to the xref:cache-redis-reference.adoc[Redis cache backend reference] to configure the Redis backend."
msgstr "このガイドでは、デフォルトのQuarkus Cacheバックエンド(Caffeine)を使用します。代わりにRedisを使用することができます。 xref:cache-redis-reference.adoc[Redisキャッシュバックエンドのリファレンスを] 参照して、Redisバックエンドを設定します。"

#. type: Title ==
#: upstream/_guides/cache.adoc:35
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/cache.adoc:39
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "次のセクションで紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/cache.adoc:41
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "Gitレポジトリをクローン `git clone {quickstarts-clone-url}` するか、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。"

#. type: Plain text
#: upstream/_guides/cache.adoc:43
msgid "The solution is located in the `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory]."
msgstr "ソリューションは `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[ディレクトリ] にあります。"

#. type: Title ==
#: upstream/_guides/cache.adoc:44
#, no-wrap
msgid "Creating the Maven project"
msgstr "Mavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/cache.adoc:47
msgid "First, we need to create a new Quarkus project with the following command:"
msgstr "まず、以下のコマンドで新しいQuarkusプロジェクトを作成します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:53
msgid "This command generates the project and imports the `cache` and `resteasy-reactive-jackson` extensions."
msgstr "このコマンドは、プロジェクトを生成し、 `cache` と `resteasy-reactive-jackson` のエクステンションをインポートします。"

#. type: Plain text
#: upstream/_guides/cache.adoc:56
msgid "If you already have your Quarkus project configured, you can add the `cache` extension to your project by running the following command in your project base directory:"
msgstr "すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `cache` エクステンションを追加することができます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:61
msgid "This will add the following to your build file:"
msgstr "これにより、ビルドファイルに以下の内容が追加されます。"

#. type: Block title
#: upstream/_guides/cache.adoc:63
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/cache.adoc:69
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-cache</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/cache.adoc:72
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/cache.adoc:75
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-cache\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:77
#, no-wrap
msgid "Creating the REST API"
msgstr "REST APIの作成"

#. type: Plain text
#: upstream/_guides/cache.adoc:81
msgid "Let's start by creating a service that will simulate an extremely slow call to the external meteorological service.  Create `src/main/java/org/acme/cache/WeatherForecastService.java` with the following content:"
msgstr "まずは、外部気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/cache/WeatherForecastService.java` を作成します。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:85 upstream/_guides/cache.adoc:126
#: upstream/_guides/cache.adoc:156 upstream/_guides/cache.adoc:218
#: upstream/_guides/cache.adoc:353 upstream/_guides/cache.adoc:403
#: upstream/_guides/cache.adoc:433 upstream/_guides/cache.adoc:456
#: upstream/_guides/cache.adoc:505 upstream/_guides/cache.adoc:548
#: upstream/_guides/cache.adoc:590 upstream/_guides/cache.adoc:619
#: upstream/_guides/cache.adoc:651 upstream/_guides/cache.adoc:680
#: upstream/_guides/cache.adoc:819 upstream/_guides/cache.adoc:850
#: upstream/_guides/cache.adoc:882 upstream/_guides/cache.adoc:913
#: upstream/_guides/cache.adoc:943
#, no-wrap
msgid "package org.acme.cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:87 upstream/_guides/cache.adoc:220
#, no-wrap
msgid "import java.time.LocalDate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:89 upstream/_guides/cache.adoc:222
#: upstream/_guides/cache.adoc:355 upstream/_guides/cache.adoc:458
#: upstream/_guides/cache.adoc:592 upstream/_guides/cache.adoc:621
#: upstream/_guides/cache.adoc:653 upstream/_guides/cache.adoc:821
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:92 upstream/_guides/cache.adoc:227
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class WeatherForecastService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:101
#, no-wrap
msgid ""
"    public String getDailyForecast(LocalDate date, String city) {\n"
"        try {\n"
"            Thread.sleep(2000L); <1>\n"
"        } catch (InterruptedException e) {\n"
"            Thread.currentThread().interrupt();\n"
"        }\n"
"        return date.getDayOfWeek() + \" will be \" + getDailyResult(date.getDayOfMonth() % 4) + \" in \" + city;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:117 upstream/_guides/cache.adoc:253
#, no-wrap
msgid ""
"    private String getDailyResult(int dayOfMonthModuloFour) {\n"
"        switch (dayOfMonthModuloFour) {\n"
"            case 0:\n"
"                return \"sunny\";\n"
"            case 1:\n"
"                return \"cloudy\";\n"
"            case 2:\n"
"                return \"chilly\";\n"
"            case 3:\n"
"                return \"rainy\";\n"
"            default:\n"
"                throw new IllegalArgumentException();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:119
msgid "This is where the slowness comes from."
msgstr "遅さはここに由来します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:122
msgid "We also need a class that will contain the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/cache/WeatherForecast.java` this way:"
msgstr "また、ユーザーが次の3日間の天気予報を求めたときに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/cache/WeatherForecast.java` をこのように作成します。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:128
#, no-wrap
msgid "import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:130
#, no-wrap
msgid "public class WeatherForecast {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:132
#, no-wrap
msgid "    private List<String> dailyForecasts;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:134
#, no-wrap
msgid "    private long executionTimeInMs;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:139
#, no-wrap
msgid ""
"    public WeatherForecast(List<String> dailyForecasts, long executionTimeInMs) {\n"
"        this.dailyForecasts = dailyForecasts;\n"
"        this.executionTimeInMs = executionTimeInMs;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:143
#, no-wrap
msgid ""
"    public List<String> getDailyForecasts() {\n"
"        return dailyForecasts;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:148
#, no-wrap
msgid ""
"    public long getExecutionTimeInMs() {\n"
"        return executionTimeInMs;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:152
msgid "Now, we just need to create the REST resource.  Create the `src/main/java/org/acme/cache/WeatherForecastResource.java` file with this content:"
msgstr "あとは、RESTリソースを作成するだけです。 この内容で `src/main/java/org/acme/cache/WeatherForecastResource.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:160
#, no-wrap
msgid ""
"import java.time.LocalDate;\n"
"import java.util.Arrays;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:165
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:167
#, no-wrap
msgid "import org.jboss.resteasy.reactive.RestQuery;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:170
#, no-wrap
msgid ""
"@Path(\"/weather\")\n"
"public class WeatherForecastResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:173
#, no-wrap
msgid ""
"    @Inject\n"
"    WeatherForecastService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:185
#, no-wrap
msgid ""
"    @GET\n"
"    public WeatherForecast getForecast(@RestQuery String city, @RestQuery long daysInFuture) { <1>\n"
"        long executionStart = System.currentTimeMillis();\n"
"        List<String> dailyForecasts = Arrays.asList(\n"
"                service.getDailyForecast(LocalDate.now().plusDays(daysInFuture), city),\n"
"                service.getDailyForecast(LocalDate.now().plusDays(daysInFuture + 1L), city),\n"
"                service.getDailyForecast(LocalDate.now().plusDays(daysInFuture + 2L), city));\n"
"        long executionEnd = System.currentTimeMillis();\n"
"        return new WeatherForecast(dailyForecasts, executionEnd - executionStart);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:188
msgid "If the `daysInFuture` query parameter is omitted, the three days weather forecast will start from the current day.  Otherwise, it will start from the current day plus the `daysInFuture` value."
msgstr "`daysInFuture` クエリパラメーターが省略された場合、3 日間の天気予報は現在の日から始まります。それ以外の場合は、現在の日に `daysInFuture` の値を加えたものから始まります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:190
msgid "We're all done! Let's check if everything's working."
msgstr "完了です！うまくいっているか確認してみましょう。"

#. type: Plain text
#: upstream/_guides/cache.adoc:192
msgid "First, run the application using dev mode from the project directory:"
msgstr "まず、プロジェクトディレクトリからDevモードでアプリケーションを実行します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:197
msgid "Then, call `http://localhost:8080/weather?city=Raleigh` from a browser.  After six long seconds, the application will answer something like this:"
msgstr "次に、ブラウザから `http://localhost:8080/weather?city=Raleigh` を呼び出します。6秒ほど長い時間が経過すると、アプリケーションは次のような回答をします。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:201
#, no-wrap
msgid "{\"dailyForecasts\":[\"MONDAY will be cloudy in Raleigh\",\"TUESDAY will be chilly in Raleigh\",\"WEDNESDAY will be rainy in Raleigh\"],\"executionTimeInMs\":6001}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/cache.adoc:206
msgid "The response content may vary depending on the day you run the code."
msgstr "コードを実行する日によってレスポンスの内容が異なる場合があります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:209
msgid "You can try calling the same URL again and again, it will always take six seconds to answer."
msgstr "何度同じURLを呼び出してみても、必ず6秒でレスポンスが返却されます。"

#. type: Title ==
#: upstream/_guides/cache.adoc:210
#, no-wrap
msgid "Enabling the cache"
msgstr "キャッシュの有効化"

#. type: Plain text
#: upstream/_guides/cache.adoc:214
msgid "Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class like this:"
msgstr "Quarkusアプリケーションが動いたので、外部の気象サービスのレスポンスをキャッシュすることで、レスポンスタイムを大幅に改善してみましょう。 `WeatherForecastService` クラスを次のように修正します。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:224
#, no-wrap
msgid "import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:237
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"weather-cache\") <1>\n"
"    public String getDailyForecast(LocalDate date, String city) {\n"
"        try {\n"
"            Thread.sleep(2000L);\n"
"        } catch (InterruptedException e) {\n"
"            Thread.currentThread().interrupt();\n"
"        }\n"
"        return date.getDayOfWeek() + \" will be \" + getDailyResult(date.getDayOfMonth() % 4) + \" in \" + city;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:255
msgid "We only added this annotation (and the associated import of course)."
msgstr "このアノテーション(もちろん関連するインポートも)を追加しただけです。"

#. type: Plain text
#: upstream/_guides/cache.adoc:259
msgid "Let's try to call `http://localhost:8080/weather?city=Raleigh` again.  You're still waiting a long time before receiving an answer.  This is normal since the server just restarted and the cache was empty."
msgstr "`http://localhost:8080/weather?city=Raleigh` をもう一度実行してみましょう。レスポンスが来るまでにまだ長い時間待たされています。これはサーバーが再起動したばかりでキャッシュが空になっているので正常です。"

#. type: Plain text
#: upstream/_guides/cache.adoc:262
msgid "Wait a second! The server restarted by itself after the `WeatherForecastService` update? Yes, this is one of Quarkus amazing features for developers called `live coding`."
msgstr "ちょっと待って！ `WeatherForecastService` を更新した後にサーバーが勝手に再起動した？はい、これは `live coding` と呼ばれる開発者のためのQuarkusの素晴らしい機能の一つです。"

#. type: Plain text
#: upstream/_guides/cache.adoc:265
msgid "Now that the cache was loaded during the previous call, try calling the same URL.  This time, you should get a super fast answer with an `executionTimeInMs` value close to 0."
msgstr "前回の呼び出しでキャッシュが読み込まれたので、同じ URL を呼び出してみてください。今度は、 `executionTimeInMs` の値が 0 に近い超高速な応答が返ってくるはずです。"

#. type: Plain text
#: upstream/_guides/cache.adoc:268
msgid "Let's see what happens if we start from one day in the future using the `http://localhost:8080/weather?city=Raleigh&daysInFuture=1` URL.  You should get an answer two seconds later since two of the requested days were already loaded in the cache."
msgstr "`http://localhost:8080/weather?city=Raleigh&daysInFuture=1` のURLで、未来のある日から始めるとどうなるか見てみましょう。要求された日のうち2つはすでにキャッシュに読み込まれていたので、2秒後に回答が得られるはずです。"

#. type: Plain text
#: upstream/_guides/cache.adoc:271
msgid "You can also try calling the same URL with a different city and see the cache in action again.  The first call will take six seconds and the following ones will be answered immediately."
msgstr "また、同じURLを別の都市で呼び出してみて、再度キャッシュの動作を確認することもできます。最初の呼出には6秒ほどかかり、次の呼出にはすぐに出ます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:273
msgid "Congratulations! You just added application data caching to your Quarkus application with a single line of code!"
msgstr "おめでとうございます！たった1行のコードでQuarkusアプリケーションにアプリケーションデータのキャッシングを追加しました！"

#. type: Plain text
#: upstream/_guides/cache.adoc:276
msgid "Do you want to learn more about the Quarkus application data caching abilities? The following sections will show you everything there is to know about it."
msgstr "Quarkusアプリケーションのデータキャッシング機能について詳しく知りたいですか？次のセクションでは、この機能について知っておくべきことをすべて紹介します。"

#. type: Title ==
#: upstream/_guides/cache.adoc:278
#, no-wrap
msgid "Caching using annotations"
msgstr "アノテーションを利用したキャッシング"

#. type: Plain text
#: upstream/_guides/cache.adoc:281
msgid "Quarkus offers a set of annotations that can be used in a CDI managed bean to enable caching abilities."
msgstr "Quarkusは、CDI管理されたBeanで使用できる、キャッシュ機能を有効にするアノテーションのセットを提供します。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:286
msgid "Caching annotations are not allowed on private methods.  They will work fine with any other access modifier including package-private (no explicit modifier)."
msgstr "プライベートメソッドではキャッシュのアノテーションは許可されていません。package-private (明示的な修飾子を持たない) を含む他のアクセス修飾子では問題なく動作します。"

#. type: Title ===
#: upstream/_guides/cache.adoc:288
#, no-wrap
msgid "@CacheResult"
msgstr "@CacheResult"

#. type: Plain text
#: upstream/_guides/cache.adoc:291
msgid "Loads a method result from the cache without executing the method body whenever possible."
msgstr "可能な限り、メソッドボディを実行せずにキャッシュからメソッドの結果を読み込みます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:296
#, fuzzy
msgid "When a method annotated with `@CacheResult` is invoked, Quarkus will compute a cache key and use it to check in the cache whether the method has been already invoked.  See the xref:cache-keys-building-logic[Cache keys building logic] section of this guide to learn how the cache key is computed.  If a value is found in the cache, it is returned and the annotated method is never actually executed.  If no value is found, the annotated method is invoked and the returned value is stored in the cache using the computed key."
msgstr "`@CacheResult` でアノテーションされたメソッドが呼び出されると、Quarkusはキャッシュキーを計算し、そのキーを使用して、そのメソッドがすでに呼び出されているかどうかをキャッシュで確認します。キャッシュキーの計算方法については、このガイドの「 xref:cache-keys-building-logic[キャッシュキーの構築ロジック] 」セクションを参照してください。キャッシュ内に値が見つかった場合、その値が返され、アノテーションされたメソッドが実際に実行されることはありません。値が見つからない場合は、注釈付きメソッドが呼び出され、計算されたキーを使用して戻り値がキャッシュに格納されます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:303
msgid "A method annotated with `CacheResult` is protected by a lock on cache miss mechanism.  If several concurrent invocations try to retrieve a cache value from the same missing key, the method will only be invoked once.  The first concurrent invocation will trigger the method invocation while the subsequent concurrent invocations will wait for the end of the method invocation to get the cached result.  The `lockTimeout` parameter can be used to interrupt the lock after a given delay.  The lock timeout is disabled by default, meaning the lock is never interrupted.  See the parameter Javadoc for more details."
msgstr "`CacheResult` でアノテーションされたメソッドは、キャッシュミスのロックメカニズムによって保護されています。複数の同時呼び出しが値の欠落している同じキーからキャッシュされた値を取得しようとした場合、メソッドは一度だけ呼び出されます。最初の同時呼び出しはメソッドの呼び出しをトリガーし、その後の同時呼び出しはキャッシュされた結果を取得するためにメソッドの呼び出しの終了を待ちます。 `lockTimeout` パラメーターを使用すると、所定の遅延後にロックを中断することができます。ロックのタイムアウトは既定では無効になっており、ロックが中断されることはありません。詳細は、パラメーター Javadoc を参照してください。"

#. type: Plain text
#: upstream/_guides/cache.adoc:305
msgid "This annotation cannot be used on a method returning `void`."
msgstr "このアノテーションは、 `void` を返すメソッドでは使用できません。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:310
#, fuzzy
msgid "Quarkus is able to also cache `null` values unlike the underlying Caffeine provider.  See xref:negative-cache[more on this topic below]."
msgstr "Quarkusは、基盤となるCaffeineプロバイダとは異なり、 `null` の値もキャッシュすることができます。 xref:negative-cache[このトピックについては、以下を] 参照してください。"

#. type: Title ===
#: upstream/_guides/cache.adoc:312
#, no-wrap
msgid "@CacheInvalidate"
msgstr "@CacheInvalidate"

#. type: Plain text
#: upstream/_guides/cache.adoc:315
msgid "Removes an entry from the cache."
msgstr "キャッシュからエントリーを削除します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:319
#, fuzzy
msgid "When a method annotated with `@CacheInvalidate` is invoked, Quarkus will compute a cache key and use it to try to remove an existing entry from the cache.  See the xref:cache-keys-building-logic[Cache keys building logic] section of this guide to learn how the cache key is computed.  If the key does not identify any cache entry, nothing will happen."
msgstr "`@CacheInvalidate` でアノテーションされたメソッドが呼び出されると、Quarkusはキャッシュキーを計算し、それを使用してキャッシュから既存のエントリーを削除しようとします。キャッシュキーの計算方法については、このガイドの「 xref:cache-keys-building-logic[キャッシュキーの構築ロジック] 」セクションを参照してください。キーがどのキャッシュ・エントリも識別しない場合、何も起こりません。"

#. type: Title ===
#: upstream/_guides/cache.adoc:320
#, no-wrap
msgid "@CacheInvalidateAll"
msgstr "@CacheInvalidateAll"

#. type: Plain text
#: upstream/_guides/cache.adoc:323
msgid "When a method annotated with `@CacheInvalidateAll` is invoked, Quarkus will remove all entries from the cache."
msgstr "`@CacheInvalidateAll` でアノテーションされたメソッドが呼び出されると、Quarkusはキャッシュからすべてのエントリーを削除します。"

#. type: Title ===
#: upstream/_guides/cache.adoc:324
#, no-wrap
msgid "@CacheKey"
msgstr "@CacheKey"

#. type: Plain text
#: upstream/_guides/cache.adoc:328
msgid "When a method argument is annotated with `@CacheKey`, it is identified as a part of the cache key during an invocation of a method annotated with `@CacheResult` or `@CacheInvalidate`."
msgstr "メソッドの引数が `@CacheKey` でアノテーションされている場合、 `@CacheResult` または `@CacheInvalidate` でアノテーションされたメソッドの呼び出し時にキャッシュキーの一部として識別されます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:330
msgid "This annotation is optional and should only be used when some method arguments are NOT part of the cache key."
msgstr "このアノテーションはオプションで、メソッドの引数の一部がキャッシュキーの一部ではない場合にのみ使用されるべきです。"

#. type: Title ===
#: upstream/_guides/cache.adoc:332
#, no-wrap
msgid "Cache keys building logic"
msgstr "キャッシュキー構築ロジック"

#. type: Plain text
#: upstream/_guides/cache.adoc:335
msgid "Cache keys are built by the annotations API using the following logic:"
msgstr "キャッシュキーはアノテーションAPIにより、以下のロジックで構築されます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:337
msgid "If an `io.quarkus.cache.CacheKeyGenerator` is declared in a `@CacheResult` or a `@CacheInvalidate` annotation, then it is used to generate the cache key. The `@CacheKey` annotations that might be present on some method arguments are ignored."
msgstr " `io.quarkus.cache.CacheKeyGenerator` が `@CacheResult` または `@CacheInvalidate` アノテーションで宣言されている場合、キャッシュ・キーの生成に使用されます。いくつかのメソッド引数の存在する可能性のある `@CacheKey` アノテーションは無視されます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:338
msgid "Otherwise, if the method has no arguments, then the cache key is an instance of `io.quarkus.cache.DefaultCacheKey` built from the cache name."
msgstr "このメソッドに引数がなければ、キャッシュキーはキャッシュ名から作成される `io.quarkus.cache.DefaultCacheKey` のインスタンスとなります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:339
msgid "Otherwise, if the method has exactly one argument, then that argument is the cache key."
msgstr "このメソッドが正確に1つの引数を持つ場合、この引数はキャッシュキーとなります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:340
msgid "Otherwise, if the method has multiple arguments but only one annotated with `@CacheKey`, then that annotated argument is the cache key."
msgstr "メソッドに複数の引数があり、 `@CacheKey` でアノテーションされたものが１つだけある場合、このアノテーションされた引数がキャッシュキーとなります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:341
msgid "Otherwise, if the method has multiple arguments annotated with `@CacheKey`, then the cache key is an instance of `io.quarkus.cache.CompositeCacheKey` built from these annotated arguments."
msgstr "メソッドが `@CacheKey` でアノテーションされた複数の引数を持つ場合、キャッシュキーはこれらのアノテーションされた引数から構築される `io.quarkus.cache.CompositeCacheKey` のインスタンスになります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:342
msgid "Otherwise, if the method has multiple arguments and none of them are annotated with `@CacheKey`, the cache key is an instance of `io.quarkus.cache.CompositeCacheKey` built from all the method arguments."
msgstr "メソッドが複数の引数を持ち、そのどれにも `@CacheKey` でアノテーションされていない場合、キャッシュキーはすべてのメソッド引数から構築される `io.quarkus.cache.CompositeCacheKey` のインスタンスになります。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:346
msgid "Each non-primitive method argument that is part of the key must implement `equals()` and `hashCode()` correctly for the cache to work as expected."
msgstr "キーの一部である非プリミティブメソッドの各引数は、キャッシュが期待通りに動作するために、 `equals()` と `hashCode()` を正しく実装する必要があります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:349
msgid "When a cache key is built from several method arguments, whether they are explicitly identified with `@CacheKey` or not, the building logic depends on the order of these arguments in the method signature. On the other hand, the arguments names are not used at all and do not have any effect on the cache key."
msgstr "キャッシュキーが複数のメソッド引数から構築される場合、それらが明示的に `@CacheKey` で識別されているかどうかに関わらず、構築ロジックはメソッドシグネチャ内のこれらの引数の順序に依存します。一方、引数名は全く使用されず、キャッシュキーには何の影響も与えません。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:358
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:361 upstream/_guides/cache.adoc:468
#: upstream/_guides/cache.adoc:828
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CachedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:366
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public Object load(String keyElement1, Integer keyElement2) {\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:370
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate1(String keyElement2, Integer keyElement1) { <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:374
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate2(Integer keyElement2, String keyElement1) { <2>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:378
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate3(Object notPartOfTheKey, @CacheKey String keyElement1, @CacheKey Integer keyElement2) { <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:383
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate4(Object notPartOfTheKey, @CacheKey Integer keyElement2, @CacheKey String keyElement1) { <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:385
msgid "Calling this method WILL invalidate values cached by the `load` method even if the key elements names have been swapped."
msgstr "このメソッドを呼び出すと、キー要素名が入れ替わっていても `load` メソッドでキャッシュされた値が無効になります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:386 upstream/_guides/cache.adoc:388
msgid "Calling this method WILL NOT invalidate values cached by the `load` method because the key elements order is different."
msgstr "このメソッドを呼び出すと、キー要素の順序が異なるため、 `load` メソッドでキャッシュされた値が無効になることはありません。"

#. type: Plain text
#: upstream/_guides/cache.adoc:387
msgid "Calling this method WILL invalidate values cached by the `load` method because the key elements order is the same."
msgstr "このメソッドを呼び出すと、キー要素の順序が同じなので、 `load` メソッドでキャッシュされた値が無効になります。"

#. type: Title ===
#: upstream/_guides/cache.adoc:389
#, no-wrap
msgid "Generating a cache key with `CacheKeyGenerator`"
msgstr "`CacheKeyGenerator` でキャッシュキーを生成する"

#. type: Plain text
#: upstream/_guides/cache.adoc:393
msgid "You may want to include more than the arguments of a method into a cache key.  This can be done by implementing the `io.quarkus.cache.CacheKeyGenerator` interface and declaring that implementation in the `keyGenerator` field of a `@CacheResult` or `@CacheInvalidate` annotation."
msgstr "メソッドの引数以外もキャッシュ・キーに含めたい場合があります。これは、 `io.quarkus.cache.CacheKeyGenerator` インターフェイスを実装し、その実装を `@CacheResult` または `@CacheInvalidate` アノテーションの `keyGenerator` フィールドで宣言することで実現できます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:397
#, fuzzy
msgid "If a CDI scope is declared on a key generator class and if that class has a default qualifier (no qualifier annotation or `@jakarta.enterprise.inject.Default`), then the key generator will be injected as a CDI bean during the cache key computation.  Otherwise, the key generator will be instantiated using its default constructor.  All CDI scopes supported by Quarkus can be used on a key generator."
msgstr "CDIスコープがキー生成器クラス上で宣言され、そのクラスがデフォルトの修飾子をもつ場合（修飾子注釈又は `@jakarta.enterprise.inject.Default` ）、キー生成器はキャッシュキー計算中にCDIビーンとして注入される。そうでない場合、鍵生成器は、そのデフォルトコンストラクタを使用してインスタンス化される。QuarkusがサポートするすべてのCDIスコープは、キー・ジェネレーターで使用することができます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:399
msgid "The following key generator will be injected as a CDI bean:"
msgstr "以下のキージェネレータはCDI Beanとして注入されます。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:407
#, no-wrap
msgid ""
"import java.lang.reflect.Method;\n"
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:410 upstream/_guides/cache.adoc:438
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheKeyGenerator;\n"
"import io.quarkus.cache.CompositeCacheKey;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:413
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ApplicationScopedKeyGen implements CacheKeyGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:416
#, no-wrap
msgid ""
"    @Inject\n"
"    AnythingYouNeedHere anythingYouNeedHere; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:422
#, no-wrap
msgid ""
"    @Override\n"
"    public Object generate(Method method, Object... methodParams) { <2>\n"
"        return new CompositeCacheKey(anythingYouNeedHere.getData(), methodParams[1]); <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:424
msgid "External data can be included into the cache key by injecting a CDI bean in the key generator."
msgstr "キージェネレータにCDI Beanをインジェクトすることで、外部データをキャッシュキーに含めることができます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:425
msgid "Be careful while using `Method`, some of its methods can be expensive."
msgstr " `Method` を使っている間、メソッドのいくつかは高価になることがあるため注意してください。"

#. type: Plain text
#: upstream/_guides/cache.adoc:427
msgid "Make sure the method has enough arguments before accessing them from their index.  Otherwise, an `IndexOutOfBoundsException` may be thrown during the cache key computation."
msgstr "インデックスからアクセスする前に、このメソッドが十分な引数を持っていることを確認してください。そうでないと、キャッシュキーの計算中に `IndexOutOfBoundsException` が投げられるかもしれません。"

#. type: Plain text
#: upstream/_guides/cache.adoc:429
msgid "The following key generator will be instantiated using its default constructor:"
msgstr "以下のキージェネレータは、デフォルトのコンストラクタを使用してインスタンス化されます。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:435
#, no-wrap
msgid "import java.lang.reflect.Method;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:440
#, no-wrap
msgid "public class NotABeanKeyGen implements CacheKeyGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:442
#, no-wrap
msgid "    // CDI injections won't work here because it's not a CDI bean.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:448
#, no-wrap
msgid ""
"    @Override\n"
"    public Object generate(Method method, Object... methodParams) {\n"
"        return new CompositeCacheKey(method.getName(), methodParams[0]); <1>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:450
msgid "Including the method name into the cache key is not expensive, unlike other methods from `Method`."
msgstr "メソッド名をキャッシュキーに含めることは、 `Method` の他のメソッドとは異なり、高価なものではありません。"

#. type: Plain text
#: upstream/_guides/cache.adoc:452
msgid "Both kinds of key generators can be used in a similar way:"
msgstr "どちらの種類のキージェネレーターも、同様の方法で使用することができます。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:461
#, no-wrap
msgid ""
"import org.acme.cache.ApplicationScopedKeyGen;\n"
"import org.acme.cache.NotABeanKeyGen;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:465
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheKey;\n"
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:473
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\", keyGenerator = ApplicationScopedKeyGen.class) <1>\n"
"    public Object load(@CacheKey Object notUsedInKey, String keyElement) { <2>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:477
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\", keyGenerator = NotABeanKeyGen.class) <3>\n"
"    public void invalidate(Object keyElement) {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:483
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\", keyGenerator = NotABeanKeyGen.class)\n"
"    @CacheInvalidate(cacheName = \"bar\")\n"
"    public void invalidate(Integer param0, @CacheKey BigDecimal param1) { <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:485
msgid "This key generator is a CDI bean."
msgstr "このキージェネレーターはCDI Beanです。"

#. type: Plain text
#: upstream/_guides/cache.adoc:486
msgid "The `@CacheKey` annotation will be ignored because a key generator is declared in the `@CacheResult` annotation."
msgstr "キー・ジェネレータが `@CacheResult` アノテーションで宣言されているため、 `@CacheKey` アノテーションは無視されます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:487
msgid "This key generator is not a CDI bean."
msgstr "このキージェネレーターはCDI Beanではありません。"

#. type: Plain text
#: upstream/_guides/cache.adoc:488
msgid "The `@CacheKey` annotation will be ignored when the `foo` cache data is invalidated, but `param1` will be the cache key when the `bar` cache data is invalidated."
msgstr "`@CacheKey` アノテーションは `foo` キャッシュデータが無効化されると無視されますが、`bar` キャッシュデータが無効化されると `param1` がキャッシュキーになります。"

#. type: Title ==
#: upstream/_guides/cache.adoc:490
#, no-wrap
msgid "Caching using the programmatic API"
msgstr "プログラムAPIを使ったキャッシング"

#. type: Plain text
#: upstream/_guides/cache.adoc:494
msgid "Quarkus also offers a programmatic API which can be used to store, retrieve or delete values from any cache declared using the annotations API.  All operations from the programmatic API are non-blocking and rely on https://smallrye.io/smallrye-mutiny/[Mutiny] under the hood."
msgstr "Quarkusは、アノテーションAPIを使用して宣言された任意のキャッシュから値を保存、取得、削除するために使用できるプログラムAPIも提供しています。プログラムAPIからのすべての操作はノンブロッキングで、フードの下で https://smallrye.io/smallrye-mutiny/[Mutiny] に依存しています。"

#. type: Plain text
#: upstream/_guides/cache.adoc:497
msgid "Before accessing programmatically the cached data, you need to retrieve an `io.quarkus.cache.Cache` instance.  The following sections will show you how to do that."
msgstr "キャッシュされたデータにプログラムでアクセスする前に、 `io.quarkus.cache.Cache` のインスタンスを取得する必要があります。以下のセクションでは、その方法をご紹介します。"

#. type: Title ===
#: upstream/_guides/cache.adoc:498
#, no-wrap
msgid "Injecting a `Cache` with the `@CacheName` annotation"
msgstr "`@CacheName` アノテーションとともに `Cache` をインジェクトする"

#. type: Plain text
#: upstream/_guides/cache.adoc:501
msgid "`io.quarkus.cache.CacheName` can be used on a field, a constructor parameter or a method parameter to inject a `Cache`:"
msgstr "`io.quarkus.cache.CacheName` は、フィールド、コンストラクタパラメータ、またはメソッドのパラメータに使用して、 `Cache` をインジェクトすることができます。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:508
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:512
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheName;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:515
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CachedExpensiveService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:519
#, no-wrap
msgid ""
"    @Inject //<1>\n"
"    @CacheName(\"my-cache\")\n"
"    Cache cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:528
#, no-wrap
msgid ""
"    public Uni<String> getNonBlockingExpensiveValue(Object key) { //<2>\n"
"        return cache.get(key, k -> { //<3>\n"
"            /*\n"
"             * Put an expensive call here.\n"
"             * It will be executed only if the key is not already associated with a value in the cache.\n"
"             */\n"
"        });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:535
#, no-wrap
msgid ""
"    public String getBlockingExpensiveValue(Object key) {\n"
"        return cache.get(key, k -> {\n"
"            // Put an expensive call here.\n"
"        }).await().indefinitely(); //<4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:537
msgid "This is optional."
msgstr "これはオプションです。"

#. type: Plain text
#: upstream/_guides/cache.adoc:538
msgid "This method returns the `Uni<String>` type which is non-blocking."
msgstr "このメソッドは、ノンブロッキングである `Uni<String>` タイプを返します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:539
msgid "The `k` argument contains the cache key value."
msgstr "`k` 引数には、キャッシュキーの値が含まれています。"

#. type: Plain text
#: upstream/_guides/cache.adoc:540
msgid "If you don't need the call to be non-blocking, this is how you can retrieve the cache value in a blocking way."
msgstr "呼び出しをノンブロッキングにする必要がない場合は、このようにしてブロッキングしてキャッシュ値を取得することができます。"

#. type: Title ===
#: upstream/_guides/cache.adoc:541
#, no-wrap
msgid "Retrieving a `Cache` from the `CacheManager`"
msgstr " `CacheManager` から `Cache` を取得しています。"

#. type: Plain text
#: upstream/_guides/cache.adoc:544
msgid "Another way to retrieve a `Cache` instance consists in injecting the `io.quarkus.cache.CacheManager` first and then retrieving the desired `Cache` from its name:"
msgstr "`Cache` のインスタンスを取得するもう一つの方法は、まず `io.quarkus.cache.CacheManager` をインジェクトし、その名前から目的の `Cache` を取得するやり方です。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:551 upstream/_guides/cache.adoc:683
#: upstream/_guides/cache.adoc:946
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:554
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:556
#, no-wrap
msgid "import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:559 upstream/_guides/cache.adoc:951
#, no-wrap
msgid ""
"@Singleton\n"
"public class CacheClearer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:561 upstream/_guides/cache.adoc:695
#: upstream/_guides/cache.adoc:953
#, no-wrap
msgid "    private final CacheManager cacheManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:565 upstream/_guides/cache.adoc:957
#, no-wrap
msgid ""
"    public CacheClearer(CacheManager cacheManager) {\n"
"        this.cacheManager = cacheManager;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:573
#, no-wrap
msgid ""
"    public void clearCache(String cacheName) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().invalidateAll().await().indefinitely();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:575
#, no-wrap
msgid "Building a programmatic cache key"
msgstr "プログラムキャッシュキーの構築"

#. type: Plain text
#: upstream/_guides/cache.adoc:579
#, fuzzy
msgid "Before building a programmatic cache key, you need to know how cache keys are built by the annotations API when an annotated method is invoked.  This is explained in the xref:cache-keys-building-logic[Cache keys building logic] section of this guide."
msgstr "プログラムによるキャッシュ・キーを構築する前に、アノテーション・メソッドが呼び出されたときにアノテーション API によってキャッシュ・キーがどのように構築されるかを知っておく必要があります。これについては、本ガイドの「 xref:cache-keys-building-logic[キャッシュキーの構築ロジック] 」のセクションで説明します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:581
msgid "Now, if you want to retrieve or delete, using the programmatic API, a cache value that was stored using the annotations API, you just need to make sure the same key is used with both APIs."
msgstr "アノテーションAPIを使って保存されたキャッシュ値を、プログラムAPIを使って取得または削除したい場合、両方のAPIで同じキーが使われていることを確認する必要があります。"

#. type: Title ===
#: upstream/_guides/cache.adoc:582
#, no-wrap
msgid "Retrieving all keys from a `CaffeineCache`"
msgstr "`CaffeineCache` からすべてのキーを取得します。"

#. type: Plain text
#: upstream/_guides/cache.adoc:586
msgid "The cache keys from a specific `CaffeineCache` can be retrieved as an unmodifiable `Set` as shown below.  If the cache entries are modified while an iteration over the set is in progress, the set will remain unchanged."
msgstr "特定の `CaffeineCache` からのキャッシュキーは、以下に示すように、変更不可能な `Set` として取得できます。セットに対するイテレーションが進行している間にキャッシュエントリが変更された場合、セットは変更されないままとなります。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:596 upstream/_guides/cache.adoc:625
#: upstream/_guides/cache.adoc:657
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheName;\n"
"import io.quarkus.cache.CaffeineCache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:598
#, no-wrap
msgid "import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:601 upstream/_guides/cache.adoc:662
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CacheKeysService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:604 upstream/_guides/cache.adoc:633
#: upstream/_guides/cache.adoc:665
#, no-wrap
msgid ""
"    @CacheName(\"my-cache\")\n"
"    Cache cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:609
#, no-wrap
msgid ""
"    public Set<Object> getAllCacheKeys() {\n"
"        return cache.as(CaffeineCache.class).keySet();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:611
#, no-wrap
msgid "Populating a `CaffeineCache`"
msgstr "`CaffeineCache` にデータを追加する"

#. type: Plain text
#: upstream/_guides/cache.adoc:615
msgid "You can populate a `CaffeineCache` using the `CaffeineCache#put(Object, CompletableFuture)` method.  This method associates the `CompletableFuture` with the given key in the cache. If the cache previously contained a value associated with the key, the old value is replaced by this `CompletableFuture`. If the asynchronous computation fails, the entry will be automatically removed."
msgstr "`CaffeineCache` にデータを追加するには `CaffeineCache#put(Object, CompletableFuture)` メソッドを使います。 このメソッドは `CompletableFuture` をキャッシュ内の与えられたキーと関連付けます。キャッシュに以前からそのキーに関連する値が入っていた場合、古い値はこの `CompletableFuture` に置き換えられます。非同期計算が失敗した場合、そのエントリは自動的に削除されます。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:627 upstream/_guides/cache.adoc:659
#, no-wrap
msgid "import java.util.concurrent.CompletableFuture;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:630
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CacheService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:639
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    public void initialize() {\n"
"        cache.as(CaffeineCache.class).put(\"foo\", CompletableFuture.completedFuture(\"bar\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:641
#, no-wrap
msgid "Retrieving a value if a key is present from a `CaffeineCache`"
msgstr "`CaffeineCache` からすべてのキーを取得する"

#. type: Plain text
#: upstream/_guides/cache.adoc:647
msgid "The cache value from a specific `CaffeineCache` can be retrieved if present as shown below.  If the given key is contained in the cache, the method will return the `CompletableFuture` the specified key is mapped to.  That `CompletableFuture` may be computing or may already be completed.  Otherwise, the method will return `null`."
msgstr "特定の `CaffeineCache` からのキャッシュ値は、以下に示すように存在する場合に取得できます。 与えられたキーがキャッシュに含まれている場合、このメソッドは指定されたキーがマッピングされた `CompletableFuture` を返します。 その `CompletableFuture` は計算中であるか、あるいは既に終了している可能性があります。 そうでなければ、このメソッドは `null` を返します。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:670
#, no-wrap
msgid ""
"    public CompletableFuture<Object> getIfPresent(Object key) {\n"
"        return cache.as(CaffeineCache.class).getIfPresent(key);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cache.adoc:672
#, no-wrap
msgid "Changing the expiration policy or the maximum size of a `CaffeineCache` in real time"
msgstr "リアルタイムで `CaffeineCache` の有効期限ポリシーや最大サイズを変更"

#. type: Plain text
#: upstream/_guides/cache.adoc:676
msgid "The expiration policy of a `CaffeineCache` can be changed while a Quarkus app is running if that policy was initially specified in the Quarkus configuration.  Similarly, the maximum size of a `CaffeineCache` can be changed in real time if the cache was built with an initial maximum size defined in the configuration."
msgstr "`CaffeineCache` の有効期限ポリシーは、そのポリシーが Quarkus の設定で最初に指定されている場合、Quarkus アプリの実行中に変更することができます。同様に、 `CaffeineCache` の最大サイズも、設定に定義された初期最大サイズでキャッシュが構築された場合、リアルタイムで変更できます。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:687
#, no-wrap
msgid ""
"import io.quarkus.cache.Cache;\n"
"import io.quarkus.cache.CacheManager;\n"
"import io.quarkus.cache.CaffeineCache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:690
#, no-wrap
msgid ""
"import java.time.Duration;\n"
"import java.util.Optional;import javax.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:693
#, no-wrap
msgid ""
"@Singleton\n"
"public class CacheConfigManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:699
#, no-wrap
msgid ""
"    public CacheConfigManager(CacheManager cacheManager) {\n"
"        this.cacheManager = cacheManager;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:706
#, no-wrap
msgid ""
"    public void setExpireAfterAccess(String cacheName, Duration duration) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().as(CaffeineCache.class).setExpireAfterAccess(duration); <1>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:713
#, no-wrap
msgid ""
"    public void setExpireAfterWrite(String cacheName, Duration duration) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().as(CaffeineCache.class).setExpireAfterWrite(duration); <2>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:721
#, no-wrap
msgid ""
"    public void setMaximumSize(String cacheName, long maximumSize) {\n"
"        Optional<Cache> cache = cacheManager.getCache(cacheName);\n"
"        if (cache.isPresent()) {\n"
"            cache.get().as(CaffeineCache.class).setMaximumSize(maximumSize); <3>\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:723
msgid "This line will only work if the cache was constructed with an `expire-after-access` configuration value. Otherwise, an `IllegalStateException` will be thrown."
msgstr "この行は、キャッシュが `expire-after-access` という設定値で構築された場合にのみ機能します。そうでない場合は、 `IllegalStateException` がスローされます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:724
msgid "This line will only work if the cache was constructed with an `expire-after-write` configuration value. Otherwise, an `IllegalStateException` will be thrown."
msgstr "この行は、キャッシュが `expire-after-write` という設定値で構築された場合にのみ機能します。そうでない場合は、 `IllegalStateException` がスローされます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:725
msgid "This line will only work if the cache was constructed with a `maximum-size` configuration value. Otherwise, an `IllegalStateException` will be thrown."
msgstr "この行は、キャッシュが `maximum-size` という設定値で構築された場合にのみ機能します。そうでない場合は、 `IllegalStateException` がスローされます。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:729
msgid "The `setExpireAfterAccess`, `setExpireAfterWrite` and `setMaximumSize` methods from `CaffeineCache` must never be invoked from within an atomic scope of a cache operation."
msgstr "`CaffeineCache` の `setExpireAfterAccess` 、 `setExpireAfterWrite` 、 `setMaximumSize` メソッドは、 キャッシュ操作のアトミックスコープ内から決して呼び出してはいけません。"

#. type: Title ==
#: upstream/_guides/cache.adoc:731
#, no-wrap
msgid "Configuring the underlying caching provider"
msgstr "基礎となるキャッシュプロバイダの設定"

#. type: Plain text
#: upstream/_guides/cache.adoc:735
msgid "This extension uses https://github.com/ben-manes/caffeine[Caffeine] as its underlying caching provider.  Caffeine is a high performance, near optimal caching library."
msgstr "このエクステンションは、基礎となるキャッシュプロバイダとして https://github.com/ben-manes/caffeine[Caffeine] を使用しています。Caffeine は高性能で最適に近いキャッシュライブラリです。"

#. type: Title ===
#: upstream/_guides/cache.adoc:736
#, no-wrap
msgid "Caffeine configuration properties"
msgstr "Caffeine設定プロパティ"

#. type: Plain text
#: upstream/_guides/cache.adoc:740
msgid "Each of the Caffeine caches backing up the Quarkus application data caching extension can be configured using the following properties in the `application.properties` file. By default, caches do not perform any type of eviction if not configured."
msgstr "Quarkusアプリケーションのデータキャッシュエクステンションをバックアップする各Caffeineキャッシュは、 `application.properties` ファイルの以下のプロパティーを使用して設定することができます。デフォルトでは、設定されていない場合、キャッシュはどのようなタイプのエヴィクションも実行しません。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:744
msgid "You need to replace `cache-name` in all the following properties with the real name of the cache you want to configure."
msgstr "以下のすべてのプロパティーで `cache-name` を設定したいキャッシュの実名に置き換える必要があります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:749
msgid "Here's what your cache configuration could look like:"
msgstr "キャッシュの設定は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:756
#, no-wrap
msgid ""
"quarkus.cache.caffeine.\"foo\".initial-capacity=10 <1>\n"
"quarkus.cache.caffeine.\"foo\".maximum-size=20\n"
"quarkus.cache.caffeine.\"foo\".expire-after-write=60S\n"
"quarkus.cache.caffeine.\"bar\".maximum-size=1000 <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:758
msgid "The `foo` cache is being configured."
msgstr "`foo` キャッシュの設定を行っています。"

#. type: Plain text
#: upstream/_guides/cache.adoc:759
msgid "The `bar` cache is being configured."
msgstr "`bar` キャッシュの設定を行っています。"

#. type: Title ==
#: upstream/_guides/cache.adoc:760
#, no-wrap
msgid "Enabling Micrometer metrics"
msgstr "マイクロメーターメトリクスの有効化"

#. type: Plain text
#: upstream/_guides/cache.adoc:763
#, fuzzy
msgid "Each cache declared using the xref:annotations-api[annotations caching API] can be monitored using Micrometer metrics."
msgstr "xref:annotations-api[アノテーションキャッシングAPIを] 使用して宣言された各キャッシュは、Micrometerメトリクスを使用して監視することができます。"

#. type: delimited block =
#: upstream/_guides/cache.adoc:768
msgid "The cache metrics collection will only work if your application depends on a `quarkus-micrometer-registry-*` extension.  See the xref:micrometer.adoc[Micrometer metrics guide] to learn how to use Micrometer in Quarkus."
msgstr "キャッシュメトリクスコレクションは、アプリケーションが `quarkus-micrometer-registry-*` エクステンションに依存している場合にのみ動作します。Quarkusでのマイクロケーターの使用方法については、 xref:micrometer.adoc[マイクロメーターメトリクスガイド]を参照してください。"

#. type: Plain text
#: upstream/_guides/cache.adoc:772
msgid "The cache metrics collection is disabled by default.  It can be enabled from the `application.properties` file:"
msgstr "デフォルトでは、キャッシュメトリクスの収集は無効になっています。 `application.properties` ファイルから有効にすることができます。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:776
#, no-wrap
msgid "quarkus.cache.caffeine.\"foo\".metrics-enabled=true\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/cache.adoc:781
msgid "Like all instrumentation methods, collecting metrics comes with a small overhead that can impact the application performances."
msgstr "全ての計測手法のように、メトリクスの収集にはわずかなオーバーヘッドが伴い、アプリケーションのパフォーマンスに影響を与える可能性があります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:784
msgid "The collected metrics contain cache statistics such as:"
msgstr "収集されたメトリクスには、以下のようなキャッシュの統計情報が含まれています。"

#. type: Plain text
#: upstream/_guides/cache.adoc:786
msgid "the approximate current number of entries in the cache"
msgstr "キャッシュ内のエントリーのおおよその数"

#. type: Plain text
#: upstream/_guides/cache.adoc:787
msgid "the number of entries that were added to the cache"
msgstr "キャッシュに追加されたエントリーの数"

#. type: Plain text
#: upstream/_guides/cache.adoc:788
msgid "the number of times a cache lookup has been performed, including information about hits and misses"
msgstr "ヒットとミスに関する情報を含む、キャッシュルックアップの実行回数"

#. type: Plain text
#: upstream/_guides/cache.adoc:789
msgid "the number of evictions and the weight of the evicted entries"
msgstr "エヴィクションの回数とエヴィクションエントリの重み"

#. type: Plain text
#: upstream/_guides/cache.adoc:791
msgid "Here is an example of cache metrics available for an application that depends on the `quarkus-micrometer-registry-prometheus` extension:"
msgstr "以下は、 `quarkus-micrometer-registry-prometheus` エクステンションに依存するアプリケーションで利用可能なキャッシュメトリクスの例です。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:810
#, no-wrap
msgid ""
"# HELP cache_size The number of entries in this cache. This may be an approximation, depending on the type of cache.\n"
"# TYPE cache_size gauge\n"
"cache_size{cache=\"foo\",} 8.0\n"
"# HELP cache_puts_total The number of entries added to the cache\n"
"# TYPE cache_puts_total counter\n"
"cache_puts_total{cache=\"foo\",} 12.0\n"
"# HELP cache_gets_total The number of times cache lookup methods have returned a cached value.\n"
"# TYPE cache_gets_total counter\n"
"cache_gets_total{cache=\"foo\",result=\"hit\",} 53.0\n"
"cache_gets_total{cache=\"foo\",result=\"miss\",} 12.0\n"
"# HELP cache_evictions_total cache evictions\n"
"# TYPE cache_evictions_total counter\n"
"cache_evictions_total{cache=\"foo\",} 4.0\n"
"# HELP cache_eviction_weight_total The sum of weights of evicted entries. This total does not include manual invalidations.\n"
"# TYPE cache_eviction_weight_total counter\n"
"cache_eviction_weight_total{cache=\"foo\",} 540.0\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:812
#, no-wrap
msgid "Annotated beans examples"
msgstr "アノテーション付きBeanの例"

#. type: Title ===
#: upstream/_guides/cache.adoc:814
#, no-wrap
msgid "Implicit simple cache key"
msgstr "暗黙の簡易キャッシュキー"

#. type: delimited block -
#: upstream/_guides/cache.adoc:825 upstream/_guides/cache.adoc:888
#: upstream/_guides/cache.adoc:919
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheInvalidateAll;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:833
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public Object load(Object key) { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:837
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate(Object key) { <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:842 upstream/_guides/cache.adoc:874
#: upstream/_guides/cache.adoc:905
#, no-wrap
msgid ""
"    @CacheInvalidateAll(cacheName = \"foo\")\n"
"    public void invalidateAll() {\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:844
msgid "The cache key is implicit since there's no `@CacheKey` annotation."
msgstr "`@CacheKey` アノテーションがないので、キャッシュキーは暗黙的です。"

#. type: Title ===
#: upstream/_guides/cache.adoc:845
#, no-wrap
msgid "Explicit composite cache key"
msgstr "明示的な複合キャッシュキー"

#. type: delimited block -
#: upstream/_guides/cache.adoc:852 upstream/_guides/cache.adoc:884
#, no-wrap
msgid "import jakarta.enterprise.context.Dependent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:857
#, no-wrap
msgid ""
"import io.quarkus.cache.CacheInvalidate;\n"
"import io.quarkus.cache.CacheInvalidateAll;\n"
"import io.quarkus.cache.CacheKey;\n"
"import io.quarkus.cache.CacheResult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:860 upstream/_guides/cache.adoc:891
#, no-wrap
msgid ""
"@Dependent\n"
"public class CachedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:865
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public String load(@CacheKey Object keyElement1, @CacheKey Object keyElement2, Object notPartOfTheKey) { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:869
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate(@CacheKey Object keyElement1, @CacheKey Object keyElement2, Object notPartOfTheKey) { <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:876
msgid "The cache key is explicitly composed of two elements. The method signature also contains a third argument which is not part of the key."
msgstr "キャッシュキーは明示的に 2 つの要素で構成されています。メソッドシグネチャには、キーの一部ではない第三引数も含まれています。"

#. type: Title ===
#: upstream/_guides/cache.adoc:877
#, no-wrap
msgid "Default cache key"
msgstr "デフォルトのキャッシュキー"

#. type: delimited block -
#: upstream/_guides/cache.adoc:896
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public String load() { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:900
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    public void invalidate() { <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:907
msgid "A unique default cache key derived from the cache name is used because the method has no arguments."
msgstr "メソッドには引数がないため、キャッシュ名から派生した一意のデフォルトキャッシュキーが使用されます。"

#. type: Title ===
#: upstream/_guides/cache.adoc:908
#, no-wrap
msgid "Multiple annotations on a single method"
msgstr "単一メソッドでの複数アノテーション"

#. type: delimited block -
#: upstream/_guides/cache.adoc:915
#, no-wrap
msgid "import jakarta.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:922
#, no-wrap
msgid ""
"@Singleton\n"
"public class CachedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:928
#, no-wrap
msgid ""
"    @CacheInvalidate(cacheName = \"foo\")\n"
"    @CacheResult(cacheName = \"foo\")\n"
"    public String forceCacheEntryRefresh(Object key) { <1>\n"
"        // Call expensive service here.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:934
#, no-wrap
msgid ""
"    @CacheInvalidateAll(cacheName = \"foo\")\n"
"    @CacheInvalidateAll(cacheName = \"bar\")\n"
"    public void multipleInvalidateAll(Object key) { <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:936
msgid "This method can be used to force a refresh of the cache entry corresponding to the given key."
msgstr "このメソッドを使用して、指定されたキーに対応するキャッシュエントリーを強制的に更新することができます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:937
msgid "This method will invalidate all entries from the `foo` and `bar` caches with a single call."
msgstr "このメソッドは、一度の呼び出しで `foo` および `bar` キャッシュからのすべてのエントリーを無効にします。"

#. type: Title ===
#: upstream/_guides/cache.adoc:938
#, no-wrap
msgid "Clear all application caches"
msgstr "すべてのアプリケーションキャッシュの消去"

#. type: delimited block -
#: upstream/_guides/cache.adoc:948
#, no-wrap
msgid "import io.quarkus.cache.CacheManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:964
#, no-wrap
msgid ""
"    public void clearAllCaches() {\n"
"        for (String cacheName : cacheManager.getCacheNames()) {\n"
"            cacheManager.getCache(cacheName).get().invalidateAll().await().indefinitely();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cache.adoc:967
#, no-wrap
msgid "Negative caching and nulls"
msgstr "ネガティブキャッシングとnull"

#. type: Plain text
#: upstream/_guides/cache.adoc:972
msgid "Sometimes one wants to cache the result of an (expensive) remote call.  If the remote call fails, one may not want to cache the result or exception, but rather re-try the remote call on the next invocation."
msgstr "(高価な)リモートコールの結果をキャッシュしたい場合があります。リモートコールが失敗した場合、結果や例外をキャッシュするのではなく、 次の呼び出しでリモートコールを再試行したい場合があります。"

#. type: Plain text
#: upstream/_guides/cache.adoc:975
msgid "A simple approach could be to catch the exception and return `null`, so that the caller can act accordingly:"
msgstr "シンプルなアプローチとしては、例外をキャッチして `null` を返すことで、呼び出し元がそれに応じて行動できるようにすることができます。"

#. type: Block title
#: upstream/_guides/cache.adoc:976
#, no-wrap
msgid "Sample code"
msgstr "サンプルコード"

#. type: delimited block -
#: upstream/_guides/cache.adoc:980
#, no-wrap
msgid "    public void caller(int val) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:988
#, no-wrap
msgid ""
"        Integer result = callRemote(val); //<1>\n"
"        if (result != null) {\n"
"            System.out.println(\"Result is \" + result);\n"
"        else {\n"
"            System.out.println(\"Got an exception\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:991
#, no-wrap
msgid ""
"    @CacheResult(cacheName = \"foo\")\n"
"    public Integer callRemote(int val)  {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:999
#, no-wrap
msgid ""
"        try {\n"
"            Integer val = remoteWebServer.getResult(val); //<2>\n"
"            return val;\n"
"        } catch (Exception e) {\n"
"            return null; // <3>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1001 upstream/_guides/cache.adoc:1034
msgid "Call the method to call the remote"
msgstr "リモートを呼び出すためにメソッドを実行"

#. type: Plain text
#: upstream/_guides/cache.adoc:1002
msgid "Do the remote call and return its result"
msgstr "リモートコールを行い、その結果を返却"

#. type: Plain text
#: upstream/_guides/cache.adoc:1003
msgid "Return in case of exception"
msgstr "例外が発生時にリターンする"

#. type: Plain text
#: upstream/_guides/cache.adoc:1008
msgid "This approach has an unfortunate side effect: as we said before, Quarkus can also cache `null` values. Which means that the next call to `callRemote()` with the same parameter value will be answered out of the cache, returning `null` and no remote call will be done.  This may be desired in some scenarios, but usually one wants to retry the remote call until it returns a result."
msgstr "このアプローチには不幸な副作用があります。先に述べたように、Quarkusは `null` の値をキャッシュすることもできます。つまり、同じパラメーター値を持つ `callRemote()` への次の呼び出しは、キャッシュの外で応答され、 `null` が返され、リモートコールは行われないということです。これはシナリオによっては望ましいことかもしれませんが、通常は結果が返ってくるまでリモートコールを再試行したいものです。"

#. type: Title ===
#: upstream/_guides/cache.adoc:1009
#, no-wrap
msgid "Let exceptions bubble up"
msgstr "例外をバブルアップさせる"

#. type: Plain text
#: upstream/_guides/cache.adoc:1013
msgid "To prevent the cache from caching (marker) results from a remote call, we need to let the exception bubble out of the called method and catch it at the caller side:"
msgstr "リモートコールの結果をキャッシュ(マーカー)しないようにするには、呼び出されたメソッドから例外をバブルアウトし、呼び出し側でキャッチする必要があります。"

#. type: Block title
#: upstream/_guides/cache.adoc:1014
#, no-wrap
msgid "With Exception bubbling up"
msgstr "例外をバブルアップ"

#. type: delimited block -
#: upstream/_guides/cache.adoc:1024
#, no-wrap
msgid ""
"   public void caller(int val) {\n"
"       try {\n"
"           Integer result = callRemote(val);  //<1>\n"
"           System.out.println(\"Result is \" + result);\n"
"       } catch (Exception e) {\n"
"           System.out.println(\"Got an exception\");\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:1027
#, no-wrap
msgid ""
"   @CacheResult(cacheName = \"foo\")\n"
"   public Integer callRemote(int val) throws Exception { // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:1030
#, no-wrap
msgid ""
"      Integer val = remoteWebServer.getResult(val);  //<3>\n"
"      return val;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cache.adoc:1032
#, no-wrap
msgid "   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1035
msgid "Exceptions may bubble up"
msgstr "例外がバブルアップする場合がある"

#. type: Plain text
#: upstream/_guides/cache.adoc:1036
msgid "This can throw all kinds of remote exceptions"
msgstr "これは、あらゆる種類のリモート例外を投げることができます"

#. type: Plain text
#: upstream/_guides/cache.adoc:1041
msgid "When the call to the remote throws an exception, the cache does not store the result, so that a subsequent call to `callRemote()` with the same parameter value will not be answered out of the cache.  It will instead result in another attempt to call the remote."
msgstr "リモートへの呼び出しが例外をスローした場合、キャッシュは結果を保存しないので、 同じパラメーター値を持つ `callRemote()` への後続の呼び出しがキャッシュから応答されることはありません。その代わりに、リモートへの呼び出しを再度試みることになります。"

#. type: Title ==
#: upstream/_guides/cache.adoc:1042
#, no-wrap
msgid "Going native"
msgstr "ネイティブ化"

#. type: Plain text
#: upstream/_guides/cache.adoc:1045
msgid "The Cache extension supports building native executables."
msgstr "Cache エクステンションは、ネイティブ実行可能ファイルの構築をサポートしています。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1049
msgid "However, to optimize runtime memory, Caffeine embarks many cache implementation classes that are selected depending on the cache configuration.  We are not registering all of them for reflection (and the ones not registered are not included into the native executables) as registering all of them would be very costly."
msgstr "実行時の速度を最適化するために、Caffeineはキャッシュ設定に応じて選択される多くのキャッシュ実装クラスを組み込んでいます。すべてのクラスを登録するのは非常にコストがかかるため、リフレクションのためにすべてのクラスを登録していません（登録されていないクラスはネイティブ実行可能ファイルに含まれません）。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1051
msgid "We are registering the most common implementations but, depending on your cache configuration, you might encounter errors like:"
msgstr "ここでは、最も一般的な実装を登録していますが、キャッシュの設定によっては、以下のようなエラーが発生する場合があります。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:1062
#, no-wrap
msgid ""
"2021-12-08 02:32:02,108 ERROR [io.qua.run.Application] (main) Failed to start application (with profile prod): java.lang.ClassNotFoundException: com.github.benmanes.caffeine.cache.PSAMS <1>\n"
"        at java.lang.Class.forName(DynamicHub.java:1433)\n"
"        at java.lang.Class.forName(DynamicHub.java:1408)\n"
"        at com.github.benmanes.caffeine.cache.NodeFactory.newFactory(NodeFactory.java:111)\n"
"        at com.github.benmanes.caffeine.cache.BoundedLocalCache.<init>(BoundedLocalCache.java:240)\n"
"        at com.github.benmanes.caffeine.cache.SS.<init>(SS.java:31)\n"
"        at com.github.benmanes.caffeine.cache.SSMS.<init>(SSMS.java:64)\n"
"        at com.github.benmanes.caffeine.cache.SSMSA.<init>(SSMSA.java:43)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1064
msgid "`PSAMS` is one of the many cache implementation classes of Caffeine so this part may vary."
msgstr "`PSAMS` は、Caffeineの数あるキャッシュ実装クラスのひとつなので、この部分は変わるかもしれません。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1067
msgid "When you encounter this error, you can easily fix it by adding the following annotation to any of your application classes (or you can create a new class such as `Reflections` just to host this annotation if you prefer):"
msgstr "このエラーが発生した場合は、アプリケーションクラスに以下のアノテーションを追加することで、簡単に修正することができます（あるいは、このアノテーションをホストするためだけに、 `Reflections` のような新しいクラスを作成することもできます）。"

#. type: delimited block -
#: upstream/_guides/cache.adoc:1071
#, no-wrap
msgid "@RegisterForReflection(classNames = { \"com.github.benmanes.caffeine.cache.PSAMS\" }) <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cache.adoc:1073
msgid "It is an array, so you can register several cache implementations in one go if your configuration requires several of them."
msgstr "配列なので、複数のキャッシュ実装が必要な構成の場合、一度に登録することができます。"

#. type: Plain text
#: upstream/_guides/cache.adoc:1074
msgid "This annotation will register the cache implementation classes for reflection and this will include the classes into the native executable."
msgstr "このアノテーションは、リフレクション向けにキャッシュ実装クラスを登録し、そのクラスをネイティブ実行可能ファイルに含めます。"

#~ msgid "When a method annotated with `@CacheResult` is invoked, Quarkus will compute a cache key and use it to check in the cache whether the method has been already invoked.  See the <<cache-keys-building-logic>> section of this guide to learn how the cache key is computed.  If a value is found in the cache, it is returned and the annotated method is never actually executed.  If no value is found, the annotated method is invoked and the returned value is stored in the cache using the computed key."
#~ msgstr "`@CacheResult` でアノテーションされたメソッドが呼び出されると、Quarkusはキャッシュキーを計算し、それを使用して、そのメソッドがすでに呼び出されているかどうかをキャッシュでチェックします。キャッシュキーの計算方法については、このガイドの <<cache-keys-building-logic>> のセクションを参照してください。 キャッシュ内に値が見つかった場合、その値が返され、アノテーションされたメソッドが実際に実行されることはありません。 値が見つからない場合、アノテーションされたメソッドが呼び出され、返された値は計算されたキーを使用してキャッシュに格納されます。"

#~ msgid "Quarkus is able to also cache `null` values unlike the underlying Caffeine provider.  See <<negative-cache,more on this topic below>>."
#~ msgstr "Quarkusは、基となっているCaffeineプロバイダとは異なり、 `null` の値をキャッシュすることもできます。 link:#negative-cache[このトピックの詳細はこちら] を参照してください。"

#~ msgid "When a method annotated with `@CacheInvalidate` is invoked, Quarkus will compute a cache key and use it to try to remove an existing entry from the cache.  See the <<cache-keys-building-logic>> section of this guide to learn how the cache key is computed.  If the key does not identify any cache entry, nothing will happen."
#~ msgstr "`@CacheInvalidate` のアノテーションが付いたメソッドが呼び出されると、Quarkus はキャッシュキーを計算し、それを使ってキャッシュから既存のエントリを削除しようとします。 キャッシュキーの計算方法については、このガイドの <<cache-keys-building-logic>> のセクションを参照してください。 もしキーがどのキャッシュエントリも特定できない場合は、何も起こりません。"

#~ msgid "If a CDI scope is declared on a key generator class and if that class has a default qualifier (no qualifier annotation or `@javax.enterprise.inject.Default`), then the key generator will be injected as a CDI bean during the cache key computation.  Otherwise, the key generator will be instantiated using its default constructor.  All CDI scopes supported by Quarkus can be used on a key generator."
#~ msgstr "CDIスコープが、キージェネレータクラスで宣言され、そのクラスがデフォルトの修飾子を持つ場合 (修飾子アノテーションまたは `@javax.enterprise.inject.Default` がない場合)、 キージェネレータはキャッシュキー計算中に CDI Beanとしてインジェクトされます。そうでない場合は、そのデフォルトのコンストラクタを使用して、キージェネレータがインスタンス化されます。Quarkus がサポートするすべての CDI スコープは、キージェネレーターで使用できます。"

#~ msgid "Before building a programmatic cache key, you need to know how cache keys are built by the annotations API when an annotated method is invoked.  This is explained in the <<cache-keys-building-logic>> section of this guide."
#~ msgstr "プログラムキャッシュキーを構築する前に、アノテーションメソッドが呼び出されたときにアノテーションAPIによってキャッシュキーがどのように構築されるかを知っておく必要があります。これについては、このガイドの <<cache-keys-building-logic> セクションで説明されています。"

#~ msgid "Each cache declared using the <<#annotations-api,annotations caching API>> can be monitored using Micrometer metrics."
#~ msgstr "<<#annotations-api,アノテーションキャッシング API>> を使って宣言された各キャッシュは、マイクロメーターのメトリクスを使ってモニターすることができます。"

#~ msgid "To complete this guide, you need:"
#~ msgstr "このガイドを完成させるには、以下が必要です:"

#~ msgid "less than 15 minutes"
#~ msgstr "15 分未満"

#~ msgid "an IDE"
#~ msgstr "IDE"

#~ msgid "JDK 11+ installed with `JAVA_HOME` configured appropriately"
#~ msgstr "JDK 11+ がインストールされ、 `JAVA_HOME` が適切に設定されていること"

#~ msgid "Apache Maven {maven-version}"
#~ msgstr "Apache Maven {maven-version}"

#~ msgid "Now, we just need to update the generated `WeatherForecastResource` class to use the service and response:"
#~ msgstr "あとは、サービスとレスポンスを使用するようにに生成された `WeatherForecastResource` クラスを更新するだけです。"
