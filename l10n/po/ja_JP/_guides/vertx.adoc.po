# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-02-02 14:04+0000\n"
"PO-Revision-Date: 2022-01-20 17:13+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/vertx.adoc:6
#, no-wrap
msgid "Using Eclipse Vert.x API from a Quarkus Application"
msgstr "QuarkusアプリケーションからのEclipse Vert.x APIの使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:12
msgid "https://vertx.io[Vert.x] is a toolkit for building reactive applications.  As described in the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture], Quarkus uses Vert.x underneath."
msgstr "link:https://vertx.io[Vert.x]は、リアクティブなアプリケーションを構築するためのツールキットです。 link:quarkus-reactive-architecture.html[Quarkus Reactive Architecture]に記載されているように、QuarkusではVert.xを下地に使用しています。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/vertx.adoc:13
#, no-wrap
msgid "Quarkus Reactive Core"
msgstr "Quarkus Reactive Core"

#. type: Target for macro image
#: upstream/_guides/vertx.adoc:13
#, no-wrap
msgid "quarkus-reactive-core.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:16
msgid "Quarkus applications can access and use the Vert.x APIs."
msgstr "QuarkusのアプリケーションはVert.xのAPIにアクセスして使用することができます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:18
msgid "This guide presents how you can build a Quarkus application using:"
msgstr "このガイドでは、Quarkusのアプリケーションで次を使って構築する方法を紹介します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:20
msgid "the managed instance of Vert.x"
msgstr "Vert.xのマネージドインスタンス"

#. type: Plain text
#: upstream/_guides/vertx.adoc:21
msgid "the Vert.x event bus"
msgstr "Vert.x イベントバス"

#. type: Plain text
#: upstream/_guides/vertx.adoc:22
msgid "the Vert.x Web Client"
msgstr "Vert.x Webクライアント"

#. type: Plain text
#: upstream/_guides/vertx.adoc:25
msgid "It's an introductory guide.  The xref:vertx-reference.adoc[Vert.x reference guide] covers more advanced features such as verticles, and native transports."
msgstr "これは入門ガイドです。 link:vertx-reference.html[Vert.xリファレンスガイド]では、バーティクルやネイティブトランスポートなど、より高度な機能について説明しています。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:26
#, no-wrap
msgid "Architecture"
msgstr "アーキテクチャ"

#. type: Plain text
#: upstream/_guides/vertx.adoc:29
msgid "We are going to build a simple application exposing four HTTP endpoints:"
msgstr "ここでは、4つのHTTPエンドポイントを公開するシンプルなアプリケーションを作成します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:31
msgid "`/vertx/lorem` returns the content from a small file"
msgstr "`/vertx/lorem` 小さなファイルからコンテンツを返す"

#. type: Plain text
#: upstream/_guides/vertx.adoc:32
msgid "`/vertx/book` returns the content from a large file (a book)"
msgstr "`/vertx/book` 大きなファイル（本）からコンテンツを返す"

#. type: Plain text
#: upstream/_guides/vertx.adoc:33
msgid "`/vertx/hello` uses the Vert.x event bus to produce the response"
msgstr "`/vertx/hello` は、Vert.x イベントバスを使用してレスポンスを生成します"

#. type: Plain text
#: upstream/_guides/vertx.adoc:34
msgid "`/vertx/web` uses the Vert.x Web Client to retrieve data from Wikipedia"
msgstr "`/vertx/web` は、Vert.x Web クライアントを使用して Wikipedia からデータを取得します"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/vertx.adoc:35
#, no-wrap
msgid "Architecture of the Vert.x guide"
msgstr "Vert.xガイドのアーキテクチャ"

#. type: Target for macro image
#: upstream/_guides/vertx.adoc:35
#, no-wrap
msgid "quarkus-vertx-guide-architecture.png"
msgstr ""

#. type: Title ==
#: upstream/_guides/vertx.adoc:37
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/vertx.adoc:41
msgid "We recommend that you follow the instructions in the following sections and create the application step by step.  However, you can go right to the completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:43
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "Gitリポジトリをクローン： `git clone {quickstarts-clone-url}` 、または {quickstarts-archive-url}[archive] をダウンロードする。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:45
msgid "The solution is located in the `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[directory]."
msgstr "このソリューションは `vertx-quickstart` {quickstarts-tree-url}/vertx-quickstart[directory] にあります。"

#. type: Block title
#: upstream/_guides/vertx.adoc:47
#, no-wrap
msgid "Mutiny"
msgstr "Mutiny"

#. type: delimited block =
#: upstream/_guides/vertx.adoc:51
msgid "This guide uses the Mutiny API.  If you are not familiar with Mutiny, check xref:mutiny-primer.adoc[Mutiny - an intuitive, reactive programming library]."
msgstr "このガイドでは、Mutiny APIを使用しています。Mutinyに慣れていない方は、 link:mutiny-primer.html[Mutiny - 直感的なリアクティブプログラミングライブラリ]をご覧ください。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:54
#, no-wrap
msgid "Bootstrapping the application"
msgstr "アプリケーションの起動"

#. type: Plain text
#: upstream/_guides/vertx.adoc:58
msgid "Click on https://code.quarkus.io/?a=quarkus-getting-started-vertx&nc=true&e=resteasy-reactive-jackson&e=vertx[this link] to configure your application.  It selected a few extensions:"
msgstr "https://code.quarkus.io/?a=quarkus-getting-started-vertx&nc=true&e=resteasy-reactive-jackson&e=vertx[このリンク]をクリックして、アプリケーションを設定してください。いくつかのエクステンションが選択されます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:60
msgid "`resteasy-reactive-jackson`, which also brings `resteasy reactive`. We are going to use it to expose our HTTP endpoints."
msgstr "`resteasy-reactive-jackson` 。これは `resteasy reactive` ももたらします。これを使って、HTTPエンドポイントを公開します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:61
msgid "`vertx`, which provides access to the underlying managed Vert.x"
msgstr "`vertx` 、下地となるマネージドVert.xへのアクセスを提供します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:64
msgid "Click on the `Generate your application` button, download the zip file and unzip it.  Then, open the project in your favorite IDE."
msgstr "`Generate your application` ボタンをクリックし、ZIPファイルをダウンロードして解凍します。その後、お好きなIDEでプロジェクトを開いてください。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:66
msgid "If you open the generated `pom.xml` file, you can see the selected extensions:"
msgstr "生成された `pom.xml` ファイルを開くと、選択されたエクステンションが表示されます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:77
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-reactive-jackson</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:80
msgid "While you are in the `pom.xml`, add the following dependency:"
msgstr "`pom.xml` の中で、以下の依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:87
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.smallrye.reactive</groupId>\n"
"  <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:90
msgid "This dependency provides the Vert.x Web Client, which we will be using to implement the `/web` endpoint."
msgstr "この依存関係は、Vert.x Web クライアントを提供し、 `/web` エンドポイントの実装に使用されます。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:92
#, no-wrap
msgid "Accessing the managed Vert.x instance"
msgstr "Vert.xマネージドインスタンスへのアクセス"

#. type: Plain text
#: upstream/_guides/vertx.adoc:96
msgid "Create the `src/main/java/org/acme/VertxResource.java` file.  It will contain our HTTP endpoints."
msgstr "`src/main/java/org/acme/VertxResource.java` ファイルを作成します。このファイルには、HTTPエンドポイントが含まれます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:98
msgid "In this file, copy the following code:"
msgstr "このファイルに、以下のコードをコピーします。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:102
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:104
#, no-wrap
msgid "import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:107
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:110
#, no-wrap
msgid ""
"@Path(\"/vertx\")                        // <1>\n"
"public class VertxResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:112
#, no-wrap
msgid "    private final Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:118
#, no-wrap
msgid ""
"    @Inject                             // <2>\n"
"    public VertxResource(Vertx vertx) { // <3>\n"
"        this.vertx = vertx;             // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:120
msgid "Declare the root HTTP path."
msgstr "ルートHTTPパスを宣言します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:121
msgid "We use constructor injection to receive the managed Vert.x instance. Field injection works too."
msgstr "コンストラクタ・インジェクションを使用して、マネージドVert.xインスタンスを受け取ります。フィールド・インジェクションも有効です。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:122
msgid "Receives the Vert.x instance as a constructor parameter"
msgstr "コンストラクタのパラメータとしてVert.xインスタンスを受け取ります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:123
msgid "Store the managed Vert.x instance into a field."
msgstr "マネージドVert.xインスタンスをフィールドに格納します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:125
msgid "With this, we can start implementing the endpoints."
msgstr "これで、エンドポイントの実装を始めることができます。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:126
#, no-wrap
msgid "Using Vert.x Core API"
msgstr "Vert.x Core APIの使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:131
msgid "The injected Vert.x instance provides a set of APIs you can use.  The one we are going to use in this section is the Vert.x File System.  It provides a non-blocking API to access files."
msgstr "インジェクションされたVert.xインスタンスは、利用可能なAPIのセットを提供します。このセクションで使用するのはVert.x File Systemです。これは、ファイルにアクセスするためのノンブロッキングAPIを提供します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:134
msgid "In the `src/main/resource` directory, create a `lorem.txt` file with the following content:"
msgstr "`src/main/resource` ディレクトリに `lorem.txt` ファイルを次の内容で作成します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:138
#, no-wrap
msgid "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:141
msgid "Then, in the `VertxResource` file add the following method:"
msgstr "そして、 `VertxResource` ファイルに以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:150
#, no-wrap
msgid ""
"@GET                                                                                   // <1>\n"
"@Path(\"/lorem\")\n"
"public Uni<String> readShortFile() {                                                   // <2>\n"
"    return vertx.fileSystem().readFile(\"lorem.txt\")                                    // <3>\n"
"            .onItem().transform(content -> content.toString(StandardCharsets.UTF_8));  // <4>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:152
msgid "This endpoint handles HTTP `GET` request on path `/lorem` (so the full path will be `vertx/lorem`)"
msgstr "このエンドポイントは、パス `/lorem` に対する HTTP `GET` リクエストを処理します（そのため、フルパスは `vertx/lorem` となります）。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:153
msgid "As the Vert.x API is asynchronous, our method returns a `Uni`. The content is written into the HTTP response when the asynchronous operation represented by the Uni completes."
msgstr "Vert.x APIは非同期なので、このメソッドは `Uni` を返却します。Uniで表される非同期操作が完了すると、その内容がHTTPレスポンスに書き込まれます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:154
msgid "We use the Vert.x file system API to read the created file"
msgstr "Vert.xのファイルシステムAPIを使用して、作成されたファイルを読み取ります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:155
msgid "Once the file is read, the content is stored in an in-memory buffer.  We transform this buffer into a String."
msgstr "ファイルが読み込まれると、その内容がメモリ内のバッファに格納されます。このバッファをStringに変換します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:157
msgid "In a terminal, navigate to the root of the project and run:"
msgstr "ターミナルで、プロジェクトのルートに移動して次を実行します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:162
#, no-wrap
msgid "> ./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:165
msgid "In another terminal, run:"
msgstr "別の端末で、次を実行します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:169
#, no-wrap
msgid "> curl http://localhost:8080/vertx/lorem\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:172
msgid "You should see the content of the file printed in the console."
msgstr "コンソールにファイルの内容が表示されるはずです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:174
msgid "Quarkus provides other ways to serve static files. This is an example made for the guide."
msgstr "Quarkusは、静的ファイルを提供する他の方法を提供しています。これはガイドのために作られた例です。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:175
#, no-wrap
msgid "Using Vert.x stream capability"
msgstr "Vert.x stream の能力の使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:179
msgid "Reading a file and storing the content in memory works for small files, but not big ones.  In this section, we will see how you can use Vert.x streaming capability."
msgstr "ファイルを読み込んで内容をメモリに保存する方法は、小さなファイルには有効ですが、大きなファイルには使えません。このセクションでは、Vert.xのストリーミング機能をどのように使用するかを説明します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:183
msgid "First, download https://www.gutenberg.org/files/2600/2600-0.txt[War and Peace] and store it in `src/main/resources/book.txt`.  It's a 3.2 Mb file, which, while not being huge, illustrates the purpose of streams.  This time, we will not accumulate the file's content in memory and write it in one batch, but read it chunk by chunk and write these chunks into the HTTP response one by one."
msgstr "まず、 link:https://www.gutenberg.org/files/2600/2600-0.txt[戦争と平和]をダウンロードして、 `src/main/resources/book.txt` に保存します。これは3.2Mbのファイルで、巨大ではありませんが、ストリームの目的を説明しています。今回は、ファイルの内容をメモリに蓄積して一括して書き込むのではなく、チャンクごとに読み込んで、そのチャンクを1つずつHTTPレスポンスに書き込んでいきます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:185
msgid "So, you should have the following files in your project:"
msgstr "そこで、プロジェクト内に以下のファイルを用意しておきます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:206
#, no-wrap
msgid ""
".\n"
"├── mvnw\n"
"├── mvnw.cmd\n"
"├── pom.xml\n"
"├── README.md\n"
"├── src\n"
"│  └── main\n"
"│     ├── docker\n"
"│     │  ├── ...\n"
"│     ├── java\n"
"│     │  └── org\n"
"│     │     └── acme\n"
"│     │        └── VertxResource.java\n"
"│     └── resources\n"
"│        ├── application.properties\n"
"│        ├── book.txt\n"
"│        └── lorem.txt\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:209
msgid "Add the following method to the `VertxResource` class:"
msgstr "`VertxResource` クラスに以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:222
#, fuzzy, no-wrap
#| msgid ""
#| "@GET\n"
#| "@Path(\"/web\")\n"
#| "public Uni<JsonArray> retrieveDataFromWikipedia() {                     // <1>\n"
#| "    return client.getAbs(URL).send()                                    // <2>\n"
#| "            .onItem().transform(HttpResponse::bodyAsJsonObject)         // <3>\n"
#| "            .onItem().transform(json -> json.getJsonObject(\"parse\")     // <4>\n"
#| "                                        .getJsonArray(\"langlinks\"));\n"
#| "}\n"
msgid ""
"@GET\n"
"@Path(\"/book\")\n"
"public Multi<String> readLargeFile() {                                               // <1>\n"
"    return vertx.fileSystem().open(\"book.txt\",                                       // <2>\n"
"                    new OpenOptions().setRead(true)\n"
"            )\n"
"            .onItem().transformToMulti(file -> file.toMulti())                       // <3>\n"
"            .onItem().transform(content -> content.toString(StandardCharsets.UTF_8)) // <4>\n"
"                    + \"\\n------------\\n\");                                           // <5>\n"
"}\n"
msgstr ""
"@GET\n"
"@Path(\"/web\")\n"
"public Uni<JsonArray> retrieveDataFromWikipedia() {                     // <1>\n"
"    return client.getAbs(URL).send()                                    // <2>\n"
"            .onItem().transform(HttpResponse::bodyAsJsonObject)         // <3>\n"
"            .onItem().transform(json -> json.getJsonObject(\"parse\")     // <4>\n"
"                                        .getJsonArray(\"langlinks\"));\n"
"}\n"

#. type: Plain text
#: upstream/_guides/vertx.adoc:224
msgid "This time, we return a Multi as we want to stream the chunks"
msgstr "今回は、チャンクをストリーミングしたいので、Multiを返します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:225
msgid "We open the file using the `open` method. It returns a `Uni<AsyncFile>`"
msgstr "`open` メソッドを使ってファイルを開きます。このメソッドは `Uni<AsyncFile>` を返却します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:226
msgid "When the file is opened, we retrieve a `Multi` which will contain the chunks."
msgstr "ファイルが開かれると、チャンクを含む `Multi` が取得できます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:227
msgid "For each chunk, we produce a String"
msgstr "各チャンクは、String を生成します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:228
msgid "To visually see the chunks in the response, we append a separator"
msgstr "レスポンス内のチャンクを視覚的に確認するために、セパレーターを追加します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:230
msgid "Then, in a terminal, run:"
msgstr "そして、ターミナルで、次を実行します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:234
#, no-wrap
msgid "> curl http://localhost:8080/vertx/book\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:238
msgid "It should retrieve the book content.  In the output you should see the separator like:"
msgstr "ブックの内容を取得します。出力には次のようなセパレータが表示されるはずです。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:243
#, no-wrap
msgid ""
"...\n"
"The little princess had also left the tea table and followed Hélène.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:245
#, no-wrap
msgid "“Wait a moment, I’ll get my work.... Now then, what\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:250
#, no-wrap
msgid ""
" are you\n"
"thinking of?” she went on, turning to Prince Hippolyte. “Fetch me my\n"
"workbag.”\n"
"...\n"
msgstr ""
" are you\n"
"thinking of?” she went on, turning to Prince Hippolyte. “Fetch me my\n"
"workbag.”\n"
"...\n"

#. type: Title ==
#: upstream/_guides/vertx.adoc:252
#, no-wrap
msgid "Using the event bus"
msgstr "イベントバスの使用"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:262
msgid "One of the core features of Vert.x is the https://vertx.io/docs/vertx-core/java/#event_bus[event bus].  It provides a message-based backbone to your application.  So, you can have components interacting using asynchronous message passing, and so decouple your components.  You can send a message to a single consumer, or dispatch to multiple consumers, or implement a request-reply interaction, where you send a message (request) and expect a response.  This is what we are going to use in this section.  Our `VertxResource` will send a message containing a name to the `greetings` address.  Another component will receive the message and produce the \"hello $name\" response.  The `VertxResource` will receive the response and return it as the HTTP response."
msgstr "Vert.xのコア機能の1つは、 https://vertx.io/docs/vertx-core/java/#event_bus[イベントバス] です。 これは、アプリケーションにメッセージベースのバックボーンを提供します。 したがって、非同期メッセージパッシングを使用してコンポーネントを相互作用させることができるため、コンポーネントを切り離すことができます。 単一のコンシューマーにメッセージを送信したり、複数のコンシューマーにディスパッチしたり、メッセージ（要求）を送信して応答を期待する要求と応答の対話を実装したりできます。 これは、このセクションで使用するものです。 `VertxResource` は、名前を含むメッセージを `greetings` アドレスに送信します。 別のコンポーネントがメッセージを受信し、 \"hello$name\" 応答を生成します。 `VertxResource` は応答を受信し、HTTP応答として返します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:264
msgid "So, first, let's extend our `VertxResource` class with the following code:"
msgstr "では、以下の内容で `VertxResource` クラスを拡張してください。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:267 upstream/_guides/vertx.adoc:337
msgid "[source, java]"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:270
#, no-wrap
msgid ""
"@Inject\n"
"EventBus bus;                                                   // <1>\n"
msgstr ""
"@Inject\n"
"EventBus bus;                                                   // <1>\n"

#. type: Plain text
#: upstream/_guides/vertx.adoc:277
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/hello\")\n"
"public Uni<String> hello(@QueryParam(\"name\") String name) {     // <2>\n"
"    return bus.<String>request(\"greetings\", name)               // <3>\n"
"            .onItem().transform(response -> response.body());   // <4>\n"
"}\n"
msgstr ""
"@GET\n"
"@Path(\"/hello\")\n"
"public Uni<String> hello(@QueryParam(\"name\") String name) {     // <2>\n"
"    return bus.<String>request(\"greetings\", name)               // <3>\n"
"            .onItem().transform(response -> response.body());   // <4>\n"
"}\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:282
#, no-wrap
msgid ""
"1. Inject the event bus. Alternatively you can use `vertx.eventBus()`.\n"
"2. We receive a _name_ as a query parameter\n"
"3. We use the `request` method to initiate the request-reply interaction. We send the name to the \"greetings\" address.\n"
"4. When the response is received, we extract the body and return it as the HTTP response\n"
msgstr ""
"1. イベントバスを注入します。 または、 `vertx.eventBus()` を使用することもできます。\n"
"2. クエリパラメータとして _name_ を受け取ります\n"
"3. `request` メソッドを使用して、要求と応答の相互作用を開始します。 名前を \"greetings\" アドレスに送信します。\n"
"4. 応答を受信すると、本文を抽出してHTTP応答として返します\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:285
#, no-wrap
msgid ""
"Now, we need the other side: the component receiving the name and replying.\n"
"Create the `src/main/java/org/acme/GreetingService.java` file with the following content:\n"
msgstr ""
"ここで、もう一方の側が必要です。名前を受け取って応答するコンポーネントです。\n"
"次の内容で `src/main/java/org/acme/GreetingService.java` ファイルを作成します。\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:287 upstream/_guides/vertx.adoc:354
#, no-wrap
msgid "[source, java]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:289
msgid "package org.acme;"
msgstr "package org.acme;"

#. type: Plain text
#: upstream/_guides/vertx.adoc:291
msgid "import io.quarkus.vertx.ConsumeEvent;"
msgstr "import io.quarkus.vertx.ConsumeEvent;"

#. type: Plain text
#: upstream/_guides/vertx.adoc:293
msgid "import javax.enterprise.context.ApplicationScoped;"
msgstr "import javax.enterprise.context.ApplicationScoped;"

#. type: Plain text
#: upstream/_guides/vertx.adoc:296
#, no-wrap
msgid ""
"@ApplicationScoped                          // <1>\n"
"public class GreetingService {\n"
msgstr ""
"@ApplicationScoped                          // <1>\n"
"public class GreetingService {\n"

#. type: Plain text
#: upstream/_guides/vertx.adoc:302
#, no-wrap
msgid ""
"    @ConsumeEvent(\"greetings\")              // <2>\n"
"    public String hello(String name) {      // <3>\n"
"        return \"Hello \" + name;             // <4>\n"
"    }\n"
"}\n"
msgstr ""
"    @ConsumeEvent(\"greetings\")              // <2>\n"
"    public String hello(String name) {      // <3>\n"
"        return \"Hello \" + name;             // <4>\n"
"    }\n"
"}\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:307
#, no-wrap
msgid ""
"1. Declaring a CDI Bean in the Application scope. Quarkus will create a single instance of this class.\n"
"2. Use the `@ConsumeEvent` annotation to declare a consumer. It is possible to use the Vert.x API directly too. TODO LINK REF\n"
"3. Receive the message payload as a method parameter. The returned object will be the reply.\n"
"4. Return the response. This response is sent back to the `VertxResource` class\n"
msgstr ""
"1. アプリケーションスコープでCDIBeanを宣言します。 Quarkusは、このクラスの単一のインスタンスを作成します。\n"
"2. `@ ConsumeEvent` アノテーションを使用して、コンシューマーを宣言します。 Vert.x APIを直接使用することも可能です。 TODO LINK REF\n"
"3. メソッドパラメータとしてメッセージペイロードを受信します。 返されるオブジェクトは応答になります。\n"
"4. 応答を返します。 この応答は `VertxResource`クラスに返送されます\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:310
#, no-wrap
msgid ""
"Let's try this.\n"
"In a terminal, run:\n"
msgstr ""
"これを試してみましょう。\n"
"ターミナルで、次の手順を実行します。\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:313 upstream/_guides/vertx.adoc:374
#, no-wrap
msgid "[source, bash]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:315
msgid "curl \"http://localhost:8080/vertx/hello?name=bob\""
msgstr "curl \"http://localhost:8080/vertx/hello?name=bob\""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:318
#, no-wrap
msgid "You should get the expected `Hello bob` message back.\n"
msgstr "期待される `Hello bob` メッセージを返す必要があります。\n"

#. type: Title ==
#: upstream/_guides/vertx.adoc:319
#, no-wrap
msgid "Using Vert.x Clients"
msgstr "Vert.x クライアントの使用"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:325
msgid "So far, we have used the Vert.x Core API.  Vert.x offers much more.  It provides a vast ecosystem.  In this section, we will see how you can use the Vert.x Web Client, a reactive HTTP client."
msgstr "これまで、Vert.x Core APIを使用してきました。 Vert.xはさらに多くの機能、広大なエコシステムを提供します。 このセクションでは、リアクティブHTTPクライアントであるVert.x Webクライアントの使用方法を説明します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:329
msgid "Note that some Quarkus extensions are wrapping Vert.x clients and manage them for you.  That's the case for the reactive data sources, Redis, mail...  That's not the case with the Web Client."
msgstr "一部のQuarkusエクステンションはVert.xクライアントをラップし、それらを管理していることに注意してください。 これは、リアクティブデータソース、Redis、メールの場合です... Webクライアントの場合はそうではありません。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:332
msgid "Remember, at the beginning of the guide, we added the `smallrye-mutiny-vertx-web-client` dependency to our `pom.xml` file.  It's now time to use it."
msgstr "ガイドの冒頭で、 `smallrye-mutiny-vertx-web-client` 依存関係を `pom.xml` ファイルに追加したことを思い出して下さい。 それを使用する時が来ました。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:335
msgid "First, we need to create an instance of `WebClient`.  Extend the `VertxResource` class with the `client` field and the creation of the web client in the constructor:"
msgstr "まず、 `WebClient` のインスタンスを作成する必要があります。 `VertxResource` クラスを `client` フィールドで拡張し、コンストラクターでWebクライアントを作成します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:340
#, no-wrap
msgid ""
"private final Vertx vertx;\n"
"private final WebClient client;            // <1>\n"
msgstr ""
"private final Vertx vertx;\n"
"private final WebClient client;            // <1>\n"

#. type: Plain text
#: upstream/_guides/vertx.adoc:346
#, no-wrap
msgid ""
"@Inject\n"
"public VertxResource(Vertx vertx) {\n"
"    this.vertx = vertx;\n"
"    this.client = WebClient.create(vertx); // <2>\n"
"}\n"
msgstr ""
"@Inject\n"
"public VertxResource(Vertx vertx) {\n"
"    this.vertx = vertx;\n"
"    this.client = WebClient.create(vertx); // <2>\n"
"}\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:349
#, no-wrap
msgid ""
"1. Store the `WebClient`, so we will be able to use it in our HTTP endpoint\n"
"2. Create the `WebClient`. Be sure to use the `io.vertx.mutiny.ext.web.client.WebClient` class\n"
msgstr ""
"1. `WebClient` を保存して、HTTPエンドポイントで使用できるようにします\n"
"2. `WebClient` を作成します。 必ず `io.vertx.mutiny.ext.web.client.WebClient`クラスを使用してください\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:352
#, no-wrap
msgid ""
"Let's now implement a new HTTP endpoint that queries the Wikipedia API to retrieve the pages about Quarkus in the different languages.\n"
"Add the following method to the `VertxResource` class:\n"
msgstr ""
"次に、Wikipedia APIにクエリを実行してQuarkusに関するページをさまざまな言語で取得する新しいHTTPエンドポイントを実装しましょう。\n"
"次のメソッドを `VertxResource`クラスに追加します。\n"

#. type: Plain text
#: upstream/_guides/vertx.adoc:356
msgid "private static final String URL = \"https://en.wikipedia.org/w/api.php?action=parse&page=Quarkus&format=json&prop=langlinks\";"
msgstr "private static final String URL = \"https://en.wikipedia.org/w/api.php?action=parse&page=Quarkus&format=json&prop=langlinks\";"

#. type: Plain text
#: upstream/_guides/vertx.adoc:365
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/web\")\n"
"public Uni<JsonArray> retrieveDataFromWikipedia() {                     // <1>\n"
"    return client.getAbs(URL).send()                                    // <2>\n"
"            .onItem().transform(HttpResponse::bodyAsJsonObject)         // <3>\n"
"            .onItem().transform(json -> json.getJsonObject(\"parse\")     // <4>\n"
"                                        .getJsonArray(\"langlinks\"));\n"
"}\n"
msgstr ""
"@GET\n"
"@Path(\"/web\")\n"
"public Uni<JsonArray> retrieveDataFromWikipedia() {                     // <1>\n"
"    return client.getAbs(URL).send()                                    // <2>\n"
"            .onItem().transform(HttpResponse::bodyAsJsonObject)         // <3>\n"
"            .onItem().transform(json -> json.getJsonObject(\"parse\")     // <4>\n"
"                                        .getJsonArray(\"langlinks\"));\n"
"}\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:370
#, no-wrap
msgid ""
"1. This endpoint returns a JSON Array. Vert.x provides a convenient way to manipulate JSON Object and Array. More details about these in xref:vertx-reference.adoc#using-vert-x-json[the reference guide].\n"
"2. Send a `GET` request to the Wikipedia API\n"
"3. Once the response is received, extract it as a JSON Object\n"
"4. Extract the `langlinks` array from the response.\n"
msgstr ""
"1.このエンドポイントはJSON配列を返します。 Vert.xは、JSONオブジェクトと配列を操作するための便利な方法を提供します。 これらの詳細については、xref:vertx-reference.adoc#using-vert-x-json[リファレンスガイド] をご覧ください。\n"
"2. `GET` リクエストをWikipedia APIに送信します\n"
"3. 応答を受信したら、それをJSONオブジェクトとして抽出します\n"
"4. 応答から `langlinks` 配列を抽出します。\n"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:372
#, no-wrap
msgid "Then, invoke the endpoint using:\n"
msgstr "そして、エンドポイントを呼び出します。\n"

#. type: Plain text
#: upstream/_guides/vertx.adoc:376
msgid "curl http://localhost:8080/vertx/web"
msgstr "curl http://localhost:8080/vertx/web"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:380
#, no-wrap
msgid "The response indicates that, in addition to the English page, there are a German and a French page about Quarkus on wikipedia.\n"
msgstr "応答は、英語のページに加えて、ウィキペディアにQuarkusに関するドイツ語とフランス語のページがあることを示しています。\n"

#. type: Title ==
#: upstream/_guides/vertx.adoc:381
#, no-wrap
msgid "Going further"
msgstr "さらに詳しく"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:386
msgid "This guide introduced how you can use Vert.x APIs from a Quarkus application.  It's just a brief overview.  If you want to know more, check the xref:vertx-reference.adoc[reference guide about Vert.x in Quarkus]."
msgstr "このガイドでは、QuarkusアプリケーションからVert.xAPIを使用する方法を紹介しました。 簡単な概要ですので、詳細については、xref:vertx-reference.adoc[QuarkusにおけるVert.xのリファレンスガイド]を参照してください。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:390
msgid "As we have seen, the event bus is the connecting tissue of Vert.x applications.  Quarkus integrates it so different beans can interact with asynchronous messages.  This part is covered in the xref:reactive-event-bus.adoc[event bus documentation]."
msgstr "イベントバスは、Vert.xアプリケーションの接続組織です。Quarkusはこれを統合しているので、様々なBeanが非同期メッセージと対話できます。この部分は、 link:reactive-event-bus[イベントバスのドキュメント] でカバーされています。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:391
msgid "Learn how to implement highly performant, low-overhead database applications on Quarkus with the xref:reactive-sql-clients.adoc[Reactive SQL Clients]."
msgstr "link:reactive-sql-clients[Reactive SQLクライアント] を使用して、Quarkus上に高パフォーマンスで低オーバーヘッドのデータベースアプリケーションを実装する方法をご紹介しています。"

#~ msgid "Quarkus - Using Eclipse Vert.x"
#~ msgstr "Quarkus - Eclipse Vert.xの使用"

#~ msgid "Eclipse https://vertx.io[Vert.x] is a toolkit for building reactive applications.  It is designed to be lightweight and embeddable.  Vert.x defines a reactive execution model and provides a large ecosystem."
#~ msgstr "Eclipse link:https://vertx.io[Vert.x] は、リアクティブなアプリケーションを構築するためのツールキットです。軽量で埋め込み可能なように設計されています。Vert.xはリアクティブ実行モデルを定義し、大規模なエコシステムを提供します。"

#~ msgid "Quarkus is based on Vert.x, and almost all network-related features rely on Vert.x.  While lots of reactive features from Quarkus don't _show_ Vert.x, it's used underneath.  Quarkus also integrates smoothly with the Vert.x event bus (to enable asynchronous messaging passing between application components) and some reactive clients.  You can also use various Vert.x APIs in your Quarkus application, such as deploying _verticles_, instantiating clients..."
#~ msgstr "QuarkusはVert.xをベースにしており、ほとんどすべてのネットワーク関連機能はVert.xに依存しています。Quarkusのリアクティブ機能の多くはVert.xを _表に出して_ いませんが、その下で使用されています。また、Quarkusは、Vert.xイベントバス(アプリケーションコンポーネント間の非同期メッセージングの受け渡しを可能にするため)やいくつかのリアクティブクライアントとスムーズに統合されています。また、Quarkusアプリケーションでは、さまざまなVert.x APIを使用することができます(例えば、 _バーティクル_ のデプロイ、クライアントのインスタンス化など)。"

#~ msgid "Installing"
#~ msgstr "インストール"

#~ msgid "To access Vert.x, well, you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter are follows:"
#~ msgstr "Vert.xにアクセスするに、この機能を利用するには、 `vertx` エクステンションを有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメーターを以下のように設定します。"

#~ msgid "If you have an already created project, the `vertx` extension can be added to an existing Quarkus project with the `add-extension` command:"
#~ msgstr "すでに作成済みのプロジェクトがある場合は、 `vertx` エクステンションを既存のQuarkusプロジェクトに `add-extension` コマンドで追加することができます。"

#~ msgid "Otherwise, you can manually add this to the dependencies section of your `pom.xml` file:"
#~ msgstr "そうでなければ、 `pom.xml` ファイルの依存関係セクションに手動で追加することができます。"

#~ msgid "Native Transport"
#~ msgstr "ネイティブトランスポート"

#~ msgid "Vert.x is capable of using https://netty.io/wiki/native-transports.html[Netty's native transports] which offers performance improvements on certain platforms. To enable them you must include the appropriate dependency for your platform. It's usually a good idea to include both to keep your application platform agnostic. Netty is smart enough to use the correct one, that includes none at all on unsupported platforms:"
#~ msgstr "Vert.x は link:https://netty.io/wiki/native-transports.html[Netty のネイティブトランスポート] を使用することができ、特定のプラットフォームでパフォーマンスを向上させることができます。これを有効にするには、プラットフォームに応じた適切な依存関係を含める必要があります。通常、アプリケーションのプラットフォームに依存しないようにするために、両方を含めるのが良いでしょう。Netty は、サポートされていないプラットフォームでは何も含まれていない方を使うようにしています。"

#~ msgid "You will also have to explicitly configure Vert.x to use the native transport. In `application.properties` add:"
#~ msgstr "また、ネイティブトランスポートを使用するよう、Vert.x を明示的に設定する必要があります。 `application.properties` で以下を追加します。"

#~ msgid "Or in `application.yml`:"
#~ msgstr "または `application.yml` で以下を追加します。"

#~ msgid "If all is well quarkus will log:"
#~ msgstr "すべてがうまくいけば、クァーカス以下のログ出力を行います。"

#~ msgid "Native Linux Transport"
#~ msgstr "ネイティブLinuxトランスポート"

#~ msgid "On Linux you can enable the following socket options:"
#~ msgstr "Linuxでは、以下のソケットオプションを有効にすることができます。"

#~ msgid "SO_REUSEPORT"
#~ msgstr "SOREUSEPORT"

#~ msgid "TCP_QUICKACK"
#~ msgstr "TCP_QUICKACK"

#~ msgid "TCP_CORK"
#~ msgstr "TCP_CORK"

#~ msgid "TCP_FASTOPEN"
#~ msgstr "TCP_FASTOPEN"

#~ msgid "Native MacOS Transport"
#~ msgstr "ネイティブMacOSトランスポート"

#~ msgid "On MacOS Sierra and above you can enable the following socket options:"
#~ msgstr "MacOS Sierra以上では、以下のソケットオプションを有効にすることができます。"

#~ msgid "Once the extension has been added, you can access the _managed_ Vert.x instance using `@Inject`:"
#~ msgstr "エクステンションを追加したら、 `@Inject` を使用して _管理されている_ Vert.x インスタンスにアクセスできます。"

#~ msgid "If you are familiar with Vert.x, you know that Vert.x provides different API models.  The _bare_ Vert.x uses callbacks, while the Mutiny variant uses `Uni` and `Multi`."
#~ msgstr "Vert.x に詳しい方は、Vert.x が異なる API モデルを提供していることをご存知でしょう。 _素の_ Vert.x はコールバックを使用し、Mutiny バリアントは `Uni` と `Multi` を使用します。"

#~ msgid "Quarkus provides 2 Vert.x APIs:"
#~ msgstr "Quarkusは2つのVert.x APIを提供しています。"

#~ msgid "Name"
#~ msgstr "名前"

#~ msgid "Code"
#~ msgstr "コード"

#~ msgid "Description"
#~ msgstr "説明"

#~ msgid "_bare_"
#~ msgstr "_bare_"

#~ msgid "`@Inject io.vertx.core.Vertx vertx`"
#~ msgstr "`@Inject io.vertx.core.Vertx vertx`"

#~ msgid "_bare_ Vert.x instance, the API uses callbacks."
#~ msgstr "_bare_ Vert.x インスタンスの場合、API はコールバックを使用します。"

#~ msgid "https://smallrye.io/smallrye-mutiny/[Mutiny]"
#~ msgstr "https://smallrye.io/smallrye-mutiny/[Mutiny]"

#~ msgid "The Mutiny API for Vert.x."
#~ msgstr "Vert.x用のMutiny API"

#, fuzzy
#~ msgid "You may inject any of the 2 flavors of `Vertx` as well as the `EventBus` in your Quarkus application beans: `bare` and `Mutiny`.  They are just shims and rely on a single _managed_ Vert.x instance."
#~ msgstr "`Vertx` と `EventBus` の4つのフレーバーのいずれかをQuarkusアプリケーションBeanに注入することができます: `bare` , `Mutiny` , `Axle` , `RxJava2` .これらは単なるシムであり、単一の _管理された_ Vert.xインスタンスに依存しています。"

#~ msgid "You will pick one or the other depending on your use cases."
#~ msgstr "ユースケースに応じてどちらかを選ぶことになります。"

#, fuzzy
#~ msgid "`bare`: for advanced usage or if you have existing Vert.x code you want to reuse in your Quarkus application"
#~ msgstr "`bare` : 高度な使用方法や、Quarkusアプリケーションで再利用したい既存のVert.xコードがある場合に使用します。"

#, fuzzy
#~ msgid "`mutiny`: Mutiny is an event-driven reactive programming API. It uses 2 types: `Uni` and `Multi`. This is the recommended API."
#~ msgstr "`mutiny` : Mutinyはイベント駆動型のリアクティブプログラミングAPIです。 `Uni` と `Multi` の2種類を使用しています。これが推奨APIです。"

#, fuzzy
#~ msgid "The following snippets illustrate the difference between these 4 APIs:"
#~ msgstr "以下のスニペットは、これら4つのAPIの違いを説明しています。"

#, fuzzy
#~ msgid "If you're not familiar with Mutiny, we recommend to read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first."
#~ msgstr "Mutinyに慣れていない場合は、まずGet link:getting-started-reactive#mutiny[ting Started with Reactiveガイド] を読むことをお勧めします。"

#~ msgid "Using Vert.x in Reactive JAX-RS resources"
#~ msgstr "Reactive JAX-RSリソースでVert.xを使用する"

#, fuzzy
#~ msgid "Quarkus web resources support asynchronous processing and streaming results over https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[server-sent events]."
#~ msgstr "Quarkusのウェブリソースは、 link:https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[サーバーから送信されたイベント] に対する非同期処理と結果のストリーミングをサポートしています。"

#~ msgid "Asynchronous processing"
#~ msgstr "非同期処理"

#, fuzzy
#~ msgid "To asynchronously handle the HTTP request, the endpoint method must return a `java.util.concurrent.CompletionStage` or an `io.smallrye.mutiny.Uni` (requires the `quarkus-resteasy-mutiny` extension):"
#~ msgstr "HTTP リクエストを非同期に処理するには、エンドポイントメソッドは `java.util.concurrent.CompletionStage` または `io.smallrye.mutiny.Uni` を返さなければなりません (エクステンション `quarkus-resteasy-mutiny` が必要です)。"

#, fuzzy
#~ msgid "Then, open your browser to http://localhost:8080/lorem and you should get the message."
#~ msgstr "そして、ブラウザで http://localhost:8080/lorem を開くと、メッセージが表示されるはずです。"

#~ msgid "So far so good.  Now let's use the Vert.x API instead of this artificial delay:"
#~ msgstr "ここまでは順調です。では、この人工的な遅延の代わりに Vert.x API を使ってみましょう。"

#, fuzzy
#~ msgid "In this code, we inject the `vertx` instance (`io.vertx.mutiny.core.Vertx`) and read a file from the file system."
#~ msgstr "このコードでは、 `vertx` インスタンス ( `io.vertx.mutiny.core.Vertx` ) を注入し、ファイルシステムからファイルを読み込んでいます。"

#, fuzzy
#~ msgid "Then, refresh the page, you should see the _lorem ipsum_ text."
#~ msgstr "その後、ページを更新すると、 _lorem ipsumの_ テキストが表示されるはずです。"

#, fuzzy
#~ msgid "Streaming using Server-Sent Events"
#~ msgstr "サーバーから送信されたイベントを使用したストリーミング"

#, fuzzy
#~ msgid "Quarkus web resources that need to send content as https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[server-sent events] must have a method:"
#~ msgstr "link:https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events[サーバー送信イベント] としてコンテンツを送信する必要があるQuarkusのウェブリソースには、メソッドが必要です。"

#, fuzzy
#~ msgid "declaring the `text/event-stream` response content type"
#~ msgstr "`text/event-stream` レスポンスコンテンツ型の宣言"

#, fuzzy
#~ msgid "returning a https://www.reactive-streams.org/[Reactive Streams] `Publisher` or Mutiny `Multi` (requires the `quarkus-resteasy-mutiny` extension)"
#~ msgstr "link:https://www.reactive-streams.org/[Reactive Streams] `Publisher` または Mutiny `Multi` を返します ( `quarkus-resteasy-mutiny` エクステンションが必要です)。"

#, fuzzy
#~ msgid "In practice, a streaming greeting service would look like:"
#~ msgstr "実際には、ストリーミングのグリーティングサービスは次のようになります。"

#, fuzzy
#~ msgid "Now we just need to return our `Publisher` or `Multi`:"
#~ msgstr "あとは、 `Publisher` か `Multi` ."

#, fuzzy
#~ msgid "The server side is ready.  In order to see the result in the browser, we need a web page."
#~ msgstr "サーバー側の準備が整いました。ブラウザで結果を見るためにはWebページが必要です。"

#, fuzzy
#~ msgid "META-INF/resources/streaming.html"
#~ msgstr "META-INF/resources/streaming.html"

#, fuzzy
#~ msgid "Our web page just has an empty `<div>` container.  The magic, as always, lies in the Javascript code:"
#~ msgstr "私たちのウェブページには、空の `<div>` コンテナーがあります。いつものように、マジックはJavascriptのコードにあります。"

#, fuzzy
#~ msgid "META-INF/resources/streaming.js"
#~ msgstr "META-INF/resources/streaming.js"

#, fuzzy
#~ msgid "Most browsers support SSE but some don't.  More about this in Mozilla's https://developer.mozilla.org/en-US/docs/Web/API/EventSource#Browser_compatibility[SSE browser-compatibility list]."
#~ msgstr "ほとんどのブラウザは SSE をサポートしていますが、一部のブラウザはサポートしていません。これについての詳細は、Mozilla の link:https://developer.mozilla.org/en-US/docs/Web/API/EventSource#Browser_compatibility[SSE ブラウザ互換性リスト] を参照してください。"

#, fuzzy
#~ msgid "Navigate to http://localhost:8080/streaming.html.  A new greeting should show-up every 2 seconds."
#~ msgstr "http://localhost:8080/streaming.html に移動します。2秒ごとに新しい挨拶が表示されます。"

#, fuzzy
#~ msgid "Using Vert.x JSON"
#~ msgstr "Vert.x JSONを使う"

#, fuzzy
#~ msgid "Vert.x API heavily relies on JSON, namely the `io.vertx.core.json.JsonObject` and `io.vertx.core.json.JsonArray` types.  They are both supported as Quarkus web resource request and response bodies."
#~ msgstr "Vert.x APIはJSON、すなわち `io.vertx.core.json.JsonObject` 型と `io.vertx.core.json.JsonArray` 型に大きく依存しています。これらはいずれもQuarkusのウェブリソースのリクエストボディとレスポンスボディとしてサポートされています。"

#, fuzzy
#~ msgid "In your browser, navigate to http://localhost:8080/hello/Quarkus/object. You should see:"
#~ msgstr "ブラウザで http://localhost:8080/hello/Quarkus/object に移動します。表示されるはずです。"

#, fuzzy
#~ msgid "Then, navigate to http://localhost:8080/hello/Quarkus/array:"
#~ msgstr "そして、 http://localhost:8080/hello/Quarkus/array に移動します。"

#, fuzzy
#~ msgid "Needless to say, this works equally well when the JSON content is a request body or is wrapped in a `Uni`, `Multi`, `CompletionStage` or `Publisher`."
#~ msgstr "言うまでもなく、これはJSONコンテンツがリクエストボディであったり、 `Uni` , `Multi` , `CompletionStage` , , `Publisher` でラップされている場合でも同様に動作します。"

#, fuzzy
#~ msgid "As you can inject a Vert.x instance, you can use Vert.x clients in a Quarkus application.  This section gives an example with the `WebClient`."
#~ msgstr "Vert.xインスタンスを注入することができるので、QuarkusアプリケーションでVert.xクライアントを使用することができます。このセクションでは、 `WebClient` ."

#, fuzzy
#~ msgid "Picking the right dependency"
#~ msgstr "正しい依存関係の選択"

#, fuzzy
#~ msgid "Depending on the API model you want to use you need to add the right dependency to your `pom.xml` file:"
#~ msgstr "使用したいAPIモデルに応じて、 `pom.xml` ファイルに適切な依存関係を追加する必要があります。"

#, fuzzy
#~ msgid "In this guide, we are going to use the Mutiny API, so:"
#~ msgstr "このガイドでは、Mutiny APIを使うことになっていますので。"

#, fuzzy
#~ msgid "src/main/java/org/acme/vertx/ResourceUsingWebClient.java"
#~ msgstr "src/main/java/org/acme/vertx/ResourceUsingWebClient.java"

#~ msgid "}\n"
#~ msgstr "}\n"

#, fuzzy
#~ msgid "This resource creates a `WebClient` and upon request use this client to invoke the _fruityvice_ API.  Depending on the result the response is forwarded as it's received, or a new JSON object is created with the status and body.  The `WebClient` is obviously asynchronous (and non-blocking), to the endpoint returns a `Uni`."
#~ msgstr "このリソースは `WebClient` を作成し、リクエスト時にこのクライアントを使用して _fruityvice_ API を呼び出します。結果に応じて、レスポンスは受信したときに転送されるか、ステータスとボディを持つ新しいJSONオブジェクトが作成されます。 `WebClient` は明らかに非同期(とノンブロッキング)で、エンドポイントに `Uni` を返します。"

#, fuzzy
#~ msgid "And then, open a browser to: `http://localhost:8080/fruit-data/pear`. You should get some details about pears."
#~ msgstr "そして、ブラウザを開いて `http://localhost:8080/fruit-data/pear` .あなたは、梨についてのいくつかの詳細を取得する必要があります。"

#, fuzzy
#~ msgid "The application can also run as a native executable.  But, first, we need to instruct Quarkus to enable _ssl_.  Open the `src/main/resources/application.properties` and add:"
#~ msgstr "アプリケーションはネイティブの実行ファイルとして実行することもできます。しかし、まず、Quarkusに _sslを_ 有効にするように指示する必要があります。 `src/main/resources/application.properties` を開いて、追加します。"

#, fuzzy
#~ msgid "Then, create the native executable with:"
#~ msgstr "そして、ネイティブの実行ファイルを"

#~ msgid "./mvnw package -Pnative\n"
#~ msgstr "./mvnw package -Pnative\n"

#, fuzzy
#~ msgid "Deploying verticles"
#~ msgstr "頂点の配置"

#, fuzzy
#~ msgid "link:https://vertx.io/docs/vertx-core/java/#\\_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.  This model does not claim to be a strict actor-model implementation, but it does share similarities especially with respect to concurrency, scaling and deployment.  To use this model, you write and _deploy_ verticles, communicating with each other by sending messages on the event bus."
#~ msgstr "link:https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] は _Vert.x_ によって提供されている「シンプルでスケーラブルなアクターライクなデプロイメントと同時実行モデル」です。このモデルは厳密なアクターモデルの実装であるとは主張しませんが、特に同時実行、スケーリング、デプロイメントに関しては類似性を共有しています。このモデルを使用するには、イベントバス上でメッセージを送信することでお互いに通信しながら、 頂点を書いて _展開し_ ます。"

#, fuzzy
#~ msgid "You can deploy _verticles_ in Quarkus.  It supports:"
#~ msgstr "Quarkusでバーティカル _を_ 展開することができます。サポートしています。"

#, fuzzy
#~ msgid "_bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`"
#~ msgstr "_裸の_ 頂点 - 拡張する Java クラス `io.vertx.core.AbstractVerticle`"

#, fuzzy
#~ msgid "_Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`"
#~ msgstr "_Mutiny_ verticle - 拡張するJavaクラス `io.smallrye.mutiny.vertx.core.AbstractVerticle`"

#, fuzzy
#~ msgid "To deploy verticles, use the regular Vert.x API:"
#~ msgstr "頂点を展開するには、通常の Vert.x API を使用します。"

#, fuzzy
#~ msgid "You can also pass deployment options to configure the verticle as well as set the number of instances."
#~ msgstr "インスタンスの数を設定するだけでなく、デプロイメントオプションを渡してバーティクルを設定することもできます。"

#, fuzzy
#~ msgid "Verticles are not _beans_ by default.  However, you can implement them as _ApplicationScoped_ beans and get injection support:"
#~ msgstr "バーチクルはデフォルトでは _Beanで_ はありません。しかし、 _ApplicationScoped_ Beanとして実装し、インジェクションのサポートを得ることができます。"

#, fuzzy
#~ msgid "You don't have to inject the `vertx` instance but instead leverage the instance stored in the protected field of `AbstractVerticle`."
#~ msgstr "`vertx` インスタンスを注入する必要はなく、代わりに `AbstractVerticle` の保護されたフィールドに保存されているインスタンスを活用します。"

#, fuzzy
#~ msgid "Then, deploy the verticle instance with:"
#~ msgstr "そして、verticleインスタンスを使ってデプロイします。"

#, fuzzy
#~ msgid "If you want to deploy every exposed `AbstractVerticle`, you can use:"
#~ msgstr "もしあなたが公開された `AbstractVerticle` をすべてデプロイしたいのであれば、あなたは使用することができます。"

#~ msgid "Listening to a Unix Domain Socket"
#~ msgstr "Unix ドメインソケットのリスニング"

#~ msgid "Listening on a unix domain socket allows us to dispense with the overhead of TCP if the connection to the quarkus service is established from the same host. This can happen if access to the service goes through a proxy which is often the case if you're setting up a service mesh with a proxy like Envoy."
#~ msgstr "unix ドメインソケットをリスンすることで、同じホストから quarkus サービスへの接続が確立されている場合、TCP のオーバーヘッドを省くことができます。これはサービスへのアクセスがプロキシーを経由している場合に起こる可能性があり、Envoyのようなプロキシーでサービスメッシュを設定している場合によく起こります。"

#~ msgid "This will only work on platforms that support <<native-transport>>."
#~ msgstr "これは、 link:#native-transport[[native-transport]] をサポートするプラットフォームでのみ動作します。"

#~ msgid "To setup please enable the appropriate <<native-transport>> and set the following environment property:"
#~ msgstr "設定するには、適切な link:#native-transport[native-transport] を有効にし、以下の環境プロパティーを設定してください。"

#, fuzzy
#~ msgid "By itself this will not disable the tcp socket which by default will open on `0.0.0.0:8080`. It can be explicitly disabled:"
#~ msgstr "これだけでは、デフォルトで `0.0.0.0:8080` で開かれる TCP ソケットを無効にすることはできません。明示的に無効にすることができます。"

#~ msgid "These properties can be set through Java's `-D` command line parameter or on `application.properties`."
#~ msgstr "これらのプロパティーは、Java の `-D` コマンドライン・パラメーターまたは `application.properties` で設定することが可能です。"

#~ msgid "Read only deployment environments"
#~ msgstr "読み込み専用のデプロイ環境"

#~ msgid "In environments with read only file systems you may receive errors of the form:"
#~ msgstr "読み取り専用のファイルシステムを使用している環境では、このような形式のエラーが発生することがあります。"

#~ msgid "Assuming `/tmp/` is writable this can be fixed by setting the `vertx.cacheDirBase` property to point to a directory in `/tmp/` for instance in OpenShift by creating an environment variable `JAVA_OPTS` with the value `-Dvertx.cacheDirBase=/tmp/vertx`."
#~ msgstr "`/tmp/` が書き込み可能である場合、 `vertx.cacheDirBase` プロパティーを `/tmp/` のディレクトリーを指すように設定し、例えば OpenShift の場合は `JAVA_OPTS` に `-Dvertx.cacheDirBase=/tmp/vertx` の値を持つ環境変数を作成することで修正できます。"

#~ msgid "Running behind a reverse proxy"
#~ msgstr "リバースプロキシーの背後での実行"

#, fuzzy
#~ msgid "Quarkus could be accessed through proxies that additionally generate headers (e.g. `X-Forwarded-Host`) to keep information from the client-facing side of the proxy servers that is altered or lost when they are involved.  In those scenarios, Quarkus can be configured to automatically update information like protocol, host, port and URI reflecting the values in these headers."
#~ msgstr "Quarkusは、プロキシーサーバーが関与したときに変更されたり失われたりする情報を、プロキシーサーバーのクライアント側から保持するために、追加でヘッダー(例: `X-Forwarded-Host` )を生成するプロキシーを介してアクセスすることができます。このような場合、Quarkusは、これらのヘッダーの値を反映して、プロトコル、ホスト、ポート、URIなどの情報を自動的に更新するように設定することができます。"

#, fuzzy
#~ msgid "Activating this feature makes the server exposed to several security issues (i.e. information spoofing).  Consider activate it only when running behind a reverse proxy."
#~ msgstr "この機能を有効にすると、サーバーはいくつかのセキュリティー上の問題(情報の詐称など)にさらされることになります。リバースプロキシーの後ろで実行している場合にのみ有効にすることを検討してください。"

#, fuzzy
#~ msgid "To setup this feature, please include the following lines in `src/main/resources/application.properties`:"
#~ msgstr "この機能を設定するには、 `src/main/resources/application.properties` ."

#, fuzzy
#~ msgid "To consider only de-facto standard header (`Forwarded` header), please include the following lines in `src/main/resources/application.properties`:"
#~ msgstr "デファクトの標準ヘッダ( `Forwarded` ヘッダ)のみを考慮する場合は、 `src/main/resources/application.properties` ."

#, fuzzy
#~ msgid "To consider only non-standard headers, please include the following lines instead in `src/main/resources/application.properties`:"
#~ msgstr "標準以外のヘッダのみを考慮するために、代わりに以下の行を `src/main/resources/application.properties` に含めてください。"

#, fuzzy
#~ msgid "Both configurations related to standard and non-standard headers can be combined, although the standard headers configuration will have precedence."
#~ msgstr "標準ヘッダと非標準ヘッダに関連する両方の設定を組み合わせることができますが、標準ヘッダの設定が優先されます。"

#~ msgid "Supported forwarding address headers are:"
#~ msgstr "サポートされている転送アドレスヘッダは以下の通りです。"

#~ msgid "`Forwarded`"
#~ msgstr "`Forwarded`"

#~ msgid "`X-Forwarded-Proto`"
#~ msgstr "`X-Forwarded-Proto`"

#~ msgid "`X-Forwarded-Host`"
#~ msgstr "`X-Forwarded-Host`"

#~ msgid "`X-Forwarded-Port`"
#~ msgstr "`X-Forwarded-Port`"

#~ msgid "`X-Forwarded-Ssl`"
#~ msgstr "`X-Forwarded-Ssl`"

#~ msgid "`X-Forwarded-Prefix`"
#~ msgstr "`X-Forwarded-Prefix`"

#~ msgid "SameSite cookies"
#~ msgstr "SameSiteクッキー"

#, fuzzy
#~ msgid "One can easily add a https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] cookie property to any of the cookies set by a Quarkus endpoint by listing a cookie name and a `SameSite` attribute, for example:"
#~ msgstr "例えば、クッキー名と `SameSite` 属性をリストアップすることで、Quarkusエンドポイントで設定されたクッキーに link:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite] クッキープロパティーを簡単に追加することができます。"

#, fuzzy
#~ msgid "Given this configuration, the `jwt` cookie will have a `SameSite=Lax` attribute and the `session` cookie will have a `SameSite=Strict` attribute."
#~ msgstr "この設定を考えると、 `jwt` クッキーは `SameSite=Lax` 属性を持ち、 `session` クッキーは `SameSite=Strict` 属性を持つことになります。"

#~ msgid "There are many other facets of Quarkus using Vert.x underneath:"
#~ msgstr "下にVert.xを使ったQuarkusの他の面はたくさんあります。"

#, fuzzy
#~ msgid "Data streaming and Apache Kafka are an important part of modern systems.  Quarkus integrates data streaming using Reactive Messaging.  More details on link:kafka[Interacting with Kafka]."
#~ msgstr "データストリーミングとApache Kafkaは、現代のシステムの重要な部分です。Quarkusは、Reactive Messagingを使用してデータストリーミングを統合しています。詳細は、 link:kafka[Kafkaとのインタラクション] を参照してください。"
