# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2023-04-30 20:50+0900\n"
"PO-Revision-Date: 2023-04-15 02:46+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi-reference.adoc:6
#, no-wrap
msgid "Contexts and Dependency Injection"
msgstr "コンテキストと依存性インジェクション"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:18
#, fuzzy
msgid "Quarkus DI solution (also called ArC) is based on the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts and Dependency Injection 4.0, window=\"_blank\"] specification.  It aims to implement the CDI Lite specification, with selected improvements on top.  It is not a CDI Full implementation and is not verified by the TCK yet.  See also xref:supported_features[the list of supported features] and xref:limitations[the list of limitations]."
msgstr "Quarkus DIソリューション（ArCとも呼ばれる）は、 link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts and Dependency Injection 4.0] 仕様に基づきます。CDI Lite仕様を実装することを目的としており、その上で厳選された改良を加えています。CDI Fullの実装ではありませんし、TCKでもまだ検証されていません。 xref:supported_features[サポートされる機能のリストと] xref:limitations[制限のリストも] 参照してください。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:20
msgid "If you're new to CDI then we recommend you to read the xref:cdi.adoc[Introduction to CDI] first."
msgstr "CDI が初めての方は、最初に xref:cdi.adoc[コンテキストと依存性注入(CDI)の紹介] を読むことをお勧め致します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:22
msgid "Most of the existing CDI code should work just fine but there are some small differences which follow from the Quarkus architecture and goals."
msgstr "既存の CDI コードのほとんどは問題なく動作するはずですが、Quarkus のアーキテクチャや目標との間には、わずかな相違点がいくつかあります。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:24
#, no-wrap
msgid "Bean Discovery"
msgstr "Bean の検出"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:29
msgid "Bean discovery in CDI is a complex process which involves legacy deployment structures and accessibility requirements of the underlying module architecture.  However, Quarkus is using a *simplified bean discovery*.  There is only single bean archive with the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"] and no visibility boundaries."
msgstr "CDI での Bean 検出は、レガシーなデプロイメント構造と、基礎となるモジュールアーキテクチャーのアクセシビリティ要件を含む複雑なプロセスです。しかし、Quarkusは *簡素化された Bean 検出* を使用しています。 https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#default_bean_discovery[`annotated` bean検出モード, window=\"_blank\"] と可視性の境界がない単一の Bean アーカイブのみが存在します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:31
msgid "The bean archive is synthesized from:"
msgstr "Bean のアーカイブは、次のものから合成されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:33
msgid "the application classes,"
msgstr "アプリケーションクラス"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:34
msgid "dependencies that contain a `beans.xml` descriptor (content is ignored),"
msgstr "`beans.xml` 記述子を含む依存関係 (内容は無視される)"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:35
msgid "dependencies that contain a Jandex index - `META-INF/jandex.idx`,"
msgstr "Jandex インデックスを含む依存関係 (`META-INF/jandex.idx`)"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:36
msgid "dependencies referenced by `quarkus.index-dependency` in `application.properties`,"
msgstr "`application.properties` の `quarkus.index-dependency` で参照される依存関係"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:37
msgid "and Quarkus integration code."
msgstr "Quarkus の統合コード"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:42
msgid "Bean classes that don't have a https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are not discovered.  This behavior is defined by CDI.  But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation (this behavior is different to what is defined in CDI).  In fact, the declaring bean classes are considered annotated with `@Dependent`."
msgstr "https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations[bean定義アノテーション, window=\"_blank\"] を持たない Bean クラスは検出されません。この動作は CDI で定義されています。しかし、producer メソッドやフィールド、observer メソッドは、宣言クラスが Bean 定義アノテーションを持たない場合でも検出されます (この動作は CDI で定義されているものとは異なります)。実際には、Bean クラスの宣言は `@Dependent` でアノテーションされていると見なされます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:44
msgid "Quarkus extensions may declare additional discovery rules. For example, `@Scheduled` business methods are registered even if the declaring class is not annotated with a bean defining annotation."
msgstr "Quarkus エクステンションは、追加のディスカバリールールを宣言することができます。たとえば、`@Scheduled` ビジネスメソッドは、宣言するクラスが Bean 定義アノテーションでアノテーションされていなくても登録されます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:45
#, no-wrap
msgid "How to Generate a Jandex Index"
msgstr "Jandex インデックスを生成する方法"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:49
msgid "A dependency with a Jandex index is automatically scanned for beans.  To generate the index just add the following plugin to your build file:"
msgstr "Jandex インデックスを持つ依存関係は、Bean に対して自動的にスキャンされます。インデックスを生成するには、次のプラグインをビルドファイルに追加するだけです。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:51
#, no-wrap
msgid "Maven"
msgstr "Maven"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:72
#, no-wrap
msgid ""
"<build>\n"
"  <plugins>\n"
"    <plugin>\n"
"      <groupId>io.smallrye</groupId>\n"
"      <artifactId>jandex-maven-plugin</artifactId>\n"
"      <version>{jandex-version}</version>\n"
"      <executions>\n"
"        <execution>\n"
"          <id>make-index</id>\n"
"          <goals>\n"
"            <goal>jandex</goal>\n"
"          </goals>\n"
"        </execution>\n"
"      </executions>\n"
"    </plugin>\n"
"  </plugins>\n"
"</build>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:76
#, no-wrap
msgid "Gradle (Groovy DSL)"
msgstr "Gradle (Groovy DSL)"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:84
#, no-wrap
msgid ""
"plugins {\n"
"    id 'org.kordamp.gradle.jandex' version '{jandex-gradle-plugin-version}'\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:89
#, no-wrap
msgid "Gradle (Kotlin DSL)"
msgstr "Gradle (Kotlin DSL)"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:97
#, no-wrap
msgid ""
"plugins {\n"
"    id(\"org.kordamp.gradle.jandex\") version '{jandex-gradle-plugin-version}'\n"
"}\n"
msgstr ""

#. type: delimited block *
#: upstream/_guides/cdi-reference.adoc:102
msgid "If you can't modify the dependency, you can still index it by adding `quarkus.index-dependency` entries to your `application.properties`:"
msgstr "依存関係を変更できなくても、`quarkus.index-dependency` エントリーを `application.properties` に追加することでインデックスを作成できます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:108
#, no-wrap
msgid ""
"quarkus.index-dependency.<name>.group-id=\n"
"quarkus.index-dependency.<name>.artifact-id=\n"
"quarkus.index-dependency.<name>.classifier=(this one is optional)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:111
msgid "For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:"
msgstr "たとえば、次のエントリーは、`org.acme:acme-api` 依存関係が確実にインデックス化されるようにします。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:112
#: upstream/_guides/cdi-reference.adoc:137
#: upstream/_guides/cdi-reference.adoc:149
#: upstream/_guides/cdi-reference.adoc:489
#: upstream/_guides/cdi-reference.adoc:673
#, no-wrap
msgid "Example application.properties"
msgstr "application.properties の例"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:117
#, no-wrap
msgid ""
"quarkus.index-dependency.acme.group-id=org.acme <1>\n"
"quarkus.index-dependency.acme.artifact-id=acme-api <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:119
#: upstream/_guides/cdi-reference.adoc:156
msgid "Value is a group id for a dependency identified by name `acme`."
msgstr "値 `acme` は、名前で識別される依存関係のグループ ID です。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:120
#: upstream/_guides/cdi-reference.adoc:157
msgid "Value is an artifact id for a dependency identified by name `acme`."
msgstr "値は、名前 `acme` で識別される依存関係のアーティファクト ID です。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:121
#, no-wrap
msgid "How To Exclude Types and Dependencies from Discovery"
msgstr "ディスカバリーから型と依存関係を除外する方法"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:127
msgid "It may happen that some beans from third-party libraries do not work correctly in Quarkus.  A typical example is a bean injecting a portable extension.  In such case, it's possible to exclude types and dependencies from the bean discovery.  The `quarkus.arc.exclude-types` property accepts a list of string values that are used to match classes that should be excluded."
msgstr "サードパーティーのライブラリーからのいくつかの Bean が Quarkus で正しく動作しないことがあります。典型的な例は、ポータブル・エクステンションを注入する Bean です。このような場合は、型や依存関係を Bean の検出から除外することができます。`quarkus.arc.exclude-types` プロパティーは、除外すべきクラスに一致するために使用される文字列値のリストを受け入れます。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:128
#: upstream/_guides/cdi-reference.adoc:480
#: upstream/_guides/cdi-reference.adoc:664
#, no-wrap
msgid "Value Examples"
msgstr "値の例"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:130
#: upstream/_guides/cdi-reference.adoc:482
#: upstream/_guides/cdi-reference.adoc:666
#, no-wrap
msgid "Valu"
msgstr "バリュー"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:131
#: upstream/_guides/cdi-reference.adoc:483
#: upstream/_guides/cdi-reference.adoc:667
#, no-wrap
msgid "Description"
msgstr "Description"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:131
#: upstream/_guides/cdi-reference.adoc:483
#: upstream/_guides/cdi-reference.adoc:667
#, no-wrap
msgid "`org.acme.Foo`"
msgstr "`org.acme.Foo`"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:132
#, no-wrap
msgid "Match the fully qualified name of the class"
msgstr "クラスの完全修飾名と一致させる"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:132
#: upstream/_guides/cdi-reference.adoc:484
#: upstream/_guides/cdi-reference.adoc:668
#, no-wrap
msgid "`org.acme.*`"
msgstr "`org.acme.*`"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:133
#, no-wrap
msgid "Match classes with package `org.acme`"
msgstr "`org.acme` パッケージとクラスを一致させる"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:133
#: upstream/_guides/cdi-reference.adoc:485
#: upstream/_guides/cdi-reference.adoc:669
#, no-wrap
msgid "`org.acme.**`"
msgstr "`org.acme.**`"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:134
#, no-wrap
msgid "Match classes where the package starts with `org.acme`"
msgstr "パッケージが `org.acme` で始まるクラスを一致させる"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:134
#: upstream/_guides/cdi-reference.adoc:486
#: upstream/_guides/cdi-reference.adoc:670
#, no-wrap
msgid "`Bar`"
msgstr "`Bar`"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:135
#, no-wrap
msgid "Match the simple name of the class"
msgstr "クラスのシンプルな名前に一致する"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:141
#, no-wrap
msgid "quarkus.arc.exclude-types=org.acme.Foo,org.acme.*,Bar <1><2><3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:143
msgid "Exclude the type `org.acme.Foo`."
msgstr "タイプ `org.acme.Foo` を除外します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:144
msgid "Exclude all types from the `org.acme` package."
msgstr "`org.acme` パッケージからすべてのタイプを除外します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:145
msgid "Exclude all types whose simple name is `Bar`"
msgstr "シンプルな名前が `Bar` であるすべてのタイプを除外します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:148
msgid "It is also possible to exclude a dependency artifact that would be otherwise scanned for beans.  For example, because it contains a `beans.xml` descriptor."
msgstr "また、除外しなければ Bean をスキャンする、依存関係のあるアーティファクトを除外することも可能です。たとえば、 `beans.xml` 記述子を含んでいる場合です。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:154
#, no-wrap
msgid ""
"quarkus.arc.exclude-dependency.acme.group-id=org.acme <1>\n"
"quarkus.arc.exclude-dependency.acme.artifact-id=acme-services <2>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:158
#, no-wrap
msgid "Native Executables and Private Members"
msgstr "ネイティブ実行可能ファイルとプライベートメンバー"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:164
msgid "Quarkus is using GraalVM to build a native executable.  One of the limitations of GraalVM is the usage of https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/Reflection/[Reflection, window=\"_blank\"].  Reflective operations are supported but all relevant members must be registered for reflection explicitly.  Those registrations result in a bigger native executable."
msgstr "Quarkus は GraalVM を使用してネイティブ実行可能ファイルをビルドしています。GraalVM での制限の 1 つは、 https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/Reflection/[リフレクション, window=\"_blank\"] の使用です。リフレクティブ操作はサポートされていますが、関連するすべてのメンバーをリフレクション用に明示的に登録する必要があります。これらの登録により、ネイティブ実行可能ファイルが大きくなります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:168
msgid "And if Quarkus DI needs to access a private member it *has to use reflection*.  That's why Quarkus users are encouraged __not to use private members__ in their beans.  This involves injection fields, constructors and initializers, observer methods, producer methods and fields, disposers and interceptor methods."
msgstr "また、Quarkus DI がプライベートメンバーにアクセスする必要がある場合は、**リフレクションを使用しなければなりません**。そのため、Quarkus ユーザーは、プライベートメンバーを Bean で _使用しないこと_ が推奨されています。これには、インジェクションフィールド、コンストラクターとイニシャライザー、observer メソッド、producer メソッドおよび producer フィールド、disposers メソッドおよび interceptor メソッドが含まれます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:171
msgid "How to avoid using private members? You can use package-private modifiers:"
msgstr "プライベートメンバーの使用を回避するには、package-private 修飾子を使うことができます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:176
#: upstream/_guides/cdi-reference.adoc:193
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CounterBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:179
#, no-wrap
msgid ""
"    @Inject\n"
"    CounterService counterService; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:183
#, no-wrap
msgid ""
"    void onMessage(@Observes Event msg) { <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:185
msgid "A package-private injection field."
msgstr "package-private injection フィールド。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:186
msgid "A package-private observer method."
msgstr "package-private observer メソッド。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:188
msgid "Or constructor injection:"
msgstr "あるいはコンストラクター注入も可能です:"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:195
#, no-wrap
msgid "    private CounterService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:200
#, no-wrap
msgid ""
"    CounterBean(CounterService service) { <1>\n"
"      this.service = service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:202
msgid "A package-private constructor injection. `@Inject` is optional in this particular case."
msgstr "パッケージプライベートコンストラクター注入。この特定の場合、`@Inject` は任意です。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:204
#, no-wrap
msgid "Supported Features"
msgstr "サポートされている機能"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:207
msgid "Programming model"
msgstr "プログラミングモデル"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:208
msgid "Managed beans implemented by a Java class"
msgstr "Java クラスによって実装されるマネージド Bean"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:209
msgid "`@PostConstruct` and `@PreDestroy` lifecycle callbacks"
msgstr "ライフサイクルコールバック `@PostConstruct` および `@PreDestroy`"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:210
msgid "Producer methods and fields, disposers"
msgstr "producer のメソッドおよびフィールド、ディスポーザー"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:211
msgid "Qualifiers"
msgstr "修飾子"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:212
msgid "Alternatives"
msgstr "代替案"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:213
msgid "Stereotypes"
msgstr "ステレオタイプ"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:214
msgid "Dependency injection and lookup"
msgstr "依存関係の注入とルックアップ"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:215
msgid "Field, constructor and initializer/setter injection"
msgstr "フィールド、コンストラクター、イニシャライザー/セッター注入"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:216
msgid "Type-safe resolution"
msgstr "タイプセーフ解決"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:217
#, fuzzy
msgid "Programmatic lookup via `jakarta.enterprise.inject.Instance`"
msgstr "プログラマティックルックアップ経由 `jakarta.enterprise.inject.Instance`"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:218
msgid "Client proxies"
msgstr "クライアントのプロキシー"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:219
msgid "Injection point metadata"
msgstr "注入ポイントメタデータ"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:220
msgid "Scopes and contexts; see xref:cdi.adoc#bean-scope-available[here] for details"
msgstr "スコープとコンテキスト、詳しくは xref:cdi.adoc#bean-scope-available[こちら]"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:221
msgid "Interceptors"
msgstr "インターセプター"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:222
msgid "Business method interceptors: `@AroundInvoke`"
msgstr "ビジネスメソッドインターセプタ―: `@AroundInvoke`"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:223
msgid "Interceptors for lifecycle event callbacks: `@PostConstruct`, `@PreDestroy`, `@AroundConstruct`"
msgstr "ライフサイクルイベントコールバックのためのインターセプター: `@PostConstruct`、`@PreDestroy`、`@AroundConstruct`"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:224
msgid "Decorators"
msgstr "デコレーター"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:225
msgid "Events and observer methods, including asynchronous events and transactional observer methods"
msgstr "非同期イベントとトランザクションオブザーバーメソッドを含むイベントとオブザーバーメソッド"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:227
#: upstream/_guides/cdi-reference.adoc:737
#, no-wrap
msgid "Limitations"
msgstr "制約事項"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:230
msgid "`@ConversationScoped` is not supported"
msgstr "`@ConversationScoped` はサポートされていません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:231
msgid "Portable Extensions are not supported"
msgstr "ポータブル・エクステンションはサポートされていません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:232
msgid "`BeanManager` - only the following methods are implemented: `getBeans()`, `createCreationalContext()`, `getReference()`, `getInjectableReference()` , `resolve()`, `getContext()`, `fireEvent()`, `getEvent()` and `createInstance()`"
msgstr "`BeanManager` - メソッドでは、`getBeans()`、`createCreationalContext()`、`getReference()`、`getInjectableReference()`、`resolve()`、`getContext()`、`fireEvent()`、`getEvent()`、および `createInstance()` のみが実装されています。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:233
msgid "Specialization is not supported"
msgstr "特殊化（Specialization）はサポートされていません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:234
msgid "`beans.xml` descriptor content is ignored"
msgstr "`beans.xml` 記述子の内容は無視されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:235
msgid "Passivation and passivating scopes are not supported"
msgstr "パッシベーションおよびパッシベーションスコープはサポートされていません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:236
msgid "Interceptor methods on superclasses are not implemented yet"
msgstr "スーパークラスのインターセプターメソッドは実装されていません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:237
msgid "`@Interceptors` is not supported"
msgstr "`@Interceptors` はサポートされていません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:238
msgid "Decoration of built-in beans, such as `Event`, is not supported"
msgstr "`Event` などのビルトイン Bean の装飾はサポートされていません"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:240
#, no-wrap
msgid "Non-standard Features"
msgstr "標準外の機能"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:242
#, no-wrap
msgid "Eager Instantiation of Beans"
msgstr "Bean の即時インスタンス化"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:245
#, no-wrap
msgid "Lazy By Default"
msgstr "デフォルトでは遅延"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:249
msgid "By default, CDI beans are created lazily, when needed.  What exactly \"needed\" means depends on the scope of a bean."
msgstr "デフォルトでは、CDI Bean は必要なときに作成されます。何が正に「必要とされる」かは、Bean のスコープに依存します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:251
msgid "A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification)."
msgstr "注入されたインスタンス (仕様に応じたコンテキスト参照) からメソッドが呼び出される場合は、*通常のスコープ付き Bean* (`@ApplicationScoped`、`@RequestScoped` など) が必要になります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:253
msgid "In other words, injecting a normal scoped bean will not suffice because a _client proxy_ is injected instead of a contextual instance of the bean."
msgstr "言い換えれば、通常のスコープ付き Bean を注入しても、Bean のコンテキストに基づいたインスタンスの代わりに _クライアントプロキシー_ が注入されるため、十分ではありません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:255
msgid "A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created when injected."
msgstr "注入時に *疑似スコープを持つ Bean* (`@Dependent` および `@Singleton`) が作成されます。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:256
#, no-wrap
msgid "Lazy Instantiation Example"
msgstr "遅延インスタンス化の例"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:265
#, no-wrap
msgid ""
"@Singleton // => pseudo-scope\n"
"class AmazingService {\n"
"  String ping() {\n"
"    return \"amazing\";\n"
"  }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:272
#, no-wrap
msgid ""
"@ApplicationScoped // => normal scope\n"
"class CoolService {\n"
"  String ping() {\n"
"    return \"cool\";\n"
"  }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:275
#, no-wrap
msgid ""
"@Path(\"/ping\")\n"
"public class PingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:278
#, no-wrap
msgid ""
"  @Inject\n"
"  AmazingService s1; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:281
#, no-wrap
msgid ""
"  @Inject\n"
"  CoolService s2; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:287
#, no-wrap
msgid ""
"  @GET\n"
"  public String ping() {\n"
"    return s1.ping() + s2.ping(); <3>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:289
msgid "Injection triggers the instantiation of `AmazingService`."
msgstr "注入は、`AmazingService` のインスタンス化をトリガーします。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:290
msgid "Injection itself does not result in the instantiation of `CoolService`. A client proxy is injected."
msgstr "注入自体は、`CoolService` のインスタンス化にはなりません。クライアントプロキシーが注入されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:291
msgid "The first invocation upon the injected proxy triggers the instantiation of `CoolService`."
msgstr "注入されたプロキシーに対する最初の呼び出しは、`CoolService` のインスタンス化をトリガーします。"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:293
#, no-wrap
msgid "Startup Event"
msgstr "スタートアップイベント"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:296
msgid "However, if you really need to instantiate a bean eagerly you can:"
msgstr "ただし、Bean の即時(eagerly)インスタンス化が必要な場合は、次のことができます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:298
msgid "Declare an observer of the `StartupEvent` - the scope of the bean does not matter in this case:"
msgstr "`StartupEvent` のオブザーバーを宣言します。この場合、Bean のスコープは重要ではありません。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:306
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class CoolService {\n"
"  void startup(@Observes StartupEvent event) { <1>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:308
msgid "A `CoolService` is created during startup to service the observer method invocation."
msgstr "`CoolService` は、起動時に作成され、オブザーバーメソッドの呼び出しを処理します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:310
#, fuzzy
msgid "Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in xref:lazy_by_default[Lazy By Default]:"
msgstr "`StartupEvent` のオブザーバでBeanを使用する。通常のスコープ付きBeanは， xref:lazy_by_default[Lazy By Defaultで] 説明するように使用する必要がある："

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:315
#, no-wrap
msgid ""
"@Dependent\n"
"class MyBeanStarter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:320
#, no-wrap
msgid ""
"  void startup(@Observes StartupEvent event, AmazingService amazing, CoolService cool) { <1>\n"
"    cool.toString(); <2>\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:322
msgid "The `AmazingService` is created during injection."
msgstr "`AmazingService` は注入時に作成されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:323
msgid "The `CoolService` is a normal scoped bean, so we have to invoke a method upon the injected proxy to force the instantiation."
msgstr "`CoolService` は通常のスコープ付き Bean であるため、強制的にインスタンス化するために挿入されたプロキシーにメソッドを呼び出さなければなりません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:325
msgid "Annotate the bean with `@io.quarkus.runtime.Startup` as described in xref:lifecycle.adoc#startup_annotation[Startup annotation]:"
msgstr "xref:lifecycle.adoc#startup_annotation[Startup annotation]: で説明したように、`@io.quarkus.runtime.Startup` で Bean をアノテーションします。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:331
#, no-wrap
msgid ""
"@Startup // <1>\n"
"@ApplicationScoped\n"
"public class EagerAppBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:333
#, no-wrap
msgid "   private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:338
#, no-wrap
msgid ""
"   EagerAppBean(NameGenerator generator) { // <2>\n"
"     this.name = generator.createName();\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:340
msgid "For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used."
msgstr "`@Startup` でアノテーションされた各Beanに対して、 `StartupEvent` の合成オブザーバが生成されます。デフォルトの優先度が使用されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:341
msgid "The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context."
msgstr "Beanのコンストラクタは、アプリケーションの起動時に呼び出され、結果として得られるコンテキストインスタンスがアプリケーションのコンテキストに格納されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:343
msgid "Quarkus users are encouraged to always prefer the `@Observes StartupEvent` to `@Initialized(ApplicationScoped.class)` as explained in the xref:lifecycle.adoc[Application Initialization and Termination] guide."
msgstr "Quarkus ユーザーは、 xref:lifecycle.adoc[アプリケーションの初期化と終了] のガイドで説明されているように、常に `@Initialized(ApplicationScoped.class)` よりも `@Observes StartupEvent` を選択することが推奨されます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:344
#, no-wrap
msgid "Request Context Lifecycle"
msgstr "リクエストコンテキストのライフサイクル"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:347
msgid "The request context is also active:"
msgstr "リクエストコンテキストは次の場合もアクティブになっています:"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:349
msgid "during notification of a synchronous observer method."
msgstr "同期オブザーバメソッドの通知中"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:351
msgid "The request context is destroyed:"
msgstr "リクエストコンテキストは破棄されます:"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:353
msgid "after the observer notification completes for an event, if it was not already active when the notification started."
msgstr "通知が開始したときにまだアクティブではなかった場合はイベントのオブザーバー通知が完了した後"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:355
msgid "An event with qualifier `@Initialized(RequestScoped.class)` is fired when the request context is initialized for an observer notification. Moreover, the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and `@Destroyed(RequestScoped.class)` are fired when the request context is destroyed."
msgstr "オブザーバー通知のためにリクエストコンテキストが初期化されると、修飾子 `@Initialized(RequestScoped.class)` を持つイベントが発生します。さらに、修飾子 `@BeforeDestroyed(RequestScoped.class)` および `@Destroyed(RequestScoped.class)` を持つイベントは、リクエストコンテキストが破棄されたときに発生します。"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:356
#, no-wrap
msgid "How to Enable Trace Logging for Request Context Activation"
msgstr "リクエストコンテキストのアクティブ化のトレースログを有効にする方法"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:359
msgid "You can set the `TRACE` level for the logger `io.quarkus.arc.requestContext` and try to analyze the log output afterwards."
msgstr "ロガー `io.quarkus.arc.requestContext` の `TRACE` レベルを設定し、後でログ出力の分析を試みることができます。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:360
#, no-wrap
msgid "`application.properties` Example"
msgstr "`application.properties` の例"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:365
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.arc.requestContext\".min-level=TRACE <1>\n"
"quarkus.log.category.\"io.quarkus.arc.requestContext\".level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:367
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "また、関連するカテゴリーの最小ログレベルを調整する必要があります。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:368
#, no-wrap
msgid "Qualified Injected Fields"
msgstr "修飾された注入フィールド"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:371
msgid "In CDI, if you declare a field injection point you need to use `@Inject` and optionally a set of qualifiers."
msgstr "CDI では、フィールド注入ポイントを宣言する場合は `@Inject` と任意で修飾子のセットを使用する必要があります。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:377
#: upstream/_guides/cdi-reference.adoc:690
#, no-wrap
msgid ""
"  @Inject\n"
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:380
msgid "In Quarkus, you can skip the `@Inject` annotation completely if the injected field declares at least one qualifier."
msgstr "Quarkus では、注入されたフィールドが少なくとも 1 つの修飾子を宣言している場合は、`@Inject` アノテーションを完全にスキップすることができます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:385
#: upstream/_guides/cdi-reference.adoc:707
#, no-wrap
msgid ""
"  @ConfigProperty(name = \"cool\")\n"
"  String coolProperty;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:388
msgid "With the notable exception of one special case discussed below, `@Inject` is still required for constructor and method injection."
msgstr "後述する特別なケースを除いて、コンストラクターとメソッドの注入には `@Inject` が必要です。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:389
#, no-wrap
msgid "Simplified Constructor Injection"
msgstr "簡略化されたコンストラクター注入"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:393
msgid "In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).  However, this requirement complicates constructor injection - you need to provide a dummy no-args constructor to make things work in CDI."
msgstr "CDI では、通常のスコープ付き Bean は常に no-args コンストラクターを宣言しなければなりません (このコンストラクターは、他のコンストラクターを宣言しない限り、通常はコンパイラーによって生成されます)。しかし、この要件はコンストラクター注入を複雑にします。CDI で動作させるためにはダミーの 変数無しのコンストラクターを提供する必要があります。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:398
#: upstream/_guides/cdi-reference.adoc:418
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyCoolService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:400
#: upstream/_guides/cdi-reference.adoc:420
#, no-wrap
msgid "  private SimpleProcessor processor;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:403
#, no-wrap
msgid ""
"  MyCoolService() { // dummy constructor needed\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:409
#, no-wrap
msgid ""
"  @Inject // constructor injection\n"
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:413
msgid "There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.  Also, if there's only one constructor there is no need for `@Inject`."
msgstr "Quarkus では、通常のスコープ付き Bean のためにダミーのコンストラクターを宣言する必要はありません。自動的に生成されます。また、コンストラクターが 1 つしかない場合は、`@Inject` の必要性はありません。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:425
#, no-wrap
msgid ""
"  MyCoolService(SimpleProcessor processor) {\n"
"    this.processor = processor;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:428
msgid "We don't generate a no-args constructor automatically if a bean class extends a class that does not declare a no-args constructor."
msgstr "変数無しコンストラクターを宣言していないクラスを Bean クラスが継承している場合は、変数無しコンストラクターは自動的に生成されません。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:430
#, no-wrap
msgid "Removing Unused Beans"
msgstr "未使用の Bean の削除"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:438
#, fuzzy
msgid "The container attempts to remove all unused beans, interceptors and decorators during build by default.  This optimization helps to minimize the amount of generated classes, thus conserving memory.  However, Quarkus can't detect the programmatic lookup performed via the `CDI.current()` static method.  Therefore, it is possible that a removal results in a false positive error, i.e. a bean is removed although it's actually used.  In such cases, you'll notice a big warning in the log.  Users and extension authors have several options xref:eliminate_false_positives[how to eliminate false positives]."
msgstr "コンテナは、デフォルトでビルド時に未使用のビーン、インターセプター、デコレーターをすべて削除しようとします。この最適化により、生成されるクラスの量を最小限に抑えることができるため、メモリを節約することができます。ただし、Quarkusでは、 `CDI.current()` の静的メソッドを介して実行されるプログラムによるルックアップを検出することはできません。つまり、実際には使用されているにもかかわらず、Beanが削除される可能性があります。このような場合、ログに大きな警告が表示されます。ユーザーと拡張機能の作者には、 xref:eliminate_false_positives[誤検出をなくす] ためのいくつかの選択肢があります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:442
msgid "The optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`.  Quarkus also provides a middle ground where application beans are never removed whether or not they are unused, while the optimization proceeds normally for non application classes.  To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or `framework`."
msgstr "この最適化は、`quarkus.arc.remove-unused-beans` を `none` または `false` に設定することで無効にすることができます。Quarkus では、アプリケーションの Bean は未使用かどうかにかかわらず削除されず、アプリケーション以外のクラスは通常通りに最適化が行われるという中間モードも提供されています。このモードを使用するには、`quarkus.arc.remove-unused-beans` を `fwk` または `framework` に設定します。"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:443
#, no-wrap
msgid "What's Removed?"
msgstr "何が削除されましたか?"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:447
#, fuzzy
msgid "Quarkus first identifies so-called _unremovable_ beans that form the roots in the dependency tree.  A good example is a Jakarta REST resource class or a bean which declares a `@Scheduled` method."
msgstr "Quarkusはまず、依存関係ツリーの根を形成する、いわゆる _削除不可能な_ Beanを特定します。良い例としては、Jakarta RESTリソースクラスや、 `@Scheduled` メソッドを宣言するビーンが挙げられます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:449
msgid "An _unremovable_ bean:"
msgstr "_unremovable_ Bean:"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:451
msgid "is excluded from removal by an extension, or"
msgstr "エクステンションによる削除から除外されている、または"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:452
msgid "has a name designated via `@Named`, or"
msgstr "`@Named` を通して指定された名前を持っているか、"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:453
msgid "declares an observer method."
msgstr "オブザーバーメソッドを宣言している場合。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:455
msgid "An _unused_ bean:"
msgstr "_unused_ Bean:"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:457
msgid "is not _unremovable_, and"
msgstr "_unremovable_ ではなく、"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:458
msgid "is not eligible for injection to any injection point in the dependency tree, and"
msgstr "依存関係ツリーの挿入ポイントへの挿入に適格ではなく、"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:459
msgid "does not declare any producer which is eligible for injection to any injection point in the dependency tree, and"
msgstr "依存関係ツリー内の挿入ポイントへの挿入に適格なプロデューサーを宣言していません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:460
#, fuzzy
msgid "is not eligible for injection into any `jakarta.enterprise.inject.Instance` or `jakarta.inject.Provider` injection point."
msgstr "は、 `jakarta.enterprise.inject.Instance` または `jakarta.inject.Provider` の注入口への注入は対象外です。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:462
msgid "Unused interceptors and decorators are not associated with any bean."
msgstr "未使用のインターセプターとデコレーターは、どの Bean とも関連付けられていません。"

#. type: delimited block =
#: upstream/_guides/cdi-reference.adoc:466
msgid "When using the dev mode (running `./mvnw clean compile quarkus:dev`), you can see more information about which beans are being removed:"
msgstr "開発モードを使用している場合（例: `./mvnw clean compile quarkus:dev` を実行している場合）、どの Bean が削除されているかの詳細な情報を見ることができます。"

#. type: delimited block =
#: upstream/_guides/cdi-reference.adoc:468
msgid "In the console - just enable the DEBUG level in your `application.properties`, i.e. `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG`"
msgstr "コンソールで - `application.properties` で DEBUG レベルを有効にするだけです。例:　`quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG`"

#. type: delimited block =
#: upstream/_guides/cdi-reference.adoc:469
msgid "In the relevant Dev UI page"
msgstr "関連する開発 UI ページ"

#. type: Title ====
#: upstream/_guides/cdi-reference.adoc:472
#, no-wrap
msgid "How To Eliminate False Positives"
msgstr "誤検知を排除する方法"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:476
msgid "Users can instruct the container to not remove any of their specific beans (even if they satisfy all the rules specified above) by annotating them with `@io.quarkus.arc.Unremovable`.  This annotation can be declared on a class, a producer method or field."
msgstr "ユーザーは、コンテナーに `@io.quarkus.arc.Unremovable` をアノテーションすることで、(上で指定したルールをすべて満たしていても) 特定の Bean を削除しないように指示することができます。このアノテーションは、クラス、producer メソッド、producer フィールドに置くことができます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:479
msgid "Since this is not always possible, there is an option to achieve the same via `application.properties`.  The `quarkus.arc.unremovable-types` property accepts a list of string values that are used to match beans based on their name or package."
msgstr "これは常に可能ではないので、`application.properties` を通して同じことを実現するオプションがあります。`quarkus.arc.unremovable-types` プロパティーは、Bean の名前やパッケージに基づいて一致させるための文字列値のリストを受け付けます。"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:484
#, no-wrap
msgid "Match the fully qualified name of the bean class"
msgstr "bean クラスの完全修飾名と一致させる"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:485
#: upstream/_guides/cdi-reference.adoc:669
#, no-wrap
msgid "Match beans where the package of the bean class is `org.acme`"
msgstr "Bean クラスのパッケージが `org.acme` である Bean に一致します。"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:486
#: upstream/_guides/cdi-reference.adoc:670
#, no-wrap
msgid "Match beans where the package of the bean class starts with `org.acme`"
msgstr "Bean クラスのパッケージが `org.acme` で開始する Bean に一致します。"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:487
#, no-wrap
msgid "Match the simple name of the bean class"
msgstr "Bean クラスのシンプルな名前に一致します。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:493
#, no-wrap
msgid "quarkus.arc.unremovable-types=org.acme.Foo,org.acme.*,Bar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:496
msgid "Furthermore, extensions can eliminate false positives by producing an `UnremovableBeanBuildItem`."
msgstr "さらに、エクステンションは `UnremovableBeanBuildItem` を生成することで、可能性のある誤検出を排除することができます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:498
#, no-wrap
msgid "Default Beans"
msgstr "デフォルトの Bean"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:502
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally declare a bean if no other bean with equal types and qualifiers was declared by any available means (bean class, producer, synthetic bean, ...)  This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best explained with an example."
msgstr "Quarkus は、CDI が現在サポートしていない機能を追加します。これは、利用可能な手段 (Beanクラス、producer、合成 Bean など) で同等の型と修飾子を持つ他の Bean が宣言されていない場合に、条件付きで Bean を宣言することです。これは、`@io .quarkus.Arc.DefaultBean` アノテーションを使用して行われ、例を挙げて説明するのが最善です。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:504
msgid "Say there is a Quarkus extension that among other things declares a few CDI beans like the following code does:"
msgstr "以下のコードのようにいくつかの CDI Bean を宣言する Quarkus エクステンションがあるとします。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:509
#: upstream/_guides/cdi-reference.adoc:563
#: upstream/_guides/cdi-reference.adoc:584
#: upstream/_guides/cdi-reference.adoc:614
#: upstream/_guides/cdi-reference.adoc:637
#, no-wrap
msgid ""
"@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:514
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:520
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:527
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:532
msgid "The idea is that the extension autoconfigures things for the user, eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever it is needed.  Now imagine that in our application we would like to utilize the configured `Tracer`, but we need to customize it a little, for example by providing a custom `Reporter`.  The only thing that would be needed in our application would be something like the following:"
msgstr "アイデアは、エクステンションがユーザーのために自動設定を行い、多くのボイラープレートを排除するということです。必要な場所であれば、`@Inject` を `Tracer` にすることができます。私たちのアプリケーションで、設定された `Tracer` を利用しようとする場合は、、カスタムの `Reporter` を提供するなど、少しカスタマイズする必要があります。アプリケーションで必要になるのは、次のようなものだけです。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:538
#, no-wrap
msgid ""
"@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:544
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:548
msgid "`@DefaultBean` allows extensions (or any other code for that matter) to provide defaults while backing off if beans of that type are supplied in any way Quarkus supports."
msgstr "`@DefaultBean` では、エクステンション (またはそのための他のコード) が Quarkus がサポートする何らかの方法でその型の Bean が提供されている場合、バックオフ中にデフォルトを提供することができます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:550
#, no-wrap
msgid "Enabling Beans for Quarkus Build Profile"
msgstr "Quarkus ビルドプロファイルの Bean の有効化"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:555
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time profile is enabled, via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build profiles."
msgstr "Quarkus は、CDI が現在サポートしていない機能を追加しました。これは、Quarkus のビルドタイムプロファイルが有効になっているときに条件付きで Bean を有効にするというもので、`@io.quarkus.arc.profile.IfBuildProfile` と `@io.quarkus.arc.profile.UnlessBuildProfile` のアノテーションを使用します。`@io.quarkus.arc.DefaultBean` と合わせて使用すると、これらのアノテーションにより、異なるビルドプロファイルに対して異なる Bean 構成を作成することができます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:558
msgid "Imagine for instance that an application contains a bean named `Tracer`, which needs to do nothing when in tests or in dev mode, but works in its normal capacity for the production artifact.  An elegant way to create such beans is the following:"
msgstr "たとえば、アプリケーションが `Tracer` という名前の Bean を含んでいるとします。この Bean は、テストや開発モードでは何もする必要はありませんが、本番の成果物に対しては通常の能力で動作します。このような Bean を作成する洗練された方法は以下の通りです。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:569
#, no-wrap
msgid ""
"    @Produces\n"
"    @IfBuildProfile(\"prod\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:576
#: upstream/_guides/cdi-reference.adoc:597
#: upstream/_guides/cdi-reference.adoc:627
#: upstream/_guides/cdi-reference.adoc:650
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Tracer noopTracer() {\n"
"        return new NoopTracer();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:579
msgid "If instead, it is required that the `Tracer` bean also works in dev mode and only default to doing nothing for tests, then `@UnlessBuildProfile` would be ideal. The code would look like:"
msgstr "代わりに、`Tracer` Bean も開発モードで動作し、デフォルトではテストのために何もしないことが要求される場合は、`@UnlessBuildProfile` が理想的です。コードは次のようになります。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:590
#, no-wrap
msgid ""
"    @Produces\n"
"    @UnlessBuildProfile(\"test\") // this will be enabled for both prod and dev build time profiles\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:600
msgid "The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`."
msgstr "ランタイムプロファイルは、`@IfBuildProfile` および `@UnlessBuildProfile` を使用した Bean 解決には影響を及ぼしません。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:602
#, no-wrap
msgid "Enabling Beans for Quarkus Build Properties"
msgstr "Quarkus ビルドプロパティーの Bean を有効にする"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:607
msgid "Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time property has/has not a specific value, via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc.properties.UnlessBuildProperty` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, this annotation allow for the creation of different bean configurations for different build properties."
msgstr "Quarkus には、CDI が現在サポートしていない機能が追加されています。それは、`@io.quarkus.arc.properties.IfBuildProperty` と `@io.quarkus.arc.properties.UnlessBuildProperty` アノテーションを使用して、ビルドタイムプロパティーが特定の値であるかないときにBeanを条件付きで有効にするものです。このアノテーションを `@io.quarkus.arc.DefaultBean` と一緒に使用すると、ビルドプロパティーごとに異なるBean設定を作成することが可能になります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:609
msgid "The scenario we mentioned above with `Tracer` could also be implemented in the following way:"
msgstr "`Tracer` を使用して上で述べたシナリオも、以下のように実装することができます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:620
#, no-wrap
msgid ""
"    @Produces\n"
"    @IfBuildProperty(name = \"some.tracer.enabled\", stringValue = \"true\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:630
msgid "`@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations, i.e. a bean will only be enabled if **all** the conditions defined by these annotations are satisfied."
msgstr "`@IfBuildProperty` と `@UnlessBuildProperty` は繰り返し可能なアノテーションです。つまり、これらのアノテーションで定義された条件の **すべて** が満たされた場合にのみBeanが有効になります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:632
msgid "If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:"
msgstr "代わりに、`some.tracer.enabled` プロパティーが `false` でない場合にのみ `RealTracer` Bean が使用されることが要求される場合は、`@UnlessBuildProperty` が理想的です。コードは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:643
#, no-wrap
msgid ""
"    @Produces\n"
"    @UnlessBuildProperty(name = \"some.tracer.enabled\", stringValue = \"false\")\n"
"    public Tracer realTracer(Reporter reporter, Configuration configuration) {\n"
"        return new RealTracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:653
msgid "Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`."
msgstr "実行時に設定されたプロパティーは、 `@IfBuildProperty` を使用しても Bean の解決に全く影響しません。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:654
#, no-wrap
msgid "Declaring Selected Alternatives"
msgstr "選択された代替の宣言"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:658
msgid "In CDI, an alternative bean may be selected either globally for an application by means of `@Priority`, or for a bean archive using a `beans.xml` descriptor.  Quarkus has a simplified bean discovery and the content of `beans.xml` is ignored."
msgstr "CDI では、代替の Bean は、`@Priority` を使用してアプリケーションに対してグローバルに選択することも、`beans.xml` 記述子を使用した Bean アーカイブ用に選択することもできます。Quarkus には単純化された Bean 検出があり、 `beans.xml` の内容は無視されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:663
#, fuzzy
msgid "However, it is also possible to select alternatives for an application using the unified configuration.  The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.  If any value matches then the priority of `Integer#MAX_VALUE` is used for the relevant bean.  The priority declared via `@Priority` or inherited from a stereotype is overridden."
msgstr "しかし、統一構成を使用してアプリケーションの代替を選択することも可能である。 `quarkus.arc.selected-alternatives` プロパティは，代替ビーンにマッチするために使用される文字列値のリストを受け入れる。いずれかの値がマッチする場合， `Integer#MAX_VALUE` の優先順位が関連するビーンに使用される。 `@Priority` で宣言された優先度や、ステレオタイプから継承された優先度は上書きされる。"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:668
#, no-wrap
msgid "Match the fully qualified name of the bean class or the bean class of the bean that declares the producer"
msgstr "Bean クラス、または producer を宣言する Bean の Bean クラスの完全修飾名に一致します。"

#. type: Table
#: upstream/_guides/cdi-reference.adoc:671
#, no-wrap
msgid "Match the simple name of the bean class or the bean class of the bean that declares the producer"
msgstr "Bean クラス、または producer を宣言する Bean の Bean クラスの単純名に一致します。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:677
#, no-wrap
msgid "quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:679
#, no-wrap
msgid "Simplified Producer Method Declaration"
msgstr "簡略化された Producer メソッドの宣言"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:682
msgid "In CDI, a producer method must be always annotated with `@Produces`."
msgstr "CDI では、producer メソッドは常に `@Produces` とアノテーションされていなければなりません。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:686
#: upstream/_guides/cdi-reference.adoc:704
#, no-wrap
msgid "class Producers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:697
#, no-wrap
msgid ""
"  @Produces\n"
"  @ApplicationScoped\n"
"  MyService produceService() {\n"
"    return new MyService(coolProperty);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:700
msgid "In Quarkus, you can skip the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier."
msgstr "Quarkus では、producer メソッドにスコープアノテーション、ステレオタイプ、または修飾子が付いている場合は、`@Produces` アノテーションを完全に省略できます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:713
#, no-wrap
msgid ""
"  @ApplicationScoped\n"
"  MyService produceService() {\n"
"    return new MyService(coolProperty);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:715
#, no-wrap
msgid "Interception of Static Methods"
msgstr "静的メソッドのインターセプション"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:721
msgid "The Interceptors specification is clear that _around-invoke_ methods must not be declared static.  However, this restriction was driven mostly by technical limitations.  And since Quarkus is a build-time oriented stack that allows for additional class transformations, those limitations don't apply anymore.  It's possible to annotate a non-private static method with an interceptor binding:"
msgstr "インターセプターの仕様は、_around-invoke_ メソッドをStatic宣言してはならないことは明らかです。しかし、この制限は、主に技術的な制限によって設定されました。Quarkus は追加のクラス変換を可能にするビルド時指向のスタックであるため、この制限は適用されなくなりました。インターセプタ―バインディングで非プライベートのStaticメソッドにアノテーションを付けることができます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:725
#, no-wrap
msgid "class Services {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:733
#, no-wrap
msgid ""
"  @Logged <1>\n"
"  static BigDecimal computePrice(long amount) { <2>\n"
"    BigDecimal price;\n"
"    // Perform computations...\n"
"    return price;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:735
msgid "`Logged` is an interceptor binding."
msgstr "`Logged` はインターセプターバインディングです。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:736
msgid "Each method invocation is intercepted if there is an interceptor associated with `Logged`."
msgstr "各メソッドの呼び出しは、`Logged` に関連付けられたインターセプターがある場合に傍受されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:740
msgid "Only *method-level bindings* are considered for backward compatibility reasons (otherwise static methods of bean classes that declare class-level bindings would be suddenly intercepted)"
msgstr "下位互換性の理由から *メソッドレベルのバインディング* のみが考慮されます (そうでないとクラスレベルのバインディングを宣言している Bean クラスのStaticメソッドが突然傍受されてしまいます)。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:741
msgid "Private static methods are never intercepted"
msgstr "プライベートなスタティックメソッドは決して傍受されません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:742
msgid "`InvocationContext#getTarget()` returns `null` for obvious reasons; therefore not all existing interceptors may behave correctly when intercepting static methods"
msgstr "`InvocationContext#getTarget()` は明白な理由により `null` を返します。したがって、Staticメソッドを傍受するときに既存のインターセプターがすべて正しく動作するとは限りません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:744
msgid "Interceptors can use `InvocationContext.getMethod()` to detect static methods and adjust the behavior accordingly."
msgstr "インターセプターは `InvocationContext.getMethod()` を使用してStaticメソッドを検出し、それに応じて動作を調整することができます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:746
#, no-wrap
msgid "Ability to handle 'final' classes and methods"
msgstr "final クラスとメソッドを処理する能力"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:751
msgid "In normal CDI, classes that are marked as `final` and / or have `final` methods are not eligible for proxy creation, which in turn means that interceptors and normal scoped beans don't work properly.  This situation is very common when trying to use CDI with alternative JVM languages like Kotlin where classes and methods are `final` by default."
msgstr "通常の CDI では、 `final` としてマークされているクラス、または `final` メソッドを持つクラスは、プロキシー作成の対象になりません。これは、インターセプターと通常のスコープ Bean が正しく動作しないことを意味します。このような状況は、クラスおよびメソッドがデフォルトで `final`である Kotlin のような代替 JVM 言語で CDI を使用しようとするときに非常に一般的です。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:753
msgid "Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value)."
msgstr "しかし、Quarkus では、`quarkus.arc.transform-unproxyable-classes` を `true` (デフォルト値) に設定すると、これらの制限を抑制することができます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:754
#, no-wrap
msgid "Container-managed Concurrency"
msgstr "コンテナー管理型の並行処理"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:762
msgid "There is no standard concurrency control mechanism for CDI beans.  Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.  In that case it should be thread-safe.  You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access.  Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this interceptor binding.  Each interceptor instance associated with a contextual instance of an intercepted bean holds a separate `ReadWriteLock` with non-fair ordering policy."
msgstr "CDI Bean の標準的な同時実行制御メカニズムはありません。それにもかかわらず、Bean インスタンスは、複数のスレッドから同時に共有およびアクセスすることができます。その場合は、スレッドセーフでなければなりません。標準の Java コンストラクト (`volatile`、`synchronized`、`ReadWriteLock` など) を使用するか、コンテナーに同時アクセスを制御させることができます。Quarkus は、`@io.quarkus.arc.Lock` と、このインターセプタ―バインディング用の組み込みインターセプターを提供します。傍受された Bean のコンテキストに基づいたインスタンスに関連付けられた各インターセプターインスタンスは、公平でない順序付けポリシーを持つ `ReadWriteLock` を保持しています。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:764
msgid "`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for \"shared\" scopes, e.g. `@Singleton` and `@ApplicationScoped`."
msgstr "`io.quarkus.arc.Lock` は通常のインターセプターバインディングであるため、任意のスコープを持つ任意の Bean に使用することができます。しかし、特に「共有」スコープ、たとえば `@Singleton` や `@ApplicationScoped` に有益です。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:765
#, no-wrap
msgid "Container-managed Concurrency Example"
msgstr "コンテナー管理された並行処理の例"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:769
#, no-wrap
msgid "import io.quarkus.arc.Lock;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:773
#, no-wrap
msgid ""
"@Lock <1>\n"
"@ApplicationScoped\n"
"class SharedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:777
#, no-wrap
msgid ""
"  void addAmount(BigDecimal amount) {\n"
"    // ...changes some internal state of the bean\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:783
#, no-wrap
msgid ""
"  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) <2> <3>\n"
"  BigDecimal getAmount() {\n"
"    // ...it is safe to read the value concurrently\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:785
msgid "`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has \"exclusive access\" and no concurrent invocations will be allowed."
msgstr "クラスで宣言された (`@Lock (Lock.type.Write)` にマッピングされる) `@Lock` は、任意のビジネスメソッドの呼び出しに対して Bean インスタンスをロックするようにコンテナーに指示します。つまり、クライアントには「排他アクセス」があり、同時呼び出しは許可されません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:786
msgid "`@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`."
msgstr "`@Lock(Lock.Type.READ)` は、クラスレベルで指定された値を上書きします。これは、Bean のインスタンスが `@Lock(Lock.Type.WRITE)` によってロックされていない限り、任意の数のクライアントが同時にメソッドを呼び出すことができることを意味します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:787
msgid "You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown."
msgstr "また、「待ち時間」を指定することもできます。指定した時間内にロックを取得できない場合は `LockException` が発生します。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:788
#, no-wrap
msgid "Repeatable interceptor bindings"
msgstr "反復可能なインターセプターバインディング"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:791
msgid "Quarkus has limited support for `@Repeatable` interceptor binding annotations."
msgstr "Quarkusでは、`@Repeatable` インターセプター結合アノテーションのサポートが制限されています。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:795
msgid "When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.  Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.  This might be added in the future."
msgstr "インターセプタ―をコンポーネントにバインドする場合は、メソッドに対して複数の `@Repeatable` アノテーションを宣言できます。インターセプター仕様との相互作用に関する未解決の問題があるため、クラスとステレオタイプで宣言された反復可能なインターセプターバインディングはサポートされていません。これは将来追加される可能性があります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:799
msgid "As an example, suppose we have an interceptor that clears a cache.  The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.  If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:"
msgstr "たとえば、キャッシュをクリアするインターセプタ―があるとします。対応するインターセプタ―バインディングは `@CacheInvalidateAll` と呼ばれ、`@Repeatable` として宣言されます。同時に 2 つのキャッシュをクリアしたい場合は、`@CacheInvalidateAll` を 2 回追加します。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:813
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class CachingService {\n"
"  @CacheInvalidateAll(cacheName = \"foo\")\n"
"  @CacheInvalidateAll(cacheName = \"bar\")\n"
"  void heavyComputation() {\n"
"    // ...\n"
"    // some computation that updates a lot of data\n"
"    // and requires 2 caches to be invalidated\n"
"    // ...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:817
msgid "This is how interceptors are used.  What about creating an interceptor?"
msgstr "ここまで、インターセプタ―がどのように使用されるかを説明しました。では、インターセプターを作成するにはどうすれば良いでしょうか。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:820
msgid "When declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.  This is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise."
msgstr "インターセプタ―のインターセプタ―バインディングを宣言する場合は、通常どおり、インターセプタ―クラスに複数の `@Repeatable` アノテーションを追加できます。`@Cached` アノテーションの場合と同様に、アノテーションメンバーが `@Nonbinding` の場合は役に立ちませんが、それ以外の場合は重要になります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:824
msgid "For example, suppose we have an interceptor that can automatically log method invocations to certain targets.  The interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.  Our implementation could be restricted to console logging and file logging:"
msgstr "たとえば、メソッド呼び出しを特定のターゲットに自動的に記録できるインターセプタ―があるとします。インターセプタ―バインディングアノテーション `@Logged` には、ログを保存する場所を指定する `target` というメンバーがあります。この実装は、コンソールログとファイルロギングに制限することができます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:833
#, no-wrap
msgid ""
"@Interceptor\n"
"@Logged(target = \"console\")\n"
"@Logged(target = \"file\")\n"
"class NaiveLoggingInterceptor {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:836
msgid "Other interceptors could be provided to log method invocations to different targets."
msgstr "他にも、異なるターゲットへのメソッド呼び出しをログに記録するためのインターセプターを提供することができます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:837
#, no-wrap
msgid "Caching the Result of Programmatic Lookup"
msgstr "プログラムによるルックアップの結果をキャッシュする"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:847
#, fuzzy
msgid "In certain situations, it is practical to obtain a bean instance programmatically via an injected `jakarta.enterprise.inject.Instance` and `Instance.get()`.  However, according to the specification the `get()` method must identify the matching bean and obtain a contextual reference.  As a consequence, a new instance of a `@Dependent` bean is returned from each invocation of `get()`.  Moreover, this instance is a dependent object of the injected `Instance`.  This behavior is well-defined, but it may lead to unexpected errors and memory leaks.  Therefore, Quarkus comes with the `io.quarkus.arc.WithCaching` annotation.  An injected `Instance` annotated with this annotation will cache the result of the `Instance#get()` operation.  The result is computed on the first call and the same value is returned for all subsequent calls, even for `@Dependent` beans."
msgstr "ある状況では，注入された `jakarta.enterprise.inject.Instance` 及び `Instance.get()` を介して，プログラム的にBeanインスタンスを得ることが現実的である。 しかし，仕様によれば， `get()` メソッドは，一致するBeanを識別し，文脈参照を得なければならない。結果として， `get()` の各呼び出しから， `@Dependent` ビーンの新しいインスタンスが返される。 さらに，このインスタンスは，注入された `Instance` の従属オブジェクトである。この動作は明確に定義されていますが、予期せぬエラーやメモリリークにつながる可能性があります。そのため、Quarkusには、 `io.quarkus.arc.WithCaching` のアノテーションが付属しています。このアノテーションが付けられた注入された `Instance` は、 `Instance#get()` の操作の結果をキャッシュします。結果は最初の呼び出しで計算され、その後のすべての呼び出しで、 `@Dependent` Beanであっても同じ値が返されます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:851
#, no-wrap
msgid "class Producer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:854
#, no-wrap
msgid ""
"  AtomicLong nextLong = new AtomicLong();\n"
"  AtomicInteger nextInt = new AtomicInteger();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:860
#, no-wrap
msgid ""
"   @Dependent\n"
"   @Produces\n"
"   Integer produceInt() {\n"
"     return nextInt.incrementAndGet();\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:867
#, no-wrap
msgid ""
"   @Dependent\n"
"   @Produces\n"
"   Long produceLong() {\n"
"     return nextLong.incrementAndGet();\n"
"   }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:869
#, no-wrap
msgid "class Consumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:872
#, no-wrap
msgid ""
"  @Inject\n"
"  Instance<Long> longInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:876
#, no-wrap
msgid ""
"  @Inject\n"
"  @WithCaching\n"
"  Instance<Integer> intInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:882
#, no-wrap
msgid ""
"  // this method should always return true\n"
"  // Producer#produceInt() is only called once\n"
"  boolean pingInt() {\n"
"    return intInstance.get().equals(intInstance.get());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:889
#, no-wrap
msgid ""
"  // this method should always return false\n"
"  // Producer#produceLong() is called twice per each pingLong() invocation\n"
"  boolean pingLong() {\n"
"    return longInstance.get().equals(longInstance.get());\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:892
#, fuzzy
msgid "It is also possible to clear the cached value via `io.quarkus.arc.InjectableInstance.clearCache()`. In this case, you'll need to inject the Quarkus-specific `io.quarkus.arc.InjectableInstance` instead of `jakarta.enterprise.inject.Instance`."
msgstr "`io.quarkus.arc.InjectableInstance.clearCache()` を使って、キャッシュされた値をクリアすることも可能です。この場合、 `jakarta.enterprise.inject.Instance` の代わりに Quarkus 固有の `io.quarkus.arc.InjectableInstance` を注入する必要があります。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:893
#, no-wrap
msgid "Declaratively Choose Beans That Can Be Obtained by Programmatic Lookup"
msgstr "プログラムによるルックアップで取得できる Bean を宣言的に選択する"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:897
#, fuzzy
msgid "It is sometimes useful to narrow down the set of beans that can be obtained by programmatic lookup via `jakarta.enterprise.inject.Instance`.  Typically, a user needs to choose the appropriate implementation of an interface based on a runtime configuration property."
msgstr "`jakarta.enterprise.inject.Instance` を介したプログラムによる検索で取得できるビーンズの集合を絞り込むことが有用な場合がある。典型的には，利用者は，実行時構成プロパティに基づいて，インタフェースの適切な実装を選択する必要がある。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:904
msgid "Imagine that we have two beans implementing the interface `org.acme.Service`.  You can't inject the `org.acme.Service` directly unless your implementations declare a CDI qualifier.  However, you can inject the `Instance<Service>` instead, then iterate over all implementations and choose the correct one manually.  Alternatively, you can use the `@LookupIfProperty` and `@LookupUnlessProperty` annotations.  `@LookupIfProperty` indicates that a bean should only be obtained if a runtime configuration property matches the provided value.  `@LookupUnlessProperty`, on the other hand, indicates that a bean should only be obtained if a runtime configuration property does not match the provided value."
msgstr "インターフェイス `org.acme.Service` を実装した 2 つの Bean があるとします。実装が CDI 修飾子を宣言していない限り、`org.acme.Service` を直接挿入することはできません。しかし、代わりに `Instance<Service>` を挿入して、すべての実装を繰り返し、正しいものを手動で選択することができます。また、`@LookupIfProperty` と `@LookupUnlessProperty` アノテーションを利用することもできます。`@LookupIfProperty` は、実行時設定プロパティーが提供された値と一致する場合にのみ、Bean を取得する必要があることを示します。一方、`@LookupUnlessProperty` は、実行時設定プロパティーが提供された値と一致しない場合にのみ、Bean を取得する必要があることを示します。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:905
#, no-wrap
msgid "`@LookupIfProperty` Example"
msgstr "`@LookupIfProperty` Example"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:911
#, no-wrap
msgid ""
" interface Service {\n"
"    String name();\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:915
#, no-wrap
msgid ""
" @LookupIfProperty(name = \"service.foo.enabled\", stringValue = \"true\")\n"
" @ApplicationScoped\n"
" class ServiceFoo implements Service {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:920
#, no-wrap
msgid ""
"    public String name() {\n"
"       return \"foo\";\n"
"    }\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:923
#, no-wrap
msgid ""
" @ApplicationScoped\n"
" class ServiceBar implements Service {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:928
#, no-wrap
msgid ""
"    public String name() {\n"
"       return \"bar\";\n"
"    }\n"
" }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:931
#, no-wrap
msgid ""
" @ApplicationScoped\n"
" class Client {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:934
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<Service> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:941
#, no-wrap
msgid ""
"    void printServiceName() {\n"
"       // This will print \"bar\" if the property \"service.foo.enabled\" is NOT set to \"true\"\n"
"       // If \"service.foo.enabled\" is set to \"true\" then service.get() would result in an AmbiguousResolutionException\n"
"       System.out.println(service.get().name());\n"
"    }\n"
" }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:943
#, no-wrap
msgid "Injecting Multiple Bean Instances Intuitively"
msgstr "複数の Bean インスタンスを直感的に注入する"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:949
#, fuzzy
msgid "In CDI, it's possible to inject multiple bean instances (aka contextual references) via the `jakarta.enterprise.inject.Instance` which implements `java.lang.Iterable`.  However, it's not exactly intuitive.  Therefore, a new way was introduced in Quarkus - you can inject a `java.util.List` annotated with the `io.quarkus.arc.All` qualifier.  The type of elements in the list is used as the required type when performing the lookup."
msgstr "CDIでは、 `java.lang.Iterable` を実装した `jakarta.enterprise.inject.Instance` を介して、複数のBeanインスタンス（別名：コンテキスト参照）を注入することが可能です。しかし、これは直感的に理解できるものではありません。そのため、Quarkusでは新しい方法が導入されました。 `io.quarkus.arc.All` 修飾子でアノテーションされた `java.util.List` を注入することができます。リスト内の要素の型は、検索を実行する際に必要な型として使用されます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:954
#: upstream/_guides/cdi-reference.adoc:974
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Processor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:959
#, no-wrap
msgid ""
"     @Inject\n"
"     @All\n"
"     List<Service> services; <1> <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:961
msgid "The injected instance is an _immutable list_ of the contextual references of the _disambiguated_ beans."
msgstr "注入されたインスタンスは、_disambiguated_ bean のコンテキスト参照の _immutable list_ です。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:962
msgid "For this injection point the required type is `Service` and no additional qualifiers are declared."
msgstr "このインジェクションポイントに必要なタイプは `Service` であり、追加の修飾子は宣言されていません。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:964
#, fuzzy
msgid "The list is sorted by priority as defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority goes first. In general, the `@jakarta.annotation.Priority` and `@io.quarkus.arc.Priority` annotations can be used to assign the priority to a class bean, producer method or producer field."
msgstr "リストは、 `io.quarkus.arc.InjectableBean#getPriority()` で定義された優先順位でソートされます。 高い優先順位が最初になります。一般に、 `@jakarta.annotation.Priority` と `@io.quarkus.arc.Priority` アノテーションを使用して、クラスビーン、プロデューサーメソッド、プロデューサーフィールドに優先度を割り当てることができます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:966
msgid "If an injection point declares no other qualifier than `@All` then `@Any` is used, i.e. the behavior is equivalent to `@Inject @Any Instance<Service>`."
msgstr "インジェクションポイントが `@All` 以外の修飾子を宣言していない場合、`@Any` が使用されます。つまり、動作は `@Inject @Any Instance<Service>` と同等です。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:969
msgid "You can also inject a list of bean instances wrapped in `io.quarkus.arc.InstanceHandle`.  This can be useful if you need to inspect the related bean metadata."
msgstr "`io.quarkus.arc.InstanceHandle` でラップされた Bean インスタンスのリストを注入することもできます。これは、関連する Bean メタデータを検査する必要がある場合に役立ちます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:978
#, no-wrap
msgid ""
"     @Inject\n"
"     @All\n"
"     List<InstanceHandle<Service>> services;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:988
#, no-wrap
msgid ""
"     public void doSomething() {\n"
"       for (InstanceHandle<Service> handle : services) {\n"
"         if (handle.getBean().getScope().equals(Dependent.class)) {\n"
"           handle.get().process();\n"
"           break;\n"
"         }\n"
"       }\n"
"     }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:991
msgid "Neither a type variable nor a wildcard is a legal type parameter for an `@All List<>` injection point, i.e. `@Inject @All List<?> all` is not supported and results in a deployment error."
msgstr "型変数もワイルドカードも `@All List<>` インジェクションポイントのタイプパラメーターとしては有効ではありません。つまり、`@Inject @All List<?> all` はサポートされておらず、デプロイメントエラーになります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:993
msgid "It is also possible to obtain the list of all bean instance handles programmatically via the `Arc.container().listAll()` methods."
msgstr "`Arc.container().listAll()` メソッドを使用して、プログラムですべての Bean インスタンスハンドルのリストを取得することもできます。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:994
#, no-wrap
msgid "Ignoring Class-Level Interceptor Bindings for Methods and Constructors"
msgstr "メソッドとコンストラクターのクラスレベルのインターセプターバインディングを無視する"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:998
msgid "If a managed bean declares interceptor binding annotations on the class level, the corresponding `@AroundInvoke` interceptors will apply to all business methods.  Similarly, the corresponding `@AroundConstruct` interceptors will apply to the bean constructor."
msgstr "マネージド Bean がクラスレベルでインターセプターバインディングアノテーションを宣言する場合、対応する `@AroundInvoke` インターセプターがすべてのビジネスメソッドに適用されます。同様に、対応する `@AroundConstruct` インターセプターが Bean コンストラクターに適用されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1000
msgid "For example, suppose we have a logging interceptor with the `@Logged` binding annotation and a tracing interceptor with the `@Traced` binding annotation:"
msgstr "たとえば、`@Logged` バインディングアノテーションを持つロギングインターセプターと `@Traced` バインディングアノテーションを持つトレースインターセプターがあるとします。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1009
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Logged\n"
"public class MyService {\n"
"    public void doSomething() {\n"
"        ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1015
#, no-wrap
msgid ""
"    @Traced\n"
"    public void doSomethingElse() {\n"
"        ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1019
msgid "In this example, both `doSomething` and `doSomethingElse` will be intercepted by the hypothetical logging interceptor.  Additionally, the `doSomethingElse` method will be intercepted by the hypothetical tracing interceptor."
msgstr "この例では、`doSomething` と `doSomethingElse` の両方が架空のロギングインターセプターによってインターセプトされます。さらに、`doSomethingElse` メソッドは、架空のトレースインターセプターによってインターセプトされます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1022
msgid "Now, if that `@Traced` interceptor also performed all the necessary logging, we'd like to skip the `@Logged` interceptor for this method, but keep it for all other methods.  To achieve that, you can annotate the method with `@NoClassInterceptors`:"
msgstr "もし `@Traced` インターセプターが必要なロギングもすべて行っていた場合、このメソッドでは `@Logged` インターセプターを省略したいのですが、他のすべてのメソッドではそのままにしておきたいと思います。これを実現するには、メソッドに `@NoClassInterceptors` というアノテーションを付けます。"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1030
#, no-wrap
msgid ""
"@Traced\n"
"@NoClassInterceptors\n"
"public void doSomethingElse() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1034
msgid "The `@NoClassInterceptors` annotation may be put on methods and constructors and means that all class-level interceptors are ignored for these methods and constructors.  In other words, if a method/constructor is annotated `@NoClassInterceptors`, then the only interceptors that will apply to this method/constructor are interceptors declared directly on the method/constructor."
msgstr "`@NoClassInterceptors` アノテーションはメソッドとコンストラクターに付けることができ、これらのメソッドとコンストラクターではすべてのクラスレベルのインターセプターが無視されることを意味します。つまり、メソッド/コンストラクターに `@NoClassInterceptors` アノテーションが付けられている場合、このメソッド/コンストラクターに適用されるインターセプターは、メソッド/コンストラクターで直接宣言されたインターセプターのみです。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1036
msgid "This annotation affects only business method interceptors (`@AroundInvoke`) and constructor lifecycle callback interceptors (`@AroundConstruct`)."
msgstr "このアノテーションは、ビジネスメソッドインターセプター (`@AroundInvoke`) とコンストラクターライフサイクルコールバックインターセプター (`@AroundConstruct`) にのみ影響します。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:1037
#, no-wrap
msgid "Exceptions Thrown By An Asynchronous Observer Method"
msgstr "非同期オブザーバーメソッドによって出力される例外"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1044
#, fuzzy
msgid "If an exception is thrown by an asynchronous observer then the `CompletionStage` returned by the `fireAsync()` method completes exceptionally so that the event producer may react appropriately.  However, if the event producer does not care then the exception is ignored silently.  Therefore, Quarkus logs an error message by default.  It is also possible to implement a custom `AsyncObserverExceptionHandler`.  A bean that implements this interface should be `@jakarta.inject.Singleton` or `@jakarta.enterprise.context.ApplicationScoped`."
msgstr "非同期オブザーバーによって例外が投げられた場合、 `fireAsync()` メソッドによって返される `CompletionStage` は例外的に完了し、イベントプロデューサが適切に対応できるようになります。しかし、イベントプロデューサが気にしない場合は、例外は黙って無視されます。そのため、Quarkusでは、デフォルトでエラーメッセージが記録されます。また、カスタム `AsyncObserverExceptionHandler` を実装することも可能です。このインターフェースを実装するビーンは、 `@jakarta.inject.Singleton` または `@jakarta.enterprise.context.ApplicationScoped` である必要があります。"

#. type: Block title
#: upstream/_guides/cdi-reference.adoc:1045
#, no-wrap
msgid "`NoopAsyncObserverExceptionHandler`"
msgstr "`NoopAsyncObserverExceptionHandler`"

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1050
#, no-wrap
msgid ""
"@Singleton\n"
"public class NoopAsyncObserverExceptionHandler implements AsyncObserverExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1054
#, no-wrap
msgid ""
"  void handle(Throwable throwable, ObserverMethod<?> observerMethod, EventContext<?> eventContext) {\n"
"    // do nothing\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1056
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1059
#, no-wrap
msgid "Build Time Extensions"
msgstr "ビルド時エクステンション"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1065
msgid "Quarkus incorporates build-time optimizations in order to provide instant startup and low memory footprint.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, most of the functionality can be achieved using Quarkus xref:writing-extensions.adoc[extensions].  See the xref:cdi-integration.adoc[integration guide] for more information."
msgstr "Quarkus は、インスタント起動と低メモリフットプリントを提供するために、ビルド時の最適化を取り入れています。このアプローチの欠点は、CDI ポータブル・エクステンションをサポートできないことです。それにもかかわらず、ほとんどの機能は、Quarkus xref:writing-extensions.adoc[エクステンション] を使用して行うことができます。詳細は、xref:cdi-integration.adoc[統合ガイド] を参照してください。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1066
#, no-wrap
msgid "Development Mode"
msgstr "開発モード"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1069
msgid "In the development mode, two special endpoints are registered automatically to provide some basic debug info in the JSON format:"
msgstr "開発モードでは、JSON 形式で基本的なデバッグ情報を提供するために、2 つの特別なエンドポイントが自動的に登録されます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1071
msgid "HTTP GET `/q/arc` - returns the summary; number of beans, config properties, etc."
msgstr "HTTP GET `/q/arc` - 要約、Bean の数、設定プロパティーなどを返します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1072
msgid "HTTP GET `/q/arc/beans` - returns the list of all beans"
msgstr "HTTP GET `/q/arc/beans` - すべての Bean のリストを返します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1073
msgid "You can use query params to filter the output:"
msgstr "クエリーパラメーターを使用して出力をフィルタリングすることができます。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1074
msgid "`scope` - include beans with scope that ends with the given value, i.e. `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`"
msgstr "`scope` - 指定した値で終わるスコープを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`)。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1075
msgid "`beanClass` - include beans with bean class that starts with the given value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`"
msgstr "`beanClass` - 与えられた値で始まる Bean クラスを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`)。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1076
msgid "`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, `PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`"
msgstr "`kind` - 指定された種類の Bean (`CLASS`、`PRODUCER_FIELD`、`PRODUCER_METHOD`、`INTERCEPTOR`、または `SYNTHETIC`) を含みます (つまり `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`)。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1077
msgid "HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed during build"
msgstr "HTTP GET `/q/arc/removed-beans` - ビルド中に削除された未使用の Bean のリストを返します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1078
msgid "HTTP GET `/q/arc/observers` - returns the list of all observer methods"
msgstr "HTTP GET `/q/arc/observers` - すべてのオブザーバーメソッドのリストを返します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1080
msgid "These endpoints are only available in the development mode, i.e. when you run your application via `mvn quarkus:dev` (or `./gradlew quarkusDev`)."
msgstr "これらのエンドポイントは開発モードでのみ使用できます。つまり `mvn quarkus:dev` (または `./gradlew quarkusDev`) 経由でアプリケーションを実行したときです。"

#. type: Title ===
#: upstream/_guides/cdi-reference.adoc:1081
#, no-wrap
msgid "Monitoring Business Method Invocations and Events"
msgstr "ビジネスメソッドの呼び出しとイベントの監視"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1085
msgid "In the development mode, it is also possible to enable monitoring of business method invocations and fired events.  Simply set the `quarkus.arc.dev-mode.monitoring-enabled` configuration property to `true` and explore the relevant Dev UI pages."
msgstr "開発モードでは、ビジネスメソッドの呼び出しと発生したイベントの監視を有効にすることも可能です。 単に `quarkus.arc.dev-mode.monitoring-enabled` 設定プロパティを `true` に設定し、関連する Dev UI ページを探索するだけです。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1087
#, fuzzy, no-wrap
msgid "Strict Mode"
msgstr "ストリクトモード"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1091
#, fuzzy
msgid "By default, ArC does not perform all validations required by the CDI specification.  It also improves CDI usability in many ways, some of them being directly against the specification."
msgstr "デフォルトでは、ArC は CDI 仕様で要求される全てのバリデーションを実行しません。また、多くの方法でCDIの使い勝手を向上させますが、その中には仕様に直接反するものもあります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1094
#, fuzzy
msgid "To be able to eventually pass the CDI Lite TCK, ArC also has a _strict_ mode.  This mode enables additional validations and disables certain improvements that conflict with the specification."
msgstr "最終的にCDI Lite TCKをパスできるようにするため、ArCには _ストリクトモードも_ 用意されています。このモードでは、追加の検証を有効にし、仕様に抵触する特定の改良を無効化します。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1096
#, fuzzy
msgid "To enable the strict mode, use the following configuration:"
msgstr "ストリクトモードを有効にするには、次のように設定します："

#. type: delimited block -
#: upstream/_guides/cdi-reference.adoc:1100
#, no-wrap
msgid "quarkus.arc.strict-compatibility=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1103
#, fuzzy
msgid "Some other features affect specification compatibility as well:"
msgstr "その他にも、仕様の互換性に影響を与える機能があります："

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1105
#, fuzzy
msgid "xref:unproxyable_classes_transformation[Transformation of unproxyable classes]"
msgstr "xref:unproxyable_classes_transformation[プロキシ不可能なクラスの変換]"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1106
#, fuzzy
msgid "xref:remove_unused_beans[Unused beans removal]"
msgstr "xref:remove_unused_beans[未使用豆の除去]"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1108
#, fuzzy
msgid "To get a behavior closer to the specification, these features should also be disabled."
msgstr "より仕様に近い動作を得るためには、これらの機能も無効にしておく必要があります。"

#. type: Plain text
#: upstream/_guides/cdi-reference.adoc:1111
#, fuzzy
msgid "Applications are recommended to use the default, non-strict mode, which makes CDI more convenient to use.  The \"strictness\" of the strict mode (the set of additional validations and the set of disabled improvements on top of the CDI specification) may change over time."
msgstr "アプリケーションは、CDIをより便利に使えるように、デフォルトの非厳密モードを使用することが推奨されます。厳密モードの「厳密さ」（CDI仕様の上に追加される検証のセットと無効にされる改良のセット）は、時間の経過とともに変化する可能性があります。"

#. type: Title ==
#: upstream/_guides/cdi-reference.adoc:1113
#, no-wrap
msgid "ArC Configuration Reference"
msgstr "ArC Configuration Reference"

#~ msgid "Quarkus DI solution (also called ArC) is based on the https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.  However, it is not a full CDI implementation verified by the TCK.  Only a subset of the CDI features is implemented - see also <<supported_features,the list of supported features>> and <<limitations,the list of limitations>>."
#~ msgstr "Quarkus DI ソリューション (ArC とも呼ばれる) は、 https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] 仕様に基づいています。ただし、TCK によって検証された完全な CDI 実装ではありません。CDI 機能のサブセットのみが実装されています - <<supported_features,サポートされている機能のリスト>> と<<limitations,制約事項のリスト>> も参照してください。"

#~ msgid "Programmatic lookup via `javax.enterprise.inject.Instance`"
#~ msgstr "`javax.Enterprise.inject.instance` を介したプログラムによる検索"

#~ msgid "Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in <<lazy_by_default>>:"
#~ msgstr "`StartupEvent` のオブザーバーで Bean を使用します - <<lazy_by_default>> で説明されているように、通常のスコープ Bean を使用する必要があります。"

#~ msgid "The container attempts to remove all unused beans, interceptors and decorators during build by default.  This optimization helps to minimize the amount of generated classes, thus conserving memory.  However, Quarkus can't detect the programmatic lookup performed via the `CDI.current()` static method.  Therefore, it is possible that a removal results in a false positive error, i.e. a bean is removed although it's actually used.  In such cases, you'll notice a big warning in the log.  Users and extension authors have several options <<eliminate_false_positives,how to eliminate false positives>>."
#~ msgstr "コンテナーは、デフォルトでビルド中に未使用の Bean、インターセプター、デコレーターをすべて削除しようとします。この最適化は、生成されるクラスの量を最小限に抑え、メモリーを節約するのに役立ちます。ただし、Quarkus は、`CDI.current()` staticメソッドを介して実行されたプログラムによるルックアップを検出できません。したがって、削除すると誤検知エラーが発生する可能性があります。つまり、Bean は実際に使用されていても、削除されます。このような場合、ログに大きな警告が表示されます。ユーザーとエクステンションの作成者にはいくつかのオプションがあります: <<eliminate_false_positives,誤検知を排除する方法>>。"

#~ msgid "Quarkus first identifies so-called _unremovable_ beans that form the roots in the dependency tree.  A good example is a JAX-RS resource class or a bean which declares a `@Scheduled` method."
#~ msgstr "Quarkus は最初に、依存関係ツリーのルートを形成する、いわゆる _unremovable_ Bean を識別します。良い例は、JAX-RS リソースクラスまたは `@Scheduled` メソッドを宣言する Bean です。"

#~ msgid "is not eligible for injection into any `javax.enterprise.inject.Instance` or `javax.inject.Provider` injection point."
#~ msgstr "`javax.enterprise.inject.Instance` または `javax.inject.Provider` の注入ポイントに注入することが出来ないこと"

#~ msgid "The disadvantage of `@javax.annotation.Priority` is that it has `@Target({ TYPE, PARAMETER })` and so it cannot be used for producer methods and fields.  This problem should be fixed in Common Annotations 2.1.  Users are encouraged to use `@io.quarkus.arc.Priority` instead, until Quarkus upgrades to this version of `jakarta.annotation-api`."
#~ msgstr "`@javax.annotation.Priority` の欠点は、`@Target({ TYPE, PARAMETER })` であるため、プロデューサーメソッドおよびフィールドには使用できません。この問題は、Common Annotations 2.1 で修正する必要があります。Quarkus がこのバージョンの `jakarta.annotation-api` にアップグレードするまでは、代わりに `@io.quarkus.arc.Priority` を使用することをお勧めします。"

#~ msgid "However, it is also possible to select alternatives for an application using the unified configuration.  The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.  If any value matches then the priority of `Integer#MAX_VALUE` is used for the relevant bean.  The priority declared via `@Priority` or `@AlternativePriority` is overridden."
#~ msgstr "ただし、統一された設定を使用して、アプリケーションの代替を選択することもできます。`quarkus.arc.selected-alternatives` プロパティーは、代替 Bean を照合するために使用される文字列値のリストを受け入れます。一致する値がある場合は、関連する Bean に `Integer#MAX_VALUE` の優先順位が使用されます。`@Priority` または `@AlternativePriority` で宣言された優先度は上書きされます。"

#~ msgid "In certain situations, it is practical to obtain a bean instance programmatically via an injected `javax.enterprise.inject.Instance` and `Instance.get()`.  However, according to the specification the `get()` method must identify the matching bean and obtain a contextual reference.  As a consequence, a new instance of a `@Dependent` bean is returned from each invocation of `get()`.  Moreover, this instance is a dependent object of the injected `Instance`.  This behavior is well-defined, but it may lead to unexpected errors and memory leaks.  Therefore, Quarkus comes with the `io.quarkus.arc.WithCaching` annotation.  An injected `Instance` annotated with this annotation will cache the result of the `Instance#get()` operation.  The result is computed on the first call and the same value is returned for all subsequent calls, even for `@Dependent` beans."
#~ msgstr "特定の状況では、注入された `javax.enterprise.inject.Instance` および `Instance.get()` を介してプログラムで Bean インスタンスを取得することが実用的です。ただし、仕様によれば、 `get()` メソッドは一致する Bean を識別し、コンテキスト参照を取得する必要があります。結果として、 `@Dependent` Bean の新しいインスタンスが、 `get()` の各呼び出しから返されます。さらに、このインスタンスは、注入された `Instance` の依存オブジェクトです。この動作は明確に定義されていますが、予期しないエラーやメモリーリークが発生する可能性があります。したがって、Quarkus には `io.quarkus.arc.WithCaching` アノテーションが付いています。このアノテーションを付けて注入された `Instance` は、 `Instance#get()` 操作の結果をキャッシュします。結果は最初の呼び出しで計算され、 `@Dependent` Bean の場合でも、後続のすべての呼び出しで同じ値が返されます。"

#~ msgid "It is also possible to clear the cached value via `io.quarkus.arc.InjectableInstance.clearCache()`. In this case, you'll need to inject the Quarkus-specific `io.quarkus.arc.InjectableInstance` instead of `javax.enterprise.inject.Instance`."
#~ msgstr "`io.quarkus.arc.InjectableInstance.clearCache()` を介してキャッシュされた値をクリアすることも可能です。この場合、`javax.enterprise.inject.Instance` の代わりに Quarkus 固有の `io.quarkus.arc.InjectableInstance` を注入する必要があります。"

#~ msgid "It is sometimes useful to narrow down the set of beans that can be obtained by programmatic lookup via `javax.enterprise.inject.Instance`.  Typically, a user needs to choose the appropriate implementation of an interface based on a runtime configuration property."
#~ msgstr "`javax.enterprise.inject.Instance` を介したプログラムによるルックアップで取得できる Bean のセットを絞り込むと便利な場合があります。通常、ユーザーはランタイム設定プロパティーに基づいてインターフェイスの適切な実装を選択する必要があります。"

#~ msgid "In CDI, it's possible to inject multiple bean instances (aka contextual references) via the `javax.enterprise.inject.Instance` which implements `java.lang.Iterable`.  However, it's not exactly intuitive.  Therefore, a new way was introduced in Quarkus - you can inject a `java.util.List` annotated with the `io.quarkus.arc.All` qualifier.  The type of elements in the list is used as the required type when performing the lookup."
#~ msgstr "CDI では、`java.lang.Iterable` を実装する `javax.enterprise.inject.Instance` を介して複数の Bean インスタンス (いわゆるコンテキスト参照) を注入することができます。ただし、それは正確には直感的ではありません。そのため、Quarkus に新しい方法が導入されました。`io.quarkus.arc.All` 修飾子でアノテーションが付けられた `java.util.List` を注入できます。リスト内の要素のタイプは、ルックアップを実行するときに必要なタイプとして使用されます。"

#~ msgid "The list is sorted by priority as defined by `io.quarkus.arc.InjectableBean#getPriority()`. Higher priority goes first. In general, the `@javax.annotation.Priority` and `@io.quarkus.arc.Priority` annotations can be used to assign the priority to a class bean, producer method or producer field."
#~ msgstr "リストは、`io.quarkus.arc.InjectableBean#getPriority()` で定義されている優先度で並べ替えられます。優先度の高い方が優先されます。一般に、`@javax.annotation.Priority` および `@io.quarkus.arc.Priority` アノテーションを使用して、クラス Bean、プロデューサーメソッド、またはプロデューサーフィールドに優先度を割り当てることができます。"

#~ msgid "If an exception is thrown by an asynchronous observer then the `CompletionStage` returned by the `fireAsync()` method completes exceptionally so that the event producer may react appropriately.  However, if the event producer does not care then the exception is ignored silently.  Therefore, Quarkus logs an error message by default.  It is also possible to implement a custom `AsyncObserverExceptionHandler`.  A bean that implements this interface should be `@javax.inject.Singleton` or `@javax.enterprise.context.ApplicationScoped`."
#~ msgstr "非同期オブザーバーによって例外が出力された場合、`fireAsync()` メソッドによって返される `CompletionStage` は例外的に完了し、イベントプロデューサーが適切に反応できるようにします。ただし、イベントプロデューサーがこれを問題にしない場合、例外は黙示的に無視されます。したがって、Quarkus はデフォルトでエラーメッセージをログに記録します。カスタムの `AsyncObserverExceptionHandler` を実装することも可能です。このインターフェイスを実装する Bean は、`@javax.inject.Singleton` または `@javax.enterprise.context.ApplicationScoped` である必要があります。"

#~ msgid "Scopes and contexts"
#~ msgstr "スコープとコンテキスト"

#~ msgid "`@Dependent`, `@ApplicationScoped`, `@Singleton`, `@RequestScoped` and `@SessionScoped`"
#~ msgstr "`@Dependent`, `@ApplicationScoped`, `@Singleton`, `@RequestScoped` and `@SessionScoped`"

#~ msgid "Custom scopes and contexts"
#~ msgstr "カスタムスコープとコンテキスト"

#~ msgid "If you are using gradle, you can apply the following plugin to your `build.gradle`:"
#~ msgstr "gradle を使っている場合は、以下のプラグインを `build.gradle` に適用することができます。"

#~ msgid "The container attempts to remove all unused beans during build by default.  This optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`."
#~ msgstr "コンテナーは、デフォルトではビルド中に未使用の Bean をすべて削除しようとします。この最適化は、`quarkus.arc.remove-unused-beans` を `none` または `false` に設定することで無効にすることができます。"

#~ msgid "is not a built-in bean or an interceptor,"
#~ msgstr "ビルトイン Bean でもインターセプターでもありません。"

#~ msgid "does not have a name,"
#~ msgstr "名前がありません。"

#~ msgid "does not declare an observer,"
#~ msgstr "オブザーバーを宣言しません。"

#~ msgid "This optimization applies to all forms of bean declarations: bean class, producer method, producer field."
#~ msgstr "この最適化は、Bean クラス、プロデューサーメソッド、プロデューサーフィールドなど、Bean 宣言のすべての形式に適用されます。"
