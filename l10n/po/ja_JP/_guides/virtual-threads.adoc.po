# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-10-02 00:32+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/virtual-threads.adoc:6
#, fuzzy, no-wrap
msgid "Writing simpler reactive REST services with Quarkus Virtual Thread support"
msgstr "Quarkus Virtual Threadのサポートによる、よりシンプルなリアクティブRESTサービスの作成"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:19
#, fuzzy
msgid "This guide explains how to benefit from Java 19 virtual threads when writing REST services in Quarkus."
msgstr "このガイドでは、QuarkusでRESTサービスを記述する際にJava 19の仮想スレッドを利用する方法について説明します。"

#. type: delimited block =
#: upstream/_guides/virtual-threads.adoc:25
#, fuzzy
msgid "This is the reference guide for using virtual threads to write reactive REST services.  Please refer to the xref:rest-json.adoc[Writing JSON REST services guides] for a lightweight introduction to reactive REST services and to the xref:resteasy-reactive.adoc[Writing REST Services with RESTEasy Reactive] guide for a detailed presentation."
msgstr "これは、仮想スレッドを使用してリアクティブ REST サービスを記述するためのリファレンスガイドです。リアクティブ REST サービスの軽量な導入については、「 link:rest-json.html[Writing JSON REST services」ガイドを] 、詳細な説明については、「 link:resteasy-reactive.html[Writing REST Services with RESTEasy Reactive] 」ガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:27
#, fuzzy, no-wrap
msgid "What are virtual threads ?"
msgstr "仮想スレッドとは何ですか？"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:29
#, no-wrap
msgid "Terminology"
msgstr "用語解説"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:30
#, fuzzy, no-wrap
msgid "OS thread"
msgstr "OSスレッド"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:32
#, fuzzy
msgid "A \"thread-like\" data-structure managed by the Operating System."
msgstr "オペレーティングシステムによって管理される「スレッドライク」なデータ構造。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:33
#, fuzzy, no-wrap
msgid "Platform thread"
msgstr "プラットフォームスレッド"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:36
#, fuzzy
msgid "Up until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, that is, a wrapper around an OS thread.  Creating a platform threads creates an OS thread, blocking a platform thread blocks an OS thread."
msgstr "Java 19 までは、 link:{thread}[Thread] クラスのすべてのインスタンスはプラットフォーム・スレッド、つまり OS スレッドのラッパーでした。プラットフォーム・スレッドを作成するとOSスレッドが作成され、プラットフォーム・スレッドをブロックするとOSスレッドがブロックされます。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:37
#, fuzzy, no-wrap
msgid "Virtual thread"
msgstr "仮想スレッド"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:40
#, fuzzy
msgid "Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.  Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr "軽量で、JVMが管理するスレッド。 link:{thread}[スレッドクラスを] 拡張していますが、1つの特定のOSスレッドに縛られることはありません。したがって、仮想スレッドのスケジューリングは、JVMの責任です。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:41
#, fuzzy, no-wrap
msgid "Carrier thread"
msgstr "キャリアスレッド"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:44
#, fuzzy
msgid "A platform thread used to execute a virtual thread is called a carrier.  This isn't a class distinct from link:{Thread}[Thread] or VirtualThread but rather a functional denomination."
msgstr "仮想スレッドを実行するために使用されるプラットフォームスレッドをキャリアと呼びます。これは link:{Thread}[Threadや] VirtualThreadとは別のクラスではなく、機能的な呼称です。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:45
#, fuzzy, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr "仮想スレッドとプラットフォームスレッドの違い"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:47
#, fuzzy
msgid "We will give a brief overview of the topic here, please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr "ここではその概要を説明しますが、詳しくは link:{vthreadjep}[JEP425を] ご参照ください。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:49
#, fuzzy
msgid "Virtual threads are a feature available since Java 19 aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr "仮想スレッドは、I/Oバウンドワークロードのためのプラットフォームスレッドの安価な代替を提供することを目的としたJava 19から利用可能な機能です。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:53
#, fuzzy
msgid "Until now, platform threads were the concurrency unit of the JVM.  They are a wrapper over OS structures.  This means that creating a Java platform thread actually results in creating a \"thread-like\" structure in your operating system."
msgstr "これまで、プラットフォーム・スレッドはJVMの並行処理単位でした。これは、OSの構造体を覆うラッパーです。つまり、Javaプラットフォームスレッドを作成することは、実際にはOSに「スレッドのような」構造を作成することになるのです。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:57
#, fuzzy
msgid "Virtual threads on the other hand are managed by the JVM. In order to be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).  As such, they have been designed to offer the following characteristics:"
msgstr "一方、仮想スレッドは、JVMによって管理されます。実行するには、プラットフォームスレッド（その仮想スレッドのキャリアとして機能する）にマウントされる必要があります。そのため、以下のような特徴を持つように設計されています。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:58
#, fuzzy, no-wrap
msgid "Lightweight "
msgstr "軽量化"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:62
#, fuzzy
msgid "Virtual threads occupy less space than platform threads in memory.  Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the heap.  By default, platform threads are created with a stack of about 1 MB where virtual threads stack is \"pay-as-you-go\".  You can find these numbers along with other motivations for virtual threads in this presentation given by the lead developer of project Loom: https://youtu.be/lIq-x_iI-kc?t=543."
msgstr "仮想スレッドは、プラットフォームスレッドよりもメモリ上で占有する領域が小さくなります。したがって、ヒープを爆発させることなく、プラットフォームスレッドよりも多くの仮想スレッドを同時に使用することが可能になります。デフォルトでは、プラットフォームスレッドは約1MBのスタックで作成され、仮想スレッドのスタックは「pay-as-you-go」です。この数字と仮想スレッドの他の動機は、Loomプロジェクトのリード開発者が行ったプレゼンテーションで知ることができます https://youtu.be/lIq-x_iI-kc?t=543 "

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:63
#, fuzzy, no-wrap
msgid "Cheap to create"
msgstr "安価に作成できる"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:68
#, fuzzy
msgid "Creating a platform thread in Java takes time.  Currently, techniques such as pooling where threads are created once then reused are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).  Virtual threads are supposed to be disposable entities that we create when we need them, it is discouraged to pool them or to reuse them for different tasks."
msgstr "Javaでプラットフォームスレッドを作成するのは時間がかかります。現在では、スレッドの起動にかかる時間を最小限にするために、一度作成したスレッドを再利用するプーリングなどの技術が強く推奨されています（同様に、メモリ消費を抑えるためにスレッドの最大数を制限することも推奨されています）。仮想スレッドは必要なときに作る使い捨ての存在であり、スレッドをプールしたり異なるタスクに再利用したりすることは推奨されません。"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:69
#, fuzzy, no-wrap
msgid "Cheap to block"
msgstr "安価にブロック化"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:73
#, fuzzy
msgid "When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.  Since virtual threads are managed by the JVM, no underlying OS thread is blocked when they perform a blocking operation.  Their state is simply stored in the heap and another Virtual thread is executed on the same Java platform thread."
msgstr "ブロッキングI/Oを実行する場合、Javaプラットフォームのスレッドにラップされた基礎となるOSスレッドは待ち行列に入れられ、新しいスレッドコンテキストをCPUコアにロードするためにコンテキストスイッチが発生します。この操作には時間がかかる。仮想スレッドはJVMによって管理されるため、ブロッキング処理を実行しても、基盤となるOSスレッドがブロックされることはありません。その状態は単にヒープに格納され、別の仮想スレッドが同じJavaプラットフォームのスレッドで実行されます。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:74
#, fuzzy, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr "仮想スレッドは、I/Oバウンドワークロードにのみ有効です。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:82
#, fuzzy
msgid "We now know that we can create way more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).  This is useless if not counterproductive.  CPU-bound doesn't consist in quickly swapping threads while they need to wait for the completion of an I/O but in leaving them attached to a CPU-core to actually compute something.  In this scenario, it is useless to have thousands of threads if we have tens of CPU-cores, virtual threads won't enhance the performance of CPU-bound workloads."
msgstr "私たちは、プラットフォームスレッドよりもはるかに多くの仮想スレッドを作成できることを知っています。長い計算を行うために仮想スレッドを使いたくなるかもしれません（CPUバウンドワークロード）。これは逆効果とまではいかないまでも、無駄なことです。CPUバウンドとは、I/Oの完了を待つ間にスレッドをすばやくスワップすることではなく、実際に何かを計算するためにスレッドをCPUコアに接続したままにしておくことです。このシナリオでは、数十個のCPUコアがあれば、数千個のスレッドを持つことは無意味であり、仮想スレッドはCPUバウンドワークロードの性能を向上させることはありません。"

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:84
#, fuzzy, no-wrap
msgid "Bringing virtual threads to reactive REST services"
msgstr "リアクティブなRESTサービスに仮想スレッドを導入する"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:88
#, fuzzy
msgid "Since virtual threads are disposable entities, the fundamental idea of quarkus-loom is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop (in the case of RESTeasy-reactive) or a platform worker thread."
msgstr "仮想スレッドは使い捨てのエンティティなので、quarkus-loomの基本的な考え方は、エンドポイントハンドラをイベントループ（RESTeasy-reactiveの場合）やプラットフォームワーカスレッドで実行するのではなく、新しい仮想スレッドでオフロードすることです。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:93
#, fuzzy
msgid "To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.  If the JDK is compatible (Java 19 or later versions) then the endpoint will be offloaded to a virtual thread.  It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
msgstr "そのためには、エンドポイントに link:{runonvthread}[@RunOnVirtualThread] アノテーションを追加すれば十分です。JDKが互換性がある場合（Java 19またはそれ以降のバージョン）、エンドポイントは仮想スレッドにオフロードされます。これにより、仮想スレッドがマウントされているプラットフォーム・スレッドをブロックすることなく、ブロック操作を実行できるようになります。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:98
#, fuzzy
msgid "This annotation can only be used in conjunction with endpoints annotated with link:{blockingannotation}[@Blocking] or considered blocking because of their signature.  You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking] for more information."
msgstr "このアノテーションは、 link:{blockingannotation}[@Blockingで] アノテーションされたエンドポイント、またはそのシグネチャのためにブロッキングとみなされるエンドポイントとの組み合わせでのみ使用することができます。詳しくは、 link:resteasy-reactive.html#execution-model-blocking-non-blocking[実行モデル、ブロッキング、ノンブロッキングを] ご覧ください。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:99
#, no-wrap
msgid "Getting started"
msgstr "はじめに"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:102
msgid "Add the following import to your build file:"
msgstr "次のインポートをビルドファイルに追加します:"

#. type: Block title
#: upstream/_guides/virtual-threads.adoc:104
#: upstream/_guides/virtual-threads.adoc:121
#: upstream/_guides/virtual-threads.adoc:450
#: upstream/_guides/virtual-threads.adoc:470
#: upstream/_guides/virtual-threads.adoc:503
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:110
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
msgstr ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"

#. type: Block title
#: upstream/_guides/virtual-threads.adoc:113
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:116
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-resteasy-reactive\")\n"
msgstr "implementation(\"io.quarkus:quarkus-resteasy-reactive\")\n"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:119
#, fuzzy
msgid "You also need to make sure that you are using the version 19 of Java, this can be enforced in your pom.xml file with the following:"
msgstr "また、Javaのバージョン19を使用していることを確認する必要があります。これは、pom.xmlファイルで次のように強制することができます。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:127
#, no-wrap
msgid ""
"<properties>\n"
"    <maven.compiler.source>19</maven.compiler.source>\n"
"    <maven.compiler.target>19</maven.compiler.target>\n"
"</properties>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:130
#, fuzzy
msgid "Virtual threads are still an experimental feature, you need to start your application with the `--enable-preview` flag:"
msgstr "仮想スレッドはまだ実験的な機能なので、 `--enable-preview` フラグを付けてアプリケーションを起動する必要があります。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:134
#, no-wrap
msgid "java --enable-preview -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:138
#, fuzzy
msgid "The example below shows the differences between three endpoints, all of them querying a fortune in the database then returning it to the client."
msgstr "以下の例は、3つのエンドポイントの違いを示している。これらのエンドポイントはすべて、データベースの財産を照会し、それをクライアントに返している。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:140
#, fuzzy
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr "は、伝統的なブロッキングスタイルを採用しており、その特徴からブロッキングとされています。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:141
#, fuzzy
msgid "the second one uses Mutiny reactive streams in a declarative style, it is considered non-blocking due to its signature."
msgstr "は、Mutinyのリアクティブストリームを宣言的なスタイルで使用し、そのシグネチャによりノンブロッキングとみなされます。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:143
#, fuzzy
msgid "the third one uses Mutiny reactive streams in a synchronous way, since it doesn't return a \"reactive type\" it is considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr "3つ目は、Mutinyのリアクティブストリームを同期的に使うもので、「リアクティブ型」を返さないので、ブロッキングとみなされ、 link:{runonvthread}[@RunOnVirtualThread] アノテーションが使えるようになる。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:147
#, fuzzy
msgid "When using Mutiny, alternative \"xAndAwait\" methods are provided to be used with virtual threads.  They ensure that waiting for the completion of the I/O will not \"pin\" the carrier thread and deteriorate performance.  Pinning is a phenomenon that we describe in xref:Pinning cases[this section]."
msgstr "Mutinyを使用する場合、仮想スレッドで使用するために、代替の「xAndAwait」メソッドが提供されます。これらは、I/Oの完了を待っても、キャリアスレッドを「ピン留め」して性能を悪化させないようにするものです。ピン止めとは、 link:#Pinning cases[このセクションで] 説明する現象です。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:151
#, fuzzy
msgid "In other words, the mutiny environment is a safe environment for virtual threads.  The guarantees offered by Mutiny are detailed later."
msgstr "つまり、mutiny環境は仮想スレッドにとって安全な環境なのです。Mutinyが提供する保証については、後で詳しく説明します。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:155
#: upstream/_guides/virtual-threads.adoc:206
#, no-wrap
msgid "package org.acme.rest;\n"
msgstr "package org.acme.rest;\n"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:160
#: upstream/_guides/virtual-threads.adoc:211
#, no-wrap
msgid ""
"import org.acme.fortune.model.Fortune;\n"
"import org.acme.fortune.repository.FortuneRepository;\n"
"import io.smallrye.common.annotation.RunOnVirtualThread;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:165
#: upstream/_guides/virtual-threads.adoc:216
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:169
#: upstream/_guides/virtual-threads.adoc:220
#, no-wrap
msgid ""
"@Path(\"\")\n"
"public class FortuneResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:176
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/blocking\")\n"
"    public Fortune blocking() {\n"
"        var list = repository.findAllBlocking();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:183
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/reactive\")\n"
"    public Uni<Fortune> reactive() {\n"
"        return repository.findAllAsync()\n"
"                .map(this::pickOne);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:191
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/virtual\")\n"
"    @RunOnVirtualThread\n"
"    public Fortune virtualThread() {\n"
"        var list = repository.findAllAsyncAndAwait();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:193
#: upstream/_guides/virtual-threads.adoc:286
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:195
#, fuzzy, no-wrap
msgid "Simplifying complex logic"
msgstr "複雑なロジックの簡略化"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:200
#, fuzzy
msgid "The previous example is trivial and doesn't capture how imperative style can simplify complex reactive operations.  Below is a more complex example.  The endpoints must now fetch all the fortunes in the database, then append a quote to each fortune before finally returning the result to the client."
msgstr "先ほどの例は些細なもので、命令型スタイルがいかに複雑なリアクティブ操作を簡略化できるかを理解していません。以下は、もっと複雑な例です。エンドポイントはデータベース内のすべての運勢を取得し、 最後に結果をクライアントに返す前に、それぞれの運勢に引用文を追加しなければなりません。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:222
#, no-wrap
msgid "    private final FortuneRepository repository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:227
#, no-wrap
msgid ""
"    public Uni<List<String>> getQuotesAsync(int size){\n"
"        //...\n"
"        //asynchronously returns a list of quotes from an arbitrary source\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:233
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/quoted-blocking\")\n"
"    public List<Fortune> getAllQuotedBlocking() {\n"
"        // we get the list of fortunes\n"
"        var fortunes = repository.findAllBlocking();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:236
#, no-wrap
msgid ""
"        // we get the list of quotes\n"
"        var quotes = getQuotes(fortunes.size()).await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:243
#, no-wrap
msgid ""
"        // we append each quote to each fortune\n"
"        for(int i=0; i  < fortunes.size();i ++){\n"
"            fortunes.get(i).title+= \"   -  \"+quotes.get(i);\n"
"        }\n"
"        return todos;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:250
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/quoted-reactive\")\n"
"    public Uni<List<Fortune>> getAllQuoted() {\n"
"        // we first fetch the list of resource and we memoize it\n"
"        // to avoid fetching it again everytime need it\n"
"        var fortunes = repository.findAllAsync().memoize().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:254
#, no-wrap
msgid ""
"        // once we get a result for fortunes,\n"
"        // we know its size and can thus query the right number of quotes\n"
"        var quotes = fortunes.onItem().transformToUni(list -> getQuotes(list.size()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:267
#, no-wrap
msgid ""
"        // we now need to combine the two reactive streams\n"
"        // before returning the result to the user\n"
"        return Uni.combine().all().unis(fortunes,quotes).asTuple().onItem().transform(tuple -> {\n"
"            var todoList=tuple.getItem1();\n"
"            //can await it since it is already resolved\n"
"            var quotesList = tuple.getItem2();\n"
"            for(int i=0; i  < todoList.size();i ++){\n"
"                            todoList.get(i).title+= \"   -  \"+quotesList.get(i);\n"
"            }\n"
"            return todoList;\n"
"        });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:274
#, no-wrap
msgid ""
"    @GET\n"
"    @RunOnVirtualThread\n"
"    @Path(\"/quoted-virtual-thread\")\n"
"    public List<Fortune> getAllQuotedBlocking() {\n"
"        //we get the list of fortunes\n"
"        var fortunes = repository.findAllAsyncAndAwait();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:277
#, no-wrap
msgid ""
"        //we get the list of quotes\n"
"        var quotes = getQuotes(fortunes.size()).await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:284
#, no-wrap
msgid ""
"        //we append each quote to each fortune\n"
"        for(int i=0; i  < fortunes.size();i ++){\n"
"            fortunes.get(i).title+= \"   -  \"+quotes.get(i);\n"
"        }\n"
"        return todos;\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:288
#, fuzzy, no-wrap
msgid "Pinning cases"
msgstr "ピン止めのケース"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:292
#, fuzzy
msgid "The notion of \"cheap blocking\" might not always be true: in certain occasions a virtual thread might \"pin\" its carrier (the platform thread it is mounted upon).  In this situation, the platform thread is blocked exactly as it would have been in a typical blocking scenario."
msgstr "仮想スレッドがそのキャリア（マウントされているプラットフォームスレッド）を「ピン留め」する場合があります。この場合、プラットフォームスレッドは通常のブロッキングシナリオと同じようにブロックされます。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:294
#, fuzzy
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr "link:{vthreadjep}[JEP 425に] よると、これは2つの状況で起こりうる。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:296
#, fuzzy
msgid "when a virtual thread executes performs a blocking operation inside a `synchronized` block or method"
msgstr "仮想スレッドが `synchronized` ブロックまたはメソッドの内部でブロック操作を実行するとき。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:297
#, fuzzy
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr "ネイティブメソッドや外部関数内でブロック操作を実行した場合"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:301
#, fuzzy
msgid "It can be fairly easy to avoid these situations in our own code, but it is hard to verify every dependency we use.  Typically, while experimenting with virtual-threads, we realized that using the link:{pgsql-driver}[postgresql-JDBC driver] results in frequent pinning."
msgstr "自分たちのコードでこのような状況を回避するのはかなり簡単ですが、使用する依存関係をすべて検証するのは困難です。典型的な例としては、仮想スレッドの実験をしているときに、 link:{pgsql-driver}[postgresql-JDBC ドライバを] 使うと頻繁に pining が発生することに気づきました。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:302
#, fuzzy, no-wrap
msgid "The JDBC problem"
msgstr "JDBCの問題"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:305
#, fuzzy
msgid "Our experiments so far show that when a virtual thread queries a database using the JDBC driver, it will pin its carrier thread during the entire operation."
msgstr "これまでの実験から、仮想スレッドがJDBCドライバを使ってデータベースに問い合わせを行う場合、その操作の間、仮想スレッドはキャリアスレッドを固定することが分かっています。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:307
#, fuzzy
msgid "Let's show the code of the `findAllBlocking()` method we used in the first example"
msgstr "最初の例で使用した `findAllBlocking()` メソッドのコードを表示してみましょう。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:311
#: upstream/_guides/virtual-threads.adoc:384
#, no-wrap
msgid "//import ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:315
#: upstream/_guides/virtual-threads.adoc:388
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FortuneRepository {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:335
#, no-wrap
msgid ""
"    public List<Fortune> findAllBlocking() {\n"
"        List<Fortune> fortunes = new ArrayList<>();\n"
"        Connection conn = null;\n"
"        try {\n"
"            conn = db.getJdbcConnection();\n"
"            var preparedStatement = conn.prepareStatement(SELECT_ALL);\n"
"            ResultSet rs = preparedStatement.executeQuery();\n"
"            while (rs.next()) {\n"
"                fortunes.add(create(rs));\n"
"            }\n"
"            rs.close();\n"
"            preparedStatement.close();\n"
"        } catch (SQLException e) {\n"
"            logger.warn(\"Unable to retrieve fortunes from the database\", e);\n"
"        } finally {\n"
"           close(conn);\n"
"        }\n"
"        return fortunes;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:338
#: upstream/_guides/virtual-threads.adoc:404
#, no-wrap
msgid ""
"    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:342
#, fuzzy
msgid "The actual query happens at `ResultSet rs = preparedStatement.executeQuery();`, here is how it is implemented in the postgresql-jdbc driver 42.5.0:"
msgstr "実際のクエリは `ResultSet rs = preparedStatement.executeQuery();` で行われます。以下は、postgresql-jdbc ドライバ 42.5.0 で実装されている方法です。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:347
#, no-wrap
msgid ""
"class PgPreparedStatement extends PgStatement implements PreparedStatement {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:364
#, no-wrap
msgid ""
"    /*\n"
"    * A Prepared SQL query is executed and its ResultSet is returned\n"
"    *\n"
"    * @return a ResultSet that contains the data produced by the * query - never null\n"
"    *\n"
"    * @exception SQLException if a database access error occurs\n"
"    */\n"
"    @Override\n"
"    public ResultSet executeQuery() throws SQLException {\n"
"        synchronized (this) {\n"
"            if (!executeWithFlags(0)) {\n"
"                throw new PSQLException(GT.tr(\"No results were returned by the query.\"), PSQLState.NO_DATA);\n"
"            }\n"
"            return getSingleResultSet();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:367
#, no-wrap
msgid ""
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:372
#, fuzzy
msgid "This `synchronized` block is the culprit.  Replacing it with a lock is a good solution, but it won't be enough: `synchronized` blocks are also used in `executeWithFlags(int flag)`.  A systematic review of the postgresql-jdbc driver is necessary to make sure that it is compliant with virtual threads."
msgstr "この `synchronized` のブロックが原因です。ロックに置き換えることは良い解決策ですが、それだけでは十分ではありません。 `synchronized` ブロックは、 `executeWithFlags(int flag)` でも使用されています。postgresql-jdbcドライバが仮想スレッドに準拠していることを確認するために、体系的なレビューが必要である。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:373
#, fuzzy, no-wrap
msgid "Reactive drivers at the rescue"
msgstr "レスキューするリアクティブドライバー"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:378
#, fuzzy
msgid "The vertx-sql-client is a reactive client, hence it is not supposed to block while waiting for the completion of a transaction with the database.  However, when using the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] it is possible to use a variant method that will await for the completion of the transaction, mimicking a blocking behaviour."
msgstr "vertx-sql-client は反応型クライアントであり、データベースとのトランザクションの完了を待っている間はブロックしないことになっています。しかし、 link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] を使用する場合、トランザクションの完了を待つ可変メソッドを使用し、ブロッキングの挙動を模倣することが可能です。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:380
#, fuzzy
msgid "Below is the `FortuneRepository` except the blocking we've seen earlier has been replaced by reactive methods."
msgstr "以下は、先に見たブロッキングがリアクティブメソッドに置き換わっていることを除けば、 `FortuneRepository` 。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:393
#, no-wrap
msgid ""
"    public Uni<List<Fortune>> findAllAsync() {\n"
"        return db.getPool()\n"
"                .preparedQuery(SELECT_ALL).execute()\n"
"                .map(this::createListOfFortunes);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:395
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:401
#, no-wrap
msgid ""
"    public List<Fortune> findAllAsyncAndAwait() {\n"
"        var rows = db.getPool().preparedQuery(SELECT_ALL)\n"
"                .executeAndAwait();\n"
"        return createListOfFortunes(rows);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:408
#, fuzzy
msgid "Contrary to the link:{pgsql-driver}[postgresql-jdbc driver], no `synchronized` block is used where it shouldn't be, and the `await` behaviour is implemented using locks and latches that won't cause pinning."
msgstr "link:{pgsql-driver}[postgresql-jdbcドライバとは] 逆に、 `synchronized` ブロックが使用されるべきではない場所で使用されることはなく、 `await` 動作は、ピンを発生させないロックとラッチを使用して実装されています。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:412
#, fuzzy
msgid "Using the synchronous methods of the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] along with virtual threads will allow you to use the synchronous blocking style, avoid pinning the carrier thread, and get performance close to a pure reactive implementation."
msgstr "link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] の同期メソッドと仮想スレッドを使用することで、同期ブロッキングスタイルを使用し、キャリアスレッドの固定化を回避し、純粋なリアクティブ実装に近い性能を得ることができます。"

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:413
#, fuzzy, no-wrap
msgid "A point about performance"
msgstr "性能に関するポイント"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:419
#, fuzzy
msgid "Our experiments seem to indicate that Quarkus with virtual threads will scale better than Quarkus blocking (offloading the computation on a pool of platform worker threads) but not as well Quarkus reactive.  The memory consumption especially might be an issue: if your system needs to keep its memory footprint low we would advise you stick to using reactive constructs."
msgstr "我々の実験では、仮想スレッドを使用したQuarkusは、Quarkus blocking（プラットフォームワーカスレッドのプールに計算をオフロードする）よりも拡張性が高く、Quarkus reactiveほどには拡張性が高くないようです。特にメモリ消費量が問題です。もし、システムがメモリフットプリントを低く抑える必要がある場合は、リアクティブコンストラクトを使用することをお勧めします。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:423
#, fuzzy
msgid "This degradation of performance doesn't seem to come from virtual threads themselves but from the interactions between Vert.x/Netty (Quarkus underlying reactive engine) and the virtual threads.  This was illustrated in the issue that we will now describe."
msgstr "この性能低下は、仮想スレッドそのものではなく、Vert.x/Netty（Quarkusの基盤となる反応エンジン）と仮想スレッドの間の相互作用に起因しているようです。このことは、これから説明する問題にも表れています。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:424
#, fuzzy, no-wrap
msgid "The Netty problem"
msgstr "ネティ問題"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:429
#, fuzzy
msgid "For JSON serialization, Netty uses their custom implementation of thread locals, `FastThreadLocal` to store buffers.  When using virtual threads in quarkus, then number of virtual threads simultaneously living in the service is directly related to the incoming traffic.  It is possible to get hundreds of thousands, if not millions, of them."
msgstr "JSONのシリアライゼーションでは、Nettyはスレッドローカルのカスタム実装を使用しています。 `FastThreadLocal` 、バッファを保存します。Quarkusで仮想スレッドを使用する場合、サービス内に同時に存在する仮想スレッドの数は、受信するトラフィックに直接関係します。数百万とまではいかなくても、数十万はあり得ます。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:433
#, fuzzy
msgid "If they need to serialize some data to JSON they will end up creating as many instances of `FastThreadLocal`, resulting on a massive memory consumption as well as exacerbated pressure on the garbage collector.  This will eventually affect the performance of the application and inhibit its scalability."
msgstr "もし、データをJSONにシリアライズする必要がある場合、 `FastThreadLocal` のインスタンスを多数作成することになり、結果として、大量のメモリを消費し、ガベージコレクタにかかる負担も大きくなってしまいます。これは最終的にアプリケーションの性能に影響を与え、スケーラビリティを阻害することになります。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:440
#, fuzzy
msgid "This is a perfect example of the mismatch between the reactive stack and the virtual threads.  The fundamental hypothesis are completely different and result in different optimizations.  Netty expects a system using few event-loops (as many event-loops as CPU cores by default in Quarkus), but it gets hundreds of thousands of threads.  You can refer to link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[this mail] to get more information on how we envision our future with virtual threads."
msgstr "これは、リアクティブスタックと仮想スレッドのミスマッチの好例である。根本的な仮説が全く異なるため、結果として最適化も異なってきます。Nettyは少数のイベントループ（QuarkusのデフォルトではCPUコアと同数のイベントループ）を使用するシステムを想定していますが、何十万ものスレッドを取得します。私たちが仮想スレッドを使ってどのような未来を描いているかについては、 link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[このメールを] 参照してください。"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:441
#, fuzzy, no-wrap
msgid "Our solution to the Netty problem"
msgstr "Netty問題に対する我々の解決策"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:446
#, fuzzy
msgid "In order to avoid this wasting of resource without modifying Netty upstream, we wrote an extension that modifies the bytecode of the class responsible for creating the thread locals at build time.  Using this extension, performance of virtual threads in Quarkus for the Json Serialization test of the Techempower suite increased by nearly 80%, making it almost as good as reactive endpoints."
msgstr "Nettyの上流に手を加えることなくこのリソースの浪費を避けるために、ビルド時にスレッドローカルの作成を担当するクラスのバイトコードを変更する拡張機能を書きました。この拡張機能を使うと、TechempowerスイートのJson SerializationテストにおけるQuarkusの仮想スレッドのパフォーマンスが80%近く向上し、リアクティブエンドポイントとほぼ同等になりました。"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:448
#, fuzzy
msgid "To use it, it needs to be added as a dependency:"
msgstr "使用するには、依存関係として追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:456
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-netty-loom-adaptor</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:459
msgid "Furthermore, some operations undertaken by this extension need special access, it is necessary to"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:461
msgid "compile the application with the flag `-Dnet.bytebuddy.experimental`"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:462
msgid "open the `java.base.lang` module at runtime with the flag `--add-opens java.base/java.lang=ALL-UNNAMED`"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:464
msgid "This extension is only intended to improve performance, it is perfectly fine not to use it."
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:465
#, no-wrap
msgid "Concerning dev mode"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:468
msgid "If you want to use quarkus with the dev mode, it won't be possible to manually specify the flags we mentioned along this guide.  Instead, you want to specify them all in the configuration of the `quarkus-maven-plugin` as presented below."
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:483
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-maven-plugin</artifactId>\n"
"    <version>${quarkus.version}</version>\n"
"    <executions>\n"
"        <execution>\n"
"            <goals>\n"
"                <goal>build</goal>\n"
"            </goals>\n"
"        </execution>\n"
"    </executions>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:493
#, no-wrap
msgid ""
"    <configuration>\n"
"      <source>19</source>\n"
"      <target>19</target>\n"
"      <compilerArgs>\n"
"        <arg>--enable-preview</arg>\n"
"        <arg>-Dnet.bytebuddy.experimental</arg>\n"
"      </compilerArgs>\n"
"      <jvmArgs>--enable-preview --add-opens java.base/java.lang=ALL-UNNAMED</jvmArgs>\n"
"    </configuration>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:495
#, no-wrap
msgid "</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:499
msgid "If you don't want to put specify the opening the `java.lang` module in your pom.xml file, you can also specify it as an argument when you start the dev mode."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:501
msgid "The configuration of the quarkus-maven-plugin will be simpler:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:514
#, no-wrap
msgid ""
"    <configuration>\n"
"      <source>19</source>\n"
"      <target>19</target>\n"
"      <compilerArgs>\n"
"        <arg>--enable-preview</arg>\n"
"        <arg>-Dnet.bytebuddy.experimental</arg>\n"
"      </compilerArgs>\n"
"      <jvmArgs>--enable-preview</jvmArgs>\n"
"    </configuration>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:517
msgid "And the command will become:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:521
#, no-wrap
msgid "mvn quarkus:dev -Dopen-lang-package\n"
msgstr ""
