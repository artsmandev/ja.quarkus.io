# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2022-02-04 01:49+0900\n"
"PO-Revision-Date: 2022-02-05 01:20+0900\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.0.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/native-reference.adoc:6
#, no-wrap
msgid "Native Reference Guide"
msgstr "ネイティブリファレンスガイド"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:14
msgid "This guide is a companion to the xref:building-native-image.adoc[Building a Native Executable], xref:native-and-ssl.adoc[Using SSL With Native Images], and xref:writing-native-applications-tips.adoc[Writing Native Applications], guides.  It provides further details to debugging issues in Quarkus native executables that might arise during development or production."
msgstr "このガイドは、 xref:building-native-image.adoc[ネイティブ実行可能ファイルのビルド]、 xref:native-and-ssl.adoc[ネイティブイメージでのSSLの使用]、 xref:writing-native-applications-tips.adoc[ネイティブアプリケーションの作成]の各ガイドに付随するものです。このガイドでは、開発時や本番時に発生する可能性のあるQuarkusのネイティブ実行可能ファイルの問題をデバッグするための詳細を説明しています。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:16
msgid "This reference guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide]."
msgstr "このリファレンスガイドは、 link:getting-started.html[入門ガイド]で開発されたアプリケーションを入力としています。"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:17
#, no-wrap
msgid "Requirements and Assumptions"
msgstr "要件と前提条件"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:23
msgid "Debugging Quarkus native executables experience is best done within a Linux environment.  Root access is not needed except to install packages required to run some debug steps, or to enable `perf` to gather events at the kernel.  Debugging in macOS and Windows environments also works in a container environment (see <<macwindows,FAQ entry>>)."
msgstr "Quarkusのネイティブ実行可能ファイルのデバッグは、Linux環境で行うのが最適です。一部のデバッグ手順を実行するために必要なパッケージをインストールする場合や、 `perf` でカーネルのイベントを収集できるようにする場合を除き、ルートアクセスは必要ありません。macOSやWindows環境でのデバッグは、コンテナ環境でも機能します（ link:#macwindows[FAQエントリ]を参照）。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:25
msgid "These are the packages you'll need on your Linux environment to run through the different debugging sections:"
msgstr "これらのパッケージは、様々なデバッグの節を実行するために、Linux環境で必要となるものです。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:32
#, no-wrap
msgid ""
"# dnf (rpm-based)\n"
"sudo dnf install binutils gdb perf perl-open\n"
"# Debian-based distributions:\n"
"sudo apt install binutils gdb perf\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:35
msgid "Aside from system level packages, you'll need:"
msgstr "システムレベルのパッケージの他に、以下が必要です:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:37
msgid "JDK 11 installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 11 がインストールされ、 `JAVA_HOME`  が適切に設定されていること"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:38
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:39
msgid "A working container runtime (Docker, podman)"
msgstr "動作するコンテナーランタイム(Docker, podman)"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:40
msgid "The code of the application developed in the xref:getting-started.adoc[Getting Started Guide]."
msgstr "xref:getting-started.adoc[入門ガイド]で開発したアプリケーションのコード"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:43
msgid "Finally, this guide assumes the use of the Mandrel distribution of GraalVM for building native executables, and these are built within a container."
msgstr "最後に、このガイドでは、ネイティブ実行可能ファイルをビルドするために、GraalVMのMandrelディストリビューションの使用を想定しており、これらはコンテナ内でビルドされます。"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:44
#, no-wrap
msgid "First Debugging Steps"
msgstr "デバッグの最初のステップ"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:47
msgid "As a first step, build the native executable for the application:"
msgstr "まず最初のステップとして、アプリケーションのネイティブ実行可能ファイルをビルドします。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:52
#: upstream/_guides/native-reference.adoc:407
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:55
msgid "Run the application to verify it works as expected. In one terminal:"
msgstr "アプリケーションを実行して、期待通りに動作することを確認します。一つのターミナルで以下を実行します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:59
#: upstream/_guides/native-reference.adoc:414
#, no-wrap
msgid "./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:62
msgid "In another:"
msgstr "別のターミナルで以下を実行します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:66
#, no-wrap
msgid "curl http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:69
msgid "We can obtain basic extra information while building the native executable by adding additional native-image build options using `-Dquarkus.native.additional-build-args`, e.g."
msgstr "ネイティブ実行可能ファイルをビルドする際に `-Dquarkus.native.additional-build-args` というネイティブイメージのビルドオプションを追加することで、基本的な追加情報を得ることができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:75
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:78
msgid "Executing that will produce additional output lines like this:"
msgstr "これを実行すると、次のような追加の出力行が得られます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:85
#, no-wrap
msgid ""
"...\n"
"# Printing compilation-target information to: /project/reports/target_info_20211115_094828.txt\n"
"…\n"
"# Printing native-library information to: /project/reports/native_library_info_20211115_094841.txt\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:90
msgid "The target info file contains information such as the target platform, the toolchain used to compile the executable, and the C library in use:"
msgstr "ターゲット情報ファイルには、ターゲットプラットフォーム、実行ファイルのコンパイルに使用されたツールチェーン、使用されているCライブラリなどの情報が含まれています。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:102
#, no-wrap
msgid ""
"$ cat target/*/reports/target_info_*.txt\n"
"Building image for target platform: org.graalvm.nativeimage.Platform$LINUX_AMD64\n"
"Using native toolchain:\n"
"   Name: GNU project C and C++ compiler (gcc)\n"
"   Vendor: redhat\n"
"   Version: 8.5.0\n"
"   Target architecture: x86_64\n"
"   Path: /usr/bin/gcc\n"
"Using CLibrary: com.oracle.svm.core.posix.linux.libc.GLib\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:105
msgid "The native library info file contains information on the static libraries added to the binary and the other libraries dynamically linked to the executable:"
msgstr "ネイティブライブラリ情報ファイルには、バイナリに追加されるスタティックライブラリと、実行ファイルに動的にリンクされるその他のライブラリの情報が含まれています。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:120
#, no-wrap
msgid ""
"$ cat target/*/reports/native_library_info_*.txt\n"
"Static libraries:\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/liblibchelper.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libextnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnio.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libjava.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libfdlibm.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libsunec.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libzip.a\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/libjvm.a\n"
"Other libraries: stdc++,pthread,dl,z,rt\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:125
msgid "Even more detail can be obtained by passing in `--verbose` as an additional native-image build argument.  This option can be very useful in detecting whether the options that you pass at a high level via Quarkus are being passed down to the native executable production, or whether some third party jar has some native-image configuration embedded in it that is reaching the native-image invocation:"
msgstr "ネイティブイメージビルドの追加引数として `--verbose` を渡すことで、さらに詳細な情報を得ることができます。このオプションは、Quarkusを介して高いレベルで渡されたオプションがネイティブ実行可能ファイルの生成に渡されているのか、あるいはサードパーティのjarにネイティブイメージの設定が埋め込まれていて、それがネイティブイメージの呼び出しに届いているのかを検出するのに非常に役立ちます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:131
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=--verbose\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:134
msgid "Running with `--verbose` demonstrates how the native-image building process is two sequential java processes:"
msgstr "`--verbose` で実行すると、ネイティブイメージのビルドプロセスが2つの連続したJavaプロセスであることが分かります。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:137
msgid "The first is a very short Java process that does some basic validation and builds the arguments for the second process (in a stock GraalVM distribution, this is executed as native code)."
msgstr "1番目は非常に短いJavaプロセスで、基本的な検証を行い、2つ目のプロセスのための引数を組み立てます（GraalVMの純正ディストリビューションでは、これはネイティブコードとして実行されます）。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:140
msgid "The second Java process is where the main part of the native executable production happens.  The `--verbose` option shows the actual Java process executed.  You could take the output and run it yourself."
msgstr "2番目のJavaプロセスでは、ネイティブ実行可能ファイル作成の主要部分が行われます。 `--verbose` オプションは、実際に実行されたJavaプロセスを表示します。出力を受けて、自分で実行することもできます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:142
msgid "One may also combine multiple native build options by separating with a comma, e.g.:"
msgstr "また、複数のネイティブ・ビルド・オプションをコンマで区切って組み合わせることもできます。例:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:148
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info,--verbose\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:154
msgid "Remember that if an argument for `-Dquarkus.native.additional-build-args` includes the `,` symbol, it needs to be escaped to be processed correcly, e.g. `\\\\,`."
msgstr "`-Dquarkus.native.additional-build-args` の引数に `,` シンボルが含まれている場合、正しく処理するためには、 `\\\\,` のようにエスケープする必要があることを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:157
msgid "Given a native executable, various Linux tools can be used to inspect it."
msgstr "ネイティブ実行可能ファイルに対して、様々なLinuxツールを使って検査することができます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:159
msgid "`ldd` shows the shared library dependencies of an executable:"
msgstr "`ldd` は、実行可能ファイルの共有ライブラリの依存関係を表示します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:163
#, no-wrap
msgid "ldd ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:166
msgid "`strings` can be used to look for text messages inside the binary:"
msgstr "`strings` は、バイナリ内のテキストメッセージを探すのに使用できます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:170
#, no-wrap
msgid "strings ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep Hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:173
msgid "Using `strings` you can also get Mandrel information given the binary:"
msgstr "`strings` を使えば、指定されたバイナリのMandrel情報を得ることもできます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:177
#, no-wrap
msgid "strings ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep core.VM\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:181
msgid "Finally, using `readelf` we can inspect different sections of the binary.  For example, we can see how the heap and text sections take most of binary:"
msgstr "最後に、 `readelf` を使って、バイナリのさまざまなセクションを調べることができます。例えば、ヒープセクションとテキストセクションがバイナリの大半を占めていることがわかります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:185
#, no-wrap
msgid "readelf -SW ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/native-reference.adoc:187
#, no-wrap
msgid "Native Reports"
msgstr "ネイティブレポート"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:190
msgid "Optionally, the native build process can generate reports that show what goes into the binary:"
msgstr "オプションとして、ネイティブビルドプロセスでは、バイナリに何が入っているかを示すレポートを生成することができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:196
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.enable-reports\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:200
msgid "The reports will be created under `target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/reports/`.  These reports are some of the most useful resources when encountering issues with missing methods/classes, or encountering forbidden methods by Mandrel."
msgstr "このレポートは `target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/reports/` の下に作成されます。これらのレポートは、メソッドやクラスが見つからない問題や、Mandrelで禁止されているメソッドに遭遇したときに、最も役に立つリソースの一部です。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:201
#, no-wrap
msgid "Call Tree Reports"
msgstr "コールツリーレポート"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:206
msgid "`call_tree` text file report is one of the default reports generated when the `-Dquarkus.native.enable-reports` option is passed in.  This is useful for getting an approximation on why a method/class is included in the binary.  However, the text format makes it very difficult to read and can take up a lot of space."
msgstr "`call_tree` テキストファイルレポートは、 `-Dquarkus.native.enable-reports` オプションが渡されたときに生成されるデフォルトのレポートの1つです。これは、あるメソッド/クラスがなぜバイナリに含まれているのかについて、おおよその見当をつけるのに便利です。しかし、テキスト形式のため非常に読みづらく、多くのスペースを必要とします。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:211
msgid "Since Mandrel 21.3.0.0-Final, the call tree is also reported as a group of CSV files.  These can in turn be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  Let’s see this in action."
msgstr "Mandrel 21.3.0.0-Final以降、コールツリーはCSVファイルのグループとしても報告されるようになりました。これらは、Neo4jなどのグラフデータベースにインポートすることで、より簡単に検査したり、コールツリーに対するクエリを実行したりすることができます。では、実際に使ってみましょう。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:213
msgid "First, start a Neo4j instance:"
msgstr "まず、Neo4jのインスタンスを起動します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:224
#, no-wrap
msgid ""
"export NEO_PASS=...\n"
"podman run \\\n"
"  --detach \\\n"
"  --rm \\\n"
"  --name testneo4j \\\n"
"  -p7474:7474 -p7687:7687 \\\n"
"  --env NEO4J_AUTH=neo4j/${NEO_PASS} \\\n"
"  neo4j:latest\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:229
msgid "Once the container is running, you can access the Neo4j browser via http://localhost:7474.  Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr "コンテナが起動したら、 http://localhost:7474  から Neo4j ブラウザにアクセスできます。ユーザー名には `neo4j` を、パスワードには `NEO_PASS` の値を使用してログインします。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:232
msgid "To import the CSV files, we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr "CSVファイルをインポートするためには、CSVファイル内のデータをインポートし、グラフデータベースのノードとエッジを作成する以下のcypherスクリプトが必要です。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:237
#, no-wrap
msgid ""
"CREATE CONSTRAINT unique_vm_id ON (v:VM) ASSERT v.vmId IS UNIQUE;\n"
"CREATE CONSTRAINT unique_method_id ON (m:Method) ASSERT m.methodId IS UNIQUE;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:241
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_vm.csv' AS row\n"
"MERGE (v:VM {vmId: row.Id, name: row.Name})\n"
"RETURN count(v);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:245
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:249
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_virtual_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:255
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_entry_points.csv' AS row\n"
"MATCH (m:Method {methodId: row.Id})\n"
"MATCH (v:VM {vmId: '0'})\n"
"MERGE (v)-[:ENTRY]->(m)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:261
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_direct_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:DIRECT {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:267
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_override_by_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:OVERRIDEN_BY]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:273
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/csv_call_tree_virtual_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:VIRTUAL {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:276
msgid "Copy and paste the contents of the script into a file called `import.cypher`."
msgstr "スクリプトの内容を `import.cypher` というファイルにコピー＆ペーストします。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:278
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr "次に、インポートサイファースクリプトとCSVファイルをNeo4jのインポートフォルダにコピーします。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:284
#, no-wrap
msgid ""
"podman cp \\\n"
"    target/*-native-image-source-jar/reports \\\n"
"    testneo4j:/var/lib/neo4j/import\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:286
#, no-wrap
msgid "podman cp import.cypher testneo4j:/var/lib/neo4j\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:289
msgid "After copying all the files, invoke the import script:"
msgstr "すべてのファイルをコピーしたら、インポートスクリプトを起動します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:293
#, no-wrap
msgid "podman exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} -f import.cypher\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:297
msgid "Once the import completes (shouldn't take more than a couple of minutes), go to the Neo4j browser, and you'll be able to observe a small summary of the data in the graph:"
msgstr "インポートが完了したら（数分以上はかからないはず）、Neo4jブラウザにアクセスして、データの小さなサマリーをグラフで見ることができます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:299
#, fuzzy
msgid "image:native-reference-neo4j-db-info.png[Neo4j database information after import]"
msgstr "image:native-reference-neo4j-db-info.png[alt=Neo4j database information after import]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:303
msgid "The data above shows that there are ~60000 methods, and just over ~200000 edges between them.  The Quarkus application demonstrated here is very basic, so there’s not a lot we can explore, but here are some example queries you can run to explore the graph in more detail.  Typically, you’d start by looking for a given method:"
msgstr "上のデータでは、~60000のメソッドがあり、それらの間には~200000のエッジがあることがわかります。ここでデモされているQuarkusアプリケーションは非常に基本的なものなので、調べられることは多くありませんが、グラフをより詳細に調べるために実行できるクエリの例をいくつか紹介します。典型的な例としては、あるメソッドを探すことから始めます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:307
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:310
msgid "From there, you can narrow down to a given method on a specific type:"
msgstr "そこから、特定の型の特定のメソッドに絞ることができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:314
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:321
msgid "Once you’ve located the node for the specific method you’re after, a typical question you’d want to get an answer for is: why does this method get included in the call tree? To do that, start from the method and look for incoming connections at a given depth, starting from the end method.  For example, methods that directly call a method can be located via:"
msgstr "探している特定のメソッドのノードを見つけたら、答えを得たい典型的な質問は、「なぜこのメソッドはコールツリーに含まれるのか」です。そのためには、終点のメソッドから始まる所定の深さの到着接続を探します。たとえば、あるメソッドを直接呼び出すメソッドは、以下のようにして見つけることができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:325
#, no-wrap
msgid "match (m:Method) <- [*1..1] - (o) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:329
msgid "Then you can look for direct calls at depth of 2, so you’d search for methods that call methods that call into the target method:"
msgstr "そうすれば、深さ2の直接呼び出しを探すことができます。つまり、対象のメソッドを呼び出すメソッドを呼び出すメソッドを探すことになります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:333
#, no-wrap
msgid "match (m:Method) <- [*1..2] - (o) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:339
msgid "You can continue going up layers, but unfortunately if you reach a depth with too many nodes, the Neo4j browser will be unable to visualize them all.  When that happens, you can alternatively run the queries directly against the cypher shell:"
msgstr "階層を上がっていくことはできますが、残念ながらノードの数が多すぎる深度に到達すると、Neo4jブラウザはそれらすべてを可視化することができません。そのような場合は、代わりにcypher shellに対して直接クエリを実行することができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:344
#, no-wrap
msgid ""
"podman exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \\\n"
"  \"match (m:Method) <- [*1..10] - (o) where m.name = 'hello' return *\"\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:346
#, no-wrap
msgid "Used Packages/Classes/Methods Reports"
msgstr "使用されているパッケージ/クラス/メソッドのレポート"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:350
msgid "`used_packages`, `used_classes` and `used_methods` text file reports come in handy when comparing different versions of the application, e.g. why does the image take longer to build? Or why is the image bigger now?"
msgstr "`used_packages`, `used_classes`, `used_methods` テキストファイルレポートは、アプリケーションの異なるバージョンを比較する際に便利です。例えば、イメージ作成に時間がかかるのはなぜか？また、なぜイメージが大きくなったのか？"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:351
#, no-wrap
msgid "Further Reports"
msgstr "更なるレポート"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:355
msgid "Mandrel can produce further reports beyond the ones that are enabled with the `-Dquarkus.native.enable-reports` option.  These are called expert options and you can learn more about them by running:"
msgstr "Mandrelは、 `-Dquarkus.native.enable-reports` オプションで有効になっているレポート以外にも、様々なレポートを作成することができます。これらはエキスパートオプションと呼ばれ、以下を実行することで詳細を知ることができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:359
#, no-wrap
msgid "podman run quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} --expert-options-all\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:362
msgid "To use these expert options, add them comma separated to the `-Dquarkus.native.additional-build-args` parameter."
msgstr "これらのエキスパートオプションを使用するには、 `-Dquarkus.native.additional-build-args` パラメータにコンマで区切って追加します。"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:363
#, no-wrap
msgid "Build-time vs Run-time Initialization"
msgstr "ビルド時と実行時の初期化"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:370
msgid "Quarkus instructs Mandrel to initialize as much as possible at build time, so that runtime startup can be as fast as possible.  This is important in containerized environments where the startup speed has a big impact on how quickly an application is ready to do work.  Build time initialization also minimizes the risk of runtime failures due to unsupported features becoming reachable through runtime initialization, thus making Quarkus more reliable."
msgstr "QuarkusはMandrelに対し、ビルド時に可能な限り初期化するよう指示し、実行時の起動を可能な限り高速化しています。これは、起動速度がアプリケーションの動作準備の早さに大きな影響を与えるコンテナ環境では重要です。また、ビルド時の初期化は、サポートされていない機能が実行時の初期化によって到達可能になることによる実行時の失敗のリスクを最小限にし、Quarkusの信頼性を高めています。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:374
msgid "The most common examples of build-time initialized code are static variables and blocks.  Although Mandrel executes those at run-time by default, Quarkus instructs Mandrel to run them at build-time for the reasons given."
msgstr "ビルド時に初期化されるコードの最も一般的な例は、静的変数とブロックです。Mandrelはこれらをデフォルトでは実行時に実行しますが、Quarkusでは先程の理由でビルド時に実行するように指示しています。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:378
msgid "This means that any static variables initialized inline, or initialized in a static block, will keep the same value even if the application is restarted.  This is a different behaviour compared to what would happen if executed as Java."
msgstr "つまり、インラインで初期化されたスタティック変数や、スタティックブロックで初期化されたスタティック変数は、アプリケーションを再起動しても同じ値を維持します。これは、Javaとして実行した場合とは異なる動作です。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:381
msgid "To see this in action with a very basic example, modify the `GreetingResource` in the application to look like this:"
msgstr "非常に基本的な例で動作を確認するために、アプリケーションの `GreetingResource` を以下のように変更します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:386
#: upstream/_guides/native-reference.adoc:485
#: upstream/_guides/native-reference.adoc:583
#: upstream/_guides/native-reference.adoc:753
#: upstream/_guides/native-reference.adoc:884
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:388
#, no-wrap
msgid "    static long firstAccess;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:392
#, no-wrap
msgid ""
"    static {\n"
"        firstAccess = System.currentTimeMillis();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:399
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello RESTEasy, first accessed: \" + firstAccess;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:402
msgid "Rebuild the binary using:"
msgstr "次のようにバイナリを再ビルドします。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:410
msgid "Run the application in one terminal:"
msgstr "ターミナルでアプリケーションを実行します。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:417
msgid "Send a `GET` request multiple times from another terminal:"
msgstr "別のターミナルから `GET` リクエストを複数回送信してみましょう。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:421
#, no-wrap
msgid "curl http://localhost:8080/hello # run this multiple times\n"
msgstr "curl http://localhost:8080/hello # 複数回実行してみましょう\n"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:426
msgid "to see how the current time has been baked into the binary.  This time was calculated when the binary was being built, hence application restarts have no effect."
msgstr "現在の時刻がどのようにバイナリに焼き付けられているかを確認できます。この時刻は、バイナリのビルド時に計算されたものなので、アプリケーションの再起動が影響しません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:430
msgid "In some situations, built time initializations can lead to errors when building native executables.  One example is when a value gets computed at build time which is forbidden to reside in the heap of the JVM that gets baked into the binary.  To see this in action, add this example to the same package as the REST resource:"
msgstr "場合によっては、ビルド時の初期化がネイティブ実行可能ファイルのビルド時にエラーを引き起こすことがあります。例えば、バイナリに焼きこまれるJVMのヒープに存在することが禁止されている値が、ビルド時に計算された場合です。この現象を確認するには、この例をRESTリソースと同じパッケージに追加します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:434
#: upstream/_guides/native-reference.adoc:738
#: upstream/_guides/native-reference.adoc:873
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:441
#, no-wrap
msgid ""
"import javax.crypto.Cipher;\n"
"import javax.crypto.NoSuchPaddingException;\n"
"import java.nio.charset.StandardCharsets;\n"
"import java.security.KeyPair;\n"
"import java.security.KeyPairGenerator;\n"
"import java.security.NoSuchAlgorithmException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:445
#, no-wrap
msgid ""
"class AsymmetricEncryption {\n"
"    static final KeyPairGenerator KEY_PAIR_GEN;\n"
"    static final Cipher CIPHER;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:450
#, no-wrap
msgid ""
"    static {\n"
"        try {\n"
"            KEY_PAIR_GEN = KeyPairGenerator.getInstance(\"RSA\");\n"
"            KEY_PAIR_GEN.initialize(1024);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:456
#, no-wrap
msgid ""
"            CIPHER = Cipher.getInstance(\"RSA\");\n"
"        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:460
#, no-wrap
msgid ""
"    static String encryptDecrypt(String msg) {\n"
"        try {\n"
"            KeyPair keyPair = KEY_PAIR_GEN.generateKeyPair();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:462
#, no-wrap
msgid "            byte[] text = msg.getBytes(StandardCharsets.UTF_8);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:466
#, no-wrap
msgid ""
"            // Encrypt with private key\n"
"            CIPHER.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());\n"
"            byte[] encrypted = CIPHER.doFinal(text);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:470
#, no-wrap
msgid ""
"            // Decrypt with public key\n"
"            CIPHER.init(Cipher.DECRYPT_MODE, keyPair.getPublic());\n"
"            byte[] unencrypted = CIPHER.doFinal(encrypted);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:477
#, no-wrap
msgid ""
"            return new String(unencrypted, StandardCharsets.UTF_8);\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:480
msgid "Then, replace the `GreetingResource` code for the following:"
msgstr "そして、 `GreetingResource` のコードを以下のように置き換えます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:492
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return AsymmetricEncryption.encryptDecrypt(\"Hello RESTEasy\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:495
msgid "When trying to rebuild the application, you’ll encounter an error:"
msgstr "アプリケーションを再ビルドしようとすると、エラーが発生します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:519
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"    reading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"   \t constant java.security.KeyPairGenerator$Delegate@491aefd7 reached by\n"
"    scanning method org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"Call path from entry point to org.acme.AsymmetricEncryption.encryptDecrypt(String):\n"
"    at org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"    at org.acme.GreetingResource.hello(GreetingResource.java:14)\n"
"    at com.oracle.svm.reflect.GreetingResource_hello_116f4f3295793f67a71f7bce0a46ea6d6055545a_85.invoke(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.reflect.Method.invoke(Method.java:566)\n"
"    at org.jboss.resteasy.core.ContextParameterInjector$GenericDelegatingProxy.invoke(ContextParameterInjector.java:166)\n"
"    at com.sun.proxy.$Proxy193.toString(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.String.valueOf(String.java:2951)\n"
"    at java.base@11.0.12/java.lang.StringBuilder.append(StringBuilder.java:168)\n"
"    at java.base@11.0.12/java.net.Proxy.<init>(Proxy.java:95)\n"
"    at com.oracle.svm.jni.JNIJavaCallWrappers.jniInvoke_VARARGS:Ljava_net_Proxy_2_0002e_0003cinit_0003e_00028Ljava_net_Proxy_00024Type_2Ljava_net_SocketAddress_2_00029V(generated:0)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:525
msgid "So, what the message above is telling us is that our application references a `KeyPairGenerator$Delegate` instance which contains a `SecureRandom` instance.  This is not desirable because something that's supposed to be random is no longer so, because the seed is baked in the image.  As a next step, we'd like to know what is causing such instances to be left in the heap image."
msgstr "さて、上記のメッセージは、私たちのアプリケーションが `KeyPairGenerator$Delegate` のインスタンスを参照し、そのインスタンスに `SecureRandom` のインスタンスが含まれていることを示しています。これは好ましいことではありません。というのも、シードがイメージに組み込まれているため、ランダムであるはずのものがそうではなくなってしまうからです。次のステップとして、何が原因でこのようなインスタンスがヒープイメージに残っているのかを知りたいと思います。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:527
msgid "We could try again adding option to track object instantiation:"
msgstr "オブジェクトのインスタンス化を追跡するオプションを追加して、もう一度試してみましょう。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:557
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=\"--trace-object-instantiation=java.security.SecureRandom\"\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
"\t at java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"    at sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"    at sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"    at com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"    reading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"   \t constant java.security.KeyPairGenerator$Delegate@7725180c reached by\n"
"    scanning method org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"Call path from entry point to org.acme.AsymmetricEncryption.encryptDecrypt(String):\n"
"    at org.acme.AsymmetricEncryption.encryptDecrypt(AsymmetricEncryption.java:27)\n"
"    at org.acme.GreetingResource.hello(GreetingResource.java:14)\n"
"    at com.oracle.svm.reflect.GreetingResource_hello_116f4f3295793f67a71f7bce0a46ea6d6055545a_54.invoke(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.reflect.Method.invoke(Method.java:566)\n"
"    at org.jboss.resteasy.core.ContextParameterInjector$GenericDelegatingProxy.invoke(ContextParameterInjector.java:166)\n"
"    at com.sun.proxy.$Proxy193.toString(Unknown Source)\n"
"    at java.base@11.0.12/java.lang.String.valueOf(String.java:2951)\n"
"    at java.base@11.0.12/java.lang.StringBuilder.append(StringBuilder.java:168)\n"
"    at java.base@11.0.12/java.net.Proxy.<init>(Proxy.java:95)\n"
"    at com.oracle.svm.jni.JNIJavaCallWrappers.jniInvoke_VARARGS:Ljava_net_Proxy_2_0002e_0003cinit_0003e_00028Ljava_net_Proxy_00024Type_2Ljava_net_SocketAddress_2_00029V(generated:0)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:564
msgid "What does `DnsClient` have to do with our example? The key is in what happens inside `KeyPairGenerator.initialize()` method call.  It uses `JCAUtil.getSecureRandom()` which is why this is problematic, but sometimes the tracing options can show some stack traces that do not represent what happens in reality.  The best option is to dig through the source code and use tracing output for guidance but not as full truth."
msgstr "`DnsClient` は今回の例とどう関係があるのでしょうか？鍵となるのは、 `KeyPairGenerator.initialize()` メソッドコールの内部で起こることです。 `JCAUtil.getSecureRandom()` を使用していることが問題となっていますが、トレースオプションでは、実際に起こっていることを表さないスタックトレースが表示されることがあります。ベストの方法は、ソースコードを調査し、トレース出力を完全な真実ではなく、ガイダンスとして使用することです。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:566
msgid "Moving the `KEY_PAIR_GEN.initialize(1024);` call to the run-time executed method `encryptDecrypt` is enough to solve this particular issue."
msgstr "`KEY_PAIR_GEN.initialize(1024);` の呼び出しを、実行時に実行されるメソッド `encryptDecrypt` に移すことで、この特定の問題を解決できます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:568
msgid "Additional information on which classes are initialized and why can be obtained by passing in the `-H:+PrintClassInitialization` flag via `-Dquarkus.native.additional-build-args`."
msgstr "どのクラスがどのように初期化されるかについての追加情報は、 `-Dquarkus.native.additional-build-args` を通じて `-H:+PrintClassInitialization` フラグを渡すことで得ることができます。"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:569
#, no-wrap
msgid "Profile Runtime Behaviour"
msgstr "実行時動作のプロファイリング"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:571
#, no-wrap
msgid "Single Thread"
msgstr "シングルスレッド"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:575
msgid "In this exercise, we profile the runtime behaviour of some Quarkus application that was compiled to a native executable to determine where the bottleneck is.  Assume that you’re in a scenario where profiling the pure Java version is not possible, maybe because the issue only occurs with the native version of the application."
msgstr "この演習では、ネイティブ実行可能ファイルにコンパイルされたQuarkusアプリケーションの実行時動作をプロファイリングし、ボトルネックがどこにあるかを判断します。問題がアプリケーションのネイティブバージョンでのみ発生するために、純粋なJavaバージョンのプロファイリングができないシナリオを想定しています。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:578
msgid "Replace the GreetingResource implementation with the following code (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "GreetingResourceの実装を以下のコードで置き換えてください（例は link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin氏のJava Profilingのプレゼンテーション]を参考にしています）。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:589
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        sb.append(new char[1_000_000]);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:594
#, no-wrap
msgid ""
"        do {\n"
"            sb.append(12345);\n"
"            sb.delete(0, 5);\n"
"        } while (Thread.currentThread().isAlive());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:598
#, no-wrap
msgid ""
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:601
msgid "Recompile the application, rebuild the binary and run it. Attempting a simple curl will never complete, as expected:"
msgstr "アプリケーションを再コンパイルし、バイナリを再ビルドして実行します。単純なcurlを試みても、期待通り完了しません。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:610
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
"...\n"
"$ ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/hello # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:615
msgid "However, the question we’re trying to answer here is: what would be the bottleneck of such code? Is it appending the characters? Is it deleting it? Is it checking whether the thread is alive?"
msgstr "しかし、ここで私たちが答えようとしているのは、そのようなコードのボトルネックは何か？文字を追加することか？削除していることか？スレッドが生きているかどうかをチェックしていることか？です。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:619
msgid "Since we're dealing with a linux native executable, we can use tools like `perf` directly.  To use `perf`, you either have to be an administrator, or you have to set:"
msgstr "ここでは、linuxのネイティブ実行可能ファイルを扱っているので、 `perf` のようなツールを直接使うことができます。 `perf` を使用するには、管理者になるか、または、以下のように設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:623
#, no-wrap
msgid "echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:626
msgid "Then, we execute:"
msgstr "そして、次を実行します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:630
#: upstream/_guides/native-reference.adoc:1291
#, no-wrap
msgid "perf record -F 1009 -g -a ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:633
msgid "While `perf record` is running, open another window and access the endpoint:"
msgstr "`perf record` の実行中に、別のウィンドウを開き、エンドポイントにアクセスします。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:637
#, no-wrap
msgid "curl http://localhost:8080/hello # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:646
msgid "After a few seconds, halt the `perf record` process.  This will generate a `perf.data` file.  We could use `perf report` to inspect the perf data, but you can often get a better picture showing that data as a flame graph.  To generate flame graphs, checkout the https://github.com/brendangregg/FlameGraph[FlameGraph GitHub repository] locally and export its location via the `FG_HOME` environment variable, e.g."
msgstr "数秒後、 `perf record` のプロセスを停止します。これにより、 `perf.data` ファイルが生成されます。 `perf report` を使用して perf データを検査することもできますが、そのデータをフレームグラフとして表示した方がより的確なイメージが得られることがよくあります。フレームグラフを生成するには、 link:https://github.com/brendangregg/FlameGraph[FlameGraphのGitHubリポジトリ]をローカルでチェックアウトし、その場所を環境変数 `FG_HOME` でエクスポートしてください。例:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:651
#, no-wrap
msgid ""
"export FG_HOME=/tmp/FlameGraph\n"
"git clone https://github.com/brendangregg/FlameGraph ${FG_HOME}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:654
msgid "Then, generate a flame graph using the data captured via `perf record`:"
msgstr "次に、 `perf record` で取得したデータを使ってフレームグラフを作成します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:659
#, no-wrap
msgid ""
"$ perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl > out.perf-folded\n"
"$ ${FG_HOME}/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:663
msgid "The flame graph is an svg file that a web browser, such as Firefox, can easily display.  After the above two commands complete one can open `flamegraph.svg` in their browser:"
msgstr "フレームグラフは、FirefoxなどのWebブラウザで簡単に表示できるsvgファイルです。上記の2つのコマンドが完了すると、ブラウザで `flamegraph.svg` を開くことができます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:665
#, fuzzy
msgid "image:native-reference-perf-flamegraph-no-symbols.png[Perf flamegraph without symbols]"
msgstr "image:native-reference-perf-flamegraph-no-symbols.png[alt=Perf flamegraph without symbols]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:672
msgid "We see a big majority of time spent in what is supposed to be our main, but we see no trace of the `GreetingResource` class, nor the `StringBuilder` class we're calling.  We should look at the symbol table of the binary: can we find symbols for our class and `StringBuilder`? We need those in order to get meaningful data:"
msgstr "メインと思われる部分に大部分の時間が費やされていますが、 `GreetingResource` クラスや、私たちが呼んでいる `StringBuilder` クラスの痕跡は見当たりません。バイナリのシンボルテーブルを見てみましょう。私たちのクラスと `StringBuilder` のシンボルが見つかりますか？意味のあるデータを得るためには、これらのシンボルが必要です。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:677
#, no-wrap
msgid ""
"objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep GreetingResource\n"
"[no output]\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:680
#, no-wrap
msgid ""
"objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"[no output]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:686
msgid "None of those really show anything.  This is why we don't see any call graphs in the flame graphs.  This is a deliberate decision that native-image makes.  By default, it removes symbols from the binary."
msgstr "どれも本当に何も示していません。フレームグラフの中にコールグラフが見当たらないのはそのためです。これはnative-imageが意図的に行っていることです。デフォルトでは、バイナリからシンボルを削除します。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:689
msgid "To regain the symbols, we need to rebuild the binary instructing GraalVM not to delete the symbols.  On top of that, enable DWARF debug info so that the stack traces can be populated with that information:"
msgstr "シンボルを回復するためには、GraalVMにシンボルを削除しないように指示して、バイナリを再ビルドする必要があります。その上で、DWARFのデバッグ情報を有効にして、スタックトレースにその情報を入力できるようにします。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:696
#: upstream/_guides/native-reference.adoc:810
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:700
msgid "Inspect the native executable with `objdump`, and see how the symbols are now present:"
msgstr "`objdump` でネイティブ実行可能ファイルを検査し、シンボルがどのように存在するようになったかを確認します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:704
#, no-wrap
msgid "objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:708
msgid "Then, run the executable through perf, *indicating that the call graph is dwarf*:"
msgstr "次に、実行ファイルを perf で実行すると、 *コールグラフが dwarf であることがわかります*。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:713
#: upstream/_guides/native-reference.adoc:818
#, no-wrap
msgid ""
"perf record -F 1009 --call-graph dwarf -a \\\n"
"  ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:716
msgid "Run the curl command once again, stop the binary, generate the flamegraphs and open it:"
msgstr "もう一度curlコマンドを実行し、バイナリを停止し、フレームグラフを生成して開きます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:721
#: upstream/_guides/native-reference.adoc:826
#, no-wrap
msgid ""
"perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl > out.perf-folded\n"
"${FG_HOME}/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:726
msgid "The flamegraph now shows where the bottleneck is.  It's when `StringBuilder.delete()` is called which calls `System.arraycopy()`.  The issue is that 1 million characters need to be shifted in very small increments:"
msgstr "フレームグラフを見ると、どこがボトルネックになっているかがわかります。それは、 `StringBuilder.delete()` が呼び出され、 `System.arraycopy()` を呼び出すときです。問題は、100万文字を非常に小さな単位でシフトさせる必要があることです。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:728
#, fuzzy
msgid "image:native-reference-perf-flamegraph-symbols.png[Perf flamegraph with symbols]"
msgstr "image:native-reference-perf-flamegraph-symbols.png[alt=Perf flamegraph with symbols]"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:729
#, no-wrap
msgid "Multi-Thread"
msgstr "マルチスレッド"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:734
msgid "Multi-threaded programs might require special attention when trying to understand their runtime behaviour.  To demonstrate this, replace the `GreetingResource` code for the following (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "マルチスレッドのプログラムは、その実行時の動作を理解するために特別な注意が必要な場合があります。このことを説明するために、 `GreetingResource` のコードを以下のように置き換えてみましょう（例は link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin の Java プロファイリングのプレゼンテーション]を参考にしています）。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:750
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.net.InetSocketAddress;\n"
"import java.nio.ByteBuffer;\n"
"import java.nio.channels.DatagramChannel;\n"
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.ThreadFactory;\n"
"import java.util.concurrent.atomic.AtomicInteger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:760
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() throws Exception {\n"
"        sendMulticasts();\n"
"        return \"Complete\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:765
#, no-wrap
msgid ""
"    static void sendMulticasts() throws Exception {\n"
"        DatagramChannel ch = DatagramChannel.open();\n"
"        ch.bind(new InetSocketAddress(5555));\n"
"        ch.configureBlocking(false);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:774
#, no-wrap
msgid ""
"        ExecutorService pool =\n"
"        Executors.newCachedThreadPool(new ShortNameThreadFactory());\n"
"        for (int i = 0; i < 10; i++)\n"
"        {\n"
"            pool.submit(() -> {\n"
"                final ByteBuffer buf = ByteBuffer.allocateDirect(1000);\n"
"                final InetSocketAddress remoteAddr =\n"
"                        new InetSocketAddress(\"127.0.0.1\", 5556);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:782
#, no-wrap
msgid ""
"                while (true)\n"
"                {\n"
"                    buf.clear();\n"
"                    ch.send(buf, remoteAddr);\n"
"                }\n"
"            });\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:785
#, no-wrap
msgid ""
"        System.out.println(\"Warming up...\");\n"
"        Thread.sleep(3000);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:789
#, no-wrap
msgid ""
"        System.out.println(\"Benchmarking...\");\n"
"        Thread.sleep(5000);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:791
#, no-wrap
msgid "    private static final class ShortNameThreadFactory implements ThreadFactory {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:794
#, no-wrap
msgid ""
"        private final AtomicInteger threadNumber = new AtomicInteger(1);\n"
"        private final String namePrefix = \"thread-\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:800
#, no-wrap
msgid ""
"        public Thread newThread(Runnable r) {\n"
"            return new Thread(r, namePrefix + threadNumber.getAndIncrement());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:803
msgid "Build the native executable with debug info:"
msgstr "デバッグ情報付きでネイティブ実行可能ファイルをビルドします。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:813
msgid "Run it through `perf`:"
msgstr "`perf` を介して実行してください。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:821
msgid "Make and open a flamegraph:"
msgstr "フレームグラフを作成して開いてください。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:829
#, fuzzy
msgid "image:native-reference-multi-flamegraph-separate-threads.png[Muti-thread perf flamegraph with separate threads]"
msgstr "image:native-reference-multi-flamegraph-separate-threads.png[alt=Muti-thread perf flamegraph with separate threads]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:832
msgid "The flamegraph produced looks odd. Each thread is treated independently even though they all do the same work.  This makes it difficult to have a clear picture of the bottlenecks in the program."
msgstr "作成されたフレームグラフは奇妙に見えます。すべてのスレッドが同じ作業をしているにもかかわらず、各スレッドが独立して扱われています。これでは、プログラムのボトルネックを明確に把握することができません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:835
msgid "This is happening because from a `perf` perspective, each thread is a different command.  We can see that if we inspect `perf report`:"
msgstr "これは、 `perf` の観点から見ると、各スレッドが異なるコマンドであるために起こっています。 `perf report` を確認するとわかります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:845
#, no-wrap
msgid ""
"perf report --stdio\n"
"# Children      Self  Command          Shared Object       Symbol\n"
"...\n"
"    11.07%     0.02%  thread-9         code-with-quarkus-1.0.0-SNAPSHOT-runner  [.]\n"
"...\n"
"     7.44%     0.00%  thread-6         code-with-quarkus-1.0.0-SNAPSHOT-runner  [.]\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:849
msgid "This can be worked around by applying some modifications to the perf output, in order to make all threads have the same name. E.g."
msgstr "これは、すべてのスレッドが同じ名前になるように、perfの出力にいくつかの変更を加えることで回避できます。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:855
#, no-wrap
msgid ""
"perf script | sed -E \"s/thread-[0-9]*/thread/\" \\\n"
"    | ${FG_HOME}/stackcollapse-perf.pl > out.perf-folded\n"
"${FG_HOME}/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:858
#, fuzzy
msgid "image:native-reference-multi-flamegraph-joined-threads.png[Muti-thread perf flamegraph with joined threads]"
msgstr "image:native-reference-multi-flamegraph-joined-threads.png[alt=Muti-thread perf flamegraph with joined threads]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:861
msgid "When you open the flamegraph, you will see all threads' work collapsed into a single area.  Then, you can clearly see that there's some locking that could affect performance."
msgstr "フレームグラフを開くと、すべてのスレッドの作業が1つの領域に折りたたまれているのがわかります。そして、パフォーマンスに影響を与える可能性のあるロックがあることがはっきりとわかります。"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:862
#, no-wrap
msgid "Debugging Native Crashes"
msgstr "ネイティブ・クラッシュのデバッグ"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:869
msgid "One of the drawbacks of using native executables is that they cannot be debugged using the standard Java debuggers, instead we need to debug them using `gdb`, the GNU Project debugger.  To demonstrate how to do this, we are going to generate a native Quarkus application that crashes due to a Segmentation Fault when accessing http://localhost:8080/hello.  To achieve this, replace the `GreetingResource` code with the following:"
msgstr "ネイティブ実行可能ファイルを使用することの欠点は、標準的なJavaデバッガを使用してデバッグできないことです。代わりに、GNU Projectデバッガである `gdb` を使用してデバッグする必要があります。この方法を説明するために、 http://localhost:8080/hello  へのアクセス時にセグメンテーション・フォールトによりクラッシュするネイティブの Quarkus アプリケーションを作成します。これを実現するには、 `GreetingResource` のコードを以下のように置き換えます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:875
#, no-wrap
msgid "import sun.misc.Unsafe;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:881
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.lang.reflect.Field;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:900
#, no-wrap
msgid ""
"\t@GET\n"
"\t@Produces(MediaType.TEXT_PLAIN)\n"
"\tpublic String hello() {\n"
"    \tField theUnsafe = null;\n"
"    \ttry {\n"
"        \ttheUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n"
"        \ttheUnsafe.setAccessible(true);\n"
"        \tUnsafe unsafe = (Unsafe) theUnsafe.get(null);\n"
"        \tunsafe.copyMemory(0, 128, 256);\n"
"    \t} catch (NoSuchFieldException | IllegalAccessException e) {\n"
"        \te.printStackTrace();\n"
"    \t}\n"
"    \treturn \"Never happens\";\n"
"\t}\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:904
msgid "This code will try to copy 256 bytes from address `0x0` to `0x80` resulting in a Segmentation Fault.  To verify this compile and run the example application:"
msgstr "このコードは、アドレス `0x0` から `0x80` へ 256 バイトをコピーしようとするため、セグメンテーション・フォールトが発生します。これを確認するには、サンプルアプリケーションをコンパイルして実行します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:913
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}\n"
"...\n"
"./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"curl http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:916
msgid "This will result in the following output:"
msgstr "これにより、次のような出力が得られます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:927
#, no-wrap
msgid ""
"$ ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"__  ____  __  _____   ___  __ ____  ______\n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\\n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n"
"2021-06-24 18:14:22,102 INFO  [io.quarkus] (main) code-with-quarkus 1.0.0-SNAPSHOT native (powered by Quarkus 2.2.3.Final) started in 0.026s. Listening on: http://0.0.0.0:8080\n"
"2021-06-24 18:14:22,102 INFO  [io.quarkus] (main) Profile prod activated.\n"
"2021-06-24 18:14:22,102 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:929
#, no-wrap
msgid "[ [ SubstrateSegfaultHandler caught a segfault. ] ]\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:931
#, no-wrap
msgid "...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:936
msgid "Now let’s try to debug the segmentation fault using `gdb`.  We will start our application in `gdb` and execute `run`, then we will try to access http://localhost:8080/hello."
msgstr "それでは、 `gdb` を使ってセグメンテーション・フォルトをデバッグしてみましょう。 `gdb` でアプリケーションを起動し、 `run` を実行してから、 http://localhost:8080/hello  にアクセスしてみます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:947
#, no-wrap
msgid ""
"gdb ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"Reading symbols from ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner...\n"
"(No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"(gdb) run\n"
"Starting program: /home/zakkak/tmp/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"curl http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:950
#: upstream/_guides/native-reference.adoc:997
msgid "This will result in the following message in `gdb`:"
msgstr "これにより、 `gdb` に次のようなメッセージが表示されます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:957
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-1\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to LWP 693675]\n"
"0x0000000000407380 in ?? ()\n"
"Missing separate debuginfos, use: dnf debuginfo-install glibc-2.33-15.fc34.x86_64 sssd-client-2.5.0-2.fc34.x86_64 zlib-1.2.11-26.fc34.x86_64\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:960
msgid "If we try to get more info about the backtrace that led to this crash we will see that there is not enough information available."
msgstr "このクラッシュの原因となったバックトレースの情報を得ようとすると、十分な情報が得られないことがわかります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:971
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  0x0000000000418b5e in ?? ()\n"
"#1  0x00007ffff6f2d328 in ?? ()\n"
"#2  0x0000000000418a04 in ?? ()\n"
"#3  0x00007ffff44062a0 in ?? ()\n"
"#4  0x00000000010c3dd3 in ?? ()\n"
"#5  0x0000000000000100 in ?? ()\n"
"#6  0x0000000000000000 in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:976
msgid "This is because we didn’t compile the Quarkus application with `-Dquarkus.native.debug.enabled`, so `gdb` cannot find debugging symbols for our native executable, as indicated by the \"_No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner_\" message in the beginning of `gdb`."
msgstr "これは、 `-Dquarkus.native.debug.enabled` でQuarkusアプリケーションをコンパイルしていないため、 `gdb` はネイティブ実行可能ファイルのデバッグシンボルを見つけることができません。 `gdb` の最初に _\"No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner_\" というメッセージが表示されています。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:979
msgid "Recompiling the Quarkus application with `-Dquarkus.native.debug.enabled` and rerunning it through `gdb` we are now able to get a backtrace making clear what caused the crash.  On top of that, add `-H:-OmitInlinedMethodDebugLineInfo` option to avoid inlined methods being omitted from the backtrace:"
msgstr "`-Dquarkus.native.debug.enabled` でQuarkusアプリケーションを再コンパイルし、 `gdb` で再実行すると、クラッシュの原因を明らかにするバックトレースを得ることができます。さらに、 `-H:-OmitInlinedMethodDebugLineInfo` オプションを追加すると、インライン化されたメソッドがバックトレースから省略されるのを防ぐことができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:994
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-OmitInlinedMethodDebugLineInfo\n"
"...\n"
"$ gdb ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"Reading symbols from ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner...\n"
"Reading symbols from /home/zakkak/tmp/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner.debug...\n"
"(gdb) run\n"
"Starting program: /home/zakkak/tmp/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/hello\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1005
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fffeffff640 (LWP 362984)]\n"
"com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) ()\n"
"\tat com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"169    com/oracle/svm/core/UnmanagedMemoryUtil.java: No such file or directory.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1009
msgid "We already see that `gdb` is able to tell us which method caused the crash and where it’s located in the source code.  We can also get a backtrace of the call graph that led us to this state:"
msgstr "`gdb` は、どのメソッドがクラッシュの原因となったのか、それがソースコードのどこにあるのかを教えてくれることがすでにわかりました。また、この状態に至ったコールグラフのバックトレースも得ることができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1022
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"#1  0x00000000011aff54 in com.oracle.svm.core.UnmanagedMemoryUtil::copyBackward () at com/oracle/svm/core/UnmanagedMemoryUtil.java:110\n"
"#2  com.oracle.svm.core.UnmanagedMemoryUtil::copy () at com/oracle/svm/core/UnmanagedMemoryUtil.java:67\n"
"#3  com.oracle.svm.core.JavaMemoryUtil::unsafeCopyMemory () at com/oracle/svm/core/JavaMemoryUtil.java:276\n"
"#4  jdk.internal.misc.Unsafe::copyMemory0 () at com/oracle/svm/core/jdk/SunMiscSubstitutions.java:125\n"
"#5  jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:788\n"
"#6  jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:799\n"
"#7  sun.misc.Unsafe::copyMemory () at sun/misc/Unsafe.java:585\n"
"#8  org.acme.GreetingResource::hello(void) () at org/acme/GreetingResource.java:22\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1025
msgid "Unfortunately though, running the `list` command doesn’t show us the corresponding source code."
msgstr "しかし、残念ながら、 `list` コマンドを実行しても、対応するソースコードは表示されません。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1030
#, no-wrap
msgid ""
"(gdb) list\n"
"164    in com/oracle/svm/core/UnmanagedMemoryUtil.java\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1036
msgid "This is because `gdb` is not aware of the location of the source files.  We are running the executable outside of the target directory.  To fix this we can either rerun `gdb` from the target directory or, run `directory target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/sources` e.g.:"
msgstr "これは、 `gdb` がソースファイルの場所を認識していないためです。ターゲットディレクトリの外で実行ファイルを実行しているのです。この問題を解決するには、ターゲットディレクトリから `gdb` を再実行するか、 `directory target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/sources` を実行します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1052
#, no-wrap
msgid ""
"(gdb) directory target/code-with-quarkus-1.0.0-SNAPSHOT-native-image-source-jar/sources\n"
"Source directories searched: /home/zakkak/tmp/code-with-quarkus/target/sources:$cdir:$cwd\n"
"(gdb) list\n"
"164        \tUnsignedWord offset = size;\n"
"165        \twhile (offset.aboveOrEqual(32)) {\n"
"166            \toffset = offset.subtract(32);\n"
"167            \tPointer src = from.add(offset);\n"
"168            \tPointer dst = to.add(offset);\n"
"169            \tlong l24 = src.readLong(24);\n"
"170            \tlong l16 = src.readLong(16);\n"
"171            \tlong l8 = src.readLong(8);\n"
"172            \tlong l0 = src.readLong(0);\n"
"173            \tdst.writeLong(24, l24);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1059
msgid "We can now examine line `169` and get a first hint of what might be wrong (in this case we see that it fails at the first read from src which contains the address `0x0000`), or walk up the stack using `gdb`’s `up` command to see what part of our code led to this situation.  To learn more about using gdb to debug native executables see https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DebugInfo.md[here]."
msgstr "`169` 行を調べて、何が問題なのか最初のヒントを得ることができます（この場合、アドレス `0x0000` を含む src からの最初の読み取りに失敗していることがわかります）。また、 `gdb` の `up` コマンドを使ってスタックをさかのぼり、コードのどの部分がこのような状況を引き起こしたかを確認することができます。ネイティブ実行可能ファイルをデバッグするためのgdbの使い方については、 link:https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/DebugInfo.md[こちら]をご覧ください。"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:1060
#, no-wrap
msgid "Frequently Asked Questions"
msgstr "よくある質問"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1062
#, no-wrap
msgid "Why is the process of generating a native executable slow?"
msgstr "ネイティブ実行可能ファイルを生成するプロセスが遅いのはなぜですか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1066
msgid "Native executable generation is a multi-step process.  The analysis and compile steps are the most expensive of all and hence the ones that dominate the time spent generating the native executable."
msgstr "ネイティブ実行可能ファイルの生成は、複数のステップで構成されています。その中でも解析とコンパイルのステップは最もコストがかかるため、ネイティブ実行可能ファイルの生成にかかる時間の大半を占めます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1072
msgid "In the analysis phase, a static points-to analysis starts from the main method of the program to find out what is reachable.  As new classes are discovered, some of them will be initialized during this process depending on the configuration.  In the next step, the heap is snapshotted and checks are made to see which types need to be available at runtime.  The initialization and heap snapshotting can cause new types to be discovered, in which case the process is repeated.  The process stops when a fixed point is reached, that is when the reachable program grows no more."
msgstr "解析フェーズでは、プログラムのメインメソッドから静的なPoint-to 解析を開始し、到達可能なものを見つけ出します。新しいクラスが発見されると、設定に応じてこのプロセス中にその一部が初期化されます。次のステップでは、ヒープがスナップショットされ、どのタイプが実行時に利用可能である必要があるかのチェックが行われます。初期化とヒープのスナップショットにより、新しい型が発見されることがありますが、その場合はこのプロセスが繰り返されます。このプロセスは、到達可能なプログラムがこれ以上成長しないという固定点に達したときに停止します。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1074
msgid "The compilation step is pretty straightforward, it simply compiles all the reachable code."
msgstr "コンパイルのステップは非常に簡単で、到達可能なすべてのコードを単純にコンパイルします。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1081
msgid "The time spent in analysis and compilation phases depends on how big the application is.  The bigger the application, the longer it takes to compile it.  However, there are certain features that can have an exponential effect.  For example, when registering types and methods for reflection access, the analysis can’t easily see what’s behind those types or methods, so it has to do more work to complete the analysis step."
msgstr "解析とコンパイルの段階でかかる時間は、アプリケーションの大きさによって異なります。アプリケーションが大きければ大きいほど、コンパイルにかかる時間は長くなります。ただし、指数関数的な効果をもたらす機能もあります。例えば、リフレクションアクセスのために型やメソッドを登録する場合、解析はその型やメソッドの背後にあるものを簡単に見ることができないため、解析ステップを完了するためにはより多くの仕事をしなければなりません。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1082
#, no-wrap
msgid "Why is runtime performance of a native executable inferior compared to JVM mode?"
msgstr "JVMモードと比較して、ネイティブ実行可能ファイルのランタイムパフォーマンスが劣るのはなぜですか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1087
msgid "As with most things in life there are some trade offs involved when choosing native compilation over JVM mode.  So depending on the application the runtime performance of a native application might be slower compared to JVM mode, though that’s not always the case."
msgstr "多くの場合、JVMモードではなくネイティブコンパイルを選択すると、いくつかのトレードオフが発生します。そのため、アプリケーションによっては、ネイティブアプリケーションの実行時パフォーマンスがJVMモードに比べて遅くなることがありますが、絶対にそうであるとは限りません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1093
msgid "JVM execution of an application includes runtime optimization of the code that profits from profile information built up during execution.  That includes the opportunities to inline a lot more of the code, locate hot code on direct paths (i.e. ensure better instruction cache locality)  and cut out a lot of the code on cold paths (on the JVM a lot of code does not get compiled until something tries to execute it -- it is replaced with a trap that causes deoptimization and recompilation).  Removal of cold paths provides many more optimization opportunities than are available for ahead of time compilation because it significantly reduces the branch complexity and combinatorial logic of the smaller amount of hot code that is compiled."
msgstr "JVMによるアプリケーションの実行には、実行中に蓄積されるプロファイル情報を利用したコードの実行時最適化が含まれます。これには、より多くのコードをインライン化したり、ホットコードをダイレクトパスに配置したり（つまり、より良い命令キャッシュのローカリティを確保する）、コールドパスにある多くのコードをカットしたりする機会が含まれます（JVMでは、多くのコードが何かが実行しようとするまでコンパイルされず、最適化解除や再コンパイルを引き起こすトラップに置き換えられます）。コールドパスを取り除くことで、コンパイルされる少量のホットコードの分岐の複雑さや組み合わせロジックが大幅に削減されるため、先行してコンパイルする場合よりも多くの最適化の機会が得られます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1096
msgid "By contrast, native executable compilation has to cater for all possible execution paths when it compiles code offline since it does not know which are the hot or cold paths and cannot use the trick of planting a trap and recompiling if it is hit. For the same reason it cannot load the dice to ensure that code cache conflicts are minimized by co-locating hot paths adjacent.  Native executable generation is able to remove some code because of the closed world hypothesis but that is often not enough to make up for all the benefits that profiling and runtime deopt & recompile provides to the JVM JIT compiler."
msgstr "一方、ネイティブ実行可能ファイルのコンパイルでは、オフラインでコードをコンパイルする際に、すべての可能な実行経路に対応しなければなりません。なぜならば、ホットパスやコールドパスがわからないため、罠を仕掛けて、それに当たったら再コンパイルするというようなトリックが使えないからです。同じ理由で、ホットパスを隣接して配置することでコードキャッシュの衝突を最小限に抑えるようなサイコロを積むこともできません。ネイティブ実行可能ファイルの生成は、閉じた世界の仮説により、いくつかのコードを削除することができますが、それだけでは、プロファイリングや実行時最適化解除＆再コンパイルがJVM JITコンパイラに提供するすべての利点を補うことはできません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1098
msgid "Note, however, that there is a price you pay for that potentially higher JVM speed, and that price is in increased resource usage (both CPU and memory) and startup time because:"
msgstr "ただし、JVMの速度が向上する可能性があるため、その代償として、リソース（CPUとメモリの両方）の使用量と起動時間が増加することに注意してください。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1100
msgid "it takes some time before the JIT kicks in and fully optimizes the code."
msgstr "JITが作動してコードを完全に最適化するまでに時間がかかります。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1101
msgid "the JIT compiler consumes resources that could be utilized by the application."
msgstr "JIT コンパイラは、アプリケーションが利用できるリソースを消費します。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1102
msgid "the JVM has to retain a lot more metadata and compiler/profiler data to support the better optimizations that it can offer."
msgstr "JVMは、より良い最適化をサポートするために、より多くのメタデータやコンパイラ/プロファイラのデータを保持しなければなりません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1104
msgid "The reason for 1) is that code needs to be run interpreted for some time and, possibly, to be compiled several times before all potential optimizations are realized to ensure that:"
msgstr "1)の理由は、コードはしばらくの間、インタプリタ実行する必要があり、場合によっては、以下を担保する全ての潜在的な最適化が実現される前に、何度もコンパイルする必要があるからです。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1106
msgid "it’s worth compiling that code path, i.e. it’s being executed enough times, and that"
msgstr "そのコードパスをコンパイルする価値があるかどうか、つまり十分な回数実行されているかどうか、そして"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1107
msgid "we have enough profiling data to perform meaningful optimizations."
msgstr "意味のある最適化を行うのに十分なプロファイリングデータを持っていること"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1110
msgid "An implication of 1) is that for small, short-lived applications a native executable may well be a better bet.  Although the compiled code is not as well optimized it is available straight away."
msgstr "1)の意味するところは、小規模で短命なアプリケーションには、ネイティブ実行可能ファイルの方が適しているということです。コンパイルされたコードは最適化されていませんが、すぐに利用できます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1113
msgid "The reason for 2) is that the JVM is essentially running the compiler at runtime in parallel with the application itself.  In the case of native executables the compiler is run ahead of time removing the need to run the compiler in parallel with the application."
msgstr "2)の理由は、JVMは基本的に実行時にアプリケーションと並行してコンパイラを実行しているからです。ネイティブ実行可能ファイルの場合、コンパイラは事前に実行されるため、アプリケーションと並行してコンパイラを実行する必要がありません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1122
msgid "There are several reasons for 3). The JVM does not have a closed world assumption.  So, it has to be able to recompile code if loading of new classes implies that it needs to revise optimistic assumptions made at compile time.  For example, if an interface has only one implementation it can make a call jump directly to that code.  However, in the case where a second implementation class is loaded the call site needs to be patched to test the type of the receiver instance and jump to the code that belongs to its class.  Supporting optimizations like this one requires keeping track of a lot more details of the class base than a native executable, including recording the full class and interface hierarchy, details of which methods override other methods, all method bytecode etc.  In a native executable most of the details of class structure and bytecode can be ignored at run time."
msgstr "3)にはいくつかの理由があります。JVMは閉じた世界を想定していません。そのため、新しいクラスのロードにより、コンパイル時の楽観的な仮定を修正する必要がある場合には、コードを再コンパイルできなければなりません。例えば、あるインターフェイスの実装が1つだけの場合、そのコードに直接コールジャンプすることができます。しかし、2つ目の実装クラスがロードされた場合には、レシーバのインスタンスのタイプをテストして、そのクラスに属するコードにジャンプするようにコールサイトを修正する必要があります。このような最適化をサポートするには、ネイティブ実行可能ファイルよりもクラスベースの詳細を記録しておく必要があります。これには、完全なクラスとインターフェイスの階層、どのメソッドが他のメソッドをオーバーライドするかの詳細、すべてのメソッドのバイトコードなどが含まれます。ネイティブ実行可能ファイルでは、クラス構造やバイトコードの詳細のほとんどは実行時には無視できます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1127
msgid "The JVM also has to cope with changes to the class base or execution profiles that result in a thread going down a previously cold path.  At that point the JVM has to jump out of the compiled code into the interpreter and recompile the code to cater for a new execution profile that includes the previously cold path.  That requires keeping runtime info that allow a compiled stack frame to be replaced with one or more interpreter frames.  It also requires runtime extensible profile counters to be allocated and updated to track what has or has not been executed."
msgstr "また、JVMはクラスベースや実行プロファイルの変更にも対応しなければならず、その結果、スレッドが以前のコールドパスを通ることになります。その時点で、JVMはコンパイルされたコードからインタープリタにジャンプし、以前のコールドパスを含む新しい実行プロファイルに対応するためにコードを再コンパイルしなければなりません。そのためには、コンパイルされたスタックフレームを1つまたは複数のインタープリタフレームに置き換えることができる実行時情報を保持する必要があります。また、実行されたもの、されなかったものを追跡するために、ランタイムの拡張可能なプロファイルカウンタを割り当て、更新する必要があります。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1128
#, no-wrap
msgid "Why are native executables “big”?"
msgstr "なぜネイティブ実行可能ファイルは大きいのですか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1131
msgid "This can be attributed to a number of different reasons:"
msgstr "これには様々な理由があります。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1137
msgid "Native executables include not only the application code but also, library code, and JDK code.  As a result a more fair comparison would be to compare the native executable’s size with the size of the application, plus the size of the libraries it uses, plus the size of the JDK.  Especially the JDK part is not negligible even in simple applications like HelloWorld.  To get a glance on what is being pulled in the image one can use `-H:+PrintUniverse` when building the native executable."
msgstr "ネイティブ実行可能ファイルには、アプリケーションのコードだけでなく、ライブラリのコードやJDKのコードも含まれています。そのため、ネイティブ実行可能ファイルのサイズは、アプリケーションのサイズに加えて、使用するライブラリのサイズとJDKのサイズを加えたものと比較するのが、より公平な比較となります。特にJDKの部分は、HelloWorldのようなシンプルなアプリケーションでも無視できません。イメージの中で何が引き出されているかを把握するために、ネイティブ実行可能ファイルをビルドする際に `-H:+PrintUniverse` を使用することができます。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1143
msgid "Some features are always included in a native executable even though they might never be actually used at run time.  An example of such a feature is garbage collection.  At compile time we can’t be sure whether an application will need to run garbage collection at run time, so garbage collection is always included in native executables increasing their size even if not necessary.  Native executable generation relies on static code analysis to identify which code paths are reachable, and static code analysis can be imprecise leading to more code getting into the image than what’s actually needed."
msgstr "ネイティブ実行可能ファイルには、実行時に実際には使われないかもしれないのに、必ず含まれている機能があります。そのような機能の例として、ガベージコレクションがあります。コンパイル時には、アプリケーションが実行時にガベージコレクションを実行する必要があるかどうかはわかりません。そのため、ガベージコレクションは、必要がないにもかかわらず、常にネイティブ実行可能ファイルに含まれ、サイズが大きくなります。ネイティブ実行可能ファイルの生成は、どのコードパスが到達可能かを特定するために、静的なコード解析に依存していますが、静的なコード解析は不正確な場合があり、実際に必要なコードよりも多くのコードがイメージに入ってしまうことがあります。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1146
msgid "There is a https://github.com/oracle/graal/issues/287[GraalVM upstream issue] with some interesting discussions about that topic."
msgstr "この話題については、 link:https://github.com/oracle/graal/issues/287[GraalVMアップストリーム課題]で興味深い議論が行われています。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1147
#, no-wrap
msgid "What version of Mandrel was used to generate a binary?"
msgstr "バイナリの生成に使用したMandrelのバージョンは？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1150
msgid "One can see which Mandrel version was used to generate a binary by inspecting the binary as follows:"
msgstr "どのバージョンのMandrelを使ってバイナリを生成したかは、バイナリを以下のように検査すればわかります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1155
#, no-wrap
msgid ""
"$ strings target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep GraalVM\n"
"com.oracle.svm.core.VM=GraalVM 21.3.0.0-Final Java 11 Mandrel Distribution\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1157
#, no-wrap
msgid "How do I enable GC logging in native executables?"
msgstr "ネイティブ実行可能ファイルでGCロギングを有効にするにはどうすればいいですか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1161
msgid "Executing the native executable with `-XX:PrintFlags=` prints a list of flags that can be passed to native executables.  For various levels of GC logging one may use:"
msgstr "ネイティブ実行可能ファイルに `-XX:PrintFlags=` を付けて実行すると、ネイティブ実行可能ファイルに渡すことのできるフラグのリストが表示されます。様々なレベルのGCロギングのために、次のように使用することができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1174
#, no-wrap
msgid ""
"$ ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -XX:PrintFlags=\n"
"...\n"
"  -XX:±PrintGC                                 Print summary GC information after each collection. Default: - (disabled).\n"
"  -XX:±PrintGCSummary                          Print summary GC information after application main method returns. Default: - (disabled).\n"
"  -XX:±PrintGCTimeStamps                       Print a time stamp at each collection, if +PrintGC or +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintGCTimes                            Print the time for each of the phases of each collection, if +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintHeapShape                          Print the shape of the heap before and after each collection, if +VerboseGC. Default: - (disabled).\n"
"...\n"
"  -XX:±TraceHeapChunks                         Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Default: - (disabled).\n"
"  -XX:±VerboseGC                               Print more information about the heap before and after each collection. Default: - (disabled).\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1176
#, no-wrap
msgid "Can I get a heap dump of a native executable? e.g. if it runs out of memory"
msgstr "ネイティブ実行可能ファイルのヒープダンプを取得することはできますか？ 例えば、メモリ不足になった場合などです。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1183
msgid "Unfortunately generating heap dumps in hprof format, which can be opened by tools such as VisualVM or Eclipse MAT, can only be achieved with https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition].  Mandrel, which is based on the GraalVM Community Edition, does not have this capability."
msgstr "残念ながら、VisualVMやEclipse MATなどのツールで開くことができるhprof形式のヒープダンプを生成することは、 link:https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition]でしか実現できません。GraalVM Community EditionをベースにしたMandrelには、この機能はありません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1187
msgid "Although Mandrel can generate debug symbols and these contain a fair amount of information about object layouts, including what is a pointer field vs a primitive field, this information cannot be used as is to detect memory leaks or find dominator objects.  This is because it has no idea what constitutes a root pointer nor how to recursively trace pointers from those roots."
msgstr "Mandrelはデバッグシンボルを生成することができ、その中にはポインターフィールドとプリミティブフィールドの違いなど、オブジェクトのレイアウトに関するかなりの情報が含まれていますが、この情報をそのままメモリリークの検出や支配的なオブジェクトの発見に使用することはできません。これは、何がルートポインタを構成するのか、また、それらのルートから再帰的にポインタをトレースする方法がわからないからです。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1189
#, no-wrap
msgid "Can I follow these examples if I’m running macOS or Windows?"
msgstr "macOSやWindowsを使用していても、これらの例をなぞることはできますか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1195
msgid "The ideal environment for trying out these debugging examples is Linux.  All examples, except for profiling and debugging native crashes, can also be executed natively in either macOS or Windows.  If you are in either of these two platforms, you can run all the steps (including native crash debugging and profiling) within a Linux container.  The following `Dockerfile` shows what a Linux container requires in order to follow the examples:"
msgstr "これらのデバッグ例を試すのに最適な環境はLinuxです。プロファイリングとネイティブ・クラッシュのデバッグを除くすべての例は、macOSまたはWindowsでもネイティブに実行できます。この2つのプラットフォームのいずれかを使用している場合、Linuxコンテナ内ですべての手順（ネイティブ・クラッシュのデバッグとプロファイリングを含む）を実行することができます。以下の `Dockerfile` は、例題を進めるにあたりLinuxコンテナに必要なものを示しています。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1199
#, no-wrap
msgid "FROM fedora:35\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1206
#, no-wrap
msgid ""
"RUN dnf install -y \\\n"
"binutils \\\n"
"gdb \\\n"
"git \\\n"
"perf \\\n"
"perl-open\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1209
#, no-wrap
msgid ""
"RUN cd /opt \\\n"
"&& git clone https://github.com/brendangregg/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1211
#, no-wrap
msgid "ENV FG_HOME /opt/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1213
#, no-wrap
msgid "WORKDIR /data\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1216
msgid "Using `docker` in the non-Linux environment, you can create an image using this `Dockerfile` via:"
msgstr "非Linux環境で `docker` を使用すると、この `Dockerfile` 経由でイメージを作成することができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1220
#, no-wrap
msgid "docker build -t fedora-tools:v1 .\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1223
msgid "Then, run the Docker container as:"
msgstr "そして、Dockerコンテナを次のように実行します。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1230
#, no-wrap
msgid ""
"$ docker run --privileged \\\n"
"-t -i -v $(PWD)/$(project):/data --rm -p 8080:8080 fedora-tools:v1 /bin/bash\n"
"...\n"
"[root@75d1df96849c data]# _\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1237
msgid "Note that in order to use `perf` to profile the native executables in the guide, the container needs to run as privileged, or with `--cap-add sys_admin`.  Please note that privileged containers are **NOT** recommended in production, so use this flag with caution!"
msgstr "なお、 `perf` を使用してガイドのネイティブ実行可能ファイルをプロファイルするには、コンテナを特権的に実行するか、 `--cap-add sys_admin` を使用する必要があります。本番環境では特権コンテナは推奨され *ません* ので、このフラグの使用には注意が必要です。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1240
msgid "Once the container is running, you need to ensure that the kernel is ready for the profiling exercises:"
msgstr "コンテナが稼働したら、カーネルがプロファイリングの演習に対応できるようにしておく必要があります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1245
#, no-wrap
msgid ""
"[root@75d1df96849c data]# echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
"[root@75d1df96849c data]# echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1249
msgid "Once you’re inside the container, you can execute `strings`, `perf`, `objdump`…, etc commands on the generated binary.  Since the binary was created inside a Linux container, the container tools should have no issues with them, e.g."
msgstr "コンテナの中に入ったら，生成されたバイナリに対して `strings`, `perf`, `objdump`... などのコマンドを実行することができます。バイナリはLinuxコンテナ内で作成されたものなので、コンテナツールでも問題ないはずです、例えば"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1253
#, no-wrap
msgid "[root@75d1df96849c data]# objdump -t ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner | grep “GreetingResource”\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1256
msgid "Flame graphs should also be generated inside the container:"
msgstr "フレームグラフもコンテナ内で生成されるはずです。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1261
#, no-wrap
msgid ""
"[root@75d1df96849c data]# perf script | /opt/FlameGraph/stackcollapse-perf.pl > out.perf-folded\n"
"[root@75d1df96849c data]# /opt/FlameGraph/flamegraph.pl out.perf-folded > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1264
msgid "The resulting svg files can then be opened outside the container for visualization."
msgstr "できあがったsvgファイルは、コンテナの外で開いて視覚化することができます。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1265
#, no-wrap
msgid "Generating flame graphs is slow, or produces errors, what can I do?"
msgstr "フレームグラフの生成に時間がかかったり、エラーが発生したりするのですが、どうすればいいですか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1269
msgid "There are multiple ways in which a native executable produced by Mandrel can be profiled.  All the methods require you to pass in the `-H:-DeleteLocalSymbols` option."
msgstr "Mandrelが作成したネイティブ実行可能ファイルをプロファイリングする方法は複数あります。すべての方法で、 `-H:-DeleteLocalSymbols` オプションを渡す必要があります。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1273
msgid "The method shown in this reference guide generates a binary with DWARF debug information, runs it via `perf record` and then uses `perf script` and flame graph tooling to generate the flamegraphs.  However, the `perf script` post-processing step done on this binary can appear to be slow or can show some DWARF errors."
msgstr "このリファレンス・ガイドで紹介する方法は、DWARFのデバッグ情報を含むバイナリを生成し、 `perf record` を通して実行し、 `perf script` とフレーム・グラフ・ツールを使用してフレーム・グラフを生成します。しかし、このバイナリで行われる `perf script` の後処理ステップは、時間がかかったり、DWARF のエラーが表示されたりすることがあります。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1278
msgid "An alternative method to generate flame graphs is to pass in `-H:+PreserveFramePointer` when generating the native executable instead of generating the DWARF debug information.  It instructs the binary to use an extra register for the frame pointer.  This enables `perf` to do stack walking to profile the runtime behaviour.  To generate the native executable using these flags, do the following:"
msgstr "フレームグラフを生成する別の方法として、ネイティブ実行可能ファイルを生成する際に、DWARFのデバッグ情報を生成する代わりに、 `-H:+PreserveFramePointer` を渡す方法があります。これは、フレームポインタに追加のレジスタを使用するようにバイナリに指示します。これにより、 `perf` は、実行時の動作をプロファイリングするためにスタックウォーキングを行うことができます。これらのフラグを使用してネイティブ実行可能ファイルを生成するには、以下のようにします。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1284
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.additional-build-args=-H:+PreserveFramePointer,-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1287
msgid "To get runtime profiling information out of the native executable, simply do:"
msgstr "実行時プロファイリング情報をネイティブ実行可能ファイルから取得するには、単純に次のようにします。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1295
msgid "The recommended method for generating runtime profiling information is using the debug information rather than generating a binary that preserves the frame pointer.  This is because adding debug information to the native executable build process has no negative runtime performance whereas preserving the frame pointer does."
msgstr "実行時プロファイリング情報を生成する方法としては、フレームポインタを保持したバイナリを生成するよりも、デバッグ情報を使用することを推奨します。これは、ネイティブ実行可能ファイルのビルドプロセスにデバッグ情報を追加しても、実行時のパフォーマンスには何の影響もないのに対し、フレームポインタの保持は影響があるためです。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1301
msgid "DWARF debug info is generated in a separate file and can even be omitted in the default deployment and only be transferred and used on demand, for profiling or debugging purposes.  Furthermore, the presence of debug info enables `perf` to show us the relevant source code lines as well, hence it does not bloat the native executable itself.  To do that, simply call `perf report` with an extra parameter to show source code lines:"
msgstr "DWARFのデバッグ情報は、別のファイルに生成され、デフォルトのデプロイメントでは省略することもでき、プロファイリングやデバッグの目的で必要なときだけ転送して使用することができます。さらに、デバッグ情報があることで、 `perf` は関連するソースコード行も表示することができ、ネイティブ実行可能ファイル自体を肥大化させることはありません。そのためには、 `perf report` にソースコード行を表示するパラメータを追加して呼び出すだけです。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1311
#, no-wrap
msgid ""
"perf report --stdio -F+srcline\n"
"...\n"
"83.69%     0.00%  GreetingResource.java:20 ...\n"
"...\n"
"83.69%     0.00%  AbstractStringBuilder.java:1025 ...\n"
"...\n"
"83.69%     0.00%  ArraycopySnippets.java:95 ...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1317
msgid "The performance penalty of preserving the frame pointer is due to using the extra register for stack walking, particularly in `x86_64` compared to `aarch64` where there are less registers available.  Using this extra register reduces the number of registers that are available for other work, which can lead to performance penalties."
msgstr "フレームポインタを保持することによる性能上のペナルティは、スタックウォーキングのために余分なレジスタを使用することによるもので、特に `aarch64` と比較して `x86_64` では使用できるレジスタの数が少なくなります。この余分なレジスタを使用すると、他の作業に使用できるレジスタの数が減るため、性能上のペナルティが発生します。"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1318
#, no-wrap
msgid "I think I’ve found a bug in native-image, how can I debug it with the IDE?"
msgstr "native-imageのバグを見つけたようなのですが、IDEでどのようにデバッグすればいいのでしょうか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1322
msgid "Although it is possible to remote debug processes within containers, it might be easier to step-by-step debug native-image by installing Mandrel locally and adding it to the path of the shell process."
msgstr "コンテナ内のプロセスをリモートデバッグすることは可能ですが、Mandrelをローカルにインストールしてシェルプロセスのパスに追加することで、native-imageをステップバイステップでデバッグする方が簡単かもしれません。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1327
msgid "Native executable generation is the result of two Java processes that are executed sequentially.  The first process is very short and its main job is to set things up for the second process.  The second process is the one that takes care of most of the work.  The steps to debug one process or the other vary slightly."
msgstr "ネイティブ実行可能ファイルの生成は、2つのJavaプロセスが順次実行された結果です。最初のプロセスは非常に短く、主な仕事は2番目のプロセスのために物事を準備することです。2つ目のプロセスは、ほとんどの作業を行うものです。一方のプロセスをデバッグするための手順は、若干異なります。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1332
msgid "Let’s discuss first how to debug the second process, which is the one you most likely to want to debug.  The starting point for the second process is the `com.oracle.svm.hosted.NativeImageGeneratorRunner` class.  To debug this process, simply add `--debug-attach=*:8000` as an additional build time argument:"
msgstr "まず、最もデバッグしたいと思われる2番目のプロセスのデバッグ方法について説明します。2番目のプロセスのスタートポイントは、 `com.oracle.svm.hosted.NativeImageGeneratorRunner` クラスです。このプロセスをデバッグするには、ビルド時の引数として `--debug-attach=*:8000` を追加するだけです。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1337
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative \\\n"
"    -Dquarkus.native.additional-build-args=--debug-attach=*:8000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1343
msgid "The starting point for the first process is the `com.oracle.svm.driver.NativeImages` class.  In GraalVM CE distributions, this first process is a binary, so debugging it in the traditional way with a Java IDE is not possible.  However, Mandrel distributions (or locally built GraalVM CE instances) keep this as a normal Java process, so you can remote debug this process by adding the `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` as an additional build argument, e.g."
msgstr "1番目のプロセスのスタートポイントとなるのは、 `com.oracle.svm.driver.NativeImages` クラスです。GraalVM CEのディストリビューションでは、この最初のプロセスはバイナリなので、従来のようにJava IDEを使ってデバッグすることはできません。しかし、Mandrelのディストリビューション（またはローカルにビルドされたGraalVM CEインスタンス）では、これを通常のJavaプロセスとして保持しているため、 `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` を追加のビルド引数として追加することで、このプロセスをリモートデバッグすることができます。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1348
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Pnative \\\n"
"    -Dquarkus.native.additional-build-args=--vm.agentlib:jdwp=transport=dt_socket\\\\,server=y\\\\,suspend=y\\\\,address=*:8000\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1350
#, no-wrap
msgid "Can I use JFR/JMC to debug or profile native binaries?"
msgstr "JFR/JMCを使って、ネイティブバイナリのデバッグやプロファイリングはできますか？"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1358
msgid "https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] and https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] can be used to debug profile native binaries since GraalVM CE 21.2.0.  However, JFR in GraalVM is currently significantly limited in capabilities compared to HotSpot.  The custom event API is fully supported, but many VM level features are unavailable.  They will be added in future releases. Current limitations are:"
msgstr "link:https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder(JFR)]と link:https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control(JMC)]は、GraalVM CE 21.2.0以降、プロファイル・ネイティブ・バイナリのデバッグに使用することができます。 しかし、GraalVMのJFRは現在、HotSpotと比較して機能が大幅に制限されています。カスタムイベントAPIは完全にサポートされていますが、多くのVMレベルの機能は利用できません。これらは将来のリリースで追加される予定です。現在の制限事項は以下の通りです。"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1360
msgid "Minimal VM level events"
msgstr "最小限のVMレベルのイベント"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1361
msgid "No old object sampling"
msgstr "oldオブジェクトのサンプリングはありません"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1362
msgid "No stacktrace tracing"
msgstr "スタックトレースのトレースがありません"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1363
msgid "No Streaming API for JDK 17"
msgstr "JDK 17にはストリーミングAPIはありません"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1366
msgid "To use JFR add the application property: `-Dquarkus.native.enable-vm-inspection=true`.  E.g."
msgstr "JFRを使用するには、アプリケーションのプロパティ `-Dquarkus.native.enable-vm-inspection=true` を追加します。例:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1372
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor} \\\n"
"    -Dquarkus.native.enable-vm-inspection=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1375
msgid "Once the image is compiled, enable and start JFR via runtime flags: `-XX:+FlightRecorder` and `-XX:StartFlightRecording`. For example:"
msgstr "イメージのコンパイルが完了したら、ランタイムフラグ `-XX:+FlightRecorder` と `-XX:StartFlightRecording` を使ってJFRを有効にし、起動します。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1381
#, no-wrap
msgid ""
"./target/code-with-quarkus-1.0.0-SNAPSHOT-runner \\\n"
"    -XX:+FlightRecorder \\\n"
"    -XX:StartFlightRecording=\"filename=recording.jfr\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1383
msgid "For more details on using JFR, see https://www.graalvm.org/reference-manual/native-image/JFR[here]."
msgstr "JFRの利用方法については link:https://www.graalvm.org/reference-manual/native-image/JFR[こちら]をご覧ください。"
