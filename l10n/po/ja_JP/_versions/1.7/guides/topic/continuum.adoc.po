# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-06-22 12:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:1
#, no-wrap
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:4
#, no-wrap
msgid ""
"layout: vision\n"
"permalink: /vision/continuum\n"
"---\n"
msgstr ""
"layout: vision\n"
"permalink: /vision/continuum\n"
"---\n"

#. type: Title =
#: upstream/_versions/1.7/guides/topic/continuum.adoc:7
#, no-wrap
msgid "The Imperative and Reactive Continuum"
msgstr "命令型とリアクティブ Continuum"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:14
#, fuzzy
msgid "For years, the client-server architecture has been the de-facto standard to build applications.  But a significant shift happened.  The _one model rules them all_ age is over.  A new range of applications and architectural styles have emerged and transformed how code is written and how applications are deployed and executed.  HTTP microservices, reactive applications, event-driven architecture, and serverless are now central players in modern systems."
msgstr "何年もの間、このクライアントサーバーアーキテクチャーは、アプリケーションを構築するための事実上の標準でした。しかし、大きな変化が起こったのです。_1 つのモデルがすべてを支配していた_ 時代は終わりました。新しい一連のアプリケーションとアーキテクチャーのスタイルが登場し、これはコードの書き方やアプリケーションの展開と実行の仕方に影響を与えました。HTTP マイクロサービス、リアクティブアプリケーション、メッセージ駆動型マイクロサービス、サーバーレスが、現在のシステムの中心的な役割を果たすようになったのです。"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:18
#, fuzzy
msgid "Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms.  That does not mean you cannot build monoliths with Quarkus; you can do it smoothly.  On the contrary, it means that the Quarkus development model morphs to adapt itself to the type of application you are developing, monolith, microservice, reactive, event-driven, functions..."
msgstr "Quarkus は、この新しい世界を念頭に置いて設計されており、これらの異なるパラダイムに対してファーストクラスのサポートを提供しています。Quarkus の開発モデルは、開発中のアプリケーションの種類に合わせて変化します。"

#. type: Title ==
#: upstream/_versions/1.7/guides/topic/continuum.adoc:20
#, no-wrap
msgid "HTTP microservices"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:25
#, fuzzy
msgid "Let's start with the basics: HTTP microservices.  In this context, you need to develop an HTTP endpoint, often called REST or CRUD.  You process incoming HTTP requests, and to do so you often need to rely on other services, such as databases, or another HTTP service."
msgstr "まずは基本中の基本、HTTP マイクロサービスから始めましょう。これに関しては、HTTP エンドポイントを開発する必要があり、これはしばしば REST や CRUD と呼ばれます。受信した HTTP リクエストを処理しますが、そのためにはデータベースなどの他のサービスや別の HTTP サービスに依存する必要があることが多くなります。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_versions/1.7/guides/topic/continuum.adoc:26
#, fuzzy, no-wrap
msgid "Microservice"
msgstr "メッセージ駆動型マイクロサービス"

#. type: Target for macro image
#: upstream/_versions/1.7/guides/topic/continuum.adoc:26
#, no-wrap
msgid "../../guides/images/microservices.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:29
#, fuzzy
msgid "For this type of application, Quarkus relies on well-known standards such as JAX-RS, JPA and MicroProfile Rest Client, but also Hibernate with Panache to simplify interactions with databases."
msgstr "このタイプのアプリケーションでは、Quarkus は JAX-RS、JPA、MicroProfile Rest Client などのよく知られた標準に依存しています。_果物_ を扱う非常にシンプルなアプリケーションを見てみましょう。コードは次のようになります。"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:31
msgid "Let’s take a very simple application handling _elements_ from the periodic table. The code would be something like:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:36
#, fuzzy, no-wrap
msgid ""
"@Path(\"/elements\")\n"
"public class ElementResource {\n"
msgstr ""
"@Path(\"/country\")\n"
"public class CountriesResource {\n"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:41
#, no-wrap
msgid ""
"    @GET\n"
"    public List<Element> getAll() {\n"
"        return Element.listAll();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:51
#, fuzzy, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{position}\")\n"
"    public Element getOne(@PathParam(\"position\") int position) {\n"
"        Element element = Element.find(\"position\", position).firstResult();\n"
"        if (element == null) {\n"
"            throw new WebApplicationException(\"Element with position \" + position + \" does not exist.\", 404);\n"
"        }\n"
"        return element;\n"
"    }\n"
msgstr ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Fruit getSingle(@PathParam Integer id) {\n"
"        Fruit entity = entityManager.find(Fruit.class, id);\n"
"        if (entity == null) {\n"
"            throw new WebApplicationException(\"Fruit with id of \" + id + \" does not exist.\", 404);\n"
"        }\n"
"        return entity;\n"
"    }\n"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:58
#, fuzzy, no-wrap
msgid ""
"    @POST\n"
"    @Transactional\n"
"    public Response create(Element element) {\n"
"        element.persist();\n"
"        return Response.ok(element).status(201).build();\n"
"    }\n"
msgstr ""
"        entityManager.persist(fruit);\n"
"        return Response.ok(fruit).status(201).build();\n"
"    }\n"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:61
#, no-wrap
msgid ""
"    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:69
#, fuzzy
msgid "If you are a Java EE or Spring user, this development model should look familiar.  You expose a resource containing methods annotated with `@GET`, `@POST`...​ to handle the different requests.  The path is specified using the `@Path` annotation.  Quarkus also supports https://quarkus.io/guides/spring-web[Spring controller] annotations such as `@GetMapping` or `@RestController`."
msgstr "Java EE や Spring のユーザーであれば、この開発モデルは見覚えがあるはずです。さまざまなリクエストを処理するために `@GET`、`@POST` ... のアノテーションが付いたメソッドを含む _リソース_ を公開しています。_パスは_ `@Path` アノテーションを使って指定します。"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:72
msgid "You can use the JPA entity manager directly.  Panache proposes an alternative removing boilerplate and exposing an active record and repository models."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:74
msgid "With Panache, the `Element` class would be as simple as:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:79
#, no-wrap
msgid ""
"@Entity\n"
"public class Element extends PanacheEntity {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:85
#, no-wrap
msgid ""
"    public String name;\n"
"    public String symbol;\n"
"    @Column(unique = true)\n"
"    public int position;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:91
msgid "Microservices tend to come in systems.  Let’s now imagine you need to access another HTTP endpoint.  You can use an HTTP client directly; this is nothing more than repeating boilerplate code.  Quarkus provides a way to call HTTP endpoints easily using the https://quarkus.io/guides/rest-client[MicroProfile Rest Client API]."
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:93
msgid "First declare your service as follows:"
msgstr "まずは以下のようにサービスを宣言しましょう。"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:99
#: upstream/_versions/1.7/guides/topic/continuum.adoc:173
#, fuzzy, no-wrap
msgid ""
"@Path(\"/elements\")\n"
"@RegisterRestClient(configKey=\"element-service\")\n"
"public interface ElementService {\n"
msgstr ""
"@Path(\"/v2\")\n"
"@RegisterRestClient\n"
"public interface CountriesService {\n"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:104
#, fuzzy, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{position}\")\n"
"    Element getElement(@PathParam(\"position\") int position);\n"
"}\n"
msgstr ""
"    @GET\n"
"    @Path(\"/name/{name}\")\n"
"    @Produces(\"application/json\")\n"
"    Set<Country> getByName(@PathParam(\"name\") String name);\n"
"}\n"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:109
msgid "For each call you are intending to do, add a method and use annotations to describe the behavior.  You can combine the REST Client with the https://quarkus.io/guides/smallrye-fault-tolerance[fault tolerance extension] to handle failure gracefully.  Then, in your resource, just use the `ElementService` interface:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:114
#, fuzzy, no-wrap
msgid ""
"@Path(\"/elem\")\n"
"public class ElementResource {\n"
msgstr ""
"@Path(\"/country\")\n"
"public class CountriesResource {\n"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:117
#, fuzzy, no-wrap
msgid ""
"    @RestClient\n"
"    ElementService elements;\n"
msgstr ""
"    @Inject\n"
"    @RestClient\n"
"    CountriesService countriesService;\n"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:124
#, fuzzy, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{position}\")\n"
"    public Element name(@PathParam(\"position\") int position) {\n"
"        return elements.getElement(position);\n"
"    }\n"
"}\n"
msgstr ""
"    @GET\n"
"    @Path(\"/name/{name}\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Set<Country> name(@PathParam(\"name\") String name) {\n"
"        return countriesService.getByName(name);\n"
"    }\n"
"}\n"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:129
#, fuzzy
msgid "But you may be wondering where the URL is configured as it's not in the code.  Remember, it must not be hard-coded because the URL likely depends on the environment.  The URL is configured in the application configuration:"
msgstr "しかし、URL　がコードの中に出てこないため、URL がどこに設定されているのか気になるかもしれません。URL は環境に依存している可能性が高いので、ハードコード化してはいけないことを覚えておいてください。URL はアプリケーションの設定で設定されています。"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:133
#, no-wrap
msgid "element-service/mp-rest/url=http://localhost:9001\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:136
#, fuzzy
msgid "The URL can now be updated during the deployment or at launch time using system properties or environment variables."
msgstr "システムのプロパティーや環境変数を使用して、デプロイ時や起動時に URL を更新できるようになりました。"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:139
msgid "Quarkus is not limited to HTTP.  You can use https://quarkus.io/guides/grpc-getting-started[gRPC] or https://quarkus.io/guides/smallrye-graphql[GraphQL], two prominent alternatives in the microservice space."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.7/guides/topic/continuum.adoc:140
#, no-wrap
msgid "Being reactive"
msgstr "リアクティブであること"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:144
#, fuzzy
msgid "Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, Big Data, or IoT, going reactive is increasingly becoming the architecture style to follow."
msgstr "アプリケーションの要件は、ここ数年で大きく変化しています。クラウドコンピューティング、ビッグデータ、IoT の時代において成功するためには、リアクティブなアーキテクチャーを採用することがますます重要になってきています。"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:146
#, fuzzy
msgid "Today’s users embrace applications with milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput, and elasticity. However, these features are nearly impossible to achieve using yesterday’s software architecture without a considerable investment in resources, infrastructure, and tooling. The world changed, and having dozens of servers, long response times (> 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience."
msgstr "今日のユーザーは、ミリ秒単位の応答時間、100％のアップタイム、低いレイテンシー、プルではなくプッシュデータ、より高いスループットと弾力性を持つアプリケーションを採用しています。しかし、これらの機能は、リソース、インフラストラクチャー、ツールへの莫大な投資なしに、_これまでのソフトウェアアーキテクチャー_ で実現することはほぼ不可能です。世界は変わり、何十台というサーバーの使用、長い応答時間 (500ms 以上)、メンテナンスによるダウンタイム、障害の嵐という状況では、期待されるユーザーエクスペリエンスを満たすことはできません。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_versions/1.7/guides/topic/continuum.adoc:147
#, fuzzy, no-wrap
msgid "Reactive"
msgstr "リアクティブであること"

#. type: Target for macro image
#: upstream/_versions/1.7/guides/topic/continuum.adoc:147
#, no-wrap
msgid "../../guides/images/reactive-microservice.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:152
msgid "Quarkus aids you on your journey to reactive.  Quarkus is based on a https://quarkus.io/version/main/guides/quarkus-reactive-architecture[reactive core] allowing your application to mix reactive and imperative components.  As an example, you can implement reactive HTTP endpoint using the https://quarkus.io/guides/resteasy-reactive[RESTEasy Reactive extension] as follows:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:161
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/elements/{position}\")\n"
"public Uni<Element> getElement(@PathParam(\"position\") int position) {\n"
"    return elements.getElement(position)\n"
"        .onFailure().recoverWithItem(FALLBACK);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:167
#, fuzzy
msgid "Thanks to the https://quarkus.io/version/main/guides/mutiny-primer[Mutiny Reactive API] , you can compose asynchronous operations and complete the result when everything is done without blocking the I/O threads.  This greatly improves resource consumption and elasticity.  Most Quarkus APIs are available in both imperative and reactive.  As example, you can use the reactive version of the REST Client:"
msgstr "メソッドアクションは、スレッドをブロックすることなく、すべてが行われたときに非同期操作を構成し、結果を完了させることができます。これにより、リソース消費と弾力性が大幅に向上します。"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:178
#, fuzzy, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{position}\")\n"
"    Uni<Element> getElement(@PathParam(\"position\") int position);\n"
"}\n"
msgstr ""
"    @GET\n"
"    @Path(\"/name/{name}\")\n"
"    @Produces(\"application/json\")\n"
"    Set<Country> getByName(@PathParam(\"name\") String name);\n"
"}\n"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:182
msgid "But, what about streams? Generating a _server-sent event_ response with Quarkus is just as simple:"
msgstr "しかし、ストリームについてはどうでしょうか? Quarkus を使用して _サーバーから送信されたイベント_ レスポンスを生成するのは簡単です。"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:191
#, no-wrap
msgid ""
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@GET\n"
"@Path(\"/events\")\n"
"public Multi<String> stream() {\n"
"    return kafka.toMulti();\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/1.7/guides/topic/continuum.adoc:193
#, no-wrap
msgid "Event-driven Architectures"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:197
#, fuzzy
msgid "However, HTTP characteristics prohibit implementing https://www.reactivemanifesto.org/[reactive systems], where all the components interact using asynchronous messages passing.  But there is no cause for concern as Quarkus is perfectly suited to implement event-driven microservices and reactive systems."
msgstr "しかし、HTTP の特性上、すべてのコンポーネントが非同期メッセージの通過を使用して相互作用する https://www.reactivemanifesto.org/[リアクティブシステム] を実装することはできません。しかし心配はいりません。Quarkus は、メッセージ駆動型のマイクロサービスやリアクティブシステムの実装に完全に適しています。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_versions/1.7/guides/topic/continuum.adoc:198
#, no-wrap
msgid "Event-Driven"
msgstr ""

#. type: Target for macro image
#: upstream/_versions/1.7/guides/topic/continuum.adoc:198
#, no-wrap
msgid "../../guides/images/eda.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:201
#, fuzzy
msgid "First, you can consume messages from various brokers such as AMQP or Apache Kafka, and process these messages smoothly:"
msgstr "まず、AMQP や Kafka などの各種ブローカーからのメッセージを消費し、スムーズに処理することができます。"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:206
#, fuzzy, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyEventProcessor {\n"
msgstr ""
"@ApplicationScoped\n"
"public class HealthDataProcessor {\n"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:213
#, fuzzy, no-wrap
msgid ""
"  @Incoming(\"health\")\n"
"  @Outgoing(\"heartbeat\")\n"
"  public double extractHeartbeat(Health health) {\n"
"    return health.getHeartbeat();\n"
"  }\n"
"}\n"
msgstr ""
"  @Incoming(\"health\")\n"
"  @Outgoing(\"heartbeat\")\n"
"  public double filtered(Health health) {\n"
"    return health.getHeartbeat();\n"
"  }\n"
"}\n"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:218
#, fuzzy
msgid "The `@Incoming` and `@Outgoing` annotations are part of https://www.smallrye.io/smallrye-reactive-messaging[Reactive Messaging].  They are used to express from which _channel_ you are consuming and to which _channel_ you are sending.  Thanks to Reactive Messaging you can consume and send messages from and to different brokers and transports such as HTTP, Kafka, or http://camel.apache.org[Apache Camel]."
msgstr "`@Incoming` および `@Outgoing` アノテーションは、https://www.smallrye.io/smallrye-reactive-messaging[Reactive Messaging] の一部です。これは、消費している _ストリーム_ から、送信しているストリームまでを表現するために使用されます。Reactive Messaging により、HTTP、Kafka、http://camel.apache.org[Apache Camel] などの異なるブローカーやトランスポートとの間でメッセージを消費したり、送信したりすることができます。"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:221
msgid "Sometimes you need more than just handling messages one by one.  You can also express your message processing logic using reactive programming as illustrated in the following snippet:"
msgstr "メッセージを 1 つずつ処理するだけでは不十分な場合もあります。次のスニペットに示すように、リアクティブプログラミングを使ってメッセージ処理ロジックを表現することもできます。"

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:233
#, no-wrap
msgid ""
"@Incoming(\"health\")\n"
"@Outgoing(\"output\")\n"
"public Multi<Record<String, Measure> filterState(Multi<Capture> input) {\n"
"    return input\n"
"        .drop().repetitions()\n"
"        .select().where(capture -> capture.value > 0)\n"
"        .onItem().transform(capture -> new Measure(capture.sensor, capture.value, capture.unit))    \n"
"        .onItem().transform(measure -> Record.of(measure.sensor, measure));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:236
msgid "As for the reactive APIs exposed by Quarkus, stream manipulation uses the Mutiny API."
msgstr ""

#. type: Title ==
#: upstream/_versions/1.7/guides/topic/continuum.adoc:237
#, no-wrap
msgid "Functions as a Service and Serverless"
msgstr "サービスとサーバーレスとしての関数"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:241
#, fuzzy
msgid "Thanks to their stellar startup time and low memory usage, you can implement functions using Quarkus to be used in serverless environments.  Quarkus provides Funqy, an approach to writing functions that are deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative Events (Cloud Events). It is also usable as a standalone service."
msgstr "驚異的な起動時間と低いメモリー使用量により、Quarkus を使用して、サーバーレス環境で使用するように関数を実装することができます。AWS Lambda を使用している場合、Quarkus の関数は次のようになります。"

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:243
msgid "With Funqy, a function is just:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:247
#, no-wrap
msgid "import io.quarkus.funqy.Funq;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/1.7/guides/topic/continuum.adoc:254
#, no-wrap
msgid ""
"public class GreetingFunction {\n"
"    @Funq\n"
"    public String greet(String name) {\n"
"       return \"Hello \" + name;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/1.7/guides/topic/continuum.adoc:256
msgid "You can use any of the Quarkus features in your function and benefit from the fast startup and low memory utilization. With Quarkus, you can embrace this new world without having to change your programming language."
msgstr "Quarkus の機能のいずれかは関数で使用することができ、高速な起動と低メモリー使用率の恩恵を受けることができます。Quarkus を使用すると、プログラミング言語を変更することなく、この新しい世界を採用することができます。"

#~ msgid ""
#~ "@Path(\"fruits\")\n"
#~ "@Produces(\"application/json\")\n"
#~ "@Consumes(\"application/json\")\n"
#~ "public class FruitResource {\n"
#~ msgstr ""
#~ "@Path(\"fruits\")\n"
#~ "@Produces(\"application/json\")\n"
#~ "@Consumes(\"application/json\")\n"
#~ "public class FruitResource {\n"

#~ msgid ""
#~ "    @Inject\n"
#~ "    EntityManager entityManager;\n"
#~ msgstr ""
#~ "    @Inject\n"
#~ "    EntityManager entityManager;\n"

#~ msgid ""
#~ "    @GET\n"
#~ "    public List<Fruit> get() {\n"
#~ "        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n"
#~ "              .getResultList();\n"
#~ "    }\n"
#~ msgstr ""
#~ "    @GET\n"
#~ "    public List<Fruit> get() {\n"
#~ "        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n"
#~ "              .getResultList();\n"
#~ "    }\n"

#~ msgid ""
#~ "    @POST\n"
#~ "    @Transactional\n"
#~ "    public Response create(Fruit fruit) {\n"
#~ "        if (fruit.getId() != null) {\n"
#~ "            throw new WebApplicationException(\"Id was invalidly set on request.\", 422);\n"
#~ "        }\n"
#~ msgstr ""
#~ "    @POST\n"
#~ "    @Transactional\n"
#~ "    public Response create(Fruit fruit) {\n"
#~ "        if (fruit.getId() != null) {\n"
#~ "            throw new WebApplicationException(\"Id was invalidly set on request.\", 422);\n"
#~ "        }\n"

#~ msgid "JPA users will recognize the `EntityManager` used to access the database.  Finally, methods requiring a transaction are simply annotated with `@Transactional`."
#~ msgstr "JPA ユーザーは、データベースへのアクセスに使用された `EntityManager` を認識します。最後に、トランザクションを必要とするメソッドには `@Transactional` が付けられています。"

#~ msgid "For each call you are intending to do, add a method and use annotations to describe the behavior."
#~ msgstr "意図している各呼び出しについて、メソッドを追加し、動作を記述するためにアノテーションを使用します。"

#~ msgid "Then, in your resource, just use the `CountriesService`:"
#~ msgstr "そして、リソースの中で `CountriesService` を使いします。"

#~ msgid ""
#~ "# the format is interface-name/mp-rest/url=the-service-url\n"
#~ "org.acme.restclient.CountriesService/mp-rest/url=https://restcountries.eu/rest\n"
#~ msgstr ""
#~ "# the format is interface-name/mp-rest/url=the-service-url\n"
#~ "org.acme.restclient.CountriesService/mp-rest/url=https://restcountries.eu/rest\n"

#~ msgid "Quarkus stands with you on your path to reactive.  First, you can implement asynchronous HTTP endpoint as follows:"
#~ msgstr "Quarkus は、皆様のリアクティブへの道筋をサポートします。まず、以下のように非同期 HTTP エンドポイントを実装します。"

#~ msgid "public class HelloLambda implements RequestHandler<HelloRequest, String> {\n"
#~ msgstr "public class HelloLambda implements RequestHandler<HelloRequest, String> {\n"

#~ msgid ""
#~ "    @Inject\n"
#~ "    HelloGreeter greeter;\n"
#~ msgstr ""
#~ "    @Inject\n"
#~ "    HelloGreeter greeter;\n"

#~ msgid ""
#~ "    @Override\n"
#~ "    public String handleRequest(HelloRequest request, Context context) {\n"
#~ "        return greeter.greet(request.firstName, request.lastName);\n"
#~ "    }\n"
#~ "}\n"
#~ msgstr ""
#~ "    @Override\n"
#~ "    public String handleRequest(HelloRequest request, Context context) {\n"
#~ "        return greeter.greet(request.firstName, request.lastName);\n"
#~ "    }\n"
#~ "}\n"
