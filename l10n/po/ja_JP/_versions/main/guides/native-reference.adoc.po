# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-04-20 11:31+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/native-reference.adoc:6
#, no-wrap
msgid "Native Reference Guide"
msgstr "ネイティブリファレンスガイド"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:19
msgid "This guide is a companion to the xref:building-native-image.adoc[Building a Native Executable], xref:native-and-ssl.adoc[Using SSL With Native Images], and xref:writing-native-applications-tips.adoc[Writing Native Applications], guides.  It explores advanced topics that help users diagnose issues, increase the reliability and improve the runtime performance of native executables.  These are the high level sections to be found in this guide:"
msgstr "このガイドは、xref:building-native-image.adoc[ネイティブ実行可能ファイルのビルド]、xref:native-and-ssl.adoc[ネイティブイメージでのSSLの使用]、xref:writing-native-applications-tips.adoc[ネイティブアプリケーションの作成] の各ガイドに付随するものです。ユーザーが問題を診断し、信頼性を高め、ネイティブ実行可能ファイルのランタイム パフォーマンスを向上させるのに役立つ高度なトピックについて説明します。 これらは、このガイドにある高レベルのセクションです:"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:21
#, fuzzy
msgid "xref:native-memory-management[Native Memory Management]"
msgstr "link:#native-memory-management[ネイティブメモリ管理]"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:22
#, fuzzy
msgid "xref:inspecting-and-debugging[Inspecting and Debugging Native Executables]"
msgstr "link:#inspecting-and-debugging[ネイティブ実行可能ファイルの検査とデバッグ]"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:23
#, fuzzy
msgid "xref:native-faq[Frequently Asked Questions]"
msgstr "よくある質問"

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:25
#, no-wrap
msgid "Native Memory Management"
msgstr "ネイティブメモリ管理"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:30
msgid "Memory management for Quarkus native executables is enabled by GraalVM’s SubstrateVM runtime system.  The memory management component in GraalVM is explained in detail link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[here].  This guide complements the information available in the GraalVM website with further observations particularly relevant to Quarkus applications."
msgstr "Quarkusネイティブ実行可能ファイルのメモリ管理は、GraalVMのSubstrateVMランタイムシステムによって実現されています。GraalVMのメモリ管理コンポーネントは、 link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[ここ] で詳しく説明されています。このガイドでは、GraalVMのウェブサイトで利用可能な情報を補完し、特にQuarkusアプリケーションに関連するさらなる見解を示しています。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:31
#, no-wrap
msgid "Garbage Collectors"
msgstr "ガベージコレクター"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:33
msgid "The garbage collectors available for Quarkus users are currently Serial GC and Epsilon GC."
msgstr "Quarkusのユーザーが利用できるガベージコレクタは、現在、Serial GCとEpsilon GCです。"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:34
#, no-wrap
msgid "Serial GC"
msgstr "シリアルGC"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:38
msgid "Serial GC, the default option in GraalVM and Quarkus, is a single-threaded non-concurrent GC, just like HotSpot’s Serial GC.  The implementation in GraalVM however is different from the HotSpot one, and there can be significant differences in the runtime behavior."
msgstr "GraalVMとQuarkusのデフォルトオプションであるシリアルGCは、HotSpotのシリアルGCと同様にシングルスレッドで非同期のGCです。しかし、GraalVMの実装はHotSpotのものと異なっており、実行時の動作に大きな違いがある場合があります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:49
#, fuzzy
msgid "One of the key differences between HotSpot’s Serial GC and GraalVM’s Serial GC is the way they perform full GC cycles.  In HotSpot the algorithm used is mark-sweep-compact whereas in GraalVM it is mark-copy.  Both need to traverse all live objects, but in mark-copy this traversal is also used to copy live objects to a secondary space or semi-space.  As objects are copied from one semi-space to another they’re also compacted.  In mark-sweep-compact, the compacting requires a second pass on the live objects.  This makes full GCs in mark-copy more time efficient (in terms of time spent in each GC cycle) than mark-sweep-compact.  The tradeoff mark-copy makes in order to make individual full GC cycles shorter is space.  The use of semi-spaces means that for an application to maintain the same GC performance that mark-sweep achieves (in terms of allocated MB per second), it requires double the amount of memory."
msgstr "HotSpotのシリアルGCとGraalVMのシリアルGCの主な違いの1つは、完全なGCサイクルを実行する方法です。HotSpotで使用されるアルゴリズムはmark-sweep-compactであるのに対し、GraalVMではmark-copyである。どちらもすべてのライブオブジェクトをトラバースする必要がありますが、マークコピーでは、このトラバーサルは、セカンダリ空間または半空間にライブオブジェクトをコピーするためにも使用されます。オブジェクトが半空間から別の半空間へコピーされる際に、オブジェクトもコンパクトになります。mark-sweep-compactでは、コンパクト化にはライブ・オブジェクトに対する2回目のパスが必要です。このため、mark-copyのフルGCは、mark-sweep-compactよりも時間効率（各GCサイクルに費やされる時間という意味で）が高くなっています。個々のフルGCサイクルを短くするために、mark-copyが行うトレードオフはスペースです。セミスペースの使用は、アプリケーションがmark-sweepが達成するのと同じGCパフォーマンス（1秒あたりの割り当てMB数）を維持するために、2倍のメモリ量を必要とすることを意味します。"

#. type: Title =====
#: upstream/_versions/main/guides/native-reference.adoc:50
#, no-wrap
msgid "GC Collection Policy"
msgstr "GCコレクションポリシー"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:53
msgid "GraalVM's Serial GC implementation offers a choice between two different collection policies, the default is called \"adaptive\" and the alternative is called \"space/time\"."
msgstr "GraalVMのシリアルGC実装は、2つの異なる収集ポリシー間の選択を提供します。デフォルトは \"adaptive\" と呼ばれ、代替は \"space/time\"と呼ばれます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:57
msgid "The “adaptive” collection policy is based on HotSpot's ParallelGC adaptive size policy.  The main difference with HotSpot is GraalVM's focus on memory footprint.  This means that GraalVM’s adaptive GC policy tries to aggressively trigger GCs in order to keep memory consumption down."
msgstr "“adaptive” コレクションポリシーは、HotSpotのParallelGC adaptiveサイズポリシーがベースになっています。HotSpotとの主な違いは、GraalVMがメモリフットプリントに重点を置いていることです。つまり、GraalVMの adaptive GCポリシーは、メモリ消費を抑えるために積極的にGCをトリガーしようとします。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:65
#, fuzzy
msgid "Up to version 2.13, Quarkus used the “space/time” GC collection policy by default, but starting with version 2.14, it switched to using the “adaptive” policy instead.  The reason why Quarkus initially chose to use \"space/time\" is because at that time it had considerable performance improvements over \"adaptive\".  Recent performance experiments, however, indicate that the \"space/time\" policy can result in worse out-of-the-box experience compared to the \"adaptive\" policy, while at the same time the benefits it used to offer have diminished considerably after improvements made to the \"adaptive\" policy.  As a result, the \"adaptive\" policy appears to be the best option for most, if not all, Quarkus applications.  Full details on this switch can be read in link:https://github.com/quarkusio/quarkus/issues/28267[this issue]."
msgstr "バージョン2.13までは、Quarkusはデフォルトで「space/time」GC収集ポリシーを使用していましたが、バージョン2.14から、代わりに「adaptive」ポリシーを使用するように変更されました。Quarkusが当初「space/time」の使用を選択した理由は、当時は「adaptive」よりもパフォーマンスがかなり向上していたためです。しかし、最近の性能実験によると、「space/time」ポリシーは、「adaptive」ポリシーに比べて、すぐに使える体験が悪くなると同時に、「adaptive」ポリシーの改善後は、以前提供していた利点がかなり減少していることがわかりました。その結果、すべてではないにせよ、ほとんどのQuarkusアプリケーションでは、「adaptive」ポリシーが最良の選択肢であると思われます。この切り替えの詳細については、 link:https://github.com/quarkusio/quarkus/issues/28267[本号を] お読みください。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:68
msgid "It is still possible to change the GC collection policy using GraalVM’s `-H:InitialCollectionPolicy` flag.  Switching to the \"space/time\" policy can be done by passing the following via command line:"
msgstr "GraalVMの `-H:InitialCollectionPolicy` フラグを使用して、GCコレクションポリシーを変更することはまだ可能です。\"space/time\"ポリシーへの切り替えは、コマンドライン経由で以下を渡すことで行うことができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:72
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy\\$BySpaceAndTime\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:75
msgid "Or adding this to the `application.properties` file:"
msgstr "または、 `application.properties` ファイルにこれを追加します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:79
#, no-wrap
msgid "quarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:85
msgid "Escaping the `$` character is required to configure the \"space/time\" GC collection policy if passing via command line in Bash.  Other command line environments might have similar requirements."
msgstr "Bash でコマンドラインから渡す場合、\"space/time\" GC collection ポリシーを設定するために `$` 文字をエスケープすることが必要です。他のコマンドライン環境では、同様の要件があるかもしれません。"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:87
#, no-wrap
msgid "Epsilon GC"
msgstr "Epsilon GC"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:91
msgid "Epsilon GC is a no-op garbage collector which does not do any memory reclamation.  From a Quarkus perspective, some of the most relevant use cases for this garbage collector are extremely short-lived jobs, e.g. serverless functions.  To build Quarkus native with epsilon GC, pass the following argument at build time:"
msgstr "Epsilon GCは、メモリの再利用を行わないノーオペ・ガベージコレクタです。Quarkusの観点からは、このガベージコレクタに最も関連するユースケースは、サーバーレス機能などの極めて短命のジョブです。epsilon GCを使用してQuarkusネイティブをビルドするには、ビルド時に次の引数を渡します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:95
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=--gc=epsilon\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:97
#, no-wrap
msgid "Memory Management Options"
msgstr "メモリ管理オプション"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:101
msgid "Options to control maximum heap size, young space and other typical use cases found in the JVM can be found in https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[the GraalVM memory management guide].  Setting the maximum heap size, either as a percentage or an explicit value, is generally recommended."
msgstr "最大ヒープサイズ、ヤングスペース、およびJVMで見られる他の典型的なユースケースを制御するためのオプションは、 link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[GraalVMメモリ管理ガイド] で見つけることができます。パーセンテージまたは明示的な値として、最大ヒープサイズを設定することは、一般的に推奨されます。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:103
#, no-wrap
msgid "GC Logging"
msgstr "GCロギング"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:106
msgid "Multiple options exist to print information about garbage collection cycles, depending on the level of detail required.  The minimum detail is provided `-XX:+PrintGC`, which prints a message for each GC cycle that occurs:"
msgstr "ガベージコレクションサイクルに関する情報を表示するための複数のオプションが必要な詳細度に応じて存在します。最小限の詳細は、 `-XX:+PrintGC` で提供され、発生した各GCサイクルのメッセージを表示します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:113
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -Xmx64m\n"
"...\n"
"[Incremental GC (CollectOnAllocation) 20480K->11264K, 0.0003223 secs]\n"
"[Full GC (CollectOnAllocation) 19456K->5120K, 0.0031067 secs]\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:118
#, fuzzy
msgid "When you combine this option with `-XX:+VerboseGC` you still get a message per GC cycle, but it contains extra information.  Also, adding this option shows the sizing decisions made by the GC algorithm at startup:"
msgstr "このオプションを `-XX:+VerboseGC` と組み合わせると、GC サイクルごとにメッセージが表示されますが、これには余分な情報が含まれています。また、このオプションを追加すると、GCアルゴリズムが起動時に行ったサイジングの決定が表示されます："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:137
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -XX:+VerboseGC -Xmx64m\n"
"[Heap policy parameters:\n"
"YoungGenerationSize: 25165824\n"
"MaximumHeapSize: 67108864\n"
"MinimumHeapSize: 33554432\n"
"AlignedChunkSize: 1048576\n"
"LargeArrayThreshold: 131072]\n"
"...\n"
"[[5378479783321 GC: before  epoch: 8  cause: CollectOnAllocation]\n"
"[Incremental GC (CollectOnAllocation) 16384K->9216K, 0.0003847 secs]\n"
"[5378480179046 GC: after   epoch: 8  cause: CollectOnAllocation  policy: adaptive  type: incremental\n"
"collection time: 384755 nanoSeconds]]\n"
"[[5379294042918 GC: before  epoch: 9  cause: CollectOnAllocation]\n"
"[Full GC (CollectOnAllocation) 17408K->5120K, 0.0030556 secs]\n"
"[5379297109195 GC: after   epoch: 9  cause: CollectOnAllocation  policy: adaptive  type: complete\n"
"collection time: 3055697 nanoSeconds]]\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:140
#, fuzzy
msgid "Beyond these two options, `-XX:+PrintHeapShape` and `-XX:+TraceHeapChunks` provide even lower level details about memory chunks on top of which the different memory regions are constructed."
msgstr "この2つのオプションを越えて、 `-XX:+PrintHeapShape` と `-XX:+TraceHeapChunks` は、異なるメモリ領域が構築される上に、メモリチャンクに関するさらに低いレベルの詳細を提供します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:142
msgid "The most up-to-date information on GC logging flags can be obtained by printing the list of flags that can be passed to native executables:"
msgstr "GCロギングフラグについての最新情報は、ネイティブ実行可能ファイルに渡すことができるフラグのリストを表示することで得ることができます:"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:155
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:PrintFlags=\n"
"...\n"
"  -XX:±PrintGC                                 Print summary GC information after each collection. Default: - (disabled).\n"
"  -XX:±PrintGCSummary                          Print summary GC information after application main method returns. Default: - (disabled).\n"
"  -XX:±PrintGCTimeStamps                       Print a time stamp at each collection, if +PrintGC or +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintGCTimes                            Print the time for each of the phases of each collection, if +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintHeapShape                          Print the shape of the heap before and after each collection, if +VerboseGC. Default: - (disabled).\n"
"...\n"
"  -XX:±TraceHeapChunks                         Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Default: - (disabled).\n"
"  -XX:±VerboseGC                               Print more information about the heap before and after each collection. Default: - (disabled).\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:158
#, fuzzy, no-wrap
msgid "Resident Set Size (RSS)"
msgstr "レジデント・セット・サイズ（RSS）"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:165
#, fuzzy
msgid "As described in the xref:performance-measure.adoc[Measuring Performance guide], the footprint of Quarkus applications is measured using the resident set size (RSS).  This is also applicable to native applications, but the runtime engine that manages the footprint in this case is built in the native executable itself rather than the JVM."
msgstr "link:performance-measure.html[パフォーマンスの測定」ガイドで] 説明したように、Quarkusアプリケーションのフットプリントは、レジデントセットサイズ（RSS）を使用して測定されます。これはネイティブアプリケーションにも適用できますが、この場合のフットプリントを管理するランタイムエンジンは、JVMではなく、ネイティブ実行ファイル自体に組み込まれています。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:170
#, fuzzy
msgid "The reporting techniques specified in the xref:performance-measure.adoc[Measuring Performance guide] are applicable to native applications too, but what causes the RSS to be higher or lower is specific to how the generated native executables work."
msgstr "link:performance-measure.html[パフォーマンスの測定」ガイドで] 指定されているレポート手法は、ネイティブアプリケーションにも適用できますが、RSSが高くなったり低くなったりする原因は、生成されたネイティブ実行ファイルがどのように動作するかに特有のものです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:173
#, fuzzy
msgid "When the RSS is higher in one native version of the application versus another, the following checks should be carried out first:"
msgstr "あるネイティブバージョンのアプリケーションと別のアプリケーションでRSSが高くなる場合、まず以下のチェックを行う必要があります："

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:177
#, fuzzy
msgid "Check the xref:native-reports[native build time reports] and see if there are big discrepancies in the number of used packages, used classes or used methods.  A bigger universe will result in bigger memory footprint."
msgstr "link:#native-reports[ネイティブビルドタイムレポートを] 確認し、使用パッケージ数、使用クラス数、使用メソッド数に大きな相違がないかを確認します。ユニバースが大きいと、メモリフットプリントが大きくなります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:182
#, fuzzy
msgid "Check the size of the binary for differences.  Using `readelf` you can observe the size of different sections and compare them.  The `.text` section where code lives, and the `.svm_heap` section where heap produced at build time lives, are particularly interesting."
msgstr "バイナリーのサイズに違いがないか確認する。 `readelf` を使って、異なるセクションのサイズを観察し、比較することができます。特に、コードが存在する `.text` セクションと、ビルド時に生成されるヒープが存在する `.svm_heap` セクションは興味深いです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:183
#, fuzzy
msgid "Generate xref:heap-dumps[heap dumps] and inspect them with tools such as VisualVM or Eclipse MAT."
msgstr "link:#heap-dumps[ヒープダンプを] 生成し、VisualVMやEclipse MATなどのツールで検査する。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:191
#, fuzzy
msgid "Often profiling, instrumenting or tracing applications is the best way to figure out how things work.  In the case of RSS and native applications, the techniques that Brendan Gregg explains in the https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[\"Memory Leak (and Growth) Flame Graphs\"] guide are particularly useful.  This section will apply the information in that article to show how to use `perf` and https://github.com/iovisor/bcc[bcc/eBPF] to understand what causes Quarkus native executables to consume memory on startup."
msgstr "多くの場合、アプリケーションのプロファイリング、インストルメンテーション、トレースは、物事がどのように動作するかを把握するための最良の方法です。RSSやネイティブアプリケーションの場合、Brendan Greggが link:https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[「メモリリーク（と成長）炎グラフ」] ガイドで説明しているテクニックが特に有効です。このセクションでは、その記事の情報を応用して、 `perf` 、 link:https://github.com/iovisor/bcc[bcc/eBPFを] 使用して、Quarkusネイティブ実行ファイルが起動時にメモリを消費する原因を理解する方法を紹介します。"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:193
#, fuzzy, no-wrap
msgid "Perf"
msgstr "パーフ"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:198
#, fuzzy
msgid "`perf` works in older Linux systems, whereas eBPF requires a newer Linux kernel.  The overhead of `perf` is higher than eBPF, but it can understand stack traces generated with DWARF debug symbols, which eBPF can't."
msgstr "`perf` は古いLinuxシステムで動作しますが、eBPFは新しいLinuxカーネルを必要とします。 のオーバーヘッドは eBPF よりも高いが、eBPF では理解できない DWARF デバッグシンボルで生成されたスタックトレースを理解できる。 `perf` "

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:205
#, fuzzy
msgid "In the context of GraalVM, DWARF stack traces contain more detail and are easier to understand than those generated with frame pointers.  As first step, build a Quarkus native executable with debug info enabled and a couple of extra flags.  One flag to disable optimizations, and another to avoid inlined methods being omitted from the stack traces.  These two flags have been added to obtain stack traces that contain as much information as possible."
msgstr "GraalVMのコンテキストでは、DWARFスタックトレースは、フレームポインタで生成されたものよりも詳細な情報を含み、理解しやすくなっています。最初のステップとして、デバッグ情報を有効にし、いくつかのフラグを追加したQuarkusネイティブ実行ファイルを構築します。1つは最適化を無効にするフラグ、もう1つはインライン化されたメソッドがスタックトレースから省かれるのを避けるためのフラグです。この2つのフラグは、できるだけ多くの情報を含むスタックトレースを取得するために追加されました。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:211
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.debug.enabled \\\n"
"  -Dquarkus.native.additional-build-args=-O0,-H:-OmitInlinedMethodDebugLineInfo\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:224
#, fuzzy
msgid "Disabling optimizations makes it easier to learn how to use `perf` and get as detailed stack traces as possible, because it shows more info about what gets called where.  However, doing so might lead to more allocations happening which would not happen if optimizations would have been applied.  In other words, passing in `-O0` will change the allocation pattens for many applications, because it disables optimizations such as escape analysis or dead code elimination.  To properly assess the allocations made by an application deployed in production, run with default optimizations (`-O2`).  With default optimizations the stack traces obtained with `perf` maybe be harder to decipher."
msgstr "最適化を無効にすると、 `perf` の使い方を学びやすくなり、スタックトレースをできるだけ詳細に取得することができます。これは、何がどこで呼び出されるのかについてより多くの情報を示すためです。しかし、そうすることで、最適化が適用されていれば起こらないような、より多くのアロケーションが発生する可能性があります。言い換えれば、 `-O0` を渡すと、エスケープ分析やデッドコード除去などの最適化が無効になるため、多くのアプリケーションでアロケーションパターンが変化します。本番環境に導入されたアプリケーションのアロケーションを適切に評価するには、デフォルトの最適化( `-O2 `)で実行します。デフォルトの最適化では、 `perf` で得られたスタックトレースを解読するのは難しいかもしれません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:227
#, fuzzy
msgid "Let's measure how much RSS a Quarkus native executable takes on startup on this particular environment:"
msgstr "この特定の環境で、Quarkusのネイティブ実行ファイルが起動時にどれだけのRSSを消費するかを測定してみましょう："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:233
#, no-wrap
msgid ""
"$ ps -o pid,rss,command -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"      PID   RSS COMMAND\n"
"     1915 35472 ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:252
#, fuzzy
msgid "How come this Quarkus native executable consumes ~35MB RSS on startup? To get an understanding of this number, this section will use `perf` to trace calls to `syscalls:sys_enter_mmap`.  Assuming the default https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/MemoryManagement/#serial-garbage-collector[Serial Garbage Collector] is in use, this system call is particularly interesting for native executables generated by GraalVM's `native-image` because of how it allocates heap.  In native executables generated by GraalVM's `native-image`, the heap is allocated using either aligned or unaligned heap chunks.  All non-array objects get allocated in thread local aligned chunks.  Each of these are 1MB in size by default.  For arrays, if they are bigger than 1/8 of the aligned chunk size, they will be allocated in unaligned heap chunks which have a size dependant on the object itself.  The very first time a thread allocates an object or small array, it will request an aligned heap chunk that it will use exclusively until it has run out of space in that chunk, in which case it will request another aligned heap chunk.  So by tracing these system calls, the code paths that end up requesting new aligned or unaligned heap chunks will be recorded.  Next, run the Quarkus native executable through `perf record` tracing the `mmap` system call:"
msgstr "Quarkusのネイティブ実行ファイルは、なぜ起動時に35MBのRSSを消費するのでしょうか。この数値を理解するために、このセクションでは、 `perf` を使用して `syscalls:sys_enter_mmap` への呼び出しをトレースします。デフォルトの link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/MemoryManagement/#serial-garbage-collector[シリアルガベージコレクタが] 使用されていると仮定すると、このシステムコールは、GraalVMの `native-image` 、ヒープを割り当てる方法によって生成されたネイティブ実行可能ファイルにとって特に興味深いものとなっています。GraalVMの `native-image` によって生成されたネイティブ実行可能ファイルでは、ヒープは、整列または非整列ヒープチャンクのいずれかを使用して割り当てられる。すべての非配列オブジェクトは、スレッドローカルアラインドチャンクで割り当てられる。これらの各チャンクは、デフォルトで1MBの大きさです。配列の場合、配列されたチャンクのサイズの1/8より大きい場合は、オブジェクト自体に依存するサイズを持つ非整列ヒープチャンクで割り当てられます。スレッドが初めてオブジェクトや小さな配列を割り当てたとき、そのスレッドはアラインドヒープチャンクを要求し、そのチャンクのスペースを使い果たすまで独占的に使用します。したがって、これらのシステムコールをトレースすることで、新しいアラインドヒープチャンクまたはアンアラインドヒープチャンクを要求することになるコードパスが記録されることになります。次に、Quarkusのネイティブ実行ファイルを `perf record` 、 `mmap` システムコールをトレースして実行します："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:256
#, no-wrap
msgid "$ sudo perf record -e syscalls:sys_enter_mmap --call-graph dwarf -a -- target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:263
#, fuzzy
msgid "The size of the aligned heap chunks can be changed during native build time.  A custom value (in number of bytes) can be passed via the `-H:AlignedHeapChunkSize` flag.  One caveat is that this value needs to be multiple of 4096 (4KB)."
msgstr "整列されたヒープチャンクのサイズは、ネイティブビルド時に変更することができます。カスタム値（バイト数）は、 `-H:AlignedHeapChunkSize` フラグで渡すことができます。注意点として、この値は4096（4KB）の倍数である必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:266
#, fuzzy
msgid "Once the startup completes, stop the process and generate the stacks:"
msgstr "起動が完了したら、プロセスを停止し、スタックを生成します："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:270
#, no-wrap
msgid "$ perf script > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:275
#, fuzzy
msgid "As a final step, generate a https://github.com/brendangregg/FlameGraph[flamegraph] with the generated stacks:"
msgstr "最後に、生成されたスタックを用いて link:https://github.com/brendangregg/FlameGraph[フレームグラフを] 生成する："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:281
#, no-wrap
msgid ""
"$ export FG_HOME=...\n"
"$ ${FG_HOME}/stackcollapse-perf.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"    --color=mem --title=\"mmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:284
#, fuzzy
msgid "The flamegraph should look similar to this:"
msgstr "flamegraphはこのような形になるはずです："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:285
#, fuzzy, no-wrap
msgid "mmap flamegraph"
msgstr "フレームグラフを作成して開いてください。"

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:285
#, no-wrap
msgid "mmap.svg"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:288
#, fuzzy
msgid "There are several things of interest to notice there:"
msgstr "そこには、いくつかの気になる点があります："

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:293
#, fuzzy
msgid "First, the stack traces that contain method calls to `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` are related to aligned or unaligned heap chunk allocations explained above.  As noted earlier, for the majority of allocations these chunks will be 1MB by default, so they're interesting because each allocated chunk has a considerable effect on the RSS consumption."
msgstr "まず、 `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` のメソッドコールを含むスタックトレースは、上で説明したアラインドまたはアンアラインドのヒープチャンク割り当てに関連しています。前述のように、大部分の割り当てでは、これらのチャンクはデフォルトで1MBになるので、割り当てられた各チャンクがRSS消費量にかなりの影響を与えるため、興味深いものです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:301
#, fuzzy
msgid "Second, of the thread allocation stacks, the ones under `start_thread` are particularly revealing.  In this environment, taking into account the `-Xmx` value passed in, Quarkus creates 12 event loop threads.  Aside from those, there are 6 extra threads.  The names of all those 18 threads exceed 16 characters.  This can be observed via the `ps` command:"
msgstr "次に、スレッド割り当てスタックのうち、 `start_thread` の下にあるものが特に明らかになっています。この環境では、渡された `-Xmx` の値を考慮すると、Quarkusは12個のイベントループスレッドを作成します。それとは別に、6つの余分なスレッドがあります。これら18個のスレッドの名前は、すべて16文字を超えます。これは、 `ps` コマンドで確認することができます："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:323
#, no-wrap
msgid ""
"$ ps -e -T | grep $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"   2320    2320 pts/0    00:00:00 code-with-quark\n"
"   2320    2321 pts/0    00:00:00 ference Handler\n"
"   2320    2322 pts/0    00:00:00 gnal Dispatcher\n"
"   2320    2324 pts/0    00:00:00 ecutor-thread-0\n"
"   2320    2325 pts/0    00:00:00 -thread-checker\n"
"   2320    2326 pts/0    00:00:00 ntloop-thread-0\n"
"   2320    2327 pts/0    00:00:00 ntloop-thread-1\n"
"   2320    2328 pts/0    00:00:00 ntloop-thread-2\n"
"   2320    2329 pts/0    00:00:00 ntloop-thread-3\n"
"   2320    2330 pts/0    00:00:00 ntloop-thread-4\n"
"   2320    2331 pts/0    00:00:00 ntloop-thread-5\n"
"   2320    2332 pts/0    00:00:00 ntloop-thread-6\n"
"   2320    2333 pts/0    00:00:00 ntloop-thread-7\n"
"   2320    2334 pts/0    00:00:00 ntloop-thread-8\n"
"   2320    2335 pts/0    00:00:00 ntloop-thread-9\n"
"   2320    2336 pts/0    00:00:00 tloop-thread-10\n"
"   2320    2337 pts/0    00:00:00 tloop-thread-11\n"
"   2320    2338 pts/0    00:00:00 ceptor-thread-0\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:332
#, fuzzy
msgid "The very first allocation that all these threads do is taking the thread name and trimming it so that it can fall within the character limit enforced by kernels.  For each of those allocations, there are 2 `mmap` calls, one to reserve the memory and the other to commit it.  When recording `syscalls:sys_enter_mmap` system call, the `perf` implementation tracks calls to `__GI___mmap64`.  But this glibc `__GI___mmap64` implementation makes another call into `__GI___mmap64`:"
msgstr "これらのスレッドが行う最初の割り当ては、スレッド名を取得し、カーネルが強制する文字数制限内に収まるようにトリミングすることです。これらの割り当てのそれぞれについて、2つの `mmap` 呼び出しがあります。1つはメモリを予約するため、もう1つはそれをコミットするためです。 `syscalls:sys_enter_mmap` システムコールを記録する場合、 `perf` の実装は、以下の呼び出しを追跡します。 `_GI __mmap64 `.しかし、このglibc `_GI __mmap64 `の実装では、別の呼び出しが行われます。 `_GI __mmap64 `:"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:362
#, no-wrap
msgid ""
"(gdb) break __GI___mmap64\n"
"(gdb) set scheduler-locking step\n"
"...\n"
"Thread 2 \"code-with-quark\" hit Breakpoint 1, __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"58\t  return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd, offset);\n"
"(gdb) bt\n"
"#0  __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"#1  __GI___mmap64 (addr=0x0, len=2097152, prot=0, flags=16418, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:46\n"
"#2  0x00000000004f4033 in com.oracle.svm.core.posix.headers.Mman$NoTransitions::mmap (__0=<optimized out>, __1=<optimized out>, __2=<optimized out>, __3=<optimized out>, __4=<optimized out>, __5=<optimized out>)\n"
"#3  0x00000000004f194e in com.oracle.svm.core.posix.PosixVirtualMemoryProvider::reserve (this=0x7ffff7691220, nbytes=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/posix/PosixVirtualMemoryProvider.java:126\n"
"#4  0x00000000004ef3b3 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocate (this=0x7ffff7658cb0, size=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:124\n"
"#5  0x0000000000482f40 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocateAlignedChunk (this=0x7ffff7658cb0, nbytes=0x100000, alignment=0x100000) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:107\n"
"#6  com.oracle.svm.core.genscavenge.HeapChunkProvider::produceAlignedChunk (this=0x7ffff7444398) at com/oracle/svm/core/genscavenge/HeapChunkProvider.java:112\n"
"#7  0x0000000000489485 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject0 (hub=0x7ffff6ff6110, length=15, size=0x20, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:306\n"
"#8  0x0000000000489165 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:279\n"
"#9  0x0000000000489066 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArray (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:242\n"
"#10 0x0000000000d202a1 in java.util.Arrays::copyOfRange (original=0x7ffff6a33410, from=2, to=17) at java/util/Arrays.java:3819\n"
"#11 0x0000000000acf8e6 in java.lang.StringLatin1::newString (val=0x7ffff6a33410, index=2, len=15) at java/lang/StringLatin1.java:769\n"
"#12 0x0000000000acac59 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2, endIndex=17) at java/lang/String.java:2712\n"
"#13 0x0000000000acaba2 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2) at java/lang/String.java:2680\n"
"#14 0x00000000004f96cd in com.oracle.svm.core.posix.thread.PosixPlatformThreads::setNativeName (this=0x7ffff7658d10, thread=0x7ffff723fb30, name=0x7ffff6dc0d48) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:163\n"
"#15 0x00000000004f9285 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::beforeThreadRun (this=0x7ffff7658d10, thread=0x7ffff723fb30) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:212\n"
"#16 0x00000000005237a2 in com.oracle.svm.core.thread.PlatformThreads::threadStartRoutine (threadHandle=0x1) at com/oracle/svm/core/thread/PlatformThreads.java:760\n"
"#17 0x00000000004f9627 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::pthreadStartRoutine (data=0x2a06e20) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:203\n"
"#18 0x0000000000462ab0 in com.oracle.svm.core.code.IsolateEnterStub::PosixPlatformThreads_pthreadStartRoutine_38d96cbc1a188a6051c29be1299afe681d67942e (__0=<optimized out>) at com/oracle/svm/core/code/IsolateEnterStub.java:1\n"
"#19 0x00007ffff7e4714d in start_thread (arg=<optimized out>) at pthread_create.c:442\n"
"#20 0x00007ffff7ec8950 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:368
#, fuzzy
msgid "Setting `set scheduler-locking step` when the Quarkus native executable is running through `gdb` makes it easier to debug multi-threaded applications.  It optimizes for single-stepping by stopping other threads from \"seizing the prompt\" by preempting the current thread is being stepped through."
msgstr "Quarkusのネイティブ実行ファイルが `gdb` を介して実行されているときに `set scheduler-locking step` を設定すると、マルチスレッドアプリケーションのデバッグが容易になります。これは、現在のスレッドがステップスルーされるのを先取りして、他のスレッドが「プロンプトをつかむ」のを阻止することにより、シングルステッピングを最適化します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:372
#, fuzzy
msgid "This is how the above flamegraph shows a total of 72 calls to `__GI___mmap64` for the thread name abbreviation stack trace, given that Quarkus native executable runs 18 threads."
msgstr "このように、上記のフレームグラフでは、合計72回もの呼び出しを `_GI __mmap64 `は、Quarkusのネイティブ実行ファイルが18スレッドで動作していることを想定して、スレッド名の省略形スタックトレースを作成しました。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:382
#, fuzzy
msgid "A third, and final observation, is that if you capture the `syscalls:sys_enter_munmmap` event, you might observe that some allocations also result in calls to `munmap`.  When calculating the size to reserve, the requested size to allocate can be rounded up to the page size.  The maintain alignment, 1MB in case of aligned chunks or 1 byte for unaligned chunks, some of the reserved memory might be unreserved.  That is where these `munmap` calls would come from."
msgstr "3つ目は、 `syscalls:sys_enter_munmmap` イベントをキャプチャすると、いくつかの割り当てが `munmap` の呼び出しになることが観察されることです。 予約するサイズを計算するとき、割り当て要求サイズはページサイズに切り上げられます。アライメントを維持するために、アライメントされたチャンクの場合は1MB、アライメントされていないチャンクの場合は1バイト、予約されたメモリの一部は予約されていないかもしれません。そこで、これらの `munmap` の呼び出しが発生することになる。"

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:391
#, fuzzy
msgid "Just by looking at the flamegraph and counting the number of `mmap` calls that originate in thread local allocations, an approximate estimation can be made on the RSS a Quarkus native executable uses on startup.  This estimation can't be fully precise because for unaligned heap chunks, the stack trace doesn't record the size of the chunk.  Also, if the additional build args are removed, inlining optimizations might obscure the type of array allocation chunk requested, so it might not be possible to decipher if the allocation is for an aligned or unaligned chunk."
msgstr "フレームグラフを見て、スレッドのローカル割り当てを起点とする `mmap` 呼び出しの数を数えるだけで、Quarkusネイティブ実行ファイルが起動時に使用するRSSをおおよそ推定することができます。この推定は、完全に正確なものではありません。なぜなら、整列されていないヒープチャンクの場合、スタックトレースにチャンクのサイズが記録されないからです。また、追加のビルド引数が削除された場合、インライン最適化によって要求された配列割り当てチャンクのタイプが不明瞭になり、割り当てがアラインドチャンクかアンアラインドチャンクかを判断できない可能性があります。"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:394
#, fuzzy, no-wrap
msgid "bcc/eBPF"
msgstr "bcc/eBPF"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:404
#, fuzzy
msgid "A version of https://github.com/iovisor/bcc[bcc]/ https://ebpf.io/[eBPF] that can do stack traces is only available from Linux kernel 4.8 onwards.  It can do in-kernel summaries, which makes it more efficient and has lower overhead.  Unfortunately it doesn't understand DWARF debug symbols, so the information obtained might be harder to read and contain less detail."
msgstr "スタックトレースができる link:https://github.com/iovisor/bcc[bcc/] link:https://ebpf.io/[eBPFの] バージョンは、Linuxカーネル4.8以降でのみ利用可能です。カーネル内サマリーを行うことができるため、より効率的でオーバーヘッドが少なくなっています。しかし、DWARFデバッグシンボルを理解できないため、得られる情報は読みづらく、詳細な情報が含まれていない可能性があります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:413
#, fuzzy
msgid "bcc/eBPF is very extensible so it's easier to tailor make scripts to track specific metrics.  The `bcc` project contains a `stackcount` program that can be used to count stack traces in similar way to what `perf` did in the previous section.  But in some cases, it might be more useful to have other metrics other than number of calls to a system call.  `malloc` is one such example.  The number of `malloc` calls is not so important, but rather the size of the allocations.  So rather than having a flamegraph showing sample counts, a flamegraph can be generated that shows bytes allocated."
msgstr "bcc/eBPFは非常に拡張性が高いので、特定のメトリクスを追跡するためのスクリプトを作るのが簡単です。 `bcc` プロジェクトには `stackcount` プログラムがあり、前のセクションで `perf` が行ったのと同様の方法でスタックトレースをカウントするために使用することができます。しかし、場合によっては、システムコールの呼び出し回数以外のメトリクスがあった方が便利なこともあります。 `malloc` はそのような例の1つです。 `malloc` の呼び出し回数はそれほど重要ではなく、むしろアロケーションの大きさが重要です。そのため、サンプル数を示すフレームグラフではなく、割り当てられたバイトを示すフレームグラフを生成することができます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:417
#, fuzzy
msgid "Aside from `mmap`, `malloc` system calls are also present in native executables generated by GraalVM.  Let's put bcc/eBPF in action to generate a flamegraph of bytes allocated using `malloc`."
msgstr "`mmap` 以外に、 `malloc` システムコールは、GraalVM が生成するネイティブ実行ファイルにも存在します。bcc/eBPF を使って、 `malloc` を使って割り当てられたバイトのフレームグラフを生成してみましょう。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:422
#, fuzzy
msgid "To do this, first re-generate a Quarkus native executable removing debug info, which bcc/eBPF does not understand, and instead use frame pointer with local symbols to get the stack traces:"
msgstr "そのためには、まずQuarkusのネイティブ実行ファイルを再生成し、bcc/eBPFが理解できないデバッグ情報を取り除き、代わりにローカルシンボルを含むフレームポインタを使用してスタックトレースを取得します："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:427
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols,-H:+PreserveFramePointer\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:437
#, fuzzy
msgid "The link:mallocstacks.py[mallocstacks.py] bcc/eBPF script will be used to capture the `malloc` stacktraces with their allocated size.  This script, and other typical bcc/eBPF scripts (e.g. `stackcount`), need to be given a process ID (PID).  This makes a bit tricky when you want to trace startup, but you can use `gdb` (even if you haven't enabled debug info)  to get around this obstacle because it allows you to stop the application at the first instruction.  Let's start by running the native executable via `gdb`:"
msgstr "link:mallocstacks.py[mallocstacks.py] bcc/eBPF スクリプトは、 `malloc` スタックトレースをその割り当てられたサイズとともにキャプチャするために使用されます。このスクリプトや他の典型的な bcc/eBPF スクリプト (例えば `stackcount `) には、プロセス ID (PID) を与える必要があります。このため、起動をトレースしたい場合は少し厄介ですが、 `gdb` (デバッグ情報を有効にしていなくても) を使用すると、最初の命令でアプリケーションを停止できるため、この障害を回避することが可能です。まず、 `gdb` を使ってネイティブの実行ファイルを実行してみましょう："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:443
#, no-wrap
msgid ""
"$ gdb --args ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"...\n"
"(No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:446
#, fuzzy
msgid "`starti` is a `gdb` command that sets a temporary breakpoint at the very first instruction of the program's execution."
msgstr "`starti` は、 、プログラム実行の一番最初の命令に一時的なブレークポイントを設定するコマンドです。 `gdb` "

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:453
#, no-wrap
msgid ""
"(gdb) starti\n"
"Starting program: <..>/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"Program stopped.\n"
"0x00007ffff7fe4790 in _start () from /lib64/ld-linux-x86-64.so.2\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:458
#, fuzzy
msgid "Next invoke the bcc/eBPF script giving it the PID of the Quarkus process, so that it can track the `malloc` calls, capture stack traces and dump them to a file for post-processing:"
msgstr "次に、bcc/eBPFスクリプトを起動し、QuarkusプロセスのPIDを指定して、 `malloc` の呼び出しを追跡し、スタックトレースをキャプチャして、後処理用にファイルにダンプします："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:462
#, no-wrap
msgid "$ sudo ./mallocstacks.py -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) -f > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:465
#, fuzzy
msgid "Then go back to the `gdb` shell and instruct it to continue the startup procedure after hitting the first instruction:"
msgstr "その後、 `gdb` シェルに戻り、最初の命令を打った後に起動手順を続けるように指示します："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:482
#, no-wrap
msgid ""
"(gdb) continue\n"
"Continuing.\n"
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib64/libthread_db.so.1\".\n"
"[New Thread 0x7ffff65ff6c0 (LWP 3342)]\n"
"...\n"
"[New Thread 0x7fffc6ffd6c0 (LWP 3359)]\n"
"__  ____  __  _____   ___  __ ____  ______\n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\\n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) code-with-quarkus 1.0.0-SNAPSHOT native (powered by Quarkus 2.16.1.Final) started in 0.011s. Listening on: http://0.0.0.0:8080\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Profile prod activated.\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy-reactive, smallrye-context-propagation, vertx]\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:486
#, fuzzy
msgid "Once the startup has complete, press `Ctrl-C` on the `stackcount` shell."
msgstr "起動が完了したら、 `stackcount` シェルで `Ctrl-C` を押してください。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:490
#, fuzzy
msgid "Then process the stacks file as a flamegraph.  Note that the stacks generated by this script are already collapsed, so the flamegraph can be generated just like this:"
msgstr "そして、そのスタックファイルをflamegraphとして処理します。なお、このスクリプトで生成されたスタックはすでに折りたたまれているので、このままflamegraphを生成することができます："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:494
#, no-wrap
msgid "$ cat out.stacks | ${FG_HOME}/flamegraph.pl --color=mem --title=\"malloc bytes Flame Graph\" --countname=\"bytes\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:497
#, fuzzy
msgid "The flamegraph produced should look something like this:"
msgstr "生成されたflamegraphは、次のようなものです："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:498
#, fuzzy, no-wrap
msgid "malloc bytes flamegraph"
msgstr "malloc bytes flamegraph"

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:498
#, no-wrap
msgid "malloc-bytes.svg"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:505
#, fuzzy
msgid "This shows that most of the memory requested using `malloc` comes from epoll in Java NIO, but the overall amount allocated via `malloc` is barely 268KB.  This amount of 274,269 bytes can be observed by hoovering on top of `all` at the bottom of flamegraph (you might need to ask the browser to open the flamegraph in a different tab or window to observe this).  This is very small compared with the amount allocated for the heap with `mmap`."
msgstr "これを見ると、 `malloc` を使って要求されたメモリのほとんどは Java NIO の epoll から来ているが、 `malloc` を使って割り当てられた全体の量はやっと 268KB であることがわかる。この274,269バイトという量は、flamegraphの下部にある `all` の上をフーバーすることで観察できます（これを観察するには、ブラウザでflamegraphを別のタブやウィンドウで開いてもらう必要があるかもしれません）。これは、 `mmap` でヒープに割り当てられた量と比較すると非常に小さい。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:508
#, fuzzy
msgid "Finally, just a brief mention about other bcc/eBPF commands, and how to transform them into flamegraphs."
msgstr "最後に、他のbcc/eBPFコマンドと、それらをflamegraphに変換する方法について簡単に触れておきます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:513
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:syscalls:sys_enter_m*\" # count stacks for mmap and munmap\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:516
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:*alloc\" # count stacks for malloc, calloc and realloc\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:519
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:free\" # count stacks for free\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:522
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:exceptions:page_fault_*\" # count stacks for page faults\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:526
#, fuzzy
msgid "Stacks produced by `stackcount` need to be collapsed before they can be transformed into flamegraphs.  For example:"
msgstr "`stackcount` で生成されたスタックは、flamegraph に変換する前に折りたたむ必要があります。例えば、以下のような感じです："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:531
#, no-wrap
msgid ""
"${FG_HOME}/stackcollapse.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"  --color=mem --title=\"mmap munmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:534
#, fuzzy, no-wrap
msgid "Inspecting and Debugging Native Executables"
msgstr "ネイティブ実行可能ファイルの検査"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:536
msgid "This debugging guide provides further details on debugging issues in Quarkus native executables that might arise during development or production."
msgstr "このデバッグガイドでは、開発中または生産中に発生する可能性のあるQuarkusネイティブ実行ファイルの問題のデバッグについて、さらに詳しく説明します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:539
#, fuzzy
msgid "It takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].  You can find instructions on how to quickly set up this application in this guide."
msgstr "link:getting-started.html[入門ガイド]で開発したアプリケーションのコード"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:540
#, no-wrap
msgid "Requirements and Assumptions"
msgstr "要件と前提条件"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:543
msgid "This debugging guide has the following requirements:"
msgstr "このデバッグガイドには、次の要件があります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:545
msgid "JDK 11 installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 11 がインストールされ、 `JAVA_HOME`  が適切に設定されていること"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:546
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:547
msgid "A working container runtime (Docker, podman)"
msgstr "動作するコンテナーランタイム(Docker, podman)"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:552
msgid "This guide builds and executes Quarkus native executables within a Linux environment.  To offer a homogeneous experience across all environments, the guide relies on a container runtime environment to build and run the native executables.  The instructions below use Docker as example, but very similar commands should work on alternative container runtimes, e.g. podman."
msgstr "このガイドでは、Linux 環境内で Quarkus ネイティブ実行可能ファイルをビルドして実行します。すべての環境で同種のエクスペリエンスを提供するために、ガイドはコンテナーランタイム環境に依存して、ネイティブ実行可能ファイルをビルドおよび実行します。以下の手順では例として Docker を使用していますが、podman などの他のコンテナーランタイムでも、よく似たコマンドを実行できます。"

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:558
msgid "Building native executables is an expensive process, so make sure the container runtime has enough CPU and memory to do this.  A minimum of 4 CPUs and 4GB of memory is required."
msgstr "ネイティブ実行可能ファイルのビルドはコストのかかるプロセスであるため、コンテナーランタイムに十分な CPU とメモリーがあることを確認してください。最低でも 4 つの CPU と 4GB のメモリーが必要です。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:562
msgid "Finally, this guide assumes the use of the link:https://github.com/graalvm/mandrel[Mandrel distribution] of GraalVM for building native executables, and these are built within a container so there is no need for installing Mandrel on the host."
msgstr "最後に、このガイドでは、ネイティブ実行可能ファイルのビルド用に GraalVM の link:https://github.com/graalvm/mandrel[Mandrel distribution] の使用を想定しています。これらはコンテナー内にビルドされるため、ホスト上に Mandrel をインストールする必要はありません。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:563
#, no-wrap
msgid "Bootstrapping the project"
msgstr "プロジェクトのブートストラップ"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:567
msgid "Start by creating a new Quarkus project.  Open a terminal and run the following command:"
msgstr "新しい Quarkus プロジェクトを作成することから始めます。ターミナルを開き、以下のコマンドを実行します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:569
msgid "For Linux & MacOS users"
msgstr "Linux および MacOS ユーザー向け"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:576
msgid "For Windows users"
msgstr "Windows ユーザー向け"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:578
msgid "If using cmd , (don't use backward slash `\\` and put everything on the same line)"
msgstr "cmd を使っている場合 (バックスラッシュは使わず、全て同じ行にしてください)"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:579
msgid "If using Powershell , wrap `-D` parameters in double quotes e.g. `\"-DprojectArtifactId=debugging-native\"`"
msgstr "Powershell を使用する場合は、`-D` パラメーターを二重引用符で囲みます。例: `\"-DprojectArtifactId=debugging-native\"`"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:580
#, no-wrap
msgid "Configure Quarkus properties"
msgstr "Quarkus のプロパティーを設定する"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:586
#, fuzzy
msgid "Some Quarkus configuration options will be used constantly throughout this debugging guide, so to help declutter command line invocations, it's recommended to add these options to the `application.properties` file.  So, go ahead and add the following options to that file:"
msgstr "Quarkusの設定オプションの中には、このデバッグガイドの中で常に使用されるものがあります。そのため、コマンドラインからの呼び出しを減らすために、これらのオプションを `application.properties` ファイルに追加することをお勧めします。そこで、次のオプションをそのファイルに追加してください："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:593
#, no-wrap
msgid ""
"quarkus.native.container-build=true\n"
"quarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor}\n"
"quarkus.container-image.build=true\n"
"quarkus.container-image.group=test\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:600
#, fuzzy
msgid "Starting with 22.3, Mandrel does not provide a `-java11` version anymore.  Note, however, that this doesn't mean that you may no longer produce native executables with Mandrel for Java 11 projects.  You can still compile your Java 11 projects using OpenJDK 11 and produce native executables from the resulting Java 11 bytecode using the `-java17` Mandrel builder images."
msgstr "22.3 以降、Mandrel は `-java11` バージョンを提供しなくなりました。しかし、これは、Java 11 プロジェクトで Mandrel を使用してネイティブ実行可能ファイルを作成することができなくなったことを意味するものではありません。OpenJDK 11 を使用して Java 11 プロジェクトをコンパイルし、 `-java17` Mandrel ビルダーイメージを使用して、結果の Java 11 バイトコードからネイティブ実行可能ファイルを生成することは可能です。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:602
#, no-wrap
msgid "First Debugging Steps"
msgstr "最初のデバッグ手順"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:605
msgid "As a first step, change to the project directory and build the native executable for the application:"
msgstr "最初のステップとして、プロジェクトディレクトリーに移動し、アプリケーションのネイティブ実行可能ファイルをビルドします。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:609
#: upstream/_versions/main/guides/native-reference.adoc:1074
#, no-wrap
msgid "./mvnw package -DskipTests -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:612
msgid "Run the application to verify it works as expected. In one terminal:"
msgstr "アプリケーションを実行して、期待通りに動作することを確認します。一つの端末で以下を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:616
#: upstream/_versions/main/guides/native-reference.adoc:1082
#, no-wrap
msgid "docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:619
msgid "In another:"
msgstr "別のターミナルで以下を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:623
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:628
msgid "The rest of this section explores ways to build the native executable with extra information, but first, stop the running application.  We can obtain this information while building the native executable by adding additional native-image build options using `-Dquarkus.native.additional-build-args`, e.g."
msgstr "このセクションの残りの部分では、追加情報を使用してネイティブ実行可能ファイルをビルドする方法について説明しますが、最初に、実行中のアプリケーションを停止します。`-Dquarkus.native.additional-build-args` を使用してネイティブイメージビルドオプションを追加することで、ネイティブ実行可能ファイルのビルド中にこの情報を取得できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:633
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:636
msgid "Executing that will produce additional output lines like this:"
msgstr "これを実行すると、次のような追加の出力行が得られます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:643
#, no-wrap
msgid ""
"...\n"
"# Printing compilation-target information to: /project/reports/target_info_20220223_100915.txt\n"
"…\n"
"# Printing native-library information to: /project/reports/native_library_info_20220223_100925.txt\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:651
msgid "Note that `/project` is a folder within the container that is building the native executable.  So, this is not a folder that you will find in the host environment.  `/project` folder is mapped to `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar`, so you will find the files under the `reports` folder in that directory."
msgstr "`/project` は、ネイティブ実行可能ファイルをビルドしているコンテナー内のフォルダーであることに注意してください。したがって、これはホスト環境にあるフォルダーではありません。`/project` フォルダーは `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar` にマップされているため、そのディレクトリーの `reports` フォルダーの下にファイルがあります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:656
msgid "The target info file contains information such as the target platform, the toolchain used to compile the executable, and the C library in use:"
msgstr "ターゲット情報ファイルには、ターゲットプラットフォーム、実行ファイルのコンパイルに使用されたツールチェーン、使用されているCライブラリなどの情報が含まれています。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:668
#, no-wrap
msgid ""
"$ cat target/*/reports/target_info_*.txt\n"
"Building image for target platform: org.graalvm.nativeimage.Platform$LINUX_AMD64\n"
"Using native toolchain:\n"
"   Name: GNU project C and C++ compiler (gcc)\n"
"   Vendor: redhat\n"
"   Version: 8.5.0\n"
"   Target architecture: x86_64\n"
"   Path: /usr/bin/gcc\n"
"Using CLibrary: com.oracle.svm.core.posix.linux.libc.GLib\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:671
msgid "The native library info file contains information on the static libraries added to the binary and the other libraries dynamically linked to the executable:"
msgstr "ネイティブライブラリ情報ファイルには、バイナリに追加されるスタティックライブラリと、実行ファイルに動的にリンクされるその他のライブラリの情報が含まれています。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:686
#, no-wrap
msgid ""
"$ cat target/*/reports/native_library_info_*.txt\n"
"Static libraries:\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/liblibchelper.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libextnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnio.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libjava.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libfdlibm.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libsunec.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libzip.a\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/libjvm.a\n"
"Other libraries: stdc++,pthread,dl,z,rt\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:691
msgid "Even more detail can be obtained by passing in `--verbose` as an additional native-image build argument.  This option can be very useful in detecting whether the options that you pass at a high level via Quarkus are being passed down to the native executable production, or whether some third party jar has some native-image configuration embedded in it that is reaching the native-image invocation:"
msgstr "ネイティブイメージビルドの追加引数として `--verbose` を渡すことで、さらに詳細な情報を得ることができます。このオプションは、Quarkusを介して高いレベルで渡されたオプションがネイティブ実行可能ファイルの生成に渡されているのか、あるいはサードパーティのjarにネイティブイメージの設定が埋め込まれていて、それがネイティブイメージの呼び出しに届いているのかを検出するのに非常に役立ちます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:696
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--verbose\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:699
msgid "Running with `--verbose` demonstrates how the native-image building process is two sequential java processes:"
msgstr "`--verbose` で実行すると、ネイティブイメージのビルドプロセスが2つの連続したJavaプロセスであることが分かります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:702
msgid "The first is a very short Java process that does some basic validation and builds the arguments for the second process (in a stock GraalVM distribution, this is executed as native code)."
msgstr "1番目は非常に短いJavaプロセスで、基本的な検証を行い、2つ目のプロセスのための引数を組み立てます（GraalVMの純正ディストリビューションでは、これはネイティブコードとして実行されます）。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:705
msgid "The second Java process is where the main part of the native executable production happens.  The `--verbose` option shows the actual Java process executed.  You could take the output and run it yourself."
msgstr "2番目のJavaプロセスでは、ネイティブ実行可能ファイル作成の主要部分が行われます。 `--verbose` オプションは、実際に実行されたJavaプロセスを表示します。出力を受けて、自分で実行することもできます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:707
msgid "One may also combine multiple native build options by separating with a comma, e.g.:"
msgstr "また、複数のネイティブ・ビルド・オプションをコンマで区切って組み合わせることもできます。例:"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:712
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info,--verbose\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:718
msgid "Remember that if an argument for `-Dquarkus.native.additional-build-args` includes the `,` symbol, it needs to be escaped to be processed correctly, e.g. `\\\\,`."
msgstr "`-Dquarkus.native.additional-build-args` の引数に `,` シンボルが含まれている場合、正しく処理するためには、`\\\\,` のようにエスケープする必要があることを覚えておいてください。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:720
#, no-wrap
msgid "Inspecting Native Executables"
msgstr "ネイティブ実行可能ファイルの検査"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:726
msgid "Given a native executable, various Linux tools can be used to inspect it.  To allow supporting a variety of environments, inspections will be done from within a Linux container.  Let's create a Linux container image with all the tools required for this guide:"
msgstr "ネイティブ実行可能ファイルを指定すると、さまざまな Linux ツールを使用して実行可能ファイルを検査できます。さまざまな環境をサポートできるように、検査は Linux コンテナー内から実行されます。このガイドに必要なすべてのツールを使用して、Linux コンテナーイメージを作成しましょう。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:730
#, no-wrap
msgid "FROM fedora:35\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:737
#, no-wrap
msgid ""
"RUN dnf install -y \\\n"
"binutils \\\n"
"gdb \\\n"
"git \\\n"
"perf \\\n"
"perl-open\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:739
#, no-wrap
msgid "ENV FG_HOME /opt/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:741
#, no-wrap
msgid "RUN git clone https://github.com/brendangregg/FlameGraph $FG_HOME\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:743
#, no-wrap
msgid "WORKDIR /data\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:745
#, no-wrap
msgid "ENTRYPOINT /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:748
msgid "Using docker in the non-Linux environment, you can create an image using this Dockerfile via:"
msgstr "Linux 以外の環境で docker を使用する場合は、以下を実行し、この Dockerfile を使用してイメージを作成できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:752
#, no-wrap
msgid "docker build -t fedora-tools:v1 .\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:755
msgid "Then, go to the root of the project and run the Docker container we have just created as:"
msgstr "次に、プロジェクトの root に移動し、先ほど作成した Docker コンテナーを以下のように実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:759
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:762
msgid "`ldd` shows the shared library dependencies of an executable:"
msgstr "`ldd` は、実行可能ファイルの共有ライブラリの依存関係を表示します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:766
#, no-wrap
msgid "ldd ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:769
msgid "`strings` can be used to look for text messages inside the binary:"
msgstr "`strings` は、バイナリ内のテキストメッセージを探すのに使用できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:773
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep Hello\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:776
msgid "Using `strings` you can also get Mandrel information given the binary:"
msgstr "`strings` を使えば、指定されたバイナリのMandrel情報を得ることもできます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:780
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep core.VM\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:784
msgid "Finally, using `readelf` we can inspect different sections of the binary.  For example, we can see how the heap and text sections take most of the binary:"
msgstr "最後に、 `readelf` を使って、バイナリーのさまざまなセクションを調べることができます。例えば、ヒープセクションとテキストセクションがバイナリの大半を占めていることがわかります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:788
#, no-wrap
msgid "readelf -SW ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:795
msgid "Runtime containers produced by Quarkus to run native executables will not include the tools mentioned above.  To explore a native executable within a runtime container, it's best to run the container itself and then `docker cp` the executable locally, e.g.:"
msgstr "ネイティブ実行可能ファイルを実行するために Quarkus によって生成されたランタイムコンテナーには、上記のツールは含まれません。ランタイムコンテナー内のネイティブ実行可能ファイルを調べるには、コンテナー自体を実行してから、実行可能ファイルをローカルで `docker cp` するのが最適です。次に例を示します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:800
#, no-wrap
msgid ""
"docker run -i --rm --name=mytest -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"docker cp mytest:/work/application path/on/host/\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:803
msgid "From there, you can either inspect the executable directly or use a tools container like above."
msgstr "そこから、実行ファイルを直接検査するか、上記のようなツールコンテナーを使用することができます。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:806
#, no-wrap
msgid "Native Reports"
msgstr "ネイティブレポート"

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:809
msgid "Optionally, the native build process can generate reports that show what goes into the binary:"
msgstr "オプションとして、ネイティブビルドプロセスでは、バイナリに何が入っているかを示すレポートを生成することができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:814
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.enable-reports\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:818
msgid "The reports will be created under `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/`.  These reports are some of the most useful resources when encountering issues with missing methods/classes, or encountering forbidden methods by Mandrel."
msgstr "レポートは、`target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/` の下に作成されます。これらのレポートは、メソッド/クラスが見つからない問題が発生した場合、または Mandrel によって禁止されたメソッドが発生した場合に、最も役立つリソースの一部になります。"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:819
#, no-wrap
msgid "Call Tree Reports"
msgstr "コールツリーレポート"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:825
msgid "`call_tree` csv file reports are some of the default reports generated when the `-Dquarkus.native.enable-reports` option is passed in.  These csv files can be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  This is useful for getting an approximation on why a method/class is included in the binary."
msgstr "`call_tree` csv ファイルレポートは、`-Dquarkus.native.enable-reports` オプションが渡されたときに生成されるデフォルトレポートの一部です。これらの csv ファイルは、Neo4j などのグラフデータベースにインポートして、より簡単に検査できます。呼び出しツリーに対してクエリーを実行します。これは、メソッド/クラスがバイナリーに含まれている理由の概算を取得するのに役立ちます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:827
msgid "Let’s see this in action."
msgstr "実際に見てみましょう。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:829
msgid "First, start a Neo4j instance:"
msgstr "まず、Neo4jのインスタンスを起動します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:840
#, no-wrap
msgid ""
"export NEO_PASS=...\n"
"docker run \\\n"
"    --detach \\\n"
"    --rm \\\n"
"    --name testneo4j \\\n"
"    -p7474:7474 -p7687:7687 \\\n"
"    --env NEO4J_AUTH=neo4j/${NEO_PASS} \\\n"
"    neo4j:latest\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:845
msgid "Once the container is running, you can access the link:http://localhost:7474[Neo4j browser].  Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr "コンテナーが実行されると、 link:http://localhost:7474[Neo4j ブラウザー] にアクセスできます。ログインする際は、ユーザー名として `neo4j` を使用し、パスワードとして `NEO_PASS` の値を使用します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:848
msgid "To import the CSV files, we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr "CSVファイルをインポートするためには、CSVファイル内のデータをインポートし、グラフデータベースのノードとエッジを作成する以下のcypherスクリプトが必要です。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:853
#, no-wrap
msgid ""
"CREATE CONSTRAINT unique_vm_id ON (v:VM) ASSERT v.vmId IS UNIQUE;\n"
"CREATE CONSTRAINT unique_method_id ON (m:Method) ASSERT m.methodId IS UNIQUE;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:857
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_vm.csv' AS row\n"
"MERGE (v:VM {vmId: row.Id, name: row.Name})\n"
"RETURN count(v);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:861
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:865
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:871
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_entry_points.csv' AS row\n"
"MATCH (m:Method {methodId: row.Id})\n"
"MATCH (v:VM {vmId: '0'})\n"
"MERGE (v)-[:ENTRY]->(m)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:877
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_direct_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:DIRECT {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:883
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_override_by_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:OVERRIDEN_BY]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:889
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:VIRTUAL {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:892
msgid "Copy and paste the contents of the script into a file called `import.cypher`."
msgstr "スクリプトの内容を `import.cypher` というファイルにコピー＆ペーストします。"

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:898
msgid "Mandrel 22.0.0 contains a bug where the symbolic links used by the import cypher file are not correctly set when generating reports within a container (for more details see link:https://github.com/oracle/graal/issues/4355[here]).  This can be worked around by copying the following script into a file and executing it:"
msgstr "Mandrel 22.0.0 には、コンテナー内でレポートを生成する際に、インポートサイファーファイルで使用されるシンボリックリンクが正しく設定されないというバグが含まれています (詳細は link:https://github.com/oracle/graal/issues/4355[こちら] を参照)。これは、以下のスクリプトをファイルにコピーして実行することで回避できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:902
#, no-wrap
msgid "set -e\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:904
#, no-wrap
msgid "project=\"debugging-native\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:906
#, no-wrap
msgid "pushd target/*-native-image-source-jar/reports\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:909
#, no-wrap
msgid ""
"rm -f call_tree_vm.csv\n"
"ln -s call_tree_vm_${project}-* call_tree_vm.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:912
#, no-wrap
msgid ""
"rm -f call_tree_direct_edges.csv\n"
"ln -s call_tree_direct_edges_${project}-* call_tree_direct_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:915
#, no-wrap
msgid ""
"rm -f call_tree_entry_points.csv\n"
"ln -s call_tree_entry_points_${project}-* call_tree_entry_points.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:918
#, no-wrap
msgid ""
"rm -f call_tree_methods.csv\n"
"ln -s call_tree_methods_${project}-* call_tree_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:921
#, no-wrap
msgid ""
"rm -f call_tree_virtual_edges.csv\n"
"ln -s call_tree_virtual_edges_${project}-* call_tree_virtual_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:924
#, no-wrap
msgid ""
"rm -f call_tree_virtual_methods.csv\n"
"ln -s call_tree_virtual_methods_${project}-* call_tree_virtual_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:927
#, no-wrap
msgid ""
"rm -f call_tree_override_by_edges.csv\n"
"ln -s call_tree_override_by_edges_${project}-* call_tree_override_by_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:929
#, no-wrap
msgid "popd\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:933
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr "次に、インポートサイファースクリプトとCSVファイルをNeo4jのインポートフォルダにコピーします。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:939
#, no-wrap
msgid ""
"docker cp \\\n"
"    target/*-native-image-source-jar/reports \\\n"
"    testneo4j:/var/lib/neo4j/import\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:941
#, no-wrap
msgid "docker cp import.cypher testneo4j:/var/lib/neo4j\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:944
msgid "After copying all the files, invoke the import script:"
msgstr "すべてのファイルをコピーしたら、インポートスクリプトを起動します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:948
#, no-wrap
msgid "docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} -f import.cypher\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:952
msgid "Once the import completes (shouldn't take more than a couple of minutes), go to the link:http://localhost:7474[Neo4j browser], and you'll be able to observe a small summary of the data in the graph:"
msgstr "インポートの完了 (ほんの数分で完了) 後に、link:http://localhost:7474[Neo4j ブラウザー] にアクセスすると、簡単なデータのサマリーをグラフで見ることができます。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:953
#, no-wrap
msgid "Neo4j database information after import"
msgstr "インポート後の Neo4j データベース情報"

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:953
#, no-wrap
msgid "native-reference-neo4j-db-info.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:958
msgid "The data above shows that there are ~60000 methods, and just over ~200000 edges between them.  The Quarkus application demonstrated here is very basic, so there’s not a lot we can explore, but here are some example queries you can run to explore the graph in more detail.  Typically, you’d start by looking for a given method:"
msgstr "上のデータでは、~60000のメソッドがあり、それらの間には~200000のエッジがあることがわかります。ここでデモされているQuarkusアプリケーションは非常に基本的なものなので、調べられることは多くありませんが、グラフをより詳細に調べるために実行できるクエリの例をいくつか紹介します。典型的な例としては、あるメソッドを探すことから始めます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:962
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:965
msgid "From there, you can narrow down to a given method on a specific type:"
msgstr "そこから、特定の型の特定のメソッドに絞ることができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:969
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:976
msgid "Once you’ve located the node for the specific method you’re after, a typical question you’d want to get an answer for is: why does this method get included in the call tree? To do that, start from the method and look for incoming connections at a given depth, starting from the end method.  For example, methods that directly call a method can be located via:"
msgstr "探している特定のメソッドのノードを見つけたら、答えを得たい典型的な質問は、「なぜこのメソッドはコールツリーに含まれるのか」です。そのためには、終点のメソッドから始まる所定の深さの到着接続を探します。たとえば、あるメソッドを直接呼び出すメソッドは、以下のようにして見つけることができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:980
#, no-wrap
msgid "match (m:Method) <- [*1..1] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:984
msgid "Then you can look for direct calls at depth of 2, so you’d search for methods that call methods that call into the target method:"
msgstr "そうすれば、深さ2の直接呼び出しを探すことができます。つまり、対象のメソッドを呼び出すメソッドを呼び出すメソッドを探すことになります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:988
#, no-wrap
msgid "match (m:Method) <- [*1..2] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:994
msgid "You can continue going up layers, but unfortunately if you reach a depth with too many nodes, the Neo4j browser will be unable to visualize them all.  When that happens, you can alternatively run the queries directly against the cypher shell:"
msgstr "階層を上がっていくことはできますが、残念ながらノードの数が多すぎる深度に到達すると、Neo4jブラウザはそれらすべてを可視化することができません。そのような場合は、代わりにcypher shellに対して直接クエリを実行することができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:999
#, no-wrap
msgid ""
"docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \\\n"
"  \"match (m:Method) <- [*1..10] - (o) where m.name = 'hello' and m.type =~ '.*GreetingResource' return *\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1004
msgid "For further information, check out this link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[blog post] that explores the Quarkus Hibernate ORM quickstart using the techniques explained above."
msgstr "詳細については、上記で説明した手法を使用して、Quarkus Hibernate ORM クイックスタートについて検討している https://quarkus.io/blog/quarkus-native-neo4j-call-tree[blog 記事] を参照してください。"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:1005
#, no-wrap
msgid "Used Packages/Classes/Methods Reports"
msgstr "使用されているパッケージ/クラス/メソッドのレポート"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1009
msgid "`used_packages`, `used_classes` and `used_methods` text file reports come in handy when comparing different versions of the application, e.g. why does the image take longer to build? Or why is the image bigger now?"
msgstr "`used_packages`, `used_classes`, `used_methods` テキストファイルレポートは、アプリケーションの異なるバージョンを比較する際に便利です。例えば、イメージ作成に時間がかかるのはなぜか？また、なぜイメージが大きくなったのか？"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:1010
#, no-wrap
msgid "Further Reports"
msgstr "更なるレポート"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1014
msgid "Mandrel can produce further reports beyond the ones that are enabled with the `-Dquarkus.native.enable-reports` option.  These are called expert options and you can learn more about them by running:"
msgstr "Mandrelは、 `-Dquarkus.native.enable-reports` オプションで有効になっているレポート以外にも、様々なレポートを作成することができます。これらはエキスパートオプションと呼ばれ、以下を実行することで詳細を知ることができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1018
#, no-wrap
msgid "docker run quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} --expert-options-all\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:1024
msgid "These expert options are not considered part of the GraalVM native image API, so they might change anytime."
msgstr "これらのエキスパートオプションは、GraalVM ネイティブ Image API の一部とは見なされないため、いつでも変更される可能性があります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1027
msgid "To use these expert options, add them comma separated to the `-Dquarkus.native.additional-build-args` parameter."
msgstr "これらのエキスパートオプションを使用するには、 `-Dquarkus.native.additional-build-args` パラメータにコンマで区切って追加します。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1028
#, no-wrap
msgid "Build-time vs Run-time Initialization"
msgstr "ビルド時と実行時の初期化"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1035
msgid "Quarkus instructs Mandrel to initialize as much as possible at build time, so that runtime startup can be as fast as possible.  This is important in containerized environments where the startup speed has a big impact on how quickly an application is ready to do work.  Build time initialization also minimizes the risk of runtime failures due to unsupported features becoming reachable through runtime initialization, thus making Quarkus more reliable."
msgstr "QuarkusはMandrelに対し、ビルド時に可能な限り初期化するよう指示し、実行時の起動を可能な限り高速化しています。これは、起動速度がアプリケーションの動作準備の早さに大きな影響を与えるコンテナ環境では重要です。また、ビルド時の初期化は、サポートされていない機能が実行時の初期化によって到達可能になることによる実行時の失敗のリスクを最小限にし、Quarkusの信頼性を高めています。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1039
msgid "The most common examples of build-time initialized code are static variables and blocks.  Although Mandrel executes those at run-time by default, Quarkus instructs Mandrel to run them at build-time for the reasons given."
msgstr "ビルド時に初期化されるコードの最も一般的な例は、静的変数とブロックです。Mandrelはこれらをデフォルトでは実行時に実行しますが、Quarkusでは先程の理由でビルド時に実行するように指示しています。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1043
msgid "This means that any static variables initialized inline, or initialized in a static block, will keep the same value even if the application is restarted.  This is a different behaviour compared to what would happen if executed as Java."
msgstr "つまり、インラインで初期化されたスタティック変数や、スタティックブロックで初期化されたスタティック変数は、アプリケーションを再起動しても同じ値を維持します。これは、Javaとして実行した場合とは異なる動作です。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1046
msgid "To see this in action with a very basic example, add a new `TimestampResource` to the application that looks like this:"
msgstr "これの実際の動作を非常に基本的な例で確認するには、以下のような新しい `TimestampResource` をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1050
#: upstream/_versions/main/guides/native-reference.adoc:1102
#: upstream/_versions/main/guides/native-reference.adoc:1248
#: upstream/_versions/main/guides/native-reference.adoc:1440
#: upstream/_versions/main/guides/native-reference.adoc:1577
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1055
#: upstream/_versions/main/guides/native-reference.adoc:1253
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1058
#, no-wrap
msgid ""
"@Path(\"/timestamp\")\n"
"public class TimestampResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1060
#, no-wrap
msgid "    static long firstAccess = System.currentTimeMillis();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1067
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String timestamp() {\n"
"        return \"First access \" + firstAccess;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1070
msgid "Rebuild the binary using:"
msgstr "次のようにバイナリを再ビルドします。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1078
msgid "Run the application in one terminal (make sure you stop any other native executable container runs before executing this):"
msgstr "1 つのターミナルでアプリケーションを実行します (これを実行する前に、他のネイティブ実行可能コンテナーの実行を必ず停止してください)。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1085
msgid "Send a `GET` request multiple times from another terminal:"
msgstr "別のターミナルから `GET` リクエストを複数回送信してみましょう。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1089
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/timestamp # run this multiple times\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1094
msgid "to see how the current time has been baked into the binary.  This time was calculated when the binary was being built, hence application restarts have no effect."
msgstr "現在の時刻がどのようにバイナリに焼き付けられているかを確認できます。この時刻は、バイナリのビルド時に計算されたものなので、アプリケーションの再起動が影響しません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1098
msgid "In some situations, built time initializations can lead to errors when building native executables.  One example is when a value gets computed at build time which is forbidden to reside in the heap of the JVM that gets baked into the binary.  To see this in action, add this REST resource:"
msgstr "状況によっては、ビルド時の初期化により、ネイティブ実行可能ファイルをビルドするときにエラーが発生する可能性があります。1 つの例は、バイナリーにベイクされる JVM のヒープに存在することが禁じられている値が、ビルド時に計算される場合です。これが実際に動作することを確認するには、この REST リソースを追加してください。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1111
#, no-wrap
msgid ""
"import javax.crypto.Cipher;\n"
"import javax.crypto.NoSuchPaddingException;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import java.nio.charset.StandardCharsets;\n"
"import java.security.KeyPair;\n"
"import java.security.KeyPairGenerator;\n"
"import java.security.NoSuchAlgorithmException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1114
#, no-wrap
msgid ""
"@Path(\"/encrypt-decrypt\")\n"
"public class EncryptDecryptResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1117
#, no-wrap
msgid ""
"    static final KeyPairGenerator KEY_PAIR_GEN;\n"
"    static final Cipher CIPHER;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1122
#, no-wrap
msgid ""
"    static {\n"
"        try {\n"
"            KEY_PAIR_GEN = KeyPairGenerator.getInstance(\"RSA\");\n"
"            KEY_PAIR_GEN.initialize(1024);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1128
#, no-wrap
msgid ""
"            CIPHER = Cipher.getInstance(\"RSA\");\n"
"        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1133
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{message}\")\n"
"    public String encryptDecrypt(String message) throws Exception {\n"
"        KeyPair keyPair = KEY_PAIR_GEN.generateKeyPair();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1135
#, no-wrap
msgid "        byte[] text = message.getBytes(StandardCharsets.UTF_8);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1139
#, no-wrap
msgid ""
"        // Encrypt with private key\n"
"        CIPHER.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());\n"
"        byte[] encrypted = CIPHER.doFinal(text);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1143
#, no-wrap
msgid ""
"        // Decrypt with public key\n"
"        CIPHER.init(Cipher.DECRYPT_MODE, keyPair.getPublic());\n"
"        byte[] unencrypted = CIPHER.doFinal(encrypted);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1147
#, no-wrap
msgid ""
"        return new String(unencrypted, StandardCharsets.UTF_8);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1150
msgid "When trying to rebuild the application, you’ll encounter an error:"
msgstr "アプリケーションを再ビルドしようとすると、エラーが発生します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1169
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@3248a092 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1177
msgid "So, what the message above is telling us is that our application caches a value that is supposed to be random as a constant.  This is not desirable because something that's supposed to be random is no longer so, because the seed is baked in the image.  The message above makes it quite clear what is causing this, but in other situations the cause might be more obfuscated.  As a next step, we'll add some extra flags to the native executable generation to get more information."
msgstr "したがって、上記のメッセージが示しているのは、アプリケーションが定数としてランダムであると想定される値をキャッシュしているということです。シードがイメージでベイク処理されているため、ランダムであるはずの何かがもはやランダムではないため、これは望ましくありません。上記のメッセージは、何が原因かを非常に明確に示していますが、他の状況では、原因はさらにわかりにくいかもしれません。次のステップとして、ネイティブ実行可能ファイルの生成にいくつかのフラグを追加して、より多くの情報を取得することにします。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1179
msgid "As suggested by the message, let's start by adding an option to track object instantiation:"
msgstr "メッセージにあるように、まずはオブジェクトのインスタンス化を追跡するためのオプションを追加してみましょう。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1209
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=\"--trace-object-instantiation=java.security.SecureRandom\"\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@71880cf1 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1218
msgid "The error messages point to the code in the example, but it can be surprising that a reference to `DnsClient` appears.  Why is that? The key is in what happens inside `KeyPairGenerator.initialize()` method call.  It uses `JCAUtil.getSecureRandom()` which is why this is problematic, but sometimes the tracing options can show some stack traces that do not represent what happens in reality.  The best option is to dig through the source code and use tracing output for guidance but not as full truth."
msgstr "エラーメッセージは例にあるコードを指していますが、`DnsClient` への参照が表示されるのは意外なことかもしれません。なぜでしょうか? 重要なのは、`KeyPairGenerator.initialize()` メソッド呼び出し内で起こっていることです。これは `JCAUtil.getSecureRandom()` を使用し、これが原因で問題となっていますが、トレースオプションは、実際に起きていることを表さないスタックトレースの一部を表示することがあります。最良のオプションは、ソースコードを調べ、トレース出力を完全な事実としてではなく、ガイダンスとして使用することです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1221
msgid "Moving the `KEY_PAIR_GEN.initialize(1024);` call to the run-time executed method `encryptDecrypt` is enough to solve this particular issue.  Rebuild the application and verify that encrypt/decrypt endpoint works as expected by sending any message and check if the reply is the same as the incoming message:"
msgstr "この特定の問題を解決するには、`KEY_PAIR_GEN.initialize(1024);` 呼び出しを実行時に実行されるメソッド encryptDecrypt に移動するだけで十分です。アプリケーションを再構築し、メッセージを送信して暗号化/復号化エンドポイントが期待どおりに機能することを確認し、応答が受信メッセージと同じかどうかを確認します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1230
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl -w '\\n' http://localhost:8080/encrypt-decrypt/hellomandrel\n"
"hellomandrel\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1233
msgid "Additional information on which classes are initialized and why can be obtained by passing in the `-H:+PrintClassInitialization` flag via `-Dquarkus.native.additional-build-args`."
msgstr "どのクラスがどのように初期化されるかについての追加情報は、 `-Dquarkus.native.additional-build-args` を通じて `-H:+PrintClassInitialization` フラグを渡すことで得ることができます。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1235
#, no-wrap
msgid "Profile Runtime Behaviour"
msgstr "実行時動作のプロファイリング"

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:1237
#, no-wrap
msgid "Single Thread"
msgstr "シングルスレッド"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1241
msgid "In this exercise, we profile the runtime behaviour of some Quarkus application that was compiled to a native executable to determine where the bottleneck is.  Assume that you’re in a scenario where profiling the pure Java version is not possible, maybe because the issue only occurs with the native version of the application."
msgstr "この演習では、ネイティブ実行可能ファイルにコンパイルされたQuarkusアプリケーションの実行時動作をプロファイリングし、ボトルネックがどこにあるかを判断します。問題がアプリケーションのネイティブバージョンでのみ発生するために、純粋なJavaバージョンのプロファイリングができないシナリオを想定しています。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1244
msgid "Add a REST resource with the following code (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "次のコードを使用して REST リソースを追加します (この例は link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation] からご提供いただいています):"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1256
#, no-wrap
msgid ""
"@Path(\"/string-builder\")\n"
"public class StringBuilderResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1262
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String appendDelete() {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        sb.append(new char[1_000_000]);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1268
#, no-wrap
msgid ""
"        do\n"
"        {\n"
"            sb.append(12345);\n"
"            sb.delete(0, 5);\n"
"        } while (Thread.currentThread().isAlive());\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1272
#, no-wrap
msgid ""
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1275
msgid "Recompile the application, rebuild the binary and run it. Attempting a simple curl will never complete, as expected:"
msgstr "アプリケーションを再コンパイルし、バイナリを再ビルドして実行します。単純なcurlを試みても、期待通り完了しません。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1283
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1288
msgid "However, the question we’re trying to answer here is: what would be the bottleneck of such code? Is it appending the characters? Is it deleting it? Is it checking whether the thread is alive?"
msgstr "しかし、ここで私たちが答えようとしているのは、そのようなコードのボトルネックは何か？文字を追加することか？削除していることか？スレッドが生きているかどうかをチェックしていることか？です。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1293
msgid "Since we're dealing with a linux native executable, we can use tools like `perf` directly.  To use `perf`, go to the root of the project and start the tools container created earlier as a privileged user:"
msgstr "Linux のネイティブ実行可能ファイルを扱っているので、`perf` のようなツールを直接使用できます。`perf` を使用するには、プロジェクトの root に移動し、特権ユーザーとして以前に作成したツールコンテナーを起動します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1297
#, no-wrap
msgid "docker run --privileged -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:1304
msgid "Note that in order to use `perf` to profile the native executables in the guide, the container needs to run as privileged, or with `--cap-add sys_admin`.  Please note that privileged containers are **NOT** recommended in production, so use this flag with caution!"
msgstr "なお、 `perf` を使用してガイドのネイティブ実行可能ファイルをプロファイルするには、コンテナを特権的に実行するか、 `--cap-add sys_admin` を使用する必要があります。本番環境では特権コンテナは推奨され *ません* ので、このフラグの使用には注意が必要です。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1307
msgid "Once the container is running, you need to ensure that the kernel is ready for the profiling exercises:"
msgstr "コンテナが稼働したら、カーネルがプロファイリングの演習に対応できるようにしておく必要があります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1312
#, no-wrap
msgid ""
"echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
"echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:1319
msgid "The kernel modifications above also apply to Linux virtual machines.  If running on a bare metal Linux machine, tweaking only `perf_event_paranoid` is enough."
msgstr "上記のカーネルの変更は、Linux 仮想マシンにも適用されます。ベアメタル Linux マシンで実行している場合は、`perf_event_paranoid` を微調整するだけで十分です。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1322
#, fuzzy
msgid "Then, from inside the tools container we execute:"
msgstr "そして、Dockerコンテナを次のように実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1326
#: upstream/_versions/main/guides/native-reference.adoc:2072
#, no-wrap
msgid "perf record -F 1009 -g -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/native-reference.adoc:1337
msgid "The `perf record` command above takes `1009` samples per second.  Increasing this value means more samples are gathered, which can end up affecting the runtime performance.  This also increases the amount of data generated.  The more data generated, the longer it takes to process it, but the more precision you get on what the application is doing.  So, finding the right value is a balancing act."
msgstr "上記の `perf record` コマンドは、1 秒あたり 1009 サンプルを取得します。この値を大きくすると、より多くのサンプルが収集されることを意味し、実行時のパフォーマンスに影響を与える可能性があります。これにより、生成されるデータの量も増加します。生成されるデータが多いほど、処理に時間がかかりますが、アプリケーションが行っていることをより正確に把握できます。したがって、適切な値を見つけることは、バランスをとる作業です。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1340
msgid "While `perf record` is running, open another window and access the endpoint:"
msgstr "`perf record` の実行中に、別のウィンドウを開き、エンドポイントにアクセスします。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1344
#, no-wrap
msgid "curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1353
msgid "After a few seconds, halt the `perf record` process.  This will generate a `perf.data` file.  We could use `perf report` to inspect the perf data, but you can often get a better picture showing that data as a flame graph.  To generate flame graphs, we will use https://github.com/brendangregg/FlameGraph[FlameGraph GitHub repository], which has already been installed inside the tools container."
msgstr "数秒後、`perf record` プロセスを停止します。これにより、`perf.data` ファイルが生成されます。`perf report` を使用して perf データを検査することができますが、多くの場合、データをフレームグラフとして表示した方が、より良い結果を得ることができます。フレームグラフを生成するには、ツールコンテナー内にすでにインストールされている https://github.com/brendangregg/FlameGraph[FlameGraph GitHub リポジトリー] を使用します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1355
msgid "Next, generate a flame graph using the data captured via `perf record`:"
msgstr "次に、`perf record` を介してキャプチャされたデータを使用してフレームグラフを生成します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1359
#: upstream/_versions/main/guides/native-reference.adoc:1423
#: upstream/_versions/main/guides/native-reference.adoc:1530
#, no-wrap
msgid "perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1363
msgid "The flame graph is a svg file that a web browser, such as Firefox, can easily display.  After the above two commands complete one can open `flamegraph.svg` in their browser:"
msgstr "フレームグラフは、Firefox などの Web ブラウザーで簡単に表示できる svg ファイルです。上記の2つのコマンドが完了すると、ブラウザーで `flamegraph.svg` を開くことができます。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:1364
#, no-wrap
msgid "Perf flamegraph without symbols"
msgstr "シンボルのない Perf フレームグラフ"

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:1364
#, no-wrap
msgid "native-reference-perf-flamegraph-no-symbols.svg"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1373
msgid "We see a big majority of time spent in what is supposed to be our main, but we see no trace of the `StringBuilderResource` class, nor the `StringBuilder` class we're calling.  We should look at the symbol table of the binary: can we find symbols for our class and `StringBuilder`? We need those in order to get meaningful data.  From within the tools container, query the symbol table:"
msgstr "メインとなるはずのものに大半の時間が費やされていることがわかりますが、呼び出している `StringBuilderResource` クラスや `StringBuilder` クラスの痕跡は見られません。バイナリーのシンボルテーブルを確認する必要があります。クラスと `StringBuilder` のシンボルを見つけることができますか? 意味のあるデータを取得するためにそれらが必要です。ツールコンテナー内から、シンボルテーブルをクエリーします。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1378
#, no-wrap
msgid ""
"objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"[no output]\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1384
msgid "No output appears when querying the symbol table.  This is why we don't see any call graphs in the flame graphs.  This is a deliberate decision that native-image makes.  By default, it removes symbols from the binary."
msgstr "シンボルテーブルをクエリーすると、出力は表示されません。これが、フレームグラフにコールグラフが表示されない理由です。これは、ネイティブイメージが行う意図的な決定です。デフォルトでは、バイナリーからシンボルを削除します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1388
msgid "To regain the symbols, we need to rebuild the binary instructing GraalVM not to delete the symbols.  On top of that, enable DWARF debug info so that the stack traces can be populated with that information.  From outside the tools container, execute:"
msgstr "シンボルを取り戻すには、シンボルを削除しないように GraalVM に指示するバイナリーを再ビルドする必要があります。さらに、DWARF デバッグ情報を有効にして、スタックトレースにその情報を入力できるようにします。ツールコンテナーの外部から、以下を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1394
#: upstream/_versions/main/guides/native-reference.adoc:1509
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1399
msgid "Next, re-enter the tools container if you exited, and inspect the native executable with `objdump`, and see how the symbols are now present:"
msgstr "次に、終了した場合はツールコンテナーに再度入り、`objdump` を使用してネイティブ実行可能ファイルを検査し、シンボルがどのように存在するようになったかを確認します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1406
#, no-wrap
msgid ""
"$ objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"000000000050a940 l     F .text\t0000000000000091              .hidden ReflectionAccessorHolder_StringBuilderResource_appendDelete_9e06d4817d0208a0cce97ebcc0952534cac45a19_e22addf7d3eaa3ad14013ce01941dc25beba7621\n"
"000000000050a9e0 l     F .text\t00000000000000bb              .hidden ReflectionAccessorHolder_StringBuilderResource_constructor_0f8140ea801718b80c05b979a515d8a67b8f3208_12baae06bcd6a1ef9432189004ae4e4e176dd5a4\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1409
msgid "You should see a long list of symbols that match that pattern."
msgstr "そのパターンに一致するシンボルの長いリストが表示されるはずです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1412
msgid "Then, run the executable through perf, *indicating that the call graph is dwarf*:"
msgstr "次に、実行ファイルを perf で実行すると、 *コールグラフが dwarf であることがわかります*。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1416
#: upstream/_versions/main/guides/native-reference.adoc:1516
#, no-wrap
msgid "perf record -F 1009 --call-graph dwarf -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1419
msgid "Run the curl command once again, stop the binary, generate the flamegraphs and open it:"
msgstr "もう一度curlコマンドを実行し、バイナリを停止し、フレームグラフを生成して開きます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1428
msgid "The flamegraph now shows where the bottleneck is.  It's when `StringBuilder.delete()` is called which calls `System.arraycopy()`.  The issue is that 1 million characters need to be shifted in very small increments:"
msgstr "フレームグラフを見ると、どこがボトルネックになっているかがわかります。それは、 `StringBuilder.delete()` が呼び出され、 `System.arraycopy()` を呼び出すときです。問題は、100万文字を非常に小さな単位でシフトさせる必要があることです。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:1429
#, no-wrap
msgid "Perf flamegraph with symbols"
msgstr "シンボルのある Perf フレームグラフ"

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:1429
#, no-wrap
msgid "native-reference-perf-flamegraph-symbols.svg"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/native-reference.adoc:1431
#, no-wrap
msgid "Multi-Thread"
msgstr "マルチスレッド"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1436
msgid "Multithreaded programs might require special attention when trying to understand their runtime behaviour.  To demonstrate this, add this `MulticastResource` code to your project (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "マルチスレッドプログラムは、ランタイムの動作を理解しようとするときに特別な注意が必要になる場合があります。これを実証するために、この `MulticastResource` コードをプロジェクトに追加します (この例は link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation] からご提供いただいています):"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1452
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.net.InetSocketAddress;\n"
"import java.nio.ByteBuffer;\n"
"import java.nio.channels.DatagramChannel;\n"
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.ThreadFactory;\n"
"import java.util.concurrent.atomic.AtomicInteger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1462
#, no-wrap
msgid ""
"@Path(\"/multicast\")\n"
"public class MulticastResource\n"
"{\n"
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String send() throws Exception {\n"
"        sendMulticasts();\n"
"        return \"Multicast packets sent\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1467
#, no-wrap
msgid ""
"    static void sendMulticasts() throws Exception {\n"
"        DatagramChannel ch = DatagramChannel.open();\n"
"        ch.bind(new InetSocketAddress(5555));\n"
"        ch.configureBlocking(false);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1475
#, no-wrap
msgid ""
"        ExecutorService pool =\n"
"            Executors.newCachedThreadPool(new ShortNameThreadFactory());\n"
"        for (int i = 0; i < 10; i++) {\n"
"            pool.submit(() -> {\n"
"                final ByteBuffer buf = ByteBuffer.allocateDirect(1000);\n"
"                final InetSocketAddress remoteAddr =\n"
"                    new InetSocketAddress(\"127.0.0.1\", 5556);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1482
#, no-wrap
msgid ""
"                while (true) {\n"
"                    buf.clear();\n"
"                    ch.send(buf, remoteAddr);\n"
"                }\n"
"            });\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1485
#, no-wrap
msgid ""
"        System.out.println(\"Warming up...\");\n"
"        Thread.sleep(3000);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1489
#, no-wrap
msgid ""
"        System.out.println(\"Benchmarking...\");\n"
"        Thread.sleep(5000);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1491
#, no-wrap
msgid "    private static final class ShortNameThreadFactory implements ThreadFactory {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1494
#, no-wrap
msgid ""
"        private final AtomicInteger threadNumber = new AtomicInteger(1);\n"
"        private final String namePrefix = \"thread-\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1500
#, no-wrap
msgid ""
"        public Thread newThread(Runnable r) {\n"
"            return new Thread(r, namePrefix + threadNumber.getAndIncrement());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1503
msgid "Build the native executable with debug info:"
msgstr "デバッグ情報付きでネイティブ実行可能ファイルをビルドします。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1512
msgid "From inside the tools container (as privileged user) run the native executable through `perf`:"
msgstr "ツールコンテナー内から (特権ユーザーとして)、`perf` を介してネイティブ実行可能ファイルを実行します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1519
msgid "Invoke the endpoint to send the multicast packets:"
msgstr "エンドポイントを呼び出して、マルチキャストパケットを送信します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1523
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/multicast\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1526
msgid "Make and open a flamegraph:"
msgstr "フレームグラフを作成して開いてください。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:1532
#, no-wrap
msgid "Muti-thread perf flamegraph with separate threads"
msgstr "別々のスレッドを持つマルチスレッド perf フレームグラフ"

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:1532
#, no-wrap
msgid "native-reference-multi-flamegraph-separate-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1536
msgid "The flamegraph produced looks odd. Each thread is treated independently even though they all do the same work.  This makes it difficult to have a clear picture of the bottlenecks in the program."
msgstr "作成されたフレームグラフは奇妙に見えます。すべてのスレッドが同じ作業をしているにもかかわらず、各スレッドが独立して扱われています。これでは、プログラムのボトルネックを明確に把握することができません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1539
msgid "This is happening because from a `perf` perspective, each thread is a different command.  We can see that if we inspect `perf report`:"
msgstr "これは、 `perf` の観点から見ると、各スレッドが異なるコマンドであるために起こっています。 `perf report` を確認するとわかります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1550
#, no-wrap
msgid ""
"perf report --stdio\n"
"# Children      Self  Command          Shared Object       Symbol\n"
"# ........  ........  ...............  ......................................  ......................................................................................\n"
"...\n"
"     6.95%     0.03%  thread-2         debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
"     4.60%     0.02%  thread-10        debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1554
msgid "This can be worked around by applying some modifications to the perf output, in order to make all threads have the same name. E.g."
msgstr "これは、すべてのスレッドが同じ名前になるように、perfの出力にいくつかの変更を加えることで回避できます。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1558
#, no-wrap
msgid "perf script | sed -E \"s/thread-[0-9]*/thread/\" | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/native-reference.adoc:1560
#, no-wrap
msgid "Muti-thread perf flamegraph with joined threads"
msgstr "スレッドが結合されたマルチスレッド perf フレームグラフ"

#. type: Target for macro image
#: upstream/_versions/main/guides/native-reference.adoc:1560
#, no-wrap
msgid "native-reference-multi-flamegraph-joined-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1564
msgid "When you open the flamegraph, you will see all threads' work collapsed into a single area.  Then, you can clearly see that there's some locking that could affect performance."
msgstr "フレームグラフを開くと、すべてのスレッドの作業が1つの領域に折りたたまれているのがわかります。そして、パフォーマンスに影響を与える可能性のあるロックがあることがはっきりとわかります。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1566
#, no-wrap
msgid "Debugging Native Crashes"
msgstr "ネイティブ・クラッシュのデバッグ"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1573
msgid "One of the drawbacks of using native executables is that they cannot be debugged using the standard Java debuggers, instead we need to debug them using `gdb`, the GNU Project debugger.  To demonstrate how to do this, we are going to generate a native Quarkus application that crashes due to a Segmentation Fault when accessing http://localhost:8080/crash.  To achieve this, add the following REST resource to the project:"
msgstr "ネイティブ実行可能ファイルを使用することの欠点の 1 つは、標準の Java デバッガーを使用してデバッグできないことです。代わりに、GNU プロジェクトのデバッガーである `gdb` を使用してデバッグする必要があります。その方法を示すために、http://localhost:8080/crash にアクセスするときにセグメンテーション違反が原因でクラッシュするネイティブ Quarkus アプリケーションを生成します。これを実現するには、以下の REST リソースをプロジェクトに追加します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1579
#, no-wrap
msgid "import sun.misc.Unsafe;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1585
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.lang.reflect.Field;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1588
#, no-wrap
msgid ""
"@Path(\"/crash\")\n"
"public class CrashResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1604
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        Field theUnsafe = null;\n"
"        try {\n"
"            theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n"
"            theUnsafe.setAccessible(true);\n"
"            Unsafe unsafe = (Unsafe) theUnsafe.get(null);\n"
"            unsafe.copyMemory(0, 128, 256);\n"
"        } catch (NoSuchFieldException | IllegalAccessException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1608
msgid "This code will try to copy 256 bytes from address `0x0` to `0x80` resulting in a Segmentation Fault.  To verify this, compile and run the example application:"
msgstr "このコードは、アドレス `0x0` から `0x80` へ 256 バイトをコピーしようとするため、セグメンテーションフォールトが発生します。これを確認するには、サンプルアプリケーションをコンパイルして実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1616
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1619
msgid "This will result in the following output:"
msgstr "これにより、次のような出力が得られます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1626
#, no-wrap
msgid ""
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"Segfault detected, aborting process. Use runtime option -R:-InstallSegfaultHandler if you don't want to use SubstrateSegfaultHandler.\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1632
msgid "The omitted output above contains clues to what caused the issue, but in this exercise we are going to assume that no information was provided.  Let’s try to debug the segmentation fault using `gdb`.  To do that, go to the root of the project and enter the tools container:"
msgstr "上記の省略された出力には、問題の原因の手がかりが含まれていますが、この演習では情報が提供されなかったと仮定しています。`gdb` を使用してセグメンテーション違反をデバッグしてみましょう。これを行うには、プロジェクトの root に移動し、ツールコンテナーに入ります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1636
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1 /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1639
msgid "Then start the application in `gdb` and execute `run`."
msgstr "続いて、`gdb` でアプリケーションを起動し、`run` を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1648
#, no-wrap
msgid ""
"gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(No debugging symbols found in ./target/debugging-ntaive-1.0.0-SNAPSHOT-runner)\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1651
msgid "Next, try to access http://localhost:8080/crash:"
msgstr "次に、http://localhost:8080/crash へのアクセスを試みます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1654
#, no-wrap
msgid "curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1657
#: upstream/_versions/main/guides/native-reference.adoc:1701
msgid "This will result in the following message in `gdb`:"
msgstr "これにより、 `gdb` に次のようなメッセージが表示されます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1663
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fe103dff640 (LWP 190)]\n"
"0x0000000000461f6e in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1666
msgid "If we try to get more info about the backtrace that led to this crash we will see that there is not enough information available."
msgstr "このクラッシュの原因となったバックトレースの情報を得ようとすると、十分な情報が得られないことがわかります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1677
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  0x0000000000418b5e in ?? ()\n"
"#1  0x00007ffff6f2d328 in ?? ()\n"
"#2  0x0000000000418a04 in ?? ()\n"
"#3  0x00007ffff44062a0 in ?? ()\n"
"#4  0x00000000010c3dd3 in ?? ()\n"
"#5  0x0000000000000100 in ?? ()\n"
"#6  0x0000000000000000 in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1682
msgid "This is because we didn’t compile the Quarkus application with `-Dquarkus.native.debug.enabled`, so `gdb` cannot find debugging symbols for our native executable, as indicated by the \"_No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" message in the beginning of `gdb`."
msgstr "これは、Quarkus アプリケーションを `-Dquarkus.native.debug.enabled` でコンパイルしなかったことが原因で、これにより、`gdb` の最初にある \"_No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" メッセージで示されているように、`gdb` はネイティブ実行ファイルのデバッグシンボルを見つけることができません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1685
msgid "Recompiling the Quarkus application with `-Dquarkus.native.debug.enabled` and rerunning it through `gdb` we are now able to get a backtrace making clear what caused the crash.  On top of that, add `-H:-OmitInlinedMethodDebugLineInfo` option to avoid inlined methods being omitted from the backtrace:"
msgstr "`-Dquarkus.native.debug.enabled` でQuarkusアプリケーションを再コンパイルし、 `gdb` で再実行すると、クラッシュの原因を明らかにするバックトレースを得ることができます。さらに、 `-H:-OmitInlinedMethodDebugLineInfo` オプションを追加すると、インライン化されたメソッドがバックトレースから省略されるのを防ぐことができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1698
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-OmitInlinedMethodDebugLineInfo\n"
"...\n"
"$ gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1709
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fffeffff640 (LWP 362984)]\n"
"com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) ()\n"
"\tat com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"169    com/oracle/svm/core/UnmanagedMemoryUtil.java: No such file or directory.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1713
msgid "We already see that `gdb` is able to tell us which method caused the crash and where it’s located in the source code.  We can also get a backtrace of the call graph that led us to this state:"
msgstr "`gdb` は、どのメソッドがクラッシュの原因となったのか、それがソースコードのどこにあるのかを教えてくれることがすでにわかりました。また、この状態に至ったコールグラフのバックトレースも得ることができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1726
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"#1  0x0000000000461e14 in com.oracle.svm.core.UnmanagedMemoryUtil::copyBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:110\n"
"#2  0x0000000000461dc8 in com.oracle.svm.core.UnmanagedMemoryUtil::copy(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:67\n"
"#3  0x000000000045d3c0 in com.oracle.svm.core.JavaMemoryUtil::unsafeCopyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at com/oracle/svm/core/JavaMemoryUtil.java:276\n"
"#4  0x00000000013277de in jdk.internal.misc.Unsafe::copyMemory0 () at com/oracle/svm/core/jdk/SunMiscSubstitutions.java:125\n"
"#5  jdk.internal.misc.Unsafe::copyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at jdk/internal/misc/Unsafe.java:788\n"
"#6  0x00000000013b1a3f in jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:799\n"
"#7  sun.misc.Unsafe::copyMemory () at sun/misc/Unsafe.java:585\n"
"#8  org.acme.CrashResource::hello(void) () at org/acme/CrashResource.java:22\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1729
msgid "Similarly, we can get a backtrace of the call graph of other threads."
msgstr "同様に、他のスレッドのコールグラフのバックトレースを取得できます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1731
msgid "First, we can list the available threads with:"
msgstr "まず、利用可能なスレッドを以下のように一覧表示できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1742
#, no-wrap
msgid ""
"(gdb) info threads\n"
"  Id   Target Id                                             Frame\n"
"  1    Thread 0x7fcc62a07d00 (LWP 322) \"debugging-nativ\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  2    Thread 0x7fcc60eff640 (LWP 326) \"gnal Dispatcher\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"* 4    Thread 0x7fcc5b7fe640 (LWP 328) \"ecutor-thread-0\" com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"  5    Thread 0x7fcc5abff640 (LWP 329) \"-thread-checker\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  6    Thread 0x7fcc59dff640 (LWP 330) \"ntloop-thread-0\" 0x00007fcc62c12c9e in epoll_wait () from /lib64/libc.so.6\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1745
msgid "select the thread we want to inspect, e.g. thread 1:"
msgstr "検査するスレッドを選択します (例: スレッド 1)。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1752
#, no-wrap
msgid ""
"(gdb) thread 1\n"
"[Switching to thread 1 (Thread 0x7ffff7a58d00 (LWP 1028851))]\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"57\t    return INTERNAL_SYSCALL_CANCEL (futex_time64, futex_word, op, expected,\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1755
msgid "and, finally, print the stack trace:"
msgstr "そして最後に、スタックトレースを出力します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1783
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"#1  __futex_abstimed_wait_common (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=0,\n"
"    cancel=cancel@entry=true) at futex-internal.c:87\n"
"#2  0x00007ffff7bdd79f in __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0,\n"
"    private=private@entry=0) at futex-internal.c:139\n"
"#3  0x00007ffff7bdfeb0 in __pthread_cond_wait_common (abstime=0x0, clockid=0, mutex=0x2ca07b0, cond=0x2cd7ab0) at pthread_cond_wait.c:504\n"
"#4  ___pthread_cond_wait (cond=0x2cd7ab0, mutex=0x2ca07b0) at pthread_cond_wait.c:619\n"
"#5  0x00000000004e2014 in com.oracle.svm.core.posix.headers.Pthread::pthread_cond_wait () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#6  com.oracle.svm.core.posix.thread.PosixParkEvent::condWait(void) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#7  0x0000000000547070 in com.oracle.svm.core.thread.JavaThreads::park(void) () at com/oracle/svm/core/thread/JavaThreads.java:764\n"
"#8  0x0000000000fc5f44 in jdk.internal.misc.Unsafe::park(boolean, long) () at com/oracle/svm/core/thread/Target_jdk_internal_misc_Unsafe_JavaThreads.java:49\n"
"#9  0x0000000000eac1ad in java.util.concurrent.locks.LockSupport::park(java.lang.Object *) () at java/util/concurrent/locks/LockSupport.java:194\n"
"#10 0x0000000000ea5d68 in java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject::awaitUninterruptibly(void) ()\n"
"    at java/util/concurrent/locks/AbstractQueuedSynchronizer.java:2018\n"
"#11 0x00000000008b6b30 in io.quarkus.runtime.ApplicationLifecycleManager::run(io.quarkus.runtime.Application *, java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) ()\n"
"    at io/quarkus/runtime/ApplicationLifecycleManager.java:144\n"
"#12 0x00000000008bc055 in io.quarkus.runtime.Quarkus::run(java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) () at io/quarkus/runtime/Quarkus.java:67\n"
"#13 0x000000000045c88b in io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:41\n"
"#14 io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:120\n"
"#15 0x000000000045c88b in io.quarkus.runner.GeneratedMain::main ()\n"
"#16 com.oracle.svm.core.JavaMainWrapper::runCore () at com/oracle/svm/core/JavaMainWrapper.java:150\n"
"#17 com.oracle.svm.core.JavaMainWrapper::run(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *) () at com/oracle/svm/core/JavaMainWrapper.java:186\n"
"#18 0x000000000048084d in com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *)\n"
"    () at com/oracle/svm/core/JavaMainWrapper.java:280\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1786
msgid "Alternatively, we can list the backtraces of all threads with a single command:"
msgstr "または、1 つのコマンドですべてのスレッドのバックトレースを一覧表示することもできます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1790
#, no-wrap
msgid "(gdb) thread apply all backtrace\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1810
#, no-wrap
msgid ""
"Thread 22 (Thread 0x7fffc8dff640 (LWP 1028872) \"tloop-thread-15\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=8, events=0x2ca3880, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1830
#, no-wrap
msgid ""
"Thread 21 (Thread 0x7fffc97fa640 (LWP 1028871) \"tloop-thread-14\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=53, events=0x2cd0970, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1833
#, no-wrap
msgid ""
"Thread 20 (Thread 0x7fffc9ffb640 (LWP 1028870) \"tloop-thread-13\"):\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1836
msgid "Note, however, that despite being able to get a backtrace we can still not list the source code at point with the `list` command."
msgstr "ただし、バックトレースを取得できるにもかかわらず、`list` コマンドを使用してソースコードをある点で引き続き一覧表示できないことに注意してください。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1841
#, no-wrap
msgid ""
"(gdb) list\n"
"164    in com/oracle/svm/core/UnmanagedMemoryUtil.java\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1847
msgid "This is because `gdb` is not aware of the location of the source files.  We are running the executable outside the target directory.  To fix this we can either rerun `gdb` from the target directory or, run `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` e.g.:"
msgstr "これは、`gdb` がソースファイルの場所を認識していないことが原因です。実行可能ファイルは、ターゲットディレクトリーの外で実行しています。これを修正するには、ターゲットディレクトリーから `gdb` を再実行するか、`directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` を実行します。以下に例を示します。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1863
#, no-wrap
msgid ""
"(gdb) directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources\n"
"Source directories searched: /data/target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources:$cdir:$cwd\n"
"(gdb) list\n"
"164        \tUnsignedWord offset = size;\n"
"165        \twhile (offset.aboveOrEqual(32)) {\n"
"166            \toffset = offset.subtract(32);\n"
"167            \tPointer src = from.add(offset);\n"
"168            \tPointer dst = to.add(offset);\n"
"169            \tlong l24 = src.readLong(24);\n"
"170            \tlong l16 = src.readLong(16);\n"
"171            \tlong l8 = src.readLong(8);\n"
"172            \tlong l0 = src.readLong(0);\n"
"173            \tdst.writeLong(24, l24);\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1870
msgid "We can now examine line `169` and get a first hint of what might be wrong (in this case we see that it fails at the first read from src which contains the address `0x0000`), or walk up the stack using `gdb`’s `up` command to see what part of our code led to this situation.  To learn more about using gdb to debug native executables see https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/[here]."
msgstr "`169` 行を調べて、何が問題なのか最初のヒントを得ることができます（この場合、アドレス `0x0000` を含む src からの最初の読み取りに失敗していることがわかります）。あるいは、 `gdb` の `up` コマンドを使ってスタックをさかのぼり、コードのどの部分がこのような状況を引き起こしたかを確認することができます。ネイティブ実行可能ファイルをデバッグするためのgdbの使い方については、 https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/[こちら]をご覧ください。"

#. type: Title ==
#: upstream/_versions/main/guides/native-reference.adoc:1872
#, no-wrap
msgid "Frequently Asked Questions"
msgstr "よくある質問"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1874
#, no-wrap
msgid "Why is the process of generating a native executable slow?"
msgstr "ネイティブ実行可能ファイルを生成するプロセスが遅いのはなぜですか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1878
msgid "Native executable generation is a multi-step process.  The analysis and compile steps are the most expensive of all and hence the ones that dominate the time spent generating the native executable."
msgstr "ネイティブ実行可能ファイルの生成は、複数のステップで構成されています。その中でも解析とコンパイルのステップは最もコストがかかるため、ネイティブ実行可能ファイルの生成にかかる時間の大半を占めます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1884
msgid "In the analysis phase, a static points-to analysis starts from the main method of the program to find out what is reachable.  As new classes are discovered, some of them will be initialized during this process depending on the configuration.  In the next step, the heap is snapshotted and checks are made to see which types need to be available at runtime.  The initialization and heap snapshotting can cause new types to be discovered, in which case the process is repeated.  The process stops when a fixed point is reached, that is when the reachable program grows no more."
msgstr "解析フェーズでは、プログラムのメインメソッドから静的なPoint-to 解析を開始し、到達可能なものを見つけ出します。新しいクラスが発見されると、設定に応じてこのプロセス中にその一部が初期化されます。次のステップでは、ヒープがスナップショットされ、どのタイプが実行時に利用可能である必要があるかのチェックが行われます。初期化とヒープのスナップショットにより、新しい型が発見されることがありますが、その場合はこのプロセスが繰り返されます。このプロセスは、到達可能なプログラムがこれ以上成長しないという固定点に達したときに停止します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1886
msgid "The compilation step is pretty straightforward, it simply compiles all the reachable code."
msgstr "コンパイルのステップは非常に簡単で、到達可能なすべてのコードを単純にコンパイルします。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1893
msgid "The time spent in analysis and compilation phases depends on how big the application is.  The bigger the application, the longer it takes to compile it.  However, there are certain features that can have an exponential effect.  For example, when registering types and methods for reflection access, the analysis can’t easily see what’s behind those types or methods, so it has to do more work to complete the analysis step."
msgstr "解析とコンパイルの段階でかかる時間は、アプリケーションの大きさによって異なります。アプリケーションが大きければ大きいほど、コンパイルにかかる時間は長くなります。ただし、指数関数的な効果をもたらす機能もあります。例えば、リフレクションアクセスのために型やメソッドを登録する場合、解析はその型やメソッドの背後にあるものを簡単に見ることができないため、解析ステップを完了するためにはより多くの仕事をしなければなりません。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1894
#, fuzzy, no-wrap
msgid "I get a `AnalysisError\\$ParsingError` when building a native executable due to an `UnresolvedElementException`, what can I do?"
msgstr "ネイティブ実行ファイルをビルドする際に OutOfMemoryError (OOME) が発生しました。どうすればよいですか?"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1899
#, fuzzy
msgid "When building a native executable Quarkus requires all classes being referenced by the code, no matter if they are build-time or run-time initialized, to be present in the classpath.  This way it ensures that there will be no crashes at runtime due to potential `NoClassDefFoundError` exceptions.  To achieve this it makes use of GraalVM's `--link-at-build-time` parameter:"
msgstr "Quarkusでは、ネイティブの実行ファイルを構築する際に、コードから参照されるすべてのクラスが、構築時または実行時に初期化されるかに関係なく、クラスパスに存在することが必要です。こうすることで、 `NoClassDefFoundError` の例外が発生する可能性があるため、実行時にクラッシュすることがないようにします。これを達成するために、GraalVMの `--link-at-build-time` パラメータを利用します："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:1905
#, no-wrap
msgid ""
"--link-at-build-time  require types to be fully defined at image build-time. If used\n"
"                      without args, all classes in scope of the option are required to\n"
"                      be fully defined.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1909
#, fuzzy
msgid "This, however, may result in an `AnalysisError\\$ParsingError` due to an `UnresolvedElementException` at build time.  This is often caused because the application references a class from an https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[optional dependency]."
msgstr "しかし、この場合、ビルド時に `UnresolvedElementException` が発生するため、 `AnalysisError\\$ParsingError` が発生することがあります。これは、アプリケーションが link:https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[オプションの依存関係から] クラスを参照するために起こることが多い。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1911
#, fuzzy
msgid "If you have access to the source code responsible for the reference to the missing dependency and can alter it, you should consider one of the following:"
msgstr "欠落している依存関係への参照を担当するソースコードにアクセスでき、それを変更できる場合は、次のいずれかを検討する必要があります："

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1913
#, fuzzy
msgid "Remove the reference if it's not actually necessary."
msgstr "実際に必要でない場合は、参照を削除してください。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1914
#, fuzzy
msgid "Move the affected code in a sub-module and make the dependency non-optional (as is the best practice)."
msgstr "影響を受けるコードをサブモジュールに移動し、依存関係を非オプションにする（ベストプラクティスとして）。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1915
#, fuzzy
msgid "Make the dependency non-optional."
msgstr "依存関係を非オプションにする。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1917
#, fuzzy
msgid "In the unfortunate case where the reference causing the issue is made by a 3rd party library, that you cannot modify, you should consider one of the following:"
msgstr "問題の原因となる参照がサードパーティライブラリで作られており、それを変更することができない場合は、次のいずれかを検討する必要があります："

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1919
#, fuzzy
msgid "Use a class/method substitution to remove the said reference."
msgstr "クラス/メソッド置換を使用して、当該参照を削除する。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1920
#, fuzzy
msgid "Add the optional dependency as a non-optional dependency of your project."
msgstr "オプションの依存関係を、プロジェクトの非オプションの依存関係として追加します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1924
#, fuzzy
msgid "Note that although option (1) is the best choice performance wise, as it minimizes the applications footprint,it might not be trivial to implement.  To make matters worse, it's also not easy to maintain as it is tightly coupled to the 3rd party library implementation.  Option (2) is a straight forward alternative to work around the issue, but comes at the cost of including possibly never invoked code in the resulting native executable."
msgstr "オプション(1)は、アプリケーションのフットプリントを最小化するため、パフォーマンス的には最良の選択ですが、実装が容易でない場合があることに注意してください。さらに悪いことに、サードパーティライブラリの実装と密接に結合しているため、保守も容易ではありません。オプション(2)は、この問題を回避するための簡単な代替案ですが、結果的にネイティブ実行ファイルに一度も呼び出されなかったコードが含まれる可能性があるという代償を伴います。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1925
#, no-wrap
msgid "I get an `OutOfMemoryError` (OOME) building native executables, what can I do?"
msgstr "ネイティブ実行ファイルをビルドする際に OutOfMemoryError (OOME) が発生しました。どうすればよいですか?"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1937
#, fuzzy
msgid "Building native executables is not only time consuming, but it also takes a fair amount of memory.  For example, building a sample native Quarkus Jakarta Persistence application such as the Hibernate ORM quickstart, may use 6GB to 8GB resident set size in memory.  A big chunk of this memory is Java heap, but extra memory is required for other aspects of the JVM that runs the native building process.  It is still possible to build such applications in environments that have total memory close to the limits, but to do that it is necessary to shrink the maximum heap size of the GraalVM native image process.  To do that, set a maximum heap size using the `quarkus.native.native-image-xmx` property.  For example, we can instruct GraalVM to use 5GB of maximum heap size by passing in `-Dquarkus.native.native-image-xmx=5g` in the command line."
msgstr "ネイティブ実行ファイルのビルドは時間がかかるだけでなく、かなりの量のメモリを消費します。例えば、Hibernate ORM quickstartのようなQuarkus Jakarta Persistenceのネイティブアプリケーションのサンプルをビルドすると、メモリに6GBから8GBのレジデントセットサイズを使用する場合があります。このメモリの大部分はJavaヒープですが、ネイティブの構築プロセスを実行するJVMの他の側面には、余分なメモリが必要です。総メモリ量が限界に近い環境でもこのようなアプリケーションを構築することは可能ですが、そのためにはGraalVMネイティブイメージプロセスの最大ヒープサイズを縮小することが必要です。そのためには、 `quarkus.native.native-image-xmx` プロパティを使用して最大ヒープサイズを設定します。例えば、コマンドラインで `-Dquarkus.native.native-image-xmx=5g` を渡すことで、GraalVMに最大ヒープサイズ5GBを使用するように指示することができます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1940
msgid "Building native executables this way might have the side effect of requiring more time to complete.  This is due to garbage collection having to work harder for native image generation to have free space to do its job."
msgstr "この方法でネイティブ実行可能ファイルをビルドすると、完了するまでに時間がかかるという副作用が生じる可能性があります。これは、ガベージコレクションが、ネイティブイメージの生成に必要な空き領域を確保するために、より多くの作業を行う必要があるためです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1943
msgid "Note that typical applications are likely bigger than quickstarts, so the memory requirements will also likely be higher."
msgstr "一般的なアプリケーションはクイックスタートよりも大きい可能性が高いため、メモリー要件も高くなる可能性があることに注意してください。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1944
#, no-wrap
msgid "Why is runtime performance of a native executable inferior compared to JVM mode?"
msgstr "JVMモードと比較して、ネイティブ実行可能ファイルのランタイムパフォーマンスが劣るのはなぜですか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1949
msgid "As with most things in life there are some trade-offs involved when choosing native compilation over JVM mode.  So depending on the application the runtime performance of a native application might be slower compared to JVM mode, though that’s not always the case."
msgstr "多くの場合、JVM モードではなくネイティブコンパイルを選択すると、いくつかのトレードオフが発生します。そのため、アプリケーションによっては、ネイティブアプリケーションの実行時パフォーマンスが JVM モードに比べて遅くなることがありますが、絶対にそうであるとは限りません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1955
msgid "JVM execution of an application includes runtime optimization of the code that profits from profile information built up during execution.  That includes the opportunities to inline a lot more of the code, locate hot code on direct paths (i.e. ensure better instruction cache locality)  and cut out a lot of the code on cold paths (on the JVM a lot of code does not get compiled until something tries to execute it -- it is replaced with a trap that causes deoptimization and recompilation).  Removal of cold paths provides many more optimization opportunities than are available for ahead of time compilation because it significantly reduces the branch complexity and combinatorial logic of the smaller amount of hot code that is compiled."
msgstr "JVMによるアプリケーションの実行には、実行中に蓄積されるプロファイル情報を利用したコードの実行時最適化が含まれます。これには、より多くのコードをインライン化したり、ホットコードをダイレクトパスに配置したり（つまり、より良い命令キャッシュのローカリティを確保する）、コールドパスにある多くのコードをカットしたりする機会が含まれます（JVMでは、多くのコードが何かが実行しようとするまでコンパイルされず、最適化解除や再コンパイルを引き起こすトラップに置き換えられます）。コールドパスを取り除くことで、コンパイルされる少量のホットコードの分岐の複雑さや組み合わせロジックが大幅に削減されるため、先行してコンパイルする場合よりも多くの最適化の機会が得られます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1958
msgid "By contrast, native executable compilation has to cater for all possible execution paths when it compiles code offline since it does not know which are the hot or cold paths and cannot use the trick of planting a trap and recompiling if it is hit. For the same reason it cannot load the dice to ensure that code cache conflicts are minimized by co-locating hot paths adjacent.  Native executable generation is able to remove some code because of the closed world hypothesis but that is often not enough to make up for all the benefits that profiling and runtime deopt & recompile provides to the JVM JIT compiler."
msgstr "一方、ネイティブ実行可能ファイルのコンパイルでは、オフラインでコードをコンパイルする際に、すべての可能な実行経路に対応しなければなりません。なぜならば、ホットパスやコールドパスがわからないため、罠を仕掛けて、それに当たったら再コンパイルするというようなトリックが使えないからです。同じ理由で、ホットパスを隣接して配置することでコードキャッシュの衝突を最小限に抑えるようなサイコロを積むこともできません。ネイティブ実行可能ファイルの生成は、閉じた世界の仮説により、いくつかのコードを削除することができますが、それだけでは、プロファイリングや実行時最適化解除＆再コンパイルがJVM JITコンパイラに提供するすべての利点を補うことはできません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1960
msgid "Note, however, that there is a price you pay for that potentially higher JVM speed, and that price is in increased resource usage (both CPU and memory) and startup time because:"
msgstr "ただし、JVMの速度が向上する可能性があるため、その代償として、リソース（CPUとメモリの両方）の使用量と起動時間が増加することに注意してください。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1962
msgid "it takes some time before the JIT kicks in and fully optimizes the code."
msgstr "JITが作動してコードを完全に最適化するまでに時間がかかります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1963
msgid "the JIT compiler consumes resources that could be utilized by the application."
msgstr "JIT コンパイラは、アプリケーションが利用できるリソースを消費します。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1964
msgid "the JVM has to retain a lot more metadata and compiler/profiler data to support the better optimizations that it can offer."
msgstr "JVMは、より良い最適化をサポートするために、より多くのメタデータやコンパイラ/プロファイラのデータを保持しなければなりません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1966
msgid "The reason for 1) is that code needs to be run interpreted for some time and, possibly, to be compiled several times before all potential optimizations are realized to ensure that:"
msgstr "1)の理由は、コードはしばらくの間、インタプリタ実行する必要があり、場合によっては、以下を担保する全ての潜在的な最適化が実現される前に、何度もコンパイルする必要があるからです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1968
msgid "it’s worth compiling that code path, i.e. it’s being executed enough times, and that"
msgstr "そのコードパスをコンパイルする価値があります。つまり、十分な回数実行されています。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1969
msgid "we have enough profiling data to perform meaningful optimizations."
msgstr "意味のある最適化を行うのに十分なプロファイリングデータを持っていること"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1972
msgid "An implication of 1) is that for small, short-lived applications a native executable may well be a better bet.  Although the compiled code is not as well optimized it is available straight away."
msgstr "1)の意味するところは、小規模で短命なアプリケーションには、ネイティブ実行可能ファイルの方が適しているということです。コンパイルされたコードは最適化されていませんが、すぐに利用できます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1975
msgid "The reason for 2) is that the JVM is essentially running the compiler at runtime in parallel with the application itself.  In the case of native executables the compiler is run ahead of time removing the need to run the compiler in parallel with the application."
msgstr "2)の理由は、JVMは基本的に実行時にアプリケーションと並行してコンパイラを実行しているからです。ネイティブ実行可能ファイルの場合、コンパイラは事前に実行されるため、アプリケーションと並行してコンパイラを実行する必要がありません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1984
msgid "There are several reasons for 3). The JVM does not have a closed world assumption.  So, it has to be able to recompile code if loading of new classes implies that it needs to revise optimistic assumptions made at compile time.  For example, if an interface has only one implementation it can make a call jump directly to that code.  However, in the case where a second implementation class is loaded the call site needs to be patched to test the type of the receiver instance and jump to the code that belongs to its class.  Supporting optimizations like this one requires keeping track of a lot more details of the class base than a native executable, including recording the full class and interface hierarchy, details of which methods override other methods, all method bytecode etc.  In a native executable most of the details of class structure and bytecode can be ignored at run time."
msgstr "3)にはいくつかの理由があります。JVMは閉じた世界を想定していません。そのため、新しいクラスのロードにより、コンパイル時の楽観的な仮定を修正する必要がある場合には、コードを再コンパイルできなければなりません。例えば、あるインターフェイスの実装が1つだけの場合、そのコードに直接コールジャンプすることができます。しかし、2つ目の実装クラスがロードされた場合には、レシーバのインスタンスのタイプをテストして、そのクラスに属するコードにジャンプするようにコールサイトを修正する必要があります。このような最適化をサポートするには、ネイティブ実行可能ファイルよりもクラスベースの詳細を記録しておく必要があります。これには、完全なクラスとインターフェイスの階層、どのメソッドが他のメソッドをオーバーライドするかの詳細、すべてのメソッドのバイトコードなどが含まれます。ネイティブ実行可能ファイルでは、クラス構造やバイトコードの詳細のほとんどは実行時には無視できます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1989
msgid "The JVM also has to cope with changes to the class base or execution profiles that result in a thread going down a previously cold path.  At that point the JVM has to jump out of the compiled code into the interpreter and recompile the code to cater for a new execution profile that includes the previously cold path.  That requires keeping runtime info that allow a compiled stack frame to be replaced with one or more interpreter frames.  It also requires runtime extensible profile counters to be allocated and updated to track what has or has not been executed."
msgstr "また、JVMはクラスベースや実行プロファイルの変更にも対応しなければならず、その結果、スレッドが以前のコールドパスを通ることになります。その時点で、JVMはコンパイルされたコードからインタープリタにジャンプし、以前のコールドパスを含む新しい実行プロファイルに対応するためにコードを再コンパイルしなければなりません。そのためには、コンパイルされたスタックフレームを1つまたは複数のインタープリタフレームに置き換えることができる実行時情報を保持する必要があります。また、実行されたもの、されなかったものを追跡するために、ランタイムの拡張可能なプロファイルカウンタを割り当て、更新する必要があります。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:1990
#, no-wrap
msgid "Why are native executables “big”?"
msgstr "なぜネイティブ実行可能ファイルは大きいのですか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1993
msgid "This can be attributed to a number of different reasons:"
msgstr "これには様々な理由があります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:1999
msgid "Native executables include not only the application code but also, library code, and JDK code.  As a result a more fair comparison would be to compare the native executable’s size with the size of the application, plus the size of the libraries it uses, plus the size of the JDK.  Especially the JDK part is not negligible even in simple applications like HelloWorld.  To get a glance on what is being pulled in the image one can use `-H:+PrintUniverse` when building the native executable."
msgstr "ネイティブ実行可能ファイルには、アプリケーションのコードだけでなく、ライブラリのコードやJDKのコードも含まれています。そのため、ネイティブ実行可能ファイルのサイズは、アプリケーションのサイズに加えて、使用するライブラリのサイズとJDKのサイズを加えたものと比較するのが、より公平な比較となります。特にJDKの部分は、HelloWorldのようなシンプルなアプリケーションでも無視できません。イメージの中で何が引き出されているかを把握するために、ネイティブ実行可能ファイルをビルドする際に `-H:+PrintUniverse` を使用することができます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2005
msgid "Some features are always included in a native executable even though they might never be actually used at run time.  An example of such a feature is garbage collection.  At compile time we can’t be sure whether an application will need to run garbage collection at run time, so garbage collection is always included in native executables increasing their size even if not necessary.  Native executable generation relies on static code analysis to identify which code paths are reachable, and static code analysis can be imprecise leading to more code getting into the image than what’s actually needed."
msgstr "ネイティブ実行可能ファイルには、実行時に実際には使われないかもしれないのに、必ず含まれている機能があります。そのような機能の例として、ガベージコレクションがあります。コンパイル時には、アプリケーションが実行時にガベージコレクションを実行する必要があるかどうかはわかりません。そのため、ガベージコレクションは、必要がないにもかかわらず、常にネイティブ実行可能ファイルに含まれ、サイズが大きくなります。ネイティブ実行可能ファイルの生成は、どのコードパスが到達可能かを特定するために、静的なコード解析に依存していますが、静的なコード解析は不正確な場合があり、実際に必要なコードよりも多くのコードがイメージに入ってしまうことがあります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2008
msgid "There is a https://github.com/oracle/graal/issues/287[GraalVM upstream issue] with some interesting discussions about that topic."
msgstr "この話題については、 link:https://github.com/oracle/graal/issues/287[GraalVMアップストリーム課題]で興味深い議論が行われています。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2009
#, no-wrap
msgid "What version of Mandrel was used to generate a binary?"
msgstr "バイナリの生成に使用したMandrelのバージョンは？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2012
msgid "One can see which Mandrel version was used to generate a binary by inspecting the binary as follows:"
msgstr "どのバージョンのMandrelを使ってバイナリを生成したかは、バイナリを以下のように検査すればわかります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2017
#, no-wrap
msgid ""
"$ strings target/debugging-native-1.0.0-SNAPSHOT-runner | grep GraalVM\n"
"com.oracle.svm.core.VM=GraalVM 22.0.0.2-Final Java 11 Mandrel Distribution\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2019
#, no-wrap
msgid "How do I enable GC logging in native executables?"
msgstr "ネイティブ実行可能ファイルでGCロギングを有効にするにはどうすればいいですか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2022
#, fuzzy
msgid "See xref:gc-logging[Native Memory Management GC Logging section] for details."
msgstr "詳細は、「 link:#gc-logging[ネイティブメモリ管理GCロギング」セクションを] 参照してください。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2024
#, no-wrap
msgid "Can I get a heap dump of a native executable? e.g. if it runs out of memory"
msgstr "ネイティブ実行可能ファイルのヒープダンプを取得することはできますか？ 例えば、メモリ不足になった場合などです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2029
msgid "Starting with GraalVM 22.2.0 it is possible to create heap dumps upon request, e.g. `kill -SIGUSR1 <pid>`.  Support for dumping the heap dump upon an out of memory error will follow up."
msgstr "GraalVM 22.2.0 からは、要求に応じてダンプをヒープすることが可能になります (例: `kill -SIGUSR1 <pid>` )。メモリー不足エラーの際のヒープダンプのダンプのサポートは、今後追加される予定です。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2030
#, no-wrap
msgid "Can I build and run this examples outside a container in Linux?"
msgstr "このサンプルをコンテナーの外で Linux でビルドして実行することは可能ですか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2036
msgid "Yes you can.  In fact, debugging native executables on a Linux bare metal box offers the best possible experience.  In this kind of environments, root access is not needed except to install packages required to run some debug steps, or to enable `perf` to gather events at the kernel."
msgstr "Quarkusのネイティブ実行可能ファイルのデバッグは、Linux環境で行うのが最適です。一部のデバッグ手順を実行するために必要なパッケージをインストールする場合や、 `perf` でカーネルのイベントを収集できるようにする場合を除き、ルートアクセスは必要ありません。macOSやWindows環境でのデバッグは、コンテナ環境でも機能します（ link:#macwindows[FAQエントリ]を参照）。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2038
msgid "These are the packages you'll need on your Linux environment to run through the different debugging sections:"
msgstr "これらのパッケージは、異なるデバッグセクションを実行するために、Linux環境で必要となるものです。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2045
#, no-wrap
msgid ""
"# dnf (rpm-based)\n"
"sudo dnf install binutils gdb perf perl-open\n"
"# Debian-based distributions:\n"
"sudo apt install binutils gdb perf\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2047
#, no-wrap
msgid "Generating flame graphs is slow, or produces errors, what can I do?"
msgstr "フレームグラフの生成に時間がかかったり、エラーが発生したりするのですが、どうすればいいですか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2051
msgid "There are multiple ways in which a native executable produced by Mandrel can be profiled.  All the methods require you to pass in the `-H:-DeleteLocalSymbols` option."
msgstr "Mandrelが作成したネイティブ実行可能ファイルをプロファイリングする方法は複数あります。すべての方法で、 `-H:-DeleteLocalSymbols` オプションを渡す必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2055
msgid "The method shown in this reference guide generates a binary with DWARF debug information, runs it via `perf record` and then uses `perf script` and flame graph tooling to generate the flamegraphs.  However, the `perf script` post-processing step done on this binary can appear to be slow or can show some DWARF errors."
msgstr "このリファレンス・ガイドで紹介する方法は、DWARFのデバッグ情報を含むバイナリを生成し、 `perf record` を通して実行し、 `perf script` とフレーム・グラフ・ツールを使用してフレーム・グラフを生成します。しかし、このバイナリで行われる `perf script` の後処理ステップは、時間がかかったり、DWARF のエラーが表示されたりすることがあります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2060
msgid "An alternative method to generate flame graphs is to pass in `-H:+PreserveFramePointer` when generating the native executable instead of generating the DWARF debug information.  It instructs the binary to use an extra register for the frame pointer.  This enables `perf` to do stack walking to profile the runtime behaviour.  To generate the native executable using these flags, do the following:"
msgstr "フレームグラフを生成する別の方法として、ネイティブ実行可能ファイルを生成する際に、DWARFのデバッグ情報を生成する代わりに、 `-H:+PreserveFramePointer` を渡す方法があります。これは、フレームポインタに追加のレジスタを使用するようにバイナリに指示します。これにより、 `perf` は、実行時の動作をプロファイリングするためにスタックウォーキングを行うことができます。これらのフラグを使用してネイティブ実行可能ファイルを生成するには、以下のようにします。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2065
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"    -Dquarkus.native.additional-build-args=-H:+PreserveFramePointer,-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2068
msgid "To get runtime profiling information out of the native executable, simply do:"
msgstr "実行時プロファイリング情報をネイティブ実行可能ファイルから取得するには、単純に次のようにします。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2076
msgid "The recommended method for generating runtime profiling information is using the debug information rather than generating a binary that preserves the frame pointer.  This is because adding debug information to the native executable build process has no negative runtime performance whereas preserving the frame pointer does."
msgstr "実行時プロファイリング情報を生成する方法としては、フレームポインタを保持したバイナリを生成するよりも、デバッグ情報を使用することを推奨します。これは、ネイティブ実行可能ファイルのビルドプロセスにデバッグ情報を追加しても、実行時のパフォーマンスには何の影響もないのに対し、フレームポインタの保持は影響があるためです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2082
msgid "DWARF debug info is generated in a separate file and can even be omitted in the default deployment and only be transferred and used on demand, for profiling or debugging purposes.  Furthermore, the presence of debug info enables `perf` to show us the relevant source code lines as well, hence it does not bloat the native executable itself.  To do that, simply call `perf report` with an extra parameter to show source code lines:"
msgstr "DWARFのデバッグ情報は、別のファイルに生成され、デフォルトのデプロイメントでは省略することもでき、プロファイリングやデバッグの目的で必要なときだけ転送して使用することができます。さらに、デバッグ情報があることで、 `perf` は関連するソースコード行も表示することができ、ネイティブ実行可能ファイル自体を肥大化させることはありません。そのためには、 `perf report` にソースコード行を表示するパラメータを追加して呼び出すだけです。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2092
#, no-wrap
msgid ""
"perf report --stdio -F+srcline\n"
"...\n"
"83.69%     0.00%  GreetingResource.java:20 ...\n"
"...\n"
"83.69%     0.00%  AbstractStringBuilder.java:1025 ...\n"
"...\n"
"83.69%     0.00%  ArraycopySnippets.java:95 ...\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2098
msgid "The performance penalty of preserving the frame pointer is due to using the extra register for stack walking, particularly in `x86_64` compared to `aarch64` where there are fewer registers available.  Using this extra register reduces the number of registers that are available for other work, which can lead to performance penalties."
msgstr "フレームポインターを保持することによる性能上のペナルティーは、スタックウォーキングのために余分なレジスタを使用することによるもので、特に `aarch64` と比較して `x86_64` では使用できるレジスターの数が少なくなります。この余分なレジスターを使用すると、他の作業に使用できるレジスターの数が減るため、性能上のペナルティーが発生します。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2099
#, no-wrap
msgid "I think I’ve found a bug in native-image, how can I debug it with the IDE?"
msgstr "native-imageのバグを見つけたようなのですが、IDEでどのようにデバッグすればいいのでしょうか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2103
msgid "Although it is possible to remote debug processes within containers, it might be easier to step-by-step debug native-image by installing Mandrel locally and adding it to the path of the shell process."
msgstr "コンテナ内のプロセスをリモートデバッグすることは可能ですが、Mandrelをローカルにインストールしてシェルプロセスのパスに追加することで、native-imageをステップバイステップでデバッグする方が簡単かもしれません。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2108
msgid "Native executable generation is the result of two Java processes that are executed sequentially.  The first process is very short and its main job is to set things up for the second process.  The second process is the one that takes care of most of the work.  The steps to debug one process or the other vary slightly."
msgstr "ネイティブ実行可能ファイルの生成は、2つのJavaプロセスが順次実行された結果です。最初のプロセスは非常に短く、主な仕事は2番目のプロセスのために物事を準備することです。2つ目のプロセスは、ほとんどの作業を行うものです。一方のプロセスをデバッグするための手順は、若干異なります。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2113
msgid "Let’s discuss first how to debug the second process, which is the one you most likely to want to debug.  The starting point for the second process is the `com.oracle.svm.hosted.NativeImageGeneratorRunner` class.  To debug this process, simply add `--debug-attach=*:8000` as an additional build time argument:"
msgstr "まず、最もデバッグしたいと思われる2番目のプロセスのデバッグ方法について説明します。2番目のプロセスのスタートポイントは、 `com.oracle.svm.hosted.NativeImageGeneratorRunner` クラスです。このプロセスをデバッグするには、ビルド時の引数として `--debug-attach=*:8000` を追加するだけです。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2118
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--debug-attach=*:8000\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2124
msgid "The starting point for the first process is the `com.oracle.svm.driver.NativeImages` class.  In GraalVM CE distributions, this first process is a binary, so debugging it in the traditional way with a Java IDE is not possible.  However, Mandrel distributions (or locally built GraalVM CE instances) keep this as a normal Java process, so you can remote debug this process by adding the `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` as an additional build argument, e.g."
msgstr "1番目のプロセスのスタートポイントとなるのは、 `com.oracle.svm.driver.NativeImages` クラスです。GraalVM CEのディストリビューションでは、この最初のプロセスはバイナリなので、従来のようにJava IDEを使ってデバッグすることはできません。しかし、Mandrelのディストリビューション（またはローカルにビルドされたGraalVM CEインスタンス）では、これを通常のJavaプロセスとして保持しているため、 `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` を追加のビルド引数として追加することで、このプロセスをリモートデバッグすることができます。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2129
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--vm.agentlib:jdwp=transport=dt_socket\\\\,server=y\\\\,suspend=y\\\\,address=*:8000\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2131
#, no-wrap
msgid "Can I use JFR/JMC to debug or profile native binaries?"
msgstr "JFR/JMCを使って、ネイティブバイナリのデバッグやプロファイリングはできますか？"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2139
msgid "https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] and https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] can be used to profile native binaries since GraalVM CE 21.2.0.  However, JFR in GraalVM is currently significantly limited in capabilities compared to HotSpot.  The custom event API is fully supported, but many VM level features are unavailable.  They will be added in future releases. Current limitations are:"
msgstr "link:https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder(JFR)]と link:https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control(JMC)]は、GraalVM CE 21.2.0以降、プロファイル・ネイティブ・バイナリのデバッグに使用することができます。 しかし、GraalVMのJFRは現在、HotSpotと比較して機能が大幅に制限されています。カスタムイベントAPIは完全にサポートされていますが、多くのVMレベルの機能は利用できません。これらは将来のリリースで追加される予定です。現在の制限事項は以下の通りです。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2141
msgid "Minimal VM level events"
msgstr "最小限のVMレベルのイベント"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2142
msgid "No old object sampling"
msgstr "oldオブジェクトのサンプリングはありません"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2143
msgid "No stacktrace tracing"
msgstr "スタックトレースのトレースがありません"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2144
msgid "No Streaming API for JDK 17"
msgstr "JDK 17 のストリーミング API なし"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2147
msgid "To use JFR add the application property: `-Dquarkus.native.enable-vm-inspection=true`.  E.g."
msgstr "JFRを使用するには、アプリケーションのプロパティ `-Dquarkus.native.enable-vm-inspection=true` を追加します。例:"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2153
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} \\\n"
"    -Dquarkus.native.enable-vm-inspection=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2156
msgid "Once the image is compiled, enable and start JFR via runtime flags: `-XX:+FlightRecorder` and `-XX:StartFlightRecording`. For example:"
msgstr "イメージのコンパイルが完了したら、ランタイムフラグ `-XX:+FlightRecorder` と `-XX:StartFlightRecording` を使ってJFRを有効にし、起動します。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2162
#, no-wrap
msgid ""
"./target/debugging-native-1.0.0-SNAPSHOT-runner \\\n"
"    -XX:+FlightRecorder \\\n"
"    -XX:StartFlightRecording=\"filename=recording.jfr\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2165
msgid "For more details on using JFR, see https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/JFR/[here]."
msgstr "JFR の使い方の詳細は、https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/JFR/[こちら] をご覧ください。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2166
#, no-wrap
msgid "How can we troubleshoot performance problems only reproducible in production?"
msgstr "本番環境でのみ再現可能なパフォーマンスの問題をどのようにトラブルシューティングできますか?"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2176
msgid "In this situation, switching to JVM mode would be the best thing to try first.  If the performance issues continue after switching to JVM mode, you can use more established and mature tooling to figure out the root cause.  If the performance issue is limited to native mode only, you might not be able to use `perf`, so JFR is the only way to gather any information in this situation.  As JFR support for native expands, the ability to detect root causes of performance issues directly in production will improve."
msgstr "この状況では、JVM モードに切り替えることが最初に試す最善の方法です。JVM モードに切り替えた後もパフォーマンスの問題が続く場合は、より確立された成熟したツールを使用して根本原因を突き止めることができます。パフォーマンスの問題がネイティブモードのみに限定されている場合、`perf` を使用できない可能性があるため、この状況で情報を収集するには JFR が唯一の方法です。ネイティブの JFR サポートが拡大するにつれて、パフォーマンスの問題の根本原因を本番環境で直接検出する機能が向上します。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2177
#, no-wrap
msgid "What information helps most debug issues that happen either at build-time or run-time?"
msgstr "ビルド時または実行時に発生するほとんどの問題のデバッグに役立つ情報は何ですか?"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2181
#, fuzzy
msgid "To fix classpath, class initialization or forbidden API errors at build time it's best to use xref:native-reports[build time reports] to understand the closed world universe.  A complete picture of the universe, along with the relationships between the different classes and methods will help uncover and fix most of the issues."
msgstr "ビルド時にクラスパス、クラス初期化、禁則APIエラーを修正するには、 link:#native-reports[ビルド時レポートを] 使用して閉じた世界の宇宙を理解することが最善です。異なるクラスやメソッド間の関係とともに、世界の全体像を把握することで、問題のほとんどを発見し、解決することができます。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2187
#, fuzzy
msgid "To fix runtime native specific errors, it's best to have xref:debug-info[debug info builds] of the native executables around, so that `gdb` can be hooked up quickly to debug the issue.  If you also add local symbols to the debug info builds, you will obtain precise xref:profiling[profiling information] as well."
msgstr "実行時のネイティブ特有のエラーを修正するためには、ネイティブ実行ファイルの link:#debug-info[デバッグ情報ビルドを] 用意しておくと、 `gdb` 、問題のデバッグを迅速に行うことができます。デバッグ情報ビルドにローカルシンボルも追加すれば、正確な link:#profiling[プロファイリング] 情報も得られます。"

#. type: Title ===
#: upstream/_versions/main/guides/native-reference.adoc:2188
#, no-wrap
msgid "Build stalled for minutes, barely using any CPU"
msgstr "ビルドが数分間停止し、CPU をほとんど使用していない"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2191
msgid "It might so happen that the build gets stalled and even ends up with:"
msgstr "ビルドが停止し、次のような状態で終了する場合もあるかもしれません:"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2195
#, no-wrap
msgid "Image generator watchdog detected no activity.\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2198
msgid "One of the possible explanations could be a lack of entropy, e.g. on an entropy constrained VM, if such a source is needed as it is the case with Bouncycastle at build time."
msgstr "考えられる説明の 1 つは、エントロピーの欠如です。 例えば、エントロピーに制約のある VM で、Bouncycastle のビルド時のようにそのようなソースが必要な場合。"

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2200
msgid "One can check the available entropy on a Linux system with:"
msgstr "Linuxシステムでは、利用可能なエントロピーは次のようにして確認することができます:"

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2204
#, no-wrap
msgid "$ cat /proc/sys/kernel/random/entropy_avail\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2206
#, fuzzy
msgid "If the amount is not in hundreds, it could be a problem. A possible workaround is to compromise, acceptable for testing, and set:"
msgstr "金額が百単位でない場合、問題になる可能性があります。回避策として考えられるのは、妥協する、テストに許容される、設定する、です："

#. type: delimited block -
#: upstream/_versions/main/guides/native-reference.adoc:2209
#, no-wrap
msgid "export JAVA_OPTS=-Djava.security.egd=/dev/urandom\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/native-reference.adoc:2210
msgid "The proper solution is to increase the entropy available for the system. That is specific for each OS vendor and virtualization solution though."
msgstr "適切な解決策は、システムで利用可能なエントロピーを増やすことです。それはOSベンダーや仮想化ソリューションごとに固有な方法を必要とします。"

#~ msgid "Executing the native executable with `-XX:PrintFlags=` prints a list of flags that can be passed to native executables.  For various levels of GC logging one may use:"
#~ msgstr "ネイティブ実行可能ファイルに `-XX:PrintFlags=` を付けて実行すると、ネイティブ実行可能ファイルに渡すことのできるフラグのリストが表示されます。様々なレベルのGCロギングのために、次のように使用することができます。"

#~ msgid "Unfortunately generating heap dumps in hprof format, which can be opened by tools such as VisualVM or Eclipse MAT, can only be achieved with https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition].  Mandrel, which is based on the GraalVM Community Edition, does not have this capability."
#~ msgstr "残念ながら、VisualVMやEclipse MATなどのツールで開くことができるhprof形式のヒープダンプを生成することは、 link:https://www.graalvm.org/reference-manual/native-image/NativeImageHeapdump[GraalVM Enterprise Edition]でしか実現できません。GraalVM Community EditionをベースにしたMandrelには、この機能はありません。"

#~ msgid "Although Mandrel can generate debug symbols and these contain a fair amount of information about object layouts, including what is a pointer field vs a primitive field, this information cannot be used as is to detect memory leaks or find dominator objects.  This is because it has no idea what constitutes a root pointer nor how to recursively trace pointers from those roots."
#~ msgstr "Mandrelはデバッグシンボルを生成することができ、その中にはポインターフィールドとプリミティブフィールドの違いなど、オブジェクトのレイアウトに関するかなりの情報が含まれていますが、この情報をそのままメモリリークの検出や支配的なオブジェクトの発見に使用することはできません。これは、何がルートポインタを構成するのか、また、それらのルートから再帰的にポインタをトレースする方法がわからないからです。"

#~ msgid "Aside from system level packages, you'll need:"
#~ msgstr "システムレベルのパッケージの他に、以下が必要です:"

#~ msgid "Given a native executable, various Linux tools can be used to inspect it."
#~ msgstr "ネイティブ実行可能ファイルに対して、様々なLinuxツールを使って検査することができます。"

#~ msgid "Then, replace the `GreetingResource` code for the following:"
#~ msgstr "そして、 `GreetingResource` のコードを以下のように置き換えます。"

#~ msgid "Then, we execute:"
#~ msgstr "そして、次を実行します。"

#~ msgid "Run it through `perf`:"
#~ msgstr "`perf` を介して実行してください。"

#~ msgid "Now let’s try to debug the segmentation fault using `gdb`.  We will start our application in `gdb` and execute `run`, then we will try to access http://localhost:8080/hello."
#~ msgstr "それでは、 `gdb` を使ってセグメンテーション・フォルトをデバッグしてみましょう。 `gdb` でアプリケーションを起動し、 `run` を実行してから、 http://localhost:8080/hello  にアクセスしてみます。"

#~ msgid "Can I follow these examples if I’m running macOS or Windows?"
#~ msgstr "macOSやWindowsを使用していても、これらの例をなぞることはできますか？"

#~ msgid "The ideal environment for trying out these debugging examples is Linux.  All examples, except for profiling and debugging native crashes, can also be executed natively in either macOS or Windows.  If you are in either of these two platforms, you can run all the steps (including native crash debugging and profiling) within a Linux container.  The following `Dockerfile` shows what a Linux container requires in order to follow the examples:"
#~ msgstr "これらのデバッグ例を試すのに最適な環境はLinuxです。プロファイリングとネイティブ・クラッシュのデバッグを除くすべての例は、macOSまたはWindowsでもネイティブに実行できます。この2つのプラットフォームのいずれかを使用している場合、Linuxコンテナ内ですべての手順（ネイティブ・クラッシュのデバッグとプロファイリングを含む）を実行することができます。以下の `Dockerfile` は、例題を進めるにあたりLinuxコンテナに必要なものを示しています。"

#~ msgid "Once you’re inside the container, you can execute `strings`, `perf`, `objdump`…, etc commands on the generated binary.  Since the binary was created inside a Linux container, the container tools should have no issues with them, e.g."
#~ msgstr "コンテナの中に入ったら，生成されたバイナリに対して `strings`, `perf`, `objdump`... などのコマンドを実行することができます。バイナリはLinuxコンテナ内で作成されたものなので、コンテナツールでも問題ないはずです、例えば"

#~ msgid "Flame graphs should also be generated inside the container:"
#~ msgstr "フレームグラフもコンテナ内で生成されるはずです。"

#~ msgid "The resulting svg files can then be opened outside the container for visualization."
#~ msgstr "できあがったsvgファイルは、コンテナの外で開いて視覚化することができます。"

#~ msgid "Unfortunately though, running the `list` command doesn’t show us the corresponding source code."
#~ msgstr "しかし、残念ながら、 `list` コマンドを実行しても、対応するソースコードは表示されません。"
