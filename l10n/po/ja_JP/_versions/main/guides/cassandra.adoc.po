# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-22 08:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/cassandra.adoc:6
#, no-wrap
msgid "Using the Cassandra Client"
msgstr "Cassandra クライアントの使用"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:15
msgid "Apache Cassandra® is a free and open-source, distributed, wide column store, NoSQL database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure."
msgstr "Apache Cassandra®は、フリーでオープンソースの分散型ワイドカラムストアのNoSQLデータベース管理システムで、多くのコモディティサーバーにまたがる大量のデータを処理するように設計されており、単一障害点のない高可用性を提供します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:17
msgid "In this guide, we will see how you can get your REST services to use a Cassandra database."
msgstr "このガイドでは、RESTサービスでCassandraデータベースを使用する方法を見ていきます。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:20
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:27
msgid "A running link:https://cassandra.apache.org[Apache Cassandra], link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise] (DSE) or link:https://astra.datastax.com[DataStax Astra] database; or alternatively, a fresh Docker installation."
msgstr "稼働中の link:https://cassandra.apache.org[Apache Cassandra]、 link:https://www.datastax.fr/products/datastax-enterprise[DataStax Enterprise]（DSE）、または link:https://astra.datastax.com[DataStax Astra]データベース、あるいはきれいなDockerのインストール"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:28
#, no-wrap
msgid "Architecture"
msgstr "アーキテクチャ"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:34
msgid "This quickstart guide shows how to build a REST application using the link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkus extension], which allows you to connect to an Apache Cassandra, DataStax Enterprise (DSE) or DataStax Astra database, using the link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Java driver]."
msgstr "このクイックスタート・ガイドでは、 link:https://docs.datastax.com/en/developer/java-driver/latest[DataStax Javaドライバー]を使用してApache Cassandra、DataStax Enterprise（DSE）、またはDataStax Astraデータベースに接続できる link:https://github.com/datastax/cassandra-quarkus[Cassandra Quarkusエクステンション]を使用してRESTアプリケーションを構築する方法を説明します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:39
msgid "This guide will also use the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] – a powerful Java-to-CQL mapping framework that greatly simplifies your application's data access layer code by sparing you the hassle of writing your CQL queries by hand."
msgstr "このガイドでは、link:https://docs.datastax.com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] も使用します。これは、Java から CQL にマッピングする強力なフレームワークで、CQLクエリーを手動で記述する手間を省くことで、アプリケーションのデータアクセス階層コードを大幅に簡素化します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:43
msgid "The application built in this quickstart guide is quite simple: the user can add elements in a list using a form, and the items list is updated. All the information between the browser and the server is formatted as JSON, and the elements are stored in the Cassandra database."
msgstr "このガイドで構築されたアプリケーションは非常にシンプルです: ユーザーはフォームを使用してリストに要素を追加することができ、アイテムリストが更新されます。ブラウザーとサーバー間の情報はすべてJSONフォーマットで、各要素はCassandraデータベースに保存されます。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:44
#, no-wrap
msgid "Solution"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:48
msgid "We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:52
msgid "The solution is located in the link:https://github.com/datastax/cassandra-quarkus/tree/main/quickstart[quickstart directory] of the Cassandra Quarkus extension GitHub repository."
msgstr "ソリューションはCassandra QuarkusエクステンションGitHubレポジトリの link:https://github.com/datastax/cassandra-quarkus/tree/main/quickstart[quickstart directory] にあります。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:53
#, no-wrap
msgid "Creating a Blank Maven Project"
msgstr "空白の Maven プロジェクトの作成"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:57
msgid "First, create a new Maven project and copy the `pom.xml` file that is present in the `quickstart` directory."
msgstr "まず、新しいMavenプロジェクトを作成し、 `quickstart` ディレクトリーに存在する `pom.xml` ファイルをコピーします。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:59
msgid "The `pom.xml` is importing all the Quarkus extensions and dependencies you need."
msgstr "`pom.xml` 、必要なQuarkusのエクステンションや依存関係をすべてインポートしています。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:60
#, no-wrap
msgid "Creating the Data Model and Data Access Objects"
msgstr "データモデルとデータアクセスオブジェクトの作成"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:63
msgid "In this example, we will create an application to manage a list of fruits."
msgstr "この例では、果物のリストを管理するアプリケーションを作成します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:65
msgid "First, let's create our data model – represented by the `Fruit` class – as follows:"
msgstr "まず、以下のように `Fruit` クラスであらわされるデータもデールを作成してみましょう。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:71
#, no-wrap
msgid ""
"@Entity\n"
"@PropertyStrategy(mutable = false)\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:74
#, no-wrap
msgid ""
"    @PartitionKey\n"
"    private final String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:76
#, no-wrap
msgid "    private final String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:83
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"      this.name = name;\n"
"      this.description = description;\n"
"    }\n"
"  // getters, hashCode, equals, toString methods omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:88
msgid "As stated above, we are using the DataStax Object Mapper. In other words, we are not going to write our CQL queries manually; instead, we will annotate our data model with a few annotations, and the mapper will generate proper CQL queries underneath."
msgstr "前述のとおり、ここではDataStax Object Mapperを使用しています。つまり、CQLクエリーを手動で記述するのではなく、データ・モデルにいくつかのアノテーションを付け、裏側でマッパーが適切なCQLクエリーを生成するのです。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:93
msgid "This is why the `Fruit` class is annotated with `@Entity`: this annotation marks it as an _entity class_ that is mapped to a Cassandra table. Its instances are meant to be automatically persisted into, and retrieved from, the Cassandra database. Here, the table name will be inferred from the class name: `fruit`."
msgstr "これが、 `Fruit` クラスが `@Entity` でアノテーションされている理由です。このアノテーションは、Cassandraテーブルにマッピングされる _エンティティ・クラス_としてマークされます。このクラスのインスタンスは、Cassandraデータベースに自動的に永続化され、そこから取得されます。ここでは、テーブル名はクラス名から推測されます： `fruit` 。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:96
msgid "Also, the `name` field represents a Cassandra partition key, and so we are annotating it with `@PartitionKey` – another annotation from the Object Mapper library."
msgstr "また、`name` フィールドは Cassandra パーティションキーを表すため、ObjectMapper ライブラリーの別のアノテーションである `@PartitionKey` のアノテーションを付けています。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:99
msgid "Entity classes are normally required to have a default no-arg constructor, unless they are annotated with `@PropertyStrategy(mutable = false)`, which is the case here."
msgstr "エンティティークラスには通常、今回のように `@PropertyStrategy(mutable = false)` のアノテーションが付けられている場合を除き、デフォルトの引数なしのコンストラクタが必要です。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:102
msgid "The next step is to create a DAO (Data Access Object) interface that will manage instances of `Fruit` entities:"
msgstr "次のステップでは、 `Fruit` エンティティーのインスタンスを管理する DAO (データアクセスオブジェクト) インターフェイスを作成します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:109
#, no-wrap
msgid ""
"@Dao\n"
"public interface FruitDao {\n"
"  @Update\n"
"  void update(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:113
#, no-wrap
msgid ""
"  @Select\n"
"  PagingIterable<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:118
msgid "This interface exposes operations that will be used in our REST service. Again, the annotation `@Dao` comes from the DataStax Object Mapper, which will also automatically generate an implementation of this interface for you."
msgstr "このインターフェイスは、REST サービスで使用される操作を公開します。繰り返しになりますが、アノテーション `@Dao` は DataStaxObjectMapper から取得され、このインターフェイスの実装も自動的に生成されます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:122
msgid "Note also the special return type of the `findAll` method, link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`]: it's the base type of result sets returned by the driver."
msgstr "`findAll` メソッドの特別なリターンタイプにも注意してください link:https://docs.datastax.com/en/drivers/java/latest/com/datastax/oss/driver/api/core/PagingIterable.html[`PagingIterable`]: これはドライバーによって返される結果セットの基本タイプです。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:124
msgid "Finally, let's create a Mapper interface:"
msgstr "最後に、 Mapper インタフェースを作成しましょう:"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:132
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  @DaoFactory\n"
"  FruitDao fruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:137
msgid "The `@Mapper` annotation is yet another annotation recognized by the DataStax Object Mapper. A mapper is responsible for constructing DAO instances – in this case, out mapper is constructing an instance of our only DAO, `FruitDao`."
msgstr "`@Mapper` アノテーションは、DataStax Object Mapperが認識する別のアノテーションです。マッパーはDAOインスタンスの構築を担当します。この場合、outマッパーは唯一のDAOである `FruitDao` のインスタンスを構築します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:141
msgid "Think of the mapper interface as a factory for DAO beans. If you intend to construct and inject a specific DAO bean in your own code, then you first must add a `@DaoFactory` method for it in a `@Mapper` interface."
msgstr "マッパー・インターフェースをDAO Beanのファクトリーと考えてください。もし、あなた自身のコードで特定のDAO Beanを構築し注入するつもりなら、まず、 `@Mapper` インタフェースでそのための `@DaoFactory` メソッドを追加する必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:143
msgid "`@DaoFactory` method names are irrelevant."
msgstr "`@DaoFactory` メソッド名は関係ありません。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:145
msgid "`@DaoFactory` methods should return beans of the following types:"
msgstr "`@DaoFactory` メソッドは、以下の型のBeanを返す必要があります："

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:147
msgid "Any `@Dao`-annotated interface, e.g. `FruitDao`;"
msgstr "`@Dao` アノテーションの付与されたインタフェース。例: `FruitDao`;"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:148
#, fuzzy
msgid "A `CompletionStage` of any `@Dao`-annotated interface, e.g. `CompletionStage<FruitDao>`."
msgstr "`@Dao` -注釈付きインターフェースの `CompletionStage` 、例えば `CompletionStage<FruitDao>` 。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:149
msgid "A `Uni` of any `@Dao`-annotated interface, e.g. `Uni<FruitDao>`."
msgstr "`@Dao` アノテーションの付与されたインタフェースの `Uni` 。例： `Uni<FruitDao>` 。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:152
msgid "`Uni` is a type from the Mutiny library, which is the reactive programming library used by Quarkus. This will be explained in more detail in the \"Reactive Programming\" section below."
msgstr "`Uni` は、Quarkusが使用しているリアクティブプログラミングライブラリであるMutinyライブラリの型です。これについては、後述の「リアクティブプログラミング」のセクションで詳しく説明します。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:153
#, no-wrap
msgid "Generating the DAO and mapper implementations"
msgstr "DAOとマッパーの実装の生成"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:157
msgid "As you probably guessed already, we are not going to implement the interfaces above. Instead, the Object Mapper will generate such implementations for us."
msgstr "もうお分かりだと思いますが、私たちは上記のインターフェイスを実装しません。代わりに、Object Mapperがそのような実装を生成してくれるのです。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:159
msgid "The Object Mapper is composed of 2 pieces:"
msgstr "Object Mapperは、2つのパーツから構成されています:"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:162
msgid "A (compile-time) annotation processor that scans the classpath for classes annotated with `@Mapper`, `@Dao` or `@Entity`, and generates code and CQL queries for them; and"
msgstr "`@Mapper` 、 `@Dao` または `@Entity` でアノテーションされたクラスについてクラスパスをスキャンし、それらのためのコードとCQLクエリを生成する（コンパイル時）アノテーション・プロセッサー、および"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:163
msgid "A runtime module that contains the logic to execute the generated queries."
msgstr "生成されたクエリーを実行するためのロジックを含む実行時モジュール。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:165
msgid "Therefore, enabling the Object Mapper requires two steps:"
msgstr "そのため、Object Mapperを有効にするには、2つのステップが必要です:"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:168
msgid "Declare the `cassandra-quarkus-mapper-processor` annotation processor. With Maven, this is done by modifying the compiler plugin configuration in the project's `pom.xml` file as follows:"
msgstr "`cassandra-quarkus-mapper-processor` アノテーション・プロセッサーを宣言します。Mavenでは、プロジェクトの `pom.xml` ファイルのコンパイラ・プラグイン設定を以下のように変更することで実現出来ます:"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:186
#, no-wrap
msgid ""
"<plugin>\n"
"  <artifactId>maven-compiler-plugin</artifactId>\n"
"  <version>3.10.1</version>\n"
"  <configuration>\n"
"    <source>${java.version}</source>\n"
"    <target>${java.version}</target>\n"
"    <annotationProcessorPaths>\n"
"      <path>\n"
"        <groupId>com.datastax.oss.quarkus</groupId>\n"
"        <artifactId>cassandra-quarkus-mapper-processor</artifactId>\n"
"        <version>${cassandra-quarkus.version}</version>\n"
"      </path>\n"
"    </annotationProcessorPaths>\n"
"  </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:189
msgid "With Gradle, this is done by adding the following line to the `build.gradle` file:"
msgstr "Gradleでは、 `build.gradle` ファイルに以下の行を追加することで実現します："

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:193
#, no-wrap
msgid "annotationProcessor \"com.datastax.oss.quarkus:cassandra-quarkus-mapper-processor:${cassandra-quarkus.version}\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:201
msgid "Verify that you are enabling the right annotation processor! The Cassandra driver ships with its Object Mapper annotation processor, called `java-driver-mapper-processor`. But the Cassandra Quarkus extension also ships with its own annotation processor: `cassandra-quarkus-mapper-processor`, which has more capabilities than the driver's. This annotation processor is the only one suitable for use in a Quarkus application, so check that this is the one in use. Also, never use both annotation processors together."
msgstr "正しいアノテーション・プロセッサーを有効にしていることを確認してください！Cassandraドライバには、 `java-driver-mapper-processor` というObject Mapperアノテーション・プロセッサーが付属しています。しかし、Cassandra Quarkusエクステンションには、独自のアノテーション・プロセッサーも同梱されています： `cassandra-quarkus-mapper-processor `これは、ドライバーのものよりも多くの機能を備えています。このアノテーション・プロセッサーはQuarkusアプリケーションで使用するのに適した唯一のものなので、これが使用されているものであることを確認してください。また、両方のアノテーションプロセッサを一緒に使用しないでください。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:205
msgid "Declare the `java-driver-mapper-runtime` dependency in compile scope in the project's `pom.xml` file as follows:"
msgstr "プロジェクトの `pom.xml` ファイルのコンパイルスコープで `java-driver-mapper-runtime` の依存関係を以下のように宣言します："

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:212
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-mapper-runtime</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:215
msgid "Although this module is called \"runtime\", it must be declared in compile scope."
msgstr "このモジュールは \"ランタイム \"と呼ばれていますが、コンパイルスコープで宣言する必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:220
msgid "If your project is correctly set up, you should now be able to compile it without errors, and you should see the generated code in the `target/generated-sources/annotations` directory (if you are using Maven). It's not required to get familiar with the generated code though, as it is mostly internal machinery to interact with the database."
msgstr "プロジェクトが正しくセットアップされていれば、エラーなくコンパイルできるはずです。また、生成されたコードが `target/generated-sources/annotations` ディレクトリに存在する筈です（Maven を使用している場合）。生成されたコードは、ほとんどがデータベースとやりとりするための内部処理なので、慣れる必要はないでしょう。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:221
#, no-wrap
msgid "Creating a service & JSON REST endpoint"
msgstr "serviceとJSON RESTエンドポイントの作成"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:225
msgid "Now let's create a `FruitService` that will be the business layer of our application and store/load the fruits from the Cassandra database."
msgstr "ここで、アプリケーションのビジネス層となる `FruitService` を作成し、Cassandraデータベースから果物をセーブ/ロードします。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:230
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:232
#, no-wrap
msgid "  @Inject FruitDao dao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:236
#, no-wrap
msgid ""
"  public void save(Fruit fruit) {\n"
"    dao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:241
#, no-wrap
msgid ""
"  public List<Fruit> getAll() {\n"
"    return dao.findAll().all();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:245
msgid "Note how the service is being injected a `FruitDao` instance. This DAO instance is injected automatically, thanks to the generated implementations."
msgstr "サービスが `FruitDao` インスタンスを注入されていることに注意してください。このDAOインスタンスは、生成された実装のおかげで、自動的に注入されます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:248
msgid "The Cassandra Quarkus extension allows you to inject any of the following beans in your own components:"
msgstr "Cassandra Quarkus エクステンションを使用すると、次の Bean のいずれかを独自のコンポーネントに挿入できます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:250
msgid "All `@Mapper`-annotated interfaces in your project."
msgstr "プロジェクト内にある `@Mapper` アノテーション付きインターフェイスすべて。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:251
msgid "You can also inject a `CompletionStage` or `Uni` of any `@Mapper`-annotated interface."
msgstr "`@Mapper` アノテーション付きインタフェースの `CompletionStage` または `Uni` を注入することもできます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:252
msgid "Any bean returned by a `@DaoFactory` method (see above for possible bean types)."
msgstr "`@DaoFactory` メソッドから返されるBean（とりうるBean型は上記を参照）。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:257
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`] bean: this application-scoped, singleton bean is your main entry point to the Cassandra client; it is a specialized Cassandra driver session instance with a few methods tailored especially for Quarkus. Read its javadocs carefully!"
msgstr "link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession`] bean: このアプリケーションスコープのシングルトン Bean は、Cassandra クライアントへの主要なエントリーポイントです。これは、Quarkus 用に特別に調整されたメソッドを備えた特殊な Cassandra ドライバーセッションインスタンスです。javadoc をしっかり確認してください。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:258
#, fuzzy
msgid "You can also inject `CompletionStage<QuarkusCqlSession>` or `Uni<QuarkusCqlSession>`."
msgstr "`CompletionStage<QuarkusCqlSession>` または `Uni<QuarkusCqlSession>` を注入することもできる。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:261
msgid "In our example, both `FruitMapper` and `FruitDao` could be injected anywhere. We chose to inject `FruitDao` in `FruitService`."
msgstr "この例では、 `FruitMapper` と `FruitDao` の両方をどこにでも注入できますが、 `FruitService` に `FruitDao` を注入しています。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:263
msgid "The last missing piece is the REST API that will expose GET and POST methods:"
msgstr "最後に必要なのは、GETとPOSTのメソッドを公開するREST APIです。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:270
#, no-wrap
msgid ""
"@Path(\"/fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:272
#, no-wrap
msgid "  @Inject FruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:277
#, no-wrap
msgid ""
"  @GET\n"
"  public List<FruitDto> getAll() {\n"
"    return fruitService.getAll().stream().map(this::convertToDto).collect(Collectors.toList());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:282
#, no-wrap
msgid ""
"  @POST\n"
"  public void add(FruitDto fruit) {\n"
"    fruitService.save(convertFromDto(fruit));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:286
#: upstream/_versions/main/guides/cassandra.adoc:588
#, no-wrap
msgid ""
"  private FruitDto convertToDto(Fruit fruit) {\n"
"    return new FruitDto(fruit.getName(), fruit.getDescription());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:291
#: upstream/_versions/main/guides/cassandra.adoc:593
#, no-wrap
msgid ""
"  private Fruit convertFromDto(FruitDto fruitDto) {\n"
"    return new Fruit(fruitDto.getName(), fruitDto.getDescription());\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:294
msgid "Notice how `FruitResource` is being injected a `FruitService` instance automatically."
msgstr "`FruitResource` が `FruitService` インスタンスを自動的に注入していることに注目してください。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:300
msgid "It is generally not recommended using the same entity object between the REST API and the data access layer. These layers should indeed be decoupled and use distinct APIs in order to allow each API to evolve independently of the other. This is the reason why our REST API is using a different object: the `FruitDto` class – the word DTO stands for \"Data Transfer Object\". This DTO object will be automatically converted to and from JSON in HTTP messages:"
msgstr "通常、REST API とデータアクセス層の間で同じエンティティーオブジェクトを使用することはお勧めしません。各 API を互いに独立して進化させるには、これらのレイヤーを実際に分離し、個別の API を使用する必要があります。このように、異なるオブジェクトを ( `FruitDto` ) を使用する理由です。DTO という用語は、「Data Transfer Object」の略です。この DTO オブジェクトは、HTTP メッセージで JSON に対する変換を自動的に行います。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:304
#, no-wrap
msgid "public class FruitDto {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:307
#, no-wrap
msgid ""
"  private String name;\n"
"  private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:309
#, no-wrap
msgid "  public FruitDto() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:316
#, no-wrap
msgid ""
"  public FruitDto(String name, String description) {\n"
"    this.name = name;\n"
"    this.description = description;\n"
"  }\n"
"  // getters and setters omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:321
msgid "The translation to and from JSON is done automatically by the Quarkus RESTEasy Reactive extension, which is included in this guide's pom.xml file. If you want to add it manually to your application, add the below snippet to your application's ppm.xml file:"
msgstr "JSON との間の変換は、このガイドの pom.xml ファイルに含まれている Quarkus RESTEasy Reactive エクステンションによって自動的に行われます。アプリケーションに手動で追加する場合は、以下のスニペットをアプリケーションの ppm.xml ファイルに追加します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:332
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-reactive-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:336
msgid "DTO classes used by the JSON serialization layer are required to have a default no-arg constructor."
msgstr "JSONのシリアライゼーションレイヤーで使用されるDTOクラスは、デフォルトの引数なしのコンストラクタが必要です。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:340
msgid "The conversion from DTO to JSON is handled automatically for us, but we still must convert from `Fruit` to `FruitDto` and vice versa. This must be done manually, which is why we have two conversion methods declared in `FruitResource`: `convertToDto` and `convertFromDto`."
msgstr "DTO から JSON への変換は自動的に処理されますが、それでも `Fruit` から `FruitDto` に、またはその逆に変換する必要があります。これは手動で行う必要があるので、 `FruitResource` で 2 つの変換メソッド `convertToDto` と `convertFromDto` を宣言しています。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:344
msgid "In our example, `Fruit` and `FruitDto` are very similar, so you might wonder why not use `Fruit` everywhere. In real life cases though, it's not uncommon to see DTOs and entities having very different structures."
msgstr "この例では、 `Fruit` と `FruitDto` は非常に似ているので、すべてに `Fruit` を使用しないのはなぜかと思うかもしれませんが、実際には、DTO とエンティティーの構造が大きく異なることは珍しくありません。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:345
#, no-wrap
msgid "Connecting to the Cassandra Database"
msgstr "Cassandra データベースへの接続"

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:347
#, no-wrap
msgid "Connecting to Apache Cassandra or DataStax Enterprise (DSE)"
msgstr "ApacheCassandra または DataStaxEnterprise (DSE) への接続"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:351
msgid "The main properties to configure are: `contact-points`, to access the Cassandra database; `local-datacenter`, which is required by the driver; and – optionally – the keyspace to bind to."
msgstr "構成する主なプロパティーは次のとおりです。Cassandraデータベースにアクセスするための `contact-points` 、ドライバーによって必要とされる `local-datacenter` そしてオプションでバインド先のキースペースです。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:353
msgid "A sample configuration should look like this:"
msgstr "設定のサンプルは以下のようになります。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:359
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points={cassandra_ip}:9042\n"
"quarkus.cassandra.local-datacenter={dc_name}\n"
"quarkus.cassandra.keyspace={keyspace}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:363
msgid "In this example, we are using a single instance running on localhost, and the keyspace containing our data is `k1`:"
msgstr "この例では、localhost上で動作する単一のインスタンスを使用しており、データを含むキースペースは `k1` となっています。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:369
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points=127.0.0.1:9042\n"
"quarkus.cassandra.local-datacenter=datacenter1\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:373
msgid "If your cluster requires plain text authentication, you must also provide two more settings: `username` and `password`."
msgstr "クラスタがプレーンテキスト認証を必要とする場合は、さらに2つの設定を行う必要があります。 `username` と `password` です。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:378
#, no-wrap
msgid ""
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:380
#, no-wrap
msgid "Connecting to a DataStax Astra Cloud Database"
msgstr "DataStaxAstra クラウドデータベースへの接続"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:386
msgid "When connecting to link:https://astra.datastax.com[DataStax Astra], instead of providing a contact point and a datacenter, you should provide a so-called _secure connect bundle_, which should point to a valid path to an Astra secure connect bundle file. You can download your secure connect bundle from the Astra web console."
msgstr "link:https://astra.datastax.com[DataStax Astra] に接続する場合には、接続先とデータセンターを提供する代わりに、いわゆる _セキュア接続バンドル_ を提供して、Astra のセキュア接続バンドルファイルへの有効なパスを指定する必要があります。セキュア接続バンドルは、AstraWeb コンソールからダウンロードできます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:389
msgid "You will also need to provide a username and password, since authentication is always required on Astra clusters."
msgstr "Astra クラスターでは常に認証が必要なため、ユーザー名とパスワードも指定する必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:391
msgid "A sample configuration for DataStax Astra should look like this:"
msgstr "DataStax Astraのサンプル構成は次のようになります。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:398
#, no-wrap
msgid ""
"quarkus.cassandra.cloud.secure-connect-bundle=/path/to/secure-connect-bundle.zip\n"
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:400
#, no-wrap
msgid "Advanced Driver Configuration"
msgstr "高度なドライバー設定"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:407
msgid "You can configure other Java driver settings using `application.conf` or `application.json` files.  They need to be located in the classpath of your application. All settings will be passed automatically to the underlying driver configuration mechanism. Settings defined in `application.properties` with the `quarkus.cassandra` prefix will have priority over settings defined in `application.conf` or `application.json`."
msgstr "`application.conf` または `application.json` ファイルを使用して、他の Java ドライバーの設定を設定することができます。これらのファイルは、アプリケーションのクラスパスに配置する必要があります。すべての設定は、基礎となるドライバー設定メカニズムに自動的に渡されます。 `application.properties` で `quarkus.cassandra` のプレフィックスを付けて定義された設定は、 `application.conf` または `application.json` で定義された設定よりも優先されます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:411
msgid "To see the full list of settings, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference]."
msgstr "設定の全リストを見るには、 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[ドライバーの設定リファレンス] を参照してください。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:412
#, no-wrap
msgid "Running a Local Cassandra Database"
msgstr "ローカル Cassandra データベースの実行"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:416
msgid "By default, the Cassandra client is configured to access a local Cassandra database on port 9042 (the default Cassandra port)."
msgstr "デフォルトでは、Cassandra クライアントは、ポート 9042(デフォルトの Cassandra ポート)でローカル Cassandra データベースにアクセスするように構成されています。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:419
msgid "Make sure that the setting `quarkus.cassandra.local-datacenter` matches the datacenter of your Cassandra cluster."
msgstr "設定 `quarkus.cassandra.local-datacenter` が、Cassandraクラスターのデータセンターと一致していることを確認してください。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:422
msgid "If you don't know the name of your local datacenter, this value can be found by running the following CQL query: `SELECT data_center FROM system.local`."
msgstr "ローカルのデータセンターの名前がわからない場合は、以下の CQL クエリを実行することでこの値を見つけることができます : `SELECT data_center FROM system.local` "

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:425
msgid "If you want to use Docker to run a Cassandra database, you can use the following command to launch one in the background:"
msgstr "Docker を使用して Cassandra データベースを実行する場合は、次のコマンドを使用してバックグラウンドでデータベースを起動できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:429
#, no-wrap
msgid "docker run --name local-cassandra-instance -p 9042:9042 -d cassandra\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:433
msgid "Next you need to create the keyspace and table that will be used by your application. If you are using Docker, run the following commands:"
msgstr "次に、アプリケーションで使用するキースペースとテーブルを作成する必要があります。Dockerを使用している場合は、以下のコマンドを実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:438
#, no-wrap
msgid ""
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE KEYSPACE IF NOT EXISTS k1 WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}\"\n"
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE TABLE IF NOT EXISTS k1.fruit(name text PRIMARY KEY, description text)\"\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:441
msgid "You can also use the CQLSH utility to interactively interrogate your database:"
msgstr "CQLSH ユーティリティーを使用して、データベースに対話式に問い合わせることもできます。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:445
#, no-wrap
msgid "docker exec -it local-cassandra-instance cqlsh\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:447
#, no-wrap
msgid "Testing the REST API"
msgstr "REST API のテスト"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:450
msgid "In the project root directory:"
msgstr "プロジェクトのルートディレクトリー:"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:452
msgid "Run `mvn clean package` and then `java -jar ./target/cassandra-quarkus-quickstart-*-runner.jar` to start the application;"
msgstr "`mvn clean package` を実行してから、 `java -jar./target/cassandra-quarkus-quickstart-*-runner.jar` を実行してアプリケーションを起動します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:453
msgid "Or better yet, run the application in dev mode: `mvn clean quarkus:dev`."
msgstr "または、`mvn clean quarkus:dev` でアプリケーションを開発モードで実行します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:455
msgid "Now you can use curl commands to interact with the underlying REST API."
msgstr "これで、curl コマンドを使用して、基盤となる REST API と対話できます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:457
msgid "To create a fruit:"
msgstr "fruit を作成するには以下を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:464
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"apple\",\"description\":\"red and tasty\"}' \\\n"
"  http://localhost:8080/fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:467
msgid "To retrieve fruits:"
msgstr "Fruit を回収するには以下を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:471
#, no-wrap
msgid "curl -X GET http://localhost:8080/fruits\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:473
#, no-wrap
msgid "Creating a Frontend"
msgstr "フロントエンドの作成"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:476
msgid "Now let's add a simple web page to interact with our `FruitResource`."
msgstr "それでは、 `FruitResource` と対話するためのシンプルなウェブページを追加してみましょう。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:480
msgid "Quarkus automatically serves static resources located under the `META-INF/resources` directory. In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the contents from link:src/main/resources/META-INF/resources/fruits.html[this file] in it."
msgstr "Quarkus は、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、link:src/main/resources/META-INF/resources/fruits.html[このファイル] の内容を含めて `fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:482
msgid "You can now interact with your REST service:"
msgstr "これで、REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:484
#: upstream/_versions/main/guides/cassandra.adoc:639
msgid "If you haven't done yet, start your application with `mvn clean quarkus:dev`;"
msgstr "まだの場合は、 `mvn clean quarkus:dev` を使用してアプリケーションを起動します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:485
msgid "Point your browser to `http://localhost:8080/fruits.html`;"
msgstr "ブラウザーで `http://localhost:8080/fruits.html` を指定します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:486
#: upstream/_versions/main/guides/cassandra.adoc:641
msgid "Add new fruits to the list via the form."
msgstr "フォームを使って新しいフルーツをリストに追加します。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:488
#, no-wrap
msgid "Reactive Programming with the Cassandra Client"
msgstr "Cassandra クライアントを使用したリアクティブプログラミング"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:494
msgid "The link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession` interface] gives you access to a series of reactive methods that integrate seamlessly with Quarkus and its reactive framework, Mutiny."
msgstr "link:https://javadoc.io/doc/com.datastax.oss.quarkus/cassandra-quarkus-client/latest/com/datastax/oss/quarkus/runtime/api/session/QuarkusCqlSession.html[`QuarkusCqlSession` インタフェース] を使用すると、Quarkus およびそのリアクティブフレームワークである Mutiny をシームレスに統合する一連のリアクティブメソッドにアクセスできます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:496
msgid "If you are not familiar with Mutiny, please check xref:mutiny-primer.adoc[Mutiny - an intuitive reactive programming library]."
msgstr "Mutinyに慣れていない方は、 link:mutiny-primer.html[Mutiny - 直感的なリアクティブプログラミングライブラリ]をご覧ください。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:498
msgid "Let's rewrite our application using reactive programming with Mutiny."
msgstr "Mutiny でリアクティブプログラミングを使用してアプリケーションを書き換えてみましょう。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:500
msgid "First, let's declare another DAO interface that works in a reactive way:"
msgstr "まず、リアクティブな方法で機能する別の DAO インターフェイスを宣言しましょう:"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:505
#, no-wrap
msgid ""
"@Dao\n"
"public interface ReactiveFruitDao {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:508
#, no-wrap
msgid ""
"  @Update\n"
"  Uni<Void> updateAsync(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:512
#, no-wrap
msgid ""
"  @Select\n"
"  MutinyMappedReactiveResultSet<Fruit> findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:519
msgid "Note the usage of `MutinyMappedReactiveResultSet` - it is a specialized `Mutiny` type converted from the original `Publisher` returned by the driver, which also exposes a few extra methods, e.g. to obtain the query execution info. If you don't need anything in that interface, you can also simply declare your method to return `Multi`: `Multi<Fruit> findAll()`,"
msgstr "`MutinyMappedReactiveResultSet` の使い方に注意してください。これは、ドライバが返すオリジナルの `Publisher` から変換された特殊な `Mutiny` 型で、クエリの実行情報を取得するなど、いくつかの追加メソッドも公開されています。このインターフェイスで何も必要としない場合は、単純に `Multi` を返すようにメソッドを宣言することもできます: `Multi<Fruit> findAll()` 、"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:522
msgid "Similarly, the method `updateAsync` returns a `Uni` - it is automatically converted from the original result set returned by the driver."
msgstr "同様に、メソッド `updateAsync` は `Uni` を返します。これは、ドライバーが返す元の結果セットから自動的に変換されます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:530
msgid "The Cassandra driver uses the Reactive Streams `Publisher` API for reactive calls. The Quarkus framework however uses Mutiny. Because of that, the `CqlQuarkusSession` interface transparently converts the `Publisher` instances returned by the driver into the reactive type `Multi`.  `CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` – in this case, the publisher is expected to emit at most one row, then complete. This is suitable for write queries (they return no rows), or for read queries guaranteed to return one row at most (count queries, for example)."
msgstr "Cassandraドライバは、リアクティブコールにReactive Streamsの `Publisher` APIを使用しています。しかし、QuarkusフレームワークではMutinyを使用しています。そのため、 `CqlQuarkusSession` インターフェイスは、ドライバが返す `Publisher` インスタンスを透過的にリアクティブ型の `Multi` に変換します。 `CqlQuarkusSession` は `Publisher` を `Uni` に変換することもできます - この場合、パブリッシャーは最大で1行を出力し、その後完了することが期待されます。これは書き込みクエリ(行を返さない)や、最大で1行を返すことが 保証されている読み込みクエリ(例えばカウントクエリ)に適しています。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:532
msgid "Next, we need to adapt the `FruitMapper` to construct a `ReactiveFruitDao` instance:"
msgstr "次に、 `FruitMapper` を適応させて、 `ReactiveFruitDao` インスタンスを構築する必要があります。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:538
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  // the existing method omitted\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:542
#, no-wrap
msgid ""
"  @DaoFactory\n"
"  ReactiveFruitDao reactiveFruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:546
msgid "Now, we can create a `ReactiveFruitService` that leverages our reactive DAO:"
msgstr "これで、リアクティブ DAO を活用する `ReactiveFruitService` を作成できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:551
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveFruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:553
#, no-wrap
msgid "  @Inject ReactiveFruitDao fruitDao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:557
#, no-wrap
msgid ""
"  public Uni<Void> add(Fruit fruit) {\n"
"    return fruitDao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:562
#, no-wrap
msgid ""
"  public Multi<Fruit> getAll() {\n"
"    return fruitDao.findAll();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:565
msgid "Finally, we can create a `ReactiveFruitResource`:"
msgstr "最後に、 `ReactiveFruitResource` を作成できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:572
#, no-wrap
msgid ""
"@Path(\"/reactive-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class ReactiveFruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:574
#, no-wrap
msgid "  @Inject ReactiveFruitService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:579
#, no-wrap
msgid ""
"  @GET\n"
"  public Multi<FruitDto> getAll() {\n"
"    return service.getAll().map(this::convertToDto);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:584
#, no-wrap
msgid ""
"  @POST\n"
"  public Uni<Void> add(FruitDto fruitDto) {\n"
"    return service.add(convertFromDto(fruitDto));\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:598
msgid "The above resource is exposing a new endpoint, `reactive-fruits`. Its capabilities are identical to the ones that we created before with `FruitResource`, but everything is handled in a reactive fashion, without any blocking operation."
msgstr "上記のリソースは、新しいエンドポイント `reactive-fruits` を公開しています。その機能は、以前に `FruitResource` で作成したものと同じですが、すべてがブロッキング操作なしでリアクティブな方法で処理されます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:602
msgid "The `getAll()` method above returns `Multi`, and the `add()` method returns `Uni`. These types are the same Mutiny types that we met before; they are automatically recognized by the Quarkus reactive REST API, so we don't need to convert them into JSON ourselves."
msgstr "上記の `getAll ()` メソッドは `Multi` を返し、 `add ()` メソッドは `Uni` を返します。これらのタイプは、以前使用した Mutiny タイプと同じで、Quarkus リアクティブ REST API により自動的に認識されるので、JSON に変換する必要はありません。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:604
msgid "RESTEasy Reactive natively supports the Mutiny reactive types e.g. `Uni` and `Multi`."
msgstr "RESTEasy Reactive は、 `Uni` や `Multi` などの Mutiny リアクティブタイプをネイティブにサポートします。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:607
msgid "This dependency is already included in this guide's pom.xml, but if you are starting a new project from scratch, make sure to include it."
msgstr "この依存関係は、本書の pom.xml にすでに含まれていますが、新しいプロジェクトを最初から開始する場合は必ず追加するようにしてください。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:608
#, no-wrap
msgid "Testing the Reactive REST API"
msgstr "リアクティブ REST API のテスト"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:612
msgid "Run the application in dev mode as explained above, then you can use curl commands to interact with the underlying REST API."
msgstr "上で説明したようにアプリケーションを開発モードで実行すると、curl コマンドを使用して基盤となる REST API と対話できます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:614
msgid "To create a fruit using the reactive REST endpoint:"
msgstr "リアクティブ REST エンドポイントを使用して fruit を作成するには以下を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:621
#, no-wrap
msgid ""
"curl --header \"Content-Type: application/json\" \\\n"
"  --request POST \\\n"
"  --data '{\"name\":\"banana\",\"description\":\"yellow and sweet\"}' \\\n"
"  http://localhost:8080/reactive-fruits\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:624
msgid "To retrieve fruits with the reactive REST endpoint:"
msgstr "リアクティブ REST エンドポイントを使用して fruit を取得するには以下を実行します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:628
#, no-wrap
msgid "curl -X GET http://localhost:8080/reactive-fruits\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:630
#, no-wrap
msgid "Creating a Reactive Frontend"
msgstr "リアクティブなフロントエンドの作成"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:635
msgid "Now let's add a simple web page to interact with our `ReactiveFruitResource`. In the `src/main/resources/META-INF/resources` directory, add a `reactive-fruits.html` file with the contents from link:src/main/resources/META-INF/resources/reactive-fruits.html[this file] in it."
msgstr "次に、 `ReactiveFruitResource` と対話するための簡単な Web ページを追加しましょう。 `src/main/resources/META-INF/resources` ディレクトリーに、 link:src/main/resources/META-INF/resources/reactive-fruits.html[このファイル] の内容を含めて `reactive-fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:637
msgid "You can now interact with your reactive REST service:"
msgstr "これで、リアクティブな REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:640
msgid "Point your browser to `http://localhost:8080/reactive-fruits.html`;"
msgstr "ブラウザーで `http://localhost:8080/reactive-fruits.html` を指定します。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:642
#, no-wrap
msgid "Health Checks"
msgstr "ヘルスチェック"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:648
msgid "If you are using the Quarkus SmallRye Health extension, then the Cassandra client will automatically add a readiness health check to validate the connection to the Cassandra cluster. This extension is already included in this guide's pom.xml, but if you need to include it manually in your application, add the following:"
msgstr "Quarkus SmallRye Health エクステンションを使用している場合には、Cassandra クライアントは、Cassandra クラスターへの接続を検証するための準備ヘルスチェックを自動的に追加します。このエクステンションは、本書の pom.xml にすでに含まれていますが、アプリケーションに手動で含める必要がある場合は、次を追加してください。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:655
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-health</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:659
msgid "When health checks are available, you can access the `/health/ready` endpoint of your application and have information about the connection validation status."
msgstr "ヘルスチェックが利用可能になると、アプリケーションの `/health/ready` エンドポイントにアクセスして、接続検証ステータスに関する情報を取得できます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:662
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to http://localhost:8080/health/ready you should see an output similar to the following one:"
msgstr "`mvn clean quarkus:dev` を使用して開発モードで実行している場合には、ブラウザーで http://localhost:8080/health/ready を指定すると、次のような出力が表示されます。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:681
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"UP\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"DataStax Apache Cassandra Driver health check\",\n"
"            \"status\": \"UP\",\n"
"            \"data\": {\n"
"                \"cqlVersion\": \"3.4.4\",\n"
"                \"releaseVersion\": \"3.11.7\",\n"
"                \"clusterName\": \"Test Cluster\",\n"
"                \"datacenter\": \"datacenter1\",\n"
"                \"numberOfNodes\": 1\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:686
msgid "If you need health checks globally enabled in your application, but don't want to activate Cassandra health checks, you can disable Cassandra health checks by setting the `quarkus.cassandra.health.enabled` property to `false` in your `application.properties`."
msgstr "アプリケーションでヘルスチェックをグローバルに有効にする必要があるが、Cassandra ヘルスチェックは有効にしない場合は、 `application.properties` で `quarkus.cassandra.health.enabled` プロパティーを `false` に設定して Cassandra ヘルスチェックを無効にできます。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:687
#, no-wrap
msgid "Metrics"
msgstr "メトリクス"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:691
msgid "The Cassandra Quarkus client can provide metrics about the Cassandra session and about individual Cassandra nodes. It supports both Micrometer and MicroProfile."
msgstr "Cassandra Quarkus クライアントは、Cassandra セッションおよび個々の Cassandra ノードに関するメトリクスを提供できます。このクライアントは、Micrometer と MicroProfile の両方をサポートします。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:694
msgid "The first step to enable metrics is to add a few additional dependencies depending on the metrics framework you plan to use."
msgstr "メトリクスの有効化の最初のステップは、使用する予定のメトリクスフレームワークに応じて、いくつかの依存関係を追加することです。"

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:695
#, no-wrap
msgid "Enabling Metrics with Micrometer"
msgstr "Micrometer でのメトリクスの有効化"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:698
msgid "Micrometer is the recommended metrics framework in Quarkus applications."
msgstr "Micrometer は、Quarkus アプリケーションで推奨されるメトリクスフレームワークです。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:700
msgid "To enable Micrometer metrics in your application, you need to add the following to your pom.xml."
msgstr "アプリケーションで Micrometer メトリクスを有効にするには、pom.xml に以下を追加する必要があります。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:711
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-micrometer</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-micrometer-registry-prometheus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:714
msgid "This guide uses Micrometer, so the above dependencies are already included in this guide's pom.xml."
msgstr "このガイドでは Micrometer を使用しているため、上記の依存関係はこのガイドの pom.xml にすでに含まれています。"

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:715
#, no-wrap
msgid "Enabling Metrics with MicroProfile Metrics"
msgstr "MicroProfile メトリクスを使用したメトリクスの有効化"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:718
msgid "Remove any dependency to Micrometer from your pom.xml, then add the following ones instead:"
msgstr "pom.xml から Micrometer への依存関係を削除し、代わりに次の依存関係を追加します。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:729
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>com.datastax.oss</groupId>\n"
"  <artifactId>java-driver-metrics-microprofile</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-smallrye-metrics</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/cassandra.adoc:731
#, no-wrap
msgid "Enabling Cassandra Metrics"
msgstr "Cassandra メトリクスの有効化"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:736
msgid "Even when metrics are enabled in your application, the Cassandra client will not report any metrics, unless you opt in for this feature. So your next step is to enable Cassandra metrics in your `application.properties` file."
msgstr "アプリケーションでメトリクスが有効になっている場合でも、この機能をオプトインしない限り、Cassandra クライアントはメトリクスを報告しません。そのため、次のステップとして、 `application.properties` ファイルで Cassandra メトリクスを有効化してください。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:740
#, no-wrap
msgid "quarkus.cassandra.metrics.enabled=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:743
msgid "That's it!"
msgstr "以上です!"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:747
msgid "The final (and optional) step is to customize which specific Cassandra metrics you would like the Cassandra client to track. Several metrics can be tracked; if you skip this step, a default set of useful metrics will be automatically tracked."
msgstr "最後の手順 (任意) で、Cassandra クライアントに追跡させる特定の Cassandra メトリクスをカスタマイズします。複数のメトリクスを追跡できますが、この手順をスキップすると、有用なメトリクスのデフォルトセットが自動的に追跡されます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:753
msgid "For the full list of available metric names, please refer to the link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[driver settings reference] page; search for the `advanced.metrics` section.  Also, Cassandra driver metrics are covered in detail in the https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[driver manual]."
msgstr "使用可能なメトリクス名の完全なリストについては、 link:https://docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/reference/[Driver Setting Reference] ページを参照してください。このページで `advanced.metrics` セクションを検索してください。また、Cassandra ドライバーのメトリクスについては、 https://docs.datastax.com/en/developer/java-driver/latest/manual/core/metrics/[ドライバーマニュアル] で詳しく説明されています。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:755
msgid "If you do wish to customize which metrics to track, you should use the following properties:"
msgstr "追跡するメトリクスをカスタマイズする場合は、次のプロパティーを使用する必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:758
msgid "`quarkus.cassandra.metrics.session.enabled` should contain the session-level metrics to enable (metrics that are global to the session)."
msgstr "`quarkus.cassandra.metrics.session.enabled` には、有効にするセッションレベルのメトリクス (セッションに対してグローバルなメトリクス) が含まれている必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:760
msgid "`quarkus.cassandra.metrics.node.enabled` should contain the node-level metrics to enable (metrics for which each node contacted by the Cassandra client gets its own metric value)."
msgstr "`quarkus.cassandra.metrics.node.enabled` には、有効にするノードレベルのメトリクス (Cassandra クライアントが接続する各ノードが独自のメトリクス値を取得するメトリクス) が含まれている必要があります 。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:762
msgid "Both properties accept a comma-separated list of valid metric names."
msgstr "どちらのプロパティーにも、有効なメトリクス名をコンマ区切りにした一覧を使用できます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:764
msgid "For example, let's assume that you wish to enable the following three Cassandra metrics:"
msgstr "たとえば、次の 3 つの Cassandra メトリクスを有効にする場合には、以下のとおりです。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:766
msgid "Session-level: `session.connected-nodes` and `session.bytes-sent`;"
msgstr "セッションレベル: `session.connected-nodes` および `session.bytes-sent`;"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:767
msgid "Node-level: `node.pool.open-connections`."
msgstr "ノードレベル: `node.pool.open-connections`。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:769
msgid "Then you should add the following settings to your `application.properties`:"
msgstr "次に、`application.properties` に以下の設定を追加する必要があります。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:775
#, no-wrap
msgid ""
"quarkus.cassandra.metrics.enabled=true\n"
"quarkus.cassandra.metrics.session.enabled=connected-nodes,bytes-sent\n"
"quarkus.cassandra.metrics.node.enabled=pool.open-connections\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:779
msgid "This guide's `application.properties` file has already many metrics enabled; you can use its metrics list as a good starting point for exposing useful Cassandra metrics in your application."
msgstr "本書の `application.properties` ファイルでは、すでに多くのメトリクスが有効になっています。このメトリクスリストを開始点として使用して、アプリケーションの有用な Cassandra メトリクスを公開すると適切です。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:782
msgid "When metrics are properly enabled, metric reports for all enabled metrics are available at the `/metrics` REST endpoint of your application."
msgstr "メトリクスが適切に有効になっている場合には、有効になっているすべてのメトリクスのメトリクスレポートは、アプリケーションの `/metrics` REST エンドポイントで利用できます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:786
msgid "Running in dev mode with `mvn clean quarkus:dev`, if you point your browser to `http://localhost:8080/metrics` you should see a list of metrics; search for metrics whose names contain `cassandra`."
msgstr "`mvn clean quarkus:dev` を使用して開発モードで実行している場合には、ブラウザーで `http://localhost:8080/metrics` を指定するとメトリクスのリストが表示されます。名前に `cassandra` が含まれているメトリクスを検索します。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:790
msgid "For Cassandra metrics to show up, the Cassandra client needs to be initialized and connected; if you are using lazy initialization (see below), you won't see any Cassandra metrics until your application actually connects and hits the database for the first time."
msgstr "Cassandra メトリクスを表示するには、Cassandra クライアントを初期化して接続する必要があります。遅延初期化 (以下を参照) を使用している場合には、アプリケーションが、実際に接続してデータベースに初めてアクセスするまで、Cassandra メトリクスは表示されません。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:791
#, no-wrap
msgid "Running in native mode"
msgstr "ネイティブモードでの実行"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:794
#, fuzzy
msgid "If you installed GraalVM, you can xref:building-native-image.adoc[build a native image] using:"
msgstr "GraalVMをインストールした場合は、以下の方法で xref:building-native-image.adoc[ネイティブ・イメージを構築] できる："

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:798
#, no-wrap
msgid "mvn clean package -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:802
msgid "Beware that native compilation can take a significant amount of time! Once the compilation is done, you can run the native executable as follows:"
msgstr "ネイティブコンパイルにはかなりの時間がかかる可能性があることに注意してください。コンパイルが完了したら、次のようにネイティブ実行可能ファイルを実行できます。"

#. type: delimited block -
#: upstream/_versions/main/guides/cassandra.adoc:806
#, no-wrap
msgid "./target/cassandra-quarkus-quickstart-*-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:809
msgid "You can then point your browser to `http://localhost:8080/fruits.html` and use your application."
msgstr "その後、ブラウザで `http://localhost:8080/fruits.html` を開いてアプリケーションを使用します。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:810
#, no-wrap
msgid "Choosing between eager and lazy initialization"
msgstr "Eager初期化とLazy初期化の選択"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:813
msgid "As explained above, this extension allows you to inject many types of beans:"
msgstr "上記のように、このエクステンションを使用すると、多くの種類の Bean を注入できます:"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:815
msgid "A simple bean like `QuarkusCqlSession` or `FruitDao`;"
msgstr "`QuarkusCqlSession` や `FruitDao` のようなシンプルなBean；"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:817
msgid "The asynchronous version of that bean, for example `CompletionStage<QuarkusCqlSession>` or `CompletionStage<FruitDao>;"
msgstr "そのBeanの非同期バージョン、例えば `CompletionStage<QuarkusCqlSession>` や `CompletionStage<FruitDao>> など；"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:818
msgid "The reactive version of that bean, for example `Uni<QuarkusCqlSession>` or `Uni<FruitDao>`."
msgstr "そのBeanのリアクティブバージョン、例えば `Uni<QuarkusCqlSession>` や `Uni<FruitDao>` など。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:823
msgid "The most straightforward approach is obviously to inject the bean directly. This should work just fine for most applications. However, the `QuarkusCqlSession` bean, and all DAO beans that depend on it, might take some time to initialize before they can be used for the first time, and this process is blocking."
msgstr "最も簡単な方法は、明らかにBeanを直接注入することです。これはほとんどのアプリケーションで問題なく動作するはずです。しかし、 `QuarkusCqlSession` Beanとそれに依存するすべてのDAO Beanは、初めて使用できるようになる前に初期化するのに時間がかかるかもしれませんし、このプロセスはブロッキング操作です。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:830
msgid "Fortunately, it is possible to control when the initialization should happen: the `quarkus.cassandra.init.eager-init` parameter determines if the `QuarkusCqlSession` bean should be initialized on its first access (lazy) or when the application is starting (eager). The default value of this parameter is `false`, meaning the init process is lazy: the `QuarkusCqlSession` bean will be initialized lazily on its first access – for example, when there is a first REST request that needs to interact with the Cassandra database."
msgstr "幸いにも、初期化のタイミングを制御できます。 `quarkus.cassandra.init.eager-init` パラメーターは、 `QuarkusCqlSession` bean を最初にアクセスしたタイミング (lazy) または、アプリケーションが起動するタイミング (eager) のいずれで初期化するべきかを判断します。このパラメーターのデフォルト値は、 `false` で、init プロセスが遅延設定されていることを意味しています。たとえば、Cassandra データベースと対話する必要がある最初の REST 要求がある場合に、 `QuarkusCqlSession` bean は、遅延して、最初にアクセスしたタイミングで初期化されます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:837
#, fuzzy
msgid "Using lazy initialization speeds up your application startup time, and avoids startup failures if the Cassandra database is not available. However, it could also prove dangerous if your code is fully non-blocking, for example if it uses xref:reactive-routes.adoc[reactive routes].  Indeed, the lazy initialization could accidentally happen on a thread that is not allowed to block, such as a Vert.x event loop thread. Therefore, setting `quarkus.cassandra.init.eager-init` to `false` and injecting `QuarkusCqlSession` should be avoided in these contexts."
msgstr "遅延初期化を使用すると、アプリケーションの起動時間が短縮され、Cassandraデータベースが利用できない場合の起動失敗を回避できます。ただし、コードが完全にノンブロッキングである場合、たとえば xref:reactive-routes.adoc[リアクティブ・ルートを] 使用している場合などは、危険であることがわかります。実際、遅延初期化は、Vert.xイベント・ループ・スレッドなど、ブロックが許可されていないスレッドで誤って発生する可能性があります。したがって、 `quarkus.cassandra.init.eager-init` を `false` に設定し、 `QuarkusCqlSession` を注入することは、このようなコンテキストでは避けるべきです。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:843
msgid "If you want to use Vert.x (or any other non-blocking framework) and keep the lazy initialization behavior, you should instead inject only a `CompletionStage` or a `Uni` of the desired bean. When injecting these beans, the initialization process will be triggered lazily, but it will happen in the background, in a non-blocking way, leveraging the Vert.x event loop. This way you don't risk blocking the Vert.x thread."
msgstr "Vert.x（または他のノンブロッキングフレームワーク）を使用し、遅延初期化動作を維持したい場合、代わりに目的のBeanの `CompletionStage` または `Uni` のみを注入する必要があります。これらのBeanを注入すると、初期化プロセスは遅延的にトリガーされますが、Vert.xのイベントループを活用したノンブロッキングの方法でバックグラウンドで発生します。こうすることで、Vert.xのスレッドをブロックするリスクを回避することができます。"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:848
msgid "Alternatively, you can set `quarkus.cassandra.init.eager-init` to true: in this case the session bean and all DAO beans will be initialized eagerly during application startup, on the Quarkus main thread. This would eliminate any risk of blocking a Vert.x thread, at the cost of making your startup time (much) longer."
msgstr "`quarkus.cassandra.init.eager-init` この場合、セッションBeanとすべてのDAO Beanは、アプリケーションの起動時にQuarkusのメインスレッドで、早期初期化されます。これにより、Vert.xスレッドをブロックする危険性がなくなりますが、その分、起動時間が長くなります。"

#. type: Title ==
#: upstream/_versions/main/guides/cassandra.adoc:849
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: upstream/_versions/main/guides/cassandra.adoc:853
msgid "Accessing a Cassandra database from a client application is easy with Quarkus and the Cassandra extension, which provides configuration and native support for the DataStax Java driver for Apache Cassandra."
msgstr "クライアント・アプリケーションからのCassandraデータベースへのアクセスは、QuarkusとCassandraエクステンションで簡単に行えます。"

#~ msgid "A `CompletationStage` of any `@Dao`-annotated interface, e.g. `CompletionStage<FruitDao>`."
#~ msgstr "`@Dao` アノテーションの付与されたインタフェースの `CompletationStage` 。例： `CompletionStage<FruitDao>` 。"

#~ msgid "You can also inject `CompletationStage<QuarkusCqlSession>` or `Uni<QuarkusCqlSession>`."
#~ msgstr "`CompletationStage<QuarkusCqlSession>` や `Uni<QuarkusCqlSession>` を注入することも可能です。"

#~ msgid "If you installed GraalVM, you can link:https://quarkus.io/guides/building-native-image[build a native image] using:"
#~ msgstr "GraalVM をインストールした場合は、以下を使用して、 link:https://quarkus.io/guides/building-native-image[ネイティブイメージのビルド] が可能です。"

#~ msgid "Using lazy initialization speeds up your application startup time, and avoids startup failures if the Cassandra database is not available. However, it could also prove dangerous if your code is fully non-blocking, for example if it uses https://quarkus.io/guides/reactive-routes[reactive routes]. Indeed, the lazy initialization could accidentally happen on a thread that is not allowed to block, such as a Vert.x event loop thread. Therefore, setting `quarkus.cassandra.init.eager-init` to `false` and injecting `QuarkusCqlSession` should be avoided in these contexts."
#~ msgstr "遅延初期化を使用すると、アプリケーションの起動時間が短縮され、Cassandraデータベースが利用できない場合の起動の失敗を回避することができます。しかし、コードが完全にノンブロッキングである場合、例えば link:https://quarkus.io/guides/reactive-routes[リアクティブ・ルート] を使用する場合などには、危険である可能性もあります。実際、遅延初期化は、Vert.xイベント・ループのスレッドなど、ブロックが許可されていないスレッドで誤って発生する可能性があります。したがって、 `quarkus.cassandra.init.eager-init` を `false` に設定し、 `QuarkusCqlSession` を注入することは、このようなコンテキストでは避けるべきです。"

#~ msgid "All `@Dao`-annotated interfaces in your project, as long as they are produced by a corresponding `@DaoFactory`-annotated method declared in a mapper interface from your project."
#~ msgstr "プロジェクト内のすべての `@Dao` アノテーション付きインターフェイス。ただし、このインターフェイスは、プロジェクトのマッパーインターフェイスで宣言されており、対応する `@DaoFactory` アノテーション付きメソッドによって生成されている場合に限ります。"

#~ msgid "To complete this quickstart guide, you need:"
#~ msgstr "このガイドを完成させるには、以下が必要です:"

#~ msgid "an IDE;"
#~ msgstr "IDE"

#~ msgid "link:https://www.graalvm.org/[GraalVM] installed with the `GRAALVM_HOME` environment variable configured appropriately, if you want to link:https://quarkus.io/guides/building-native-image[use the native mode];"
#~ msgstr "ネイティブモードを使用したい場合は、 `GRAALVM_HOME` が適切に設定された GraalVM がインストールされていること"

#~ msgid "Apache Maven {maven-version}"
#~ msgstr "Apache Maven {maven-version}"
