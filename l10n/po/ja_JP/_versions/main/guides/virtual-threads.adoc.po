# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-22 08:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/virtual-threads.adoc:7
#, fuzzy, no-wrap
msgid "Virtual Thread support reference"
msgstr "仮想スレッドサポートのリファレンス"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:21
#, fuzzy
msgid "This guide explains how to benefit from Java 21+ virtual threads in Quarkus application."
msgstr "このガイドでは、QuarkusアプリケーションでJava 21+の仮想スレッドを使用する方法について説明します。"

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:22
#, fuzzy, no-wrap
msgid "What are virtual threads?"
msgstr "仮想スレッドとは？"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:24
#, no-wrap
msgid "Terminology"
msgstr "用語解説"

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:25
#, no-wrap
msgid "OS thread"
msgstr "OSスレッド"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:27
#, fuzzy
msgid "A \"thread-like\" data structure managed by the Operating System."
msgstr "オペレーティング・システムによって管理される「スレッドのような」データ構造。"

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:28
#, no-wrap
msgid "Platform thread"
msgstr "プラットフォームスレッド"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:31
#, fuzzy
msgid "Until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, a wrapper around an OS thread.  Creating a platform thread creates an OS thread, and blocking a platform thread blocks an OS thread."
msgstr "Java 19までは、 link:{thread}[Thread] クラスのインスタンスはすべて、OSスレッドのラッパーであるプラットフォーム・スレッドだった。プラットフォーム・スレッドを作成するとOSスレッドが作成され、プラットフォーム・スレッドをブロックするとOSスレッドがブロックされる。"

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:32
#, no-wrap
msgid "Virtual thread"
msgstr "仮想スレッド"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:35
msgid "Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.  Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr "軽量で、JVMが管理するスレッド。 link:{thread}[Thread] クラスを拡張していますが、1つの特定のOSスレッドに縛られることはありません。したがって、仮想スレッドのスケジューリングはJVMの責任です。"

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:36
#, no-wrap
msgid "Carrier thread"
msgstr "キャリアスレッド"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:39
#, fuzzy
msgid "A platform thread used to execute a virtual thread is called a **carrier** thread.  It isn't a class distinct from link:{Thread}[Thread] or `VirtualThread` but rather a functional denomination."
msgstr "仮想スレッドを実行するために使用されるプラットフォーム・スレッドは、 *キャリア・スレッドと* 呼ばれる。 link:{Thread}[スレッドや] `VirtualThread` とは異なるクラスではなく、機能的な呼称である。"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:40
#, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr "仮想スレッドとプラットフォームスレッドの違い"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:42
#, fuzzy
msgid "We will give a brief overview of the topic here; please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr "ここではその概要を説明する。詳細は link:{vthreadjep}[JEP425を] 参照されたい。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:45
#, fuzzy
msgid "Virtual threads are a feature available since Java 19 (Java 21 is the first LTS version including virtual threads), aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr "仮想スレッドは、Java 19から利用可能な機能であり（Java 21は、仮想スレッドを含む最初のLTSバージョンである）、I/Oバウンドのワークロードに対して、プラットフォームスレッドの安価な代替を提供することを目的としている。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:49
#, fuzzy
msgid "Until now, platform threads were the concurrency unit of the JVM.  They are a wrapper over OS structures.  Creating a Java platform thread creates a \"thread-like\" structure in your operating system."
msgstr "これまでは、プラットフォーム・スレッドがJVMの同時実行ユニットだった。スレッドは、OS構造体のラッパーである。Javaプラットフォーム・スレッドを作成すると、オペレーティング・システムに「スレッドのような」構造が作成される。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:52
#, fuzzy
msgid "Virtual threads, on the other hand, are managed by the JVM. To be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).  As such, they have been designed to offer the following characteristics:"
msgstr "一方、仮想スレッドはJVMによって管理される。実行するには、プラットフォーム・スレッド（その仮想スレッドのキャリアとして機能する）にマウントする必要がある。そのため、以下のような特徴を持つように設計されている："

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:53
#, no-wrap
msgid "Lightweight "
msgstr "軽量 "

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:57
#, fuzzy
msgid "Virtual threads occupy less space than platform threads in memory.  Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the memory.  By default, platform threads are created with a stack of about 1 MB, whereas virtual threads stack is \"pay-as-you-go.\" You can find these numbers and other motivations for virtual threads in this https://youtu.be/lIq-x_iI-kc?t=543[presentation] given by the lead developer of project Loom (the project that added the virtual thread support to the JVM)."
msgstr "仮想スレッドは、プラットフォーム・スレッドよりもメモリ上の占有領域が小さい。したがって、メモリを消費することなく、プラットフォーム・スレッドよりも多くの仮想スレッドを同時に使用することが可能になる。デフォルトでは、プラットフォーム・スレッドは約1MBのスタックで作成されるが、仮想スレッドのスタックは \"pay-as-you-go \"である。Loomプロジェクト（JVMに仮想スレッド・サポートを追加したプロジェクト）のリード開発者が行った link:https://youtu.be/lIq-x_iI-kc?t=543[プレゼンテーションで] 、これらの数字や仮想スレッドの他の動機を見ることができる。"

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:58
#, no-wrap
msgid "Cheap to create"
msgstr "安価に作成できる"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:62
#, fuzzy
msgid "Creating a platform thread in Java takes time.  Currently, techniques such as pooling, where threads are created once and then reused, are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).  Virtual threads are supposed to be disposable entities that we create when we need them, it is discouraged to pool them or reuse them for different tasks."
msgstr "Javaでプラットフォーム・スレッドを作成するには時間がかかる。現在では、スレッドを一度作成してから再利用するプーリングのようなテクニックが、スレッドの起動にかかる時間のロスを最小限に抑えるために強く推奨されています（同様に、メモリ消費量を低く抑えるためにスレッドの最大数を制限することも推奨されています）。仮想スレッドは必要なときに作成する使い捨てのものであり、スレッドをプールしたり、別のタスクに再利用したりすることは推奨されません。"

#. type: Labeled list
#: upstream/_versions/main/guides/virtual-threads.adoc:63
#, no-wrap
msgid "Cheap to block"
msgstr "安価なブロック"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:66
#, fuzzy
msgid "When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue, and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.  Since the JVM manages virtual threads, no underlying OS thread is blocked when they perform a blocking operation.  Their state is stored in the heap, and another virtual thread is executed on the same Java platform (carrier) thread."
msgstr "ブロッキングI/Oを実行するとき、Javaプラットフォームのスレッドにラップされた基礎となるOSスレッドは待ち行列に入れられ、新しいスレッドコンテキストをCPUコアにロードするためにコンテキストスイッチが発生する。この操作には時間がかかる。JVMは仮想スレッドを管理するため、OSスレッドがブロッキング操作を実行するときにブロックされることはない。それらの状態はヒープに格納され、別の仮想スレッドが同じJavaプラットフォーム（キャリア）スレッド上で実行される。"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:67
#, fuzzy, no-wrap
msgid "The Continuation Dance"
msgstr "コンティニュエーション・ダンス"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:69
#, fuzzy
msgid "As mentioned above, the JVM schedules the virtual threads. These virtual threads are mounted on carrier threads. The scheduling comes with a pinch of magic. When the virtual thread attempts to use blocking I/O, the JVM _transforms_ this call into a non-blocking one, unmounts the virtual thread, and mounts another virtual thread on the carrier thread. When the I/O completes, the _waiting_ virtual thread becomes eligible again and will be re-mounted on a carrier thread to continue its execution. For the user, all this dance is invisible. Your synchronous code is executed asynchronously."
msgstr "前述のように、JVMは仮想スレッドをスケジュールする。これらの仮想スレッドはキャリア・スレッドにマウントされる。スケジューリングにはちょっとしたマジックがある。仮想スレッドがブロッキングI/Oを使用しようとすると、JVMはこの呼び出しをノンブロッキングのものに _変換_ し、仮想スレッドをアンマウントし、キャリアスレッド上に別の仮想スレッドをマウントする。I/Oが完了すると、 _待機していた_ 仮想スレッドは再び適格になり、実行を続けるためにキャリア・スレッド上に再マウントされる。ユーザーにとって、このダンスはすべて目に見えない。あなたの同期コードは非同期に実行される。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:71
#, fuzzy
msgid "Note that the virtual thread may not be re-mounted on the same carrier thread."
msgstr "仮想スレッドを同じキャリアスレッドに再マウントすることはできない。"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:73
#, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr "仮想スレッドはI/Oバウンドワークロードにのみに有効"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:81
#, fuzzy
msgid "We now know we can create more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).  It is useless and counterproductive.  CPU-bound doesn't consist of quickly swapping threads while they need to wait for the completion of an I/O, but in leaving them attached to a CPU core to compute something.  In this scenario, it is worse than useless to have thousands of threads if we have tens of CPU cores, virtual threads won't enhance the performance of CPU-bound workloads.  Even worse, when running a CPU-bound workload on a virtual thread, the virtual thread monopolizes the carrier thread on which it is mounted.  It will either reduce the chance for the other virtual thread to run or will start creating new carrier threads, leading to high memory usage."
msgstr "これで、プラットフォーム・スレッドよりも多くの仮想スレッドを作成できることがわかった。仮想スレッドを使って長い計算（CPUバウンドワークロード）を実行したくなるかもしれない。それは無駄で逆効果だ。CPUバウンドとは、I/Oの完了を待つためにスレッドを素早くスワップすることではなく、何かを計算するためにスレッドをCPUコアに接続したままにすることである。このシナリオでは、数十のCPUコアがあれば、数千のスレッドを持つことは無意味というより悪く、仮想スレッドはCPUバウンドのワークロードのパフォーマンスを向上させない。さらに悪いことに、CPUバウンドのワークロードを仮想スレッド上で実行すると、仮想スレッドはそれがマウントされているキャリアスレッドを独占する。仮想スレッドは、他の仮想スレッドが実行する機会を減らすか、新しいキャリア・スレッドを作成し始めるため、メモリ使用量が多くなります。"

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:83
#, fuzzy, no-wrap
msgid "Run code on virtual threads using @RunOnVirtualThread"
msgstr "RunOnVirtualThreadを使用して仮想スレッド上でコードを実行する。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:88
#, fuzzy
msgid "In Quarkus, the support of virtual thread is implemented using the link:{runonvthread}[@RunOnVirtualThread] annotation.  This section briefly overviews the rationale and how to use it.  There are dedicated guides for extensions supporting that annotation, such as:"
msgstr "Quarkusでは、 link:{runonvthread}[@RunOnVirtualThread] アノテーションを使用して仮想スレッドのサポートを実装しています。このセクションでは、その根拠と使用方法について簡単に説明します。このアノテーションをサポートする拡張機能については、次のような専用のガイドがあります："

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:90
#, fuzzy
msgid "xref:./resteasy-reactive-virtual-threads.adoc[Virtual threads in REST applications]"
msgstr "xref:./resteasy-reactive-virtual-threads.adoc[RESTアプリケーションにおける仮想スレッド]"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:91
#, fuzzy
msgid "xref:./messaging-virtual-threads.adoc[Virtual threads in reactive messaging applications]"
msgstr "xref:./messaging-virtual-threads.adoc[リアクティブ・メッセージング・アプリケーションにおける仮想スレッド]"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:92
#, fuzzy
msgid "xref:./grpc-virtual-threads.adoc[Virtual threads in gRPC services]"
msgstr "xref:./grpc-virtual-threads.adoc[gRPCサービスにおける仮想スレッド]"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:93
#, fuzzy
msgid "xref:./scheduler-reference.adoc#virtual_threads[Execute periodic tasks on virtual threads]"
msgstr "xref:./scheduler-reference.adoc#virtual_threads[仮想スレッド上で定期的にタスクを実行する]"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:95
#, fuzzy, no-wrap
msgid "Why not run everything on virtual threads?"
msgstr "なぜすべてを仮想スレッドで実行しないのか？"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:102
#, fuzzy
msgid "As mentioned above, not everything can run safely on virtual threads.  The risk of **monopolization** can lead to high-memory usage.  Also, there are situations where the virtual thread cannot be unmounted from the carrier thread.  This is called **pinning**.  Finally, some libraries use `ThreadLocal` to store and reuse objects.  Using virtual threads with these libraries will lead to massive allocation, as the intentionally pooled objects will be instantiated for every (disposable and generally short-lived) virtual thread."
msgstr "前述したように、すべてが仮想スレッド上で安全に実行できるわけではない。 *独占の* リスクは、高いメモリ使用量につながる可能性がある。また、仮想スレッドをキャリアスレッドからアンマウントできない状況もある。これは *ピニングと* 呼ばれる。最後に、 `ThreadLocal` を使ってオブジェクトを保存し、再利用するライブラリもある。これらのライブラリで仮想スレッドを使用すると、意図的にプールされたオブジェクトが（使い捨てで一般に短命な）仮想スレッドごとにインスタンス化されるため、大量の割り当てが発生します。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:108
#, fuzzy
msgid "As of today, it is not possible to use virtual threads in a carefree manner.  Following such a laissez-faire approach could quickly lead to memory and resource starvation issues.  Thus, Quarkus uses an explicit model until the aforementioned issues disappear (as the Java ecosystem matures).  It is also the reason why _reactive_ extensions have the virtual thread support, and rarely the _classic_ ones.  We need to know when to dispatch on a virtual thread."
msgstr "現在のところ、仮想スレッドを自由に使うことはできない。このような自由放任的なアプローチに従うと、すぐにメモリやリソースの枯渇という問題が発生する可能性があります。したがってQuarkusでは、前述の問題がなくなるまで（Javaエコシステムが成熟するまで）、明示的なモデルを使用する。 _リアクティブ_ 拡張が仮想スレッドをサポートし、 _古典的な_ スレッドをほとんどサポートしない理由もここにある。仮想スレッドでディスパッチするタイミングを知る必要がある。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:110
#, fuzzy
msgid "It is essential to understand that these issues are not Quarkus limitations or bugs but are due to the current state of the Java ecosystem which needs to evolve to become virtual thread friendly."
msgstr "これらの問題は、Quarkusの制限やバグではなく、仮想スレッドフレンドリーに進化する必要があるJavaエコシステムの現状に起因していることを理解することが重要です。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:112
#, fuzzy
msgid "To learn more about the internal design and choices, check the https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment] paper."
msgstr "内部設計と選択肢の詳細については、「 link:https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in Java framework: a Quarkus example in resource-constrained environment] 」を参照してください。"

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:114
#, fuzzy, no-wrap
msgid "Monopolization cases"
msgstr "独占事件"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:118
#, fuzzy
msgid "The monopolization has been explained in the xref:cpu-bound[Virtual threads are useful for I/O-bound workloads only] section.  When running long computations, we do not allow the JVM to unmount and switch to another virtual thread until the virtual thread terminates.  Indeed, the current scheduler does not support preempting tasks."
msgstr "独占化については、「 xref:cpu-bound[仮想スレッドはI/Oバウンドのワークロードにのみ有効] 」で説明した。長い計算を実行する場合、仮想スレッドが終了するまで、JVMがアンマウントして別の仮想スレッドに切り替えることを許可しない。実際、現在のスケジューラーはタスクのプリエンプトをサポートしていない。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:122
#, fuzzy
msgid "This monopolization can lead to the creation of new carrier threads to execute other virtual threads.  Creating carrier threads results in creating platform threads.  So, there is a memory cost associated with this creation."
msgstr "この独占は、他の仮想スレッドを実行するための新しいキャリア・スレッドの作成につながる可能性がある。キャリア・スレッドを作成することは、プラットフォーム・スレッドを作成することになる。つまり、この作成にはメモリー・コストがかかる。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:125
#, fuzzy
msgid "Suppose you run in a constrained environment, such as containers. In that case, monopolization can quickly become a concern, as the high memory usage can lead to out-of-memory issues and container termination.  The memory usage may be higher than with regular worker threads because of the inherent cost of the scheduling and virtual threads."
msgstr "コンテナのような制約のある環境で実行するとする。その場合、メモリ使用量の多さがメモリ不足の問題やコンテナの終了につながる可能性があるため、すぐに独占が懸念されるようになります。メモリ使用量は、スケジューリングと仮想スレッドに固有のコストがかかるため、通常のワーカースレッドよりも高くなる可能性があります。"

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:127
#, no-wrap
msgid "Pinning cases"
msgstr "拘束の場合"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:130
#, fuzzy
msgid "The promise of \"cheap blocking\" might not always hold: a virtual thread might _pin_ its carrier on certain occasions.  The platform thread is blocked in this situation, precisely as it would have been in a typical blocking scenario."
msgstr "仮想スレッドは、ある場面でキャリアを _ピン_ 留めすることがある。この場合、プラットフォーム・スレッドは、典型的なブロッキング・シナリオと同じようにブロックされる。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:132
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr "link:{vthreadjep}[JEP 425] によると、これは2つの状況で発生する場合があります:"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:134
msgid "when a virtual thread performs a blocking operation inside a `synchronized` block or method"
msgstr "仮想スレッドが `synchronized` ブロックまたはメソッドの内部でブロッキング操作を実行する場合"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:135
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr "ネイティブメソッドや外部関数内でブロッキング操作を実行した場合"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:140
msgid "It can be reasonably easy to avoid these situations in your code, but verifying every dependency you use is hard.  Typically, while experimenting with virtual threads, we realized that versions older than 42.6.0 of the link:{pgsql-driver}[postgresql-JDBC driver] result in frequent pinning.  Most JDBC drivers still pin the carrier thread.  Even worse, many libraries require code changes."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:142
msgid "For more information, see link:https://quarkus.io/blog/virtual-thread-1/[When Quarkus meets Virtual Threads]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:146
msgid "This information about pinning cases applies to PostgreSQL JDBC driver 42.5.4 and earlier.  For PostgreSQL JDBC driver 42.6.0 and later, virtually all synchronized methods have been replaced by reentrant locks.  For more information, see the link:https://jdbc.postgresql.org/changelogs/2023-03-17-42.6.0-release/[Notable Changes] for PostgreSQL JDBC driver 42.6.0."
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:148
#, fuzzy, no-wrap
msgid "The pooling case"
msgstr "プーリングの場合"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:151
#, fuzzy
msgid "Some libraries are using `ThreadLocal` as an object pooling mechanism.  Extremely popular libraries like https://github.com/FasterXML/jackson-core/issues/919[Jackson] and Netty assume that the application uses a limited number of threads, which are recycled (using a thread pool) to run multiple (unrelated but sequential) tasks."
msgstr "`ThreadLocal` をオブジェクト・プールの仕組みとして使っているライブラリもある。 link:https://github.com/FasterXML/jackson-core/issues/919[Jacksonや] Nettyのような非常に人気のあるライブラリは、アプリケーションが限られた数のスレッドを使用し、そのスレッドを（スレッドプールを使用して）リサイクルして複数の（無関係だが連続した）タスクを実行することを想定している。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:153
#, fuzzy
msgid "This pattern has multiple advantages, such as:"
msgstr "このパターンには、次のような利点がある："

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:155
#, fuzzy
msgid "Allocation benefit: heavy objects are only allocated once per thread, but because the number of these threads was intended to be limited, it would not use too much memory."
msgstr "割り当ての利点：重いオブジェクトはスレッドごとに一度だけ割り当てられるが、このスレッドの数は制限されることを意図しているため、メモリを使いすぎることはない。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:156
#, fuzzy
msgid "Thread safety: only one thread can access the object stored in the thread local - preventing concurrent accesses."
msgstr "スレッドセーフ：スレッドローカルに格納されたオブジェクトにアクセスできるのは1つのスレッドのみで、同時アクセスを防ぐことができます。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:163
#, fuzzy
msgid "However, this pattern is counter-productive when using virtual threads.  Virtual threads are not pooled and generally short-lived.  So, instead of a few of them, we now have many of them.  For each of them, the object stored in the `ThreadLocal` is created (often large and expensive) and won't be reused, as the virtual thread is not pooled (and won't be used to run another task once the execution completes).  This problem leads to high memory usage.  Unfortunately, it requires sophisticated code changes in the libraries themselves."
msgstr "しかし、仮想スレッドを使う場合、このパターンは逆効果である。仮想スレッドはプールされておらず、一般的に短命である。そのため、スレッド数が少ない代わりに、スレッド数が多くなる。そのたびに、 `ThreadLocal` に格納されたオブジェクトが作成され（多くの場合、大きくて高価）、仮想スレッドはプールされていないため再利用されることはない（実行が完了したら別のタスクを実行するために使われることもない）。この問題はメモリ使用量の多さにつながる。残念ながら、ライブラリ自体に高度なコード変更が必要になる。"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:164
#, fuzzy, no-wrap
msgid "Use @RunOnVirtualThread with RESTEasy Reactive"
msgstr "RESTEasy Reactiveで@RunOnVirtualThreadを使用する。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:168
#, fuzzy
msgid "This section shows a brief example of using the link:{runonvthread}[@RunOnVirtualThread] annotation.  It also explains the various development and execution models offered by Quarkus."
msgstr "このセクションでは、 link:{runonvthread}[@RunOnVirtualThread] アノテーションの簡単な使用例を示します。また、Quarkusが提供するさまざまな開発モデルと実行モデルについても説明します。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:171
#, fuzzy
msgid "The `@RunOnVirtualThread` annotation instructs Quarkus to invoke the annotated method on a **new** virtual thread instead of the current one.  Quarkus handles the creation of the virtual thread and the offloading."
msgstr "`@RunOnVirtualThread` アノテーションは、Quarkusに対して、現在のスレッドではなく *新しい* 仮想スレッドでアノテーション付きメソッドを呼び出すように指示します。Quarkusは、仮想スレッドの作成とオフロードを処理します。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:173
#, fuzzy
msgid "Since virtual threads are disposable entities, the fundamental idea of `@RunOnVirtualThread` is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop or worker thread (in the case of RESTEasy Reactive)."
msgstr "仮想スレッドは使い捨てのエンティティであるため、 `@RunOnVirtualThread` の基本的な考え方は、エンドポイントハンドラの実行をイベントループまたはワーカースレッド（RESTEasy Reactiveの場合）で実行する代わりに、新しい仮想スレッドでオフロードすることです。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:177
#, fuzzy
msgid "To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.  If the Java Virtual Machine used to **run** the application provides virtual thread support (so Java 21 or later versions), then the endpoint execution is offloaded to a virtual thread.  It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
msgstr "そのためには、エンドポイントに link:{runonvthread}[@RunOnVirtualThread] アノテーションを追加すれば十分です。アプリケーションの *実行に* 使用される Java 仮想マシンが仮想スレッドのサポートを提供している場合 (Java 21 またはそれ以降のバージョン)、エンドポイントの実行は仮想スレッドにオフロードされます。すると、仮想スレッドがマウントされているプラットフォーム・スレッドをブロックすることなく、ブロッキング処理を実行できるようになります。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:182
#, fuzzy
msgid "In the case of RESTEasy Reactive, this annotation can only be used on endpoints annotated with link:{blockingannotation}[@Blocking] or considered blocking because of their signature.  You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking] for more information."
msgstr "RESTEasy Reactive の場合、このアノテーションは link:{blockingannotation}[@Blocking] でアノテーションされたエンドポイント、またはシグネチャによってブロッキングと見なされるエンドポイントにのみ使用できます。詳細については、 xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[実行モデル、ブロッキング、ノンブロッキングを] 参照してください。"

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:183
#, fuzzy, no-wrap
msgid "Get started with virtual threads with RESTEasy Reactive"
msgstr "RESTEasy Reactiveで仮想スレッドを始める"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:186
#, fuzzy
msgid "Add the following dependency to your build file:"
msgstr "ビルドファイルに以下の依存関係を追加する："

#. type: Block title
#: upstream/_versions/main/guides/virtual-threads.adoc:188
#: upstream/_versions/main/guides/virtual-threads.adoc:205
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:194
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/virtual-threads.adoc:197
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:200
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-resteasy-reactive\")\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:203
#, fuzzy
msgid "Then, you also need to make sure that you are using Java 21+, this can be enforced in your pom.xml file with the following:"
msgstr "次に、Java 21+を使用していることを確認する必要があります。これは、pom.xmlファイルで以下のように強制することができます："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:211
#, no-wrap
msgid ""
"<properties>\n"
"    <maven.compiler.source>21</maven.compiler.source>\n"
"    <maven.compiler.target>21</maven.compiler.target>\n"
"</properties>\n"
msgstr ""

#. type: Title ====
#: upstream/_versions/main/guides/virtual-threads.adoc:213
#, fuzzy, no-wrap
msgid "Three development and execution models"
msgstr "3つの開発・実行モデル"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:217
#, fuzzy
msgid "The example below shows the differences between three endpoints, all of them querying a _fortune_ in the database then returning it to the client."
msgstr "以下の例は、3つのエンドポイントの違いを示している。これらのエンドポイントはすべて、データベースの _財産を_ 照会し、それをクライアントに返す。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:219
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr "1つ目は伝統的なブロッキングスタイルを採用しており、そのシグネチャからブロッキングとみなされます。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:220
#, fuzzy
msgid "the second one uses Mutiny, it is considered non-blocking due to its signature."
msgstr "番目のものはMutinyを使用しており、そのシグネチャーからノンブロッキングとみなされている。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:222
#, fuzzy
msgid "the third one uses Mutiny but in a synchronous way, since it doesn't return a \"reactive type\" it is considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr "リアクティブ型」を返さないので、ブロッキングとみなされ、 link:{runonvthread}[@RunOnVirtualThread] アノテーションが使える。"

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:226
#, no-wrap
msgid "package org.acme.rest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:231
#, no-wrap
msgid ""
"import org.acme.fortune.model.Fortune;\n"
"import org.acme.fortune.repository.FortuneRepository;\n"
"import io.smallrye.common.annotation.RunOnVirtualThread;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:236
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:240
#, no-wrap
msgid ""
"@Path(\"\")\n"
"public class FortuneResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:242
#, no-wrap
msgid "    @Inject FortuneRepository repository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:250
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/blocking\")\n"
"    public Fortune blocking() {\n"
"        // Runs on a worker (platform) thread\n"
"        var list = repository.findAllBlocking();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:258
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/reactive\")\n"
"    public Uni<Fortune> reactive() {\n"
"        // Runs on the event loop\n"
"        return repository.findAllAsync()\n"
"                .map(this::pickOne);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:267
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/virtual\")\n"
"    @RunOnVirtualThread\n"
"    public Fortune virtualThread() {\n"
"        // Runs on a virtual thread\n"
"        var list = repository.findAllAsyncAndAwait();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:269
#: upstream/_versions/main/guides/virtual-threads.adoc:492
#: upstream/_versions/main/guides/virtual-threads.adoc:560
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:272
#, fuzzy
msgid "The following table summarizes the options:"
msgstr "以下の表はオプションの要約である："

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:274
#, fuzzy, no-wrap
msgid "Model"
msgstr "モデル"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:274
#, fuzzy, no-wrap
msgid "Example of signature"
msgstr "署名の例"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:274
#, fuzzy, no-wrap
msgid "Pros"
msgstr "長所"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:276
#, fuzzy, no-wrap
msgid "Cons"
msgstr "短所"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:277
#, fuzzy, no-wrap
msgid "Synchronous code on worker thread"
msgstr "ワーカースレッド上の同期コード"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:278
#, fuzzy, no-wrap
msgid "`Fortune blocking()`"
msgstr "`Fortune blocking()`"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:279
#: upstream/_versions/main/guides/virtual-threads.adoc:289
#, fuzzy, no-wrap
msgid "Simple code"
msgstr "シンプルなコード"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:281
#, fuzzy, no-wrap
msgid "Use worker thread (limit concurrency)"
msgstr "ワーカースレッドを使用する（同時実行を制限する）"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:282
#, fuzzy, no-wrap
msgid "Reactive code on event loop"
msgstr "イベントループのリアクティブコード"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:283
#, fuzzy, no-wrap
msgid "`Uni<Fortune> reactive()`"
msgstr "`Uni<Fortune> reactive()`"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:284
#, fuzzy, no-wrap
msgid "High concurrency and low resource usage"
msgstr "高い同時実行性と低いリソース使用"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:286
#, fuzzy, no-wrap
msgid "More complex code"
msgstr "より複雑なコード"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:287
#, fuzzy, no-wrap
msgid "Synchronous code on virtual thread"
msgstr "仮想スレッド上の同期コード"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:288
#, fuzzy, no-wrap
msgid "`@RunOnVirtualThread Fortune vt()`"
msgstr "`@RunOnVirtualThread Fortune vt()`"

#. type: Table
#: upstream/_versions/main/guides/virtual-threads.adoc:290
#, fuzzy, no-wrap
msgid "Risk of pinning, monopolization and under-efficient object pooling"
msgstr "ピン止め、独占、効率の悪いオブジェクト・プーリングのリスク"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:293
#, fuzzy
msgid "Note that all three models can be used in a single application."
msgstr "なお、この3つのモデルはすべて1つのアプリケーションで使用できる。"

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:294
#, fuzzy, no-wrap
msgid "Use virtual thread friendly clients"
msgstr "仮想スレッド・フレンドリー・クライアントを使用する"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:298
#, fuzzy
msgid "As mentioned in the xref:why-not[Why not run everything on virtual threads?] section, the Java ecosystem is not entirely ready for virtual threads.  So, you need to be careful, especially when using a libraries doing I/O."
msgstr "xref:why-not[なぜすべてを仮想スレッドで実行しないのか] 」のセクションで述べたように、Javaエコシステムは仮想スレッドの準備が完全に整っているわけではない。そのため、特にI/Oを行うライブラリを使うときには注意が必要だ。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:301
#, fuzzy
msgid "Fortunately, Quarkus provides a massive ecosystem that is ready to be used in virtual threads.  Mutiny, the reactive programming library used in Quarkus, and the Vert.x Mutiny bindings provides the ability to write blocking code (so, no fear, no learning curve) which do not pin the carrier thread."
msgstr "幸いなことに、Quarkusは仮想スレッドで使用できる大規模なエコシステムを提供しています。Quarkusで使用されているリアクティブプログラミングライブラリであるMutinyと、Vert.xのMutinyバインディングは、キャリアスレッドを固定しないブロッキングコードを書く能力を提供します（そのため、恐れることなく、学習曲線もありません）。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:303
#, fuzzy
msgid "As a result:"
msgstr "その結果だ："

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:306
#, fuzzy
msgid "Quarkus extensions providing blocking APIs on top of reactive APIs can be used in virtual threads.  This includes the reactive rest client, the redis client, the mailer..."
msgstr "リアクティブAPIの上にブロッキングAPIを提供するQuarkusの拡張機能は、仮想スレッドで使用できます。これには、リアクティブレストクライアント、redisクライアント、メーラー..."

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:307
#, fuzzy
msgid "API returning `Uni` can be used directly using `uni.await().atMost(...)`. It blocks the virtual thread, without blocking the carrier thread, and also improves the resilience of your application with an easy (non-blocking) timeout support."
msgstr "`Uni` を返す API は、 `uni.await().atMost(…​)` を使って直接使うことができる。これは、キャリアのスレッドをブロックすることなく、仮想スレッドをブロックし、また、簡単な（ノンブロッキング）タイムアウトのサポートにより、アプリケーションの回復力を向上させます。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:308
#, fuzzy
msgid "If you use a https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[Vert.x client using the Mutiny bindings], use the `andAwait()` methods which block until you get the result without pinning the carrier thread. It includes all the reactive SQL drivers."
msgstr "link:https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[Mutinyバインディングを使用するVert.xクライアントを] 使用する場合は、キャリアスレッドを固定せずに結果を取得するまでブロックする `andAwait()` メソッドを使用してください。これには、すべてのリアクティブ SQL ドライバが含まれています。"

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:309
#, fuzzy, no-wrap
msgid "Detect pinned thread in tests"
msgstr "テストでピン止めされたスレッドを検出する"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:313
#, fuzzy
msgid "We recommend to use the following configuration when running tests in application using virtual threads.  If would not fail the tests, but at least dump start traces if the code pins the carrier thread:"
msgstr "仮想スレッドを使用するアプリケーションでテストを実行する場合は、以下の設定を使用することを推奨します。テストが失敗することはありませんが、コードがキャリアのスレッドをピン留めした場合は、少なくとも開始トレースをダンプします："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:327
#, no-wrap
msgid ""
"<plugin>\n"
"  <artifactId>maven-surefire-plugin</artifactId>\n"
"  <version>${surefire-plugin.version}</version>\n"
"  <configuration>\n"
"      <systemPropertyVariables>\n"
"        <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"        <maven.home>${maven.home}</maven.home>\n"
"      </systemPropertyVariables>\n"
"      <argLine>--enable-preview -Djdk.tracePinnedThreads</argLine>\n"
"  </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:330
#, fuzzy
msgid "The `--enable-preview` flag is not necessary with Java 21."
msgstr "Java21では、 `--enable-preview` フラグは必要ない。"

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:331
#, fuzzy, no-wrap
msgid "Run application using virtual threads"
msgstr "仮想スレッドを使用してアプリケーションを実行する"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:334
#, fuzzy
msgid "Prior to Java 21, virtual threads are still an experimental feature, you need to start your application with the `--enable-preview` flag:"
msgstr "Java 21以前では、仮想スレッドはまだ実験的な機能なので、 `--enable-preview` フラグを付けてアプリケーションを起動する必要がある："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:338
#, no-wrap
msgid "java --enable-preview -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:340
#, fuzzy, no-wrap
msgid "Build containers for application using virtual threads"
msgstr "仮想スレッドを使用したアプリケーション用コンテナの構築"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:343
#, fuzzy
msgid "When running your application in JVM mode (so not compiled into native, for native check xref:native[the dedicated section]), you can follow the xref:./container-image.adoc[containerization guide] to build a container."
msgstr "アプリケーションをJVMモードで実行する場合（ネイティブにコンパイルされていない。ネイティブについては xref:native[専用のセクションを] 参照）、 xref:./container-image.adoc[コンテナ化ガイドに従って] コンテナを構築することができる。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:346
#, fuzzy
msgid "In this section, we use JIB to build the container.  Refer to the xref:./container-image.adoc[containerization guide] to learn more about the alternatives."
msgstr "このセクションでは、JIB を使ってコンテナを構築する。他の方法については、 xref:./container-image.adoc[コンテナ化ガイドを] 参照のこと。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:348
#, fuzzy
msgid "To containerize your Quarkus application that use `@RunOnVirtualThread`, add the following properties in your `application.properties`:"
msgstr "`@RunOnVirtualThread` を使用する Quarkus アプリケーションをコンテナ化するには、 `application.properties` に以下のプロパティを追加します："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:357
#, no-wrap
msgid ""
"quarkus.container-image.build=true\n"
"quarkus.container-image.group=<your-group-name>\n"
"quarkus.container-image.name=<you-container-name>\n"
"quarkus.jib.base-jvm-image=eclipse-temurin:20.0.1_9-jre-ubi9-minimal <1>\n"
"quarkus.jib.platforms=linux/amd64,linux/arm64 <2>\n"
"quarkus.jib.jvm-arguments=--enable-preview <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:359
#, fuzzy
msgid "Make sure you use a base image supporting virtual threads. Here we use an image providing Java 20."
msgstr "必ず仮想スレッドをサポートするベース・イメージを使用してください。ここではJava 20を提供するイメージを使用する。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:360
#, fuzzy
msgid "Select the target architecture. You can select more than one to build multi-archs images."
msgstr "ターゲット・アーキテクチャを選択します。マルチアーキテクチャイメージを構築する場合は、複数選択することができます。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:361
#, fuzzy
msgid "Don't forget to use the `--enable-preview` flag if you are not using Java 21+."
msgstr "Java 21+を使用していない場合は、 `--enable-preview` フラグを使用することをお忘れなく。"

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:364
#: upstream/_versions/main/guides/virtual-threads.adoc:423
#, fuzzy
msgid "Then, build your container as you would do usually.  For example, if you are using Maven, run:"
msgstr "それから、通常と同じようにコンテナをビルドする。例えば、Mavenを使用している場合は、以下を実行する："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:368
#, no-wrap
msgid "mvn package\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:371
#, fuzzy, no-wrap
msgid "Compiling Quarkus application using virtual threads into native executable"
msgstr "仮想スレッドを使用したQuarkusアプリケーションのネイティブ実行ファイルへのコンパイル"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:373
#, fuzzy, no-wrap
msgid "Using a local GraalVM installation"
msgstr "ローカルのGraalVMインストールを使用する"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:376
#, fuzzy
msgid "To compile a Quarkus applications leveraging `@RunOnVirtualThread` into a native executable, you must be sure to use a GraalVM / Mandrel `native-image` supporting virtual threads, so providing at least Java 21."
msgstr "`@RunOnVirtualThread` 、Quarkusアプリケーションをネイティブ実行ファイルにコンパイルするには、仮想スレッドをサポートするGraalVM / Mandrel `native-image` を使用する必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:379
#, fuzzy
msgid "Build the native executable as indicated on xref:./building-native-image.adoc[the native compilation guide].  For example, with Maven, run:"
msgstr "ネイティブ・ xref:./building-native-image.adoc[コンパイル・ガイドに従って] 、ネイティブ実行ファイルをビルドする。たとえば、Mavenを使用して、実行します："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:383
#: upstream/_versions/main/guides/virtual-threads.adoc:427
#, no-wrap
msgid "mvn package -Dnative\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:385
#, fuzzy, no-wrap
msgid "Using an in-container build"
msgstr "コンテナ内ビルドの使用"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:390
#, fuzzy
msgid "In-container build allows building Linux 64 executables by using a `native-image` compiler running in a container.  It avoids having to install `native-image` on your machine, and also allows configuring the GraalVM version you need.  Note that, to use in-container build, you must have Docker or Podman installed on your machine."
msgstr "コンテナ内ビルドでは、コンテナ内で動作する `native-image` コンパイラを使用して Linux 64 実行可能ファイルをビルドできます。マシンに `native-image` をインストールする必要がなく、必要な GraalVM バージョンを設定することもできます。コンテナ内ビルドを使用するには、DockerまたはPodmanがマシンにインストールされている必要があることに注意してください。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:392
#, fuzzy
msgid "Then, add to your `application.properties` file:"
msgstr "そして、 `application.properties` ："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:397
#, no-wrap
msgid ""
"# In-container build to get a linux 64 executable\n"
"quarkus.native.container-build=true <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:399
#, fuzzy
msgid "Enables the in-container build"
msgstr "コンテナ内ビルドを有効にする"

#. type: Block title
#: upstream/_versions/main/guides/virtual-threads.adoc:401
#, fuzzy, no-wrap
msgid "From ARM/64 to AMD/64"
msgstr "ARM/64からAMD/64へ"

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:405
#, fuzzy
msgid "If you are using a Mac M1 or M2 (using an ARM64 CPU), you need to be aware that the native executable you will get using an in-container build will be a Linux executable, but using your host (ARM 64) architecture.  You can use emulation to force the architecture when using Docker with the following property:"
msgstr "Mac M1またはM2（ARM64 CPUを使用）を使用している場合、コンテナ内ビルドを使用して取得するネイティブ実行ファイルはLinux実行ファイルになりますが、ホスト（ARM64）アーキテクチャを使用していることに注意する必要があります。以下のプロパティで、Dockerを使用する際にアーキテクチャを強制的に変更するエミュレーションを使用できます："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:409
#, no-wrap
msgid "quarkus.native.container-runtime-options=--platform=linux/amd64\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:412
#, fuzzy
msgid "Be aware that it increases the compilation time... a lot (>10 minutes)."
msgstr "コンパイル時間がかなり長くなる（10分以上）。"

#. type: Title ===
#: upstream/_versions/main/guides/virtual-threads.adoc:414
#, fuzzy, no-wrap
msgid "Containerize native applications using virtual threads"
msgstr "仮想スレッドを使用してネイティブ・アプリケーションをコンテナ化する"

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:418
#, fuzzy
msgid "To build a container running a Quarkus application using virtual threads compiled into a native executable, you must make sure you have a Linux/AMD64 executable (or ARM64 if you are targeting ARM machines)."
msgstr "ネイティブ実行ファイルにコンパイルされた仮想スレッドを使用してQuarkusアプリケーションを実行するコンテナを構築するには、Linux/AMD64実行ファイル（ARMマシンをターゲットにしている場合はARM64）を用意する必要があります。"

#. type: delimited block =
#: upstream/_versions/main/guides/virtual-threads.adoc:420
#, fuzzy
msgid "Make sure your `application.properties` contains the configuration explained in xref:native[the native compilation section]."
msgstr "`application.properties` 、 xref:native[ネイティブ・コンパイルのセクションで] 説明したコンフィギュレーションが含まれていることを確認してください。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:430
msgid "If you ever want to build a native container image and already have an existing native image you can set `-Dquarkus.native.reuse-existing=true` and the native image build will not be re-run."
msgstr "ネイティブコンテナイメージをビルドしたいときに、すでに既存のネイティブイメージがある場合は、 `-Dquarkus.native.reuse-existing=true` を設定すれば、ネイティブイメージのビルドは再実行されません。"

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:431
#, fuzzy, no-wrap
msgid "Use the duplicated context in virtual threads"
msgstr "重複したコンテキストを仮想スレッドで使用する"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:435
#, fuzzy
msgid "Methods annotated with `@RunOnVirtualThread` inherit from the original duplicated context (See the xref:duplicated-context.adoc[duplicated context reference guide] for details).  So, the data written in the duplicated context (and the request scope, as the request scoped is stored in the duplicated context) by filters and interceptors are available during the method execution (even if the filters and interceptors are not run on the virtual thread)."
msgstr "`@RunOnVirtualThread` でアノテーションされたメソッドは、元の複製されたコンテキストを継承します (詳細は xref:duplicated-context.adoc[複製されたコンテキストのリファレンスガイドを] 参照ください)。そのため、フィルタやインターセプタによって複製されたコンテキストに書き込まれたデータ (およびリクエストスコープが複製されたコンテキストに格納されているため、リクエストスコープ) は、メソッドの実行中に (フィルタやインターセプタが仮想スレッド上で実行されていなくても) 利用可能です。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:437
#, fuzzy
msgid "However, thread locals are not propagated."
msgstr "しかし、スレッドローカルは伝播されない。"

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:438
#, fuzzy, no-wrap
msgid "Virtual thread names"
msgstr "仮想スレッド名"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:443
#, fuzzy
msgid "Virtual threads are created without a thread name by default, which is not practical to identify the execution for debugging and logging purposes.  Quarkus managed virtual threads are named and prefixed with `quarkus-virtual-thread-`.  You can customize this prefix, or disable the naming altogether configuring an empty value:"
msgstr "デフォルトでは、仮想スレッドはスレッド名なしで作成されます。これは、デバッグやロギングの目的で実行を識別するには実用的ではありません。Quarkusの管理対象仮想スレッドには名前が付けられ、 `quarkus-virtual-thread-` というプレフィックスが付けられます。このプレフィックスはカスタマイズすることができ、空の値を設定することで名前付けを完全に無効にすることもできます："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:447
#, no-wrap
msgid "quarkus.virtual-threads.name-prefix=\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:450
#, no-wrap
msgid "Inject the virtual thread executor"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:454
msgid "In order to run tasks on virtual threads Quarkus manages an internal `ThreadPerTaskExecutor`.  In rare instances where you'd need to access this executor directly you can inject it using the `@VirtualThreads` CDI qualifier:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:456
msgid "Injecting the Virtual Thread ExecutorService is experimental and may change in future versions."
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:460
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:462
#, no-wrap
msgid "import org.acme.fortune.repository.FortuneRepository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:464
#, no-wrap
msgid "import java.util.concurrent.ExecutorService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:468
#, no-wrap
msgid ""
"import jakarta.enterprise.event.Observes;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:472
#, no-wrap
msgid ""
"import io.quarkus.logging.Log;\n"
"import io.quarkus.runtime.StartupEvent;\n"
"import io.quarkus.virtual.threads.VirtualThreads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:474
#, no-wrap
msgid "public class MyApplication {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:477
#, no-wrap
msgid ""
"    @Inject\n"
"    FortuneRepository repository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:481
#, no-wrap
msgid ""
"    @Inject\n"
"    @VirtualThreads\n"
"    ExecutorService vThreads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:485
#, no-wrap
msgid ""
"    void onEvent(@Observes StartupEvent event) {\n"
"        vThreads.execute(this::findAll);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:490
#, no-wrap
msgid ""
"    @Transactional\n"
"    void findAll() {\n"
"        Log.info(repository.findAllBlocking());\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:494
#, fuzzy, no-wrap
msgid "Testing virtual thread applications"
msgstr "仮想スレッドアプリケーションのテスト"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:499
#, fuzzy
msgid "As mentioned above, virtual threads have a few limitations that can drastically affect your application performance and memory usage.  The _junit5-virtual-threads_ extension provides a way to detect pinned carrier threads while running your tests.  Thus, you can eliminate one of the most prominent limitations or be aware of the problem."
msgstr "上述したように、仮想スレッドにはいくつかの制限があり、 アプリケーションのパフォーマンスやメモリ使用量に大きな影響を与える可能性があります。 _junit5-virtual-threads_ 拡張モジュールは、テストの実行中にピン留めされたキャリアスレッドを検出する方法を提供します。このため、最も顕著な制限のひとつを取り除いたり、 問題に気づいたりすることができます。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:501
#, fuzzy
msgid "To enable this detection:"
msgstr "この検出を有効にするには"

#. type: Bullet: '1) '
#: upstream/_versions/main/guides/virtual-threads.adoc:503
#, fuzzy
msgid "Add the `junit5-virtual-threads` dependency to your project:"
msgstr "`junit5-virtual-threads` の依存関係をプロジェクトに追加する："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:510
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus.junit5</groupId>\n"
"    <artifactId>junit5-virtual-threads</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Bullet: '2) '
#: upstream/_versions/main/guides/virtual-threads.adoc:513
#, fuzzy
msgid "In your test case, add the `io.quarkus.test.junit5.virtual.VirtualThreadUnit` and `io.quarkus.test.junit.virtual.ShouldNotPin` annotations:"
msgstr "テストケースに、 `io.quarkus.test.junit5.virtual.VirtualThreadUnit` と `io.quarkus.test.junit.virtual.ShouldNotPin` のアノテーションを追加する："

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:522
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n"
"@VirtualThreadUnit // Use the extension\n"
"@ShouldNotPin // Detect pinned carrier thread\n"
"class TodoResourceTest {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:526
#, fuzzy
msgid "When you run your test (remember to use Java 21+), Quarkus detects pinned carrier threads.  When it happens, the test fails."
msgstr "テストを実行すると（Java 21+を使用することを忘れないでください）、Quarkusはキャリアスレッドのピンを検出します。この場合、テストは失敗します。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:528
#, fuzzy
msgid "The `@ShouldNotPin` can also be used on methods directly."
msgstr "`@ShouldNotPin` 、メソッドに直接使用することもできる。"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:531
#, fuzzy
msgid "The _junit5-virtual-threads_ also provides a `@ShouldPin` annotation for cases where pinning is unavoidable.  The following snippet demonstrates the `@ShouldPin` annotation usage and the possibility to inject a `ThreadPinnedEvents` instance in your test to verify when the carrier thread was pinned manually."
msgstr "_junit5-virtual-threads_ は、ピニングが避けられない場合のために `@ShouldPin` アノテーションも提供しています。次のスニペットは、 `@ShouldPin` アノテーションの使用法と、 `ThreadPinnedEvents` インスタンスをテストに注入してキャリアスレッドが手動でピン留めされたことを検証する可能性を示しています。"

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:536
#, no-wrap
msgid ""
"@VirtualThreadUnit // Use the extension\n"
"public class LoomUnitExampleTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:538
#, no-wrap
msgid "    CodeUnderTest codeUnderTest = new CodeUnderTest();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:544
#, no-wrap
msgid ""
"    @Test\n"
"    @ShouldNotPin\n"
"    public void testThatShouldNotPin() {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:550
#, no-wrap
msgid ""
"    @Test\n"
"    @ShouldPin(atMost = 1)\n"
"    public void testThatShouldPinAtMostOnce() {\n"
"        codeUnderTest.pin();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/virtual-threads.adoc:558
#, no-wrap
msgid ""
"    @Test\n"
"    public void testThatShouldNotPin(ThreadPinnedEvents events) { // Inject an object to check the pin events\n"
"        Assertions.assertTrue(events.getEvents().isEmpty());\n"
"        codeUnderTest.pin();\n"
"        await().until(() -> events.getEvents().size() > 0);\n"
"        Assertions.assertEquals(events.getEvents().size(), 1);\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/virtual-threads.adoc:562
#, fuzzy, no-wrap
msgid "Additional references"
msgstr "参考文献"

#. type: Plain text
#: upstream/_versions/main/guides/virtual-threads.adoc:564
#, fuzzy
msgid "https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment]"
msgstr "link:https://dl.acm.org/doi/10.1145/3583678.3596895[Javaフレームワークにおける仮想スレッドの統合に関する考察：リソース制約環境におけるQuarkusの例]"

#, fuzzy
#~ msgid "It can be reasonably easy to avoid these situations in your code, but verifying every dependency you use is hard.  Typically, while experimenting with virtual threads, we realized that old versions of the link:{pgsql-driver}[postgresql-JDBC driver] results in frequent pinning.  Most JDBC drivers still pin the carrier thread.  Even worse, lots of widespread libraries are pinning and would require code changes."
#~ msgstr "コードでこのような状況を回避するのはそれなりに簡単ですが、使用する依存関係をすべて検証するのは大変です。典型的な例としては、仮想スレッドの実験中に、 link:{pgsql-driver}[postgresql-JDBC ドライバの] 古いバージョンでは頻繁にピニングが発生することに気づきました。ほとんどのJDBCドライバはまだキャリアスレッドをピンしています。さらに悪いことに、広く普及しているライブラリの多くが pin しており、コードの変更が必要になります。"

#, fuzzy
#~ msgid "The `enable-preview` flag in only necessary until Java 21."
#~ msgstr "`enable-preview` フラグが必要なのはJava 21までだ。"

#, fuzzy
#~ msgid "The builder container to use. Make sure it supports virtual threads"
#~ msgstr "使用するビルダー・コンテナ。仮想スレッドをサポートしていることを確認する"

#, fuzzy
#~ msgid "This guide explains how to benefit from Java 19+ virtual threads in Quarkus application."
#~ msgstr "このガイドでは、QuarkusアプリケーションでJava 19+の仮想スレッドを使用する方法について説明します。"

#, fuzzy
#~ msgid "Virtual threads are a feature available since Java 19, aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
#~ msgstr "仮想スレッドはJava 19から利用可能になった機能で、I/Oバウンドのワークロードに対して、プラットフォーム・スレッドに代わる安価な機能を提供することを目的としている。"

#, fuzzy
#~ msgid "In Quarkus, the support of virtual thread is implemented using the link:{runonvthread}[@RunOnVirtualThread] annotation.  This section briefly overviews the rationale and how to use it.  There are dedicated guides for extensions supporting that annotation, such as // TODO."
#~ msgstr "Quarkusでは、 link:{runonvthread}[@RunOnVirtualThread] アノテーションを使用して仮想スレッドのサポートを実装しています。このセクションでは、その根拠と使用方法について簡単に説明します。このアノテーションをサポートする拡張機能については、 // TODO."

#, fuzzy
#~ msgid "To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.  If the Java Virtual Machine used to **run** the application provides virtual thread support (so, Java 19 or later versions), then the endpoint execution is offloaded to a virtual thread.  It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
#~ msgstr "そのためには、エンドポイントに link:{runonvthread}[@RunOnVirtualThread] アノテーションを追加すれば十分です。アプリケーションの *実行に* 使用される Java 仮想マシンが仮想スレッドのサポートを提供している場合 (Java 19 またはそれ以降のバージョン)、エンドポイントの実行は仮想スレッドにオフロードされます。すると、仮想スレッドがマウントされているプラットフォーム・スレッドをブロックすることなく、ブロッキング処理を実行できるようになります。"

#, fuzzy
#~ msgid "Then, you also need to make sure that you are using the version 19+ of Java, this can be enforced in your pom.xml file with the following:"
#~ msgstr "それから、Javaのバージョンが19以上であることも確認する必要がある。これは、pom.xmlファイルで以下のように強制することができる："

#, fuzzy
#~ msgid "Finally, until Java 21, you need to configure your compiler plugin with the `--enable-preview` flag.  If you use Maven, make sure that the configuration of the Maven compiler plugin is the following:"
#~ msgstr "最後に、Java 21までは、 `--enable-preview` フラグを使用してコンパイラ・プラグインを構成する必要があります。Mavenを使用している場合は、Mavenコンパイラ・プラグインのコンフィギュレーションが以下のようになっていることを確認してください："

#, fuzzy
#~ msgid "Then, until Java 21, you need to add the following property to your `application.properties` file:"
#~ msgstr "その後、Java 21までは、 `application.properties` ファイルに以下のプロパティを追加する必要がある："

#, fuzzy
#~ msgid "Use @RunVirtualThread with RESTEasy Reactive"
#~ msgstr "RESTEasy Reactive で @RunVirtualThread を使用する。"

#, fuzzy
#~ msgid "As mentioned in the href:why-not[Why not run everything on virtual threads?] section, the Java ecosystem is not entirely ready for virtual threads.  So, you need to be careful, especially when using a libraries doing I/O."
#~ msgstr "href:why-not[なぜすべてを仮想スレッドで実行しないのか？]のセクションで述べたように、Javaのエコシステムは仮想スレッドの準備が完全に整っているわけではない。そのため、特にI/Oを行うライブラリを使用する場合は注意が必要です。"

#, fuzzy
#~ msgid "To compile a Quarkus applications leveraging `@RunOnVirtualThreads` into native executable, you must be sure to use a GraalVM / Mandrel `native-image` supporting virtual threads, so providing at least Java 19+."
#~ msgstr "`@RunOnVirtualThreads` 、Quarkusアプリケーションをネイティブ実行ファイルにコンパイルするには、仮想スレッドをサポートするGraalVM / Mandrel `native-image` を使用する必要があります。"

#~ msgid "Writing simpler reactive REST services with Quarkus Virtual Thread support"
#~ msgstr "仮想スレッドを使ったさらにシンプルなQuarkusでのリアクティブRESTサービスの作成"

#~ msgid "This guide explains how to benefit from Java 19 virtual threads when writing REST services in Quarkus."
#~ msgstr "このガイドではQuarkusでRESTサービスを記述する際にJava 19の仮想スレッドを利用する方法について説明します。"

#~ msgid "This is the reference guide for using virtual threads to write reactive REST services.  Please refer to the xref:rest-json.adoc[Writing JSON REST services guides] for a lightweight introduction to reactive REST services and to the xref:resteasy-reactive.adoc[Writing REST Services with RESTEasy Reactive] guide for a detailed presentation."
#~ msgstr "これは仮想スレッドを使用してリアクティブ REST サービスを記述するためのリファレンスガイドです。リアクティブ REST サービスの軽い導入としてはxref:rest-json.adoc[JSON RESTサービスの実装] を参照してください。詳細な説明については xref:resteasy-reactive.adoc[RESTEASY REACTIVE を使用して REST サービスを作成する] を参照してください。"

#~ msgid "What are virtual threads ?"
#~ msgstr "仮想スレッドとは何ですか？"

#~ msgid "A \"thread-like\" data-structure managed by the Operating System."
#~ msgstr "オペレーティングシステムによって管理される「スレッド(より糸)のような」なデータ構造。"

#~ msgid "Up until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, that is, a wrapper around an OS thread.  Creating a platform threads creates an OS thread, blocking a platform thread blocks an OS thread."
#~ msgstr "Java 19 まではlink:{thread}[Thread] クラスのすべてのインスタンスはプラットフォームスレッド、つまり OSスレッドのラッパーでした。プラットフォームスレッドを作成するとOSスレッドが作成され、プラットフォームスレッドをブロックするとOSスレッドがブロックされます。"

#~ msgid "A platform thread used to execute a virtual thread is called a carrier.  This isn't a class distinct from link:{Thread}[Thread] or VirtualThread but rather a functional denomination."
#~ msgstr "仮想スレッドを実行するために使用されるプラットフォームスレッドをキャリアと呼びます。これは link:{Thread}[Thread] や VirtualThreadとは別のクラスではなく、機能的な呼称です。"

#~ msgid "We will give a brief overview of the topic here, please refer to the link:{vthreadjep}[JEP 425] for more information."
#~ msgstr "ここではその概要を説明しますが、詳細はは link:{vthreadjep}[JEP 425] を確認してください。"

#~ msgid "Virtual threads are a feature available since Java 19 aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
#~ msgstr "仮想スレッドはI/Oバウンドワークロードのためのプラットフォームスレッドの安価な代替を提供することを目的としたJava 19から利用可能な機能です。"

#~ msgid "Until now, platform threads were the concurrency unit of the JVM.  They are a wrapper over OS structures.  This means that creating a Java platform thread actually results in creating a \"thread-like\" structure in your operating system."
#~ msgstr "これまでプラットフォームスレッドはJVMの並行処理単位でした。これはOSの構造のラッパーです。つまり、Javaプラットフォームスレッドを作成することは、実際にはOSに\"スレッド(より糸)のような\"構造を作成することになるのです。"

#~ msgid "Virtual threads on the other hand are managed by the JVM. In order to be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).  As such, they have been designed to offer the following characteristics:"
#~ msgstr "一方で仮想スレッドはJVMによって管理されます。実行するにはプラットフォームスレッド（その仮想スレッドのキャリアとして機能する）にマウントされる必要があります。なので次のような特徴を持つように設計されています:"

#~ msgid "Virtual threads occupy less space than platform threads in memory.  Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the heap.  By default, platform threads are created with a stack of about 1 MB where virtual threads stack is \"pay-as-you-go\".  You can find these numbers along with other motivations for virtual threads in this presentation given by the lead developer of project Loom: https://youtu.be/lIq-x_iI-kc?t=543."
#~ msgstr "仮想スレッドはプラットフォームスレッドよりもメモリ上で占有する領域が小さくなります。したがってヒープを爆発させずにプラットフォームスレッドよりも多くの仮想スレッドを同時に使用することが可能になります。デフォルトでは、プラットフォームスレッドは約1MBのスタックで作成され、仮想スレッドのスタックは\"使った分だけ\"です。これらの数字と仮想スレッドの他の論拠はLoomプロジェクトのリードディベロッパーが行ったプレゼンテーションで知ることができます: https://youtu.be/lIq-x_iI-kc?t=543 。"

#~ msgid "Creating a platform thread in Java takes time.  Currently, techniques such as pooling where threads are created once then reused are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).  Virtual threads are supposed to be disposable entities that we create when we need them, it is discouraged to pool them or to reuse them for different tasks."
#~ msgstr "Javaでプラットフォームスレッドを作成するのは時間がかかります。現時点ではスレッドの起動にかかる時間を最小限にするために、一度作成したスレッドを再利用するプーリングなどの技術を使うことが強く推奨されています（同様にメモリ消費を抑えるためにスレッドの最大数を制限することも推奨されています）。仮想スレッドは必要なときに作る使い捨ての存在であり、スレッドをプールしたり異なるタスクに再利用したりすることは推奨されません。"

#~ msgid "When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.  Since virtual threads are managed by the JVM, no underlying OS thread is blocked when they perform a blocking operation.  Their state is simply stored in the heap and another Virtual thread is executed on the same Java platform thread."
#~ msgstr "ブロッキングI/Oを実行する場合、JavaプラットフォームのスレッドにラップされたOSスレッドは待ち行列に入れられ、新しいスレッドコンテキストをCPUコアにロードするためにコンテキストスイッチが発生します。この操作には時間がかかります。仮想スレッドはJVMによって管理されるためブロッキング処理を実行してもOSスレッドがブロックされることはありません。その状態は単にヒープに格納され、別の仮想スレッドが同じJavaプラットフォームのスレッドで実行されます。"

#~ msgid "We now know that we can create way more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).  This is useless if not counterproductive.  CPU-bound doesn't consist in quickly swapping threads while they need to wait for the completion of an I/O but in leaving them attached to a CPU-core to actually compute something.  In this scenario, it is useless to have thousands of threads if we have tens of CPU-cores, virtual threads won't enhance the performance of CPU-bound workloads."
#~ msgstr "私たちはプラットフォームスレッドよりもはるかに多くの仮想スレッドを作成できることを知っています。長い計算を行うために仮想スレッドを使いたくなるかもしれません（CPUバウンドワークロード）。これは逆効果とまでは言いませんが無駄になります。CPUバウンドとはI/Oの完了を待つ間にスレッドをすばやくスワップすることではなく、実際に何かを計算するためにスレッドをCPUコアに接続したままにしておくことです。このシナリオでは数十個のCPUコアに対して数千個のスレッドを持つことは無意味であり、仮想スレッドがCPUバウンドワークロードの性能を向上させることはありません。"

#~ msgid "Bringing virtual threads to reactive REST services"
#~ msgstr "リアクティブなRESTサービスに仮想スレッドを導入する"

#~ msgid "Since virtual threads are disposable entities, the fundamental idea of quarkus-loom is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop (in the case of RESTeasy-reactive) or a platform worker thread."
#~ msgstr "仮想スレッドは使い捨てのエンティティなので、quarkus-loomの基本的な考え方では、エンドポイントハンドラをイベントループ（RESTeasy-reactiveの場合）やプラットフォームワーカスレッドで実行せずに新しい仮想スレッドでオフロードします。"

#~ msgid "To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.  If the JDK is compatible (Java 19 or later versions) then the endpoint will be offloaded to a virtual thread.  It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
#~ msgstr "そのためには、エンドポイントに link:{runonvthread}[@RunOnVirtualThread] アノテーションを追加すれば十分です。JDKに互換性がある場合（Java 19またはそれ以降のバージョン）はエンドポイントは仮想スレッドにオフロードされます。この場合は仮想スレッドがマウントされているプラットフォームスレッドをブロックせずにブロック操作を実行できるようになります。"

#~ msgid "This annotation can only be used in conjunction with endpoints annotated with link:{blockingannotation}[@Blocking] or considered blocking because of their signature.  You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking] for more information."
#~ msgstr "このアノテーションは link:{blockingannotation}[@Blocking] アノテーションが付けられたエンドポイント、またはそのシグネチャのためにブロッキングとみなされるエンドポイントとの組み合わせでのみ使用することができます。詳しくは xref:resteasy-reactive.adoc#実行モデルブロッキングノンブロッキング[実行モデル、ブロッキング、ノンブロッキング] をご確認ください。"

#~ msgid "Getting started"
#~ msgstr "はじめに"

#~ msgid "Add the following import to your build file:"
#~ msgstr "次のインポートをビルドファイルに追加します:"

#~ msgid "You also need to make sure that you are using the version 19 of Java, this can be enforced in your pom.xml file with the following:"
#~ msgstr "また、Javaのバージョン19を使用する必要があります。これは、pom.xmlファイルで次のように指定することができます:"

#~ msgid "Virtual threads are still an experimental feature, you need to start your application with the `--enable-preview` flag:"
#~ msgstr "仮想スレッドはまだ実験的な機能なので、 `--enable-preview` フラグを付けてアプリケーションを起動する必要があります:"

#~ msgid "The example below shows the differences between three endpoints, all of them querying a fortune in the database then returning it to the client."
#~ msgstr "以下の例は3つのエンドポイントの違いを示しています。これらのエンドポイントはすべてデータベースにクエリーを投げてクライアントに結果を返しています。"

#~ msgid "the second one uses Mutiny reactive streams in a declarative style, it is considered non-blocking due to its signature."
#~ msgstr "2つ目はMutinyのリアクティブストリームを宣言的なスタイルで使用し、そのシグネチャによりノンブロッキングとみなされます。"

#~ msgid "the third one uses Mutiny reactive streams in a synchronous way, since it doesn't return a \"reactive type\" it is considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
#~ msgstr "3つ目はMutinyのリアクティブストリームを同期的に使うもので\"リアクティブ型\"を返さないのでブロッキングとみなされ、 link:{runonvthread}[@RunOnVirtualThread] アノテーションが使えます。"

#~ msgid "When using Mutiny, alternative \"xAndAwait\" methods are provided to be used with virtual threads.  They ensure that waiting for the completion of the I/O will not \"pin\" the carrier thread and deteriorate performance.  Pinning is a phenomenon that we describe in xref:Pinning cases[this section]."
#~ msgstr "Mutinyを使用する場合は仮想スレッドで使用するための代替の\"xAndAwait\"メソッドが提供されます。これらは、I/Oの完了を待っても、キャリアスレッドを\"拘束\"して性能を悪化させないようにするものです。拘束とは、 xref:拘束の場合[このセクション] で説明する現象です。"

#~ msgid "In other words, the mutiny environment is a safe environment for virtual threads.  The guarantees offered by Mutiny are detailed later."
#~ msgstr "つまり、mutiny環境は仮想スレッドにとって安全な環境なのです。Mutinyが提供する保証については後で詳しく説明します。"

#~ msgid "Simplifying complex logic"
#~ msgstr "複雑なロジックの簡略化"

#~ msgid "The previous example is trivial and doesn't capture how imperative style can simplify complex reactive operations.  Below is a more complex example.  The endpoints must now fetch all the fortunes in the database, then append a quote to each fortune before finally returning the result to the client."
#~ msgstr "先ほどの例はささいなもので、命令型スタイルが複雑なリアクティブ操作をいかに簡略化できるかをとらえていません。次はもっと複雑な例です。エンドポイントはデータベース内のすべての運勢(fortune)を取得し、 結果をクライアントに返す前にそれぞれの運勢に引用文を追加します。"

#~ msgid "The notion of \"cheap blocking\" might not always be true: in certain occasions a virtual thread might \"pin\" its carrier (the platform thread it is mounted upon).  In this situation, the platform thread is blocked exactly as it would have been in a typical blocking scenario."
#~ msgstr "仮想スレッドがそのキャリア(マウントされているプラットフォームスレッド)を\"拘束\"する場合があります。この場合はプラットフォームスレッドは通常のブロッキングシナリオと同じようにブロックされます。"

#~ msgid "It can be fairly easy to avoid these situations in our own code, but it is hard to verify every dependency we use.  Typically, while experimenting with virtual-threads, we realized that using the link:{pgsql-driver}[postgresql-JDBC driver] results in frequent pinning."
#~ msgstr "自分たちのコードでこのような状況を回避するのはかなり簡単ですが、使用する依存関係をすべて検証するのは困難です。典型的な例としては、仮想スレッドの実験をしているときに link:{pgsql-driver}[postgresqlのJDBCドライバ] を使うと拘束が多発することに気づきました。"

#~ msgid "The JDBC problem"
#~ msgstr "postgresqlのJDBCの問題"

#~ msgid "Our experiments so far show that when a virtual thread queries a database using the JDBC driver, it will pin its carrier thread during the entire operation."
#~ msgstr "これまでの実験から、仮想スレッドがJDBCドライバを使ってデータベースに問い合わせを行う操作をしている間、仮想スレッドがキャリアスレッドを拘束することが分かっています。"

#~ msgid "Let's show the code of the `findAllBlocking()` method we used in the first example"
#~ msgstr "最初の例で使用した `findAllBlocking()` メソッドのコードを表示してみましょう。"

#~ msgid "The actual query happens at `ResultSet rs = preparedStatement.executeQuery();`, here is how it is implemented in the postgresql-jdbc driver 42.5.0:"
#~ msgstr "実際のクエリは `ResultSet rs = preparedStatement.executeQuery();` で実行されます。以下は、postgresql-jdbc ドライバ 42.5.0 で実装されている方法です:"

#~ msgid "This `synchronized` block is the culprit.  Replacing it with a lock is a good solution, but it won't be enough: `synchronized` blocks are also used in `executeWithFlags(int flag)`.  A systematic review of the postgresql-jdbc driver is necessary to make sure that it is compliant with virtual threads."
#~ msgstr "この `synchronized` のブロックが原因です。ロックに置き換えることは良い解決策ですが、それだけでは十分ではありません。 `synchronized` ブロックは、 `executeWithFlags(int flag)` でも使用されています。postgresqlのjdbcドライバが仮想スレッドに準拠していることを確認するためには体系的なレビューが必要になります。"

#~ msgid "Reactive drivers at the rescue"
#~ msgstr "リアクティブドライバによる救いの手"

#~ msgid "The vertx-sql-client is a reactive client, hence it is not supposed to block while waiting for the completion of a transaction with the database.  However, when using the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] it is possible to use a variant method that will await for the completion of the transaction, mimicking a blocking behaviour."
#~ msgstr "vertx-sql-client はリアクティブクライアントであり、データベースとのトランザクションの完了を待っている間はブロックしないことになっています。しかしながら、 link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] を使用する場合、トランザクションの完了を待つ可変メソッドを使用し、ブロッキングの挙動を模倣することが可能です。"

#~ msgid "Below is the `FortuneRepository` except the blocking we've seen earlier has been replaced by reactive methods."
#~ msgstr "以下はブロッキングがリアクティブメソッドに置き換えられているだけの、先ほど見た `FortuneRepository` です。"

#~ msgid "Contrary to the link:{pgsql-driver}[postgresql-jdbc driver], no `synchronized` block is used where it shouldn't be, and the `await` behaviour is implemented using locks and latches that won't cause pinning."
#~ msgstr "link:{pgsql-driver}[postgresqlのjdbcドライバ] とは逆に、 `synchronized` ブロックが使用されるべきではない場所で使用されることはなく、 `await` 動作は、拘束を発生させないロックとラッチを使用して実装されています。"

#~ msgid "Using the synchronous methods of the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] along with virtual threads will allow you to use the synchronous blocking style, avoid pinning the carrier thread, and get performance close to a pure reactive implementation."
#~ msgstr "link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] の同期メソッドと仮想スレッドを使用することで、同期ブロッキングスタイルを使用でき、キャリアスレッドの拘束を回避し、純粋なリアクティブ実装に近い性能を得ることができます。"

#~ msgid "A point about performance"
#~ msgstr "性能に関するポイント"

#~ msgid "Our experiments seem to indicate that Quarkus with virtual threads will scale better than Quarkus blocking (offloading the computation on a pool of platform worker threads) but not as well as Quarkus reactive.  The memory consumption especially might be an issue: if your system needs to keep its memory footprint low we would advise you stick to using reactive constructs."
#~ msgstr "我々の実験は、仮想スレッドを使用したQuarkusは、Quarkus blocking（プラットフォームワーカスレッドのプールに計算をオフロードする）よりもスケーラビリティが高く、Quarkus reactiveほどにはスケーラビリティが高くないことを示しているようです。特にメモリ消費量が問題です。もし、システムがメモリフットプリントを低く抑える必要がある場合は、リアクティブの仕組みを使用することをお勧めします。"

#~ msgid "This degradation of performance doesn't seem to come from virtual threads themselves but from the interactions between Vert.x/Netty (Quarkus underlying reactive engine) and the virtual threads.  This was illustrated in the issue that we will now describe."
#~ msgstr "この性能低下は仮想スレッドそのものが原因ではなく、Vert.x/Netty（Quarkusの基盤となるリアクティブエンジン）と仮想スレッドの間の相互作用に起因しているようです。このことは、これから説明する問題にも表れています。"

#~ msgid "The Netty problem"
#~ msgstr "Nettyの問題"

#~ msgid "For JSON serialization, Netty uses their custom implementation of thread locals, `FastThreadLocal` to store buffers.  When using virtual threads in quarkus, the number of virtual threads simultaneously living in the service is directly related to the incoming traffic.  It is possible to get hundreds of thousands, if not millions, of them."
#~ msgstr "JSONのシリアライゼーションでは、Nettyはスレッドローカルの独自実装を使用しています。 `FastThreadLocal` にバッファを保存します。Quarkusで仮想スレッドを使用する場合、サービス内に同時に存在する仮想スレッドの数は受信するトラフィックに直接関係します。数百万とまではいかなくても、数十万程度はあり得ます。"

#~ msgid "If they need to serialize some data to JSON they will end up creating as many instances of `FastThreadLocal`, resulting on a massive memory consumption as well as exacerbated pressure on the garbage collector.  This will eventually affect the performance of the application and inhibit its scalability."
#~ msgstr "もし、データをJSONにシリアライズする必要がある場合、多数の `FastThreadLocal` のインスタンスを作成することになることから大量のメモリを消費し、ガベージコレクタにかかる負担も大きくなってしまいます。これは最終的にアプリケーションの性能に影響を与え、スケーラビリティを阻害することになります。"

#~ msgid "This is a perfect example of the mismatch between the reactive stack and the virtual threads.  The fundamental hypothesis are completely different and result in different optimizations.  Netty expects a system using few event-loops (as many event-loops as CPU cores by default in Quarkus), but it gets hundreds of thousands of threads.  You can refer to link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[this mail] to get more information on how we envision our future with virtual threads."
#~ msgstr "これはリアクティブスタックと仮想スレッドのミスマッチの好例です。根本的な仮説が全く異なるため、結果として最適化も異なってきます。Nettyは少数のイベントループ(QuarkusのデフォルトではCPUのコア数と同じ数のイベントループ)を使用するシステムを想定していますが、何十万ものスレッドを取得します。私たちが仮想スレッドを使ってどのような未来を描いているかについては、 link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[このメール] を参照してください。"

#~ msgid "Our solution to the Netty problem"
#~ msgstr "Nettyの問題に対する我々の解決策"

#~ msgid "In order to avoid this wasting of resource without modifying Netty upstream, we wrote an extension that modifies the bytecode of the class responsible for creating the thread locals at build time.  Using this extension, performance of virtual threads in Quarkus for the Json Serialization test of the Techempower suite increased by nearly 80%, making it almost as good as reactive endpoints."
#~ msgstr "アップストリームのNettyに手を加えることなくこのリソースの浪費を避けるために、ビルド時にスレッドローカルの作成を担当するクラスのバイトコードを変更するエクステンションを書きました。このエクステンションを使うと、TechempowerスイートのJsonのSerializationのテストにおけるQuarkusの仮想スレッドのパフォーマンスが80%近く向上し、リアクティブエンドポイントとほぼ同等になりました。"

#~ msgid "To use it, it needs to be added as a dependency:"
#~ msgstr "使用するにはこれを依存関係として追加する必要があります:"

#~ msgid "Furthermore, some operations undertaken by this extension need special access, it is necessary to"
#~ msgstr "また、このエクステンションで行う作業の中には、特別なアクセスが必要なものがあります、次のことが必要になります"

#~ msgid "compile the application with the flag `-Dnet.bytebuddy.experimental`"
#~ msgstr "`-Dnet.bytebuddy.experimental` フラグを付けてコンパイルをする"

#~ msgid "open the `java.base.lang` module at runtime with the flag `--add-opens java.base/java.lang=ALL-UNNAMED`"
#~ msgstr "実行時に `--add-opens java.base/java.lang=ALL-UNNAMED` フラグをつけて `java.base.lang` モジュールを開く"

#~ msgid "This extension is only intended to improve performance, it is perfectly fine not to use it."
#~ msgstr "このエクステンションはあくまでパフォーマンス向上のためのもので、使わなくても全く問題ありません。"

#~ msgid "Concerning dev mode"
#~ msgstr "devモードについて"

#~ msgid "If you want to use quarkus with the dev mode, it won't be possible to manually specify the flags we mentioned along this guide.  Instead, you want to specify them all in the configuration of the `quarkus-maven-plugin` as presented below."
#~ msgstr "Quarkusをdevモードで使用したい場合、このガイドで説明したフラグを手動で指定することはできません。 代わりに以下のように `quarkus-maven-plugin` の設定で指定します。"

#~ msgid "If you don't want to specify the opening of the `java.lang` module in your pom.xml file, you can also specify it as an argument when you start the dev mode."
#~ msgstr "pom.xml ファイルに `java.lang` モジュールのオープンを指定したくない場合は、devモードの起動時に引数として指定することもできます。"

#~ msgid "The configuration of the quarkus-maven-plugin will be simpler:"
#~ msgstr "quarkus-maven-pluginの設定はシンプルになるでしょう:"

#~ msgid "And the command will become:"
#~ msgstr "また、コマンドは次のようになります:"
