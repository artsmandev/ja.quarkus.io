# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-22 08:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:7
#, fuzzy, no-wrap
msgid "Protect Quarkus web application by using an Auth0 OpenID Connect provider"
msgstr "Auth0 OpenID Connectプロバイダを使用したQuarkus Webアプリケーションの保護"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:14
#, fuzzy
msgid "xref:security-architecture.adoc[Quarkus Security] provides comprehensive OpenId Connect (OIDC) and OAuth2 support with its `quarkus-oidc` extension, supporting both xref:security-oidc-code-flow-authentication.adoc[Authorization code flow] and xref:security-oidc-bearer-token-authentication.adoc[Bearer token] authentication mechanisms."
msgstr "xref:security-architecture.adoc[Quarkus Securityは] 、 `quarkus-oidc` 、包括的なOpenId Connect（OIDC）とOAuth2のサポートを提供しています。これは、 xref:security-oidc-code-flow-authentication.adoc[認証コードフローと] xref:security-oidc-bearer-token-authentication.adoc[ベアラートークンの] 認証メカニズムの両方をサポートしています。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:16
#, fuzzy
msgid "With Quarkus, you can easily configure OIDC providers such as link:https://www.keycloak.org/documentation[Keycloak], link:https://developer.okta.com/[Okta], link:https://auth0.com/docs/[Auth0], and other xref:security-openid-connect-providers.adoc[well-known social OIDC and OAuth2 providers]."
msgstr "Quarkusを使用すると、 link:https://www.keycloak.org/documentation[Keycloak] 、 link:https://developer.okta.com/[Okta] 、 link:https://auth0.com/docs/[Auth0] 、その他の xref:security-openid-connect-providers.adoc[有名なソーシャルOIDCプロバイダーやOAuth2プロバイダーなどの] OIDCプロバイダーを簡単に設定できます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:18
#, fuzzy
msgid "Learn how to use the Quarkus OpenID Connect extension (`quarkus-oidc`) together with the https://auth0.com/docs/[Auth0] OIDC provider to protect your API endpoints."
msgstr "Quarkus OpenID Connect拡張機能（ `quarkus-oidc` ）と link:https://auth0.com/docs/[Auth0] OIDCプロバイダを使用して、APIエンドポイントを保護する方法について説明します。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:19
#, no-wrap
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:22
#, fuzzy
msgid "Please review the following documentation before you begin:"
msgstr "事前に以下の書類をご確認ください："

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:24
#, fuzzy
msgid "link:https://auth0.com/docs/[Auth0 docs site]"
msgstr "link:https://auth0.com/docs/[Auth0のドキュメントサイト]"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:25
#, fuzzy
msgid "xref:security-oidc-code-flow-authentication.adoc[Quarkus OpenID Connect Authorization code flow mechanism for protecting web applications]"
msgstr "xref:security-oidc-code-flow-authentication.adoc[ウェブアプリケーションを保護するためのQuarkus OpenID Connect認証コードフローメカニズム]"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:26
#, fuzzy
msgid "xref:security-oidc-bearer-token-authentication.adoc[Quarkus OpenID Connect (OIDC) Bearer token authentication]"
msgstr "xref:security-oidc-bearer-token-authentication.adoc[Quarkus OpenID Connect（OIDC）ベアラートークン認証]"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:27
#, fuzzy, no-wrap
msgid "Create an Auth0 application"
msgstr "Auth0アプリケーションの作成"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:31
#, fuzzy
msgid "Go to the Auth0 dashboard and create a regular web application.  For example, create an Auth0 application called `QuarkusAuth0`."
msgstr "Auth0 ダッシュボードに行き、通常のウェブアプリケーションを作成する。例えば、 `QuarkusAuth0` という Auth0 アプリケーションを作成します。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:32
#, fuzzy, no-wrap
msgid "Create Auth0 application"
msgstr "Auth0アプリケーションの作成"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:32
#, no-wrap
msgid "auth0-create-application.png"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:34
#, fuzzy, no-wrap
msgid "Result"
msgstr "結果"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:37
#, fuzzy
msgid "Your Auth0 application gets created with a client ID, secret, and HTTPS-based domain.  Make a note of these properties because you will need them to complete the Quarkus configuration in the next step."
msgstr "Auth0アプリケーションは、クライアントID、シークレット、HTTPSベースのドメインとともに作成されます。これらのプロパティは、次のステップでQuarkusの設定を完了するために必要になるので、メモしておいてください。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:38
#, fuzzy, no-wrap
msgid "Created Auth0 application"
msgstr "Auth0アプリケーションの作成"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:38
#, no-wrap
msgid "auth0-created-application.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:41
#, fuzzy
msgid "Next, while still in the Auth0 dashboard, add some users to your application."
msgstr "次に、Auth0ダッシュボードのまま、アプリケーションにユーザーを追加します。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:42
#, fuzzy, no-wrap
msgid "Add Auth0 application users"
msgstr "Auth0アプリケーションユーザーを追加する"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:42
#, no-wrap
msgid "auth0-add-user.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:46
#, fuzzy
msgid "Now that you have successfully created and configured your Auth0 application, you are ready to start creating and configuring a Quarkus endpoint.  In the steps that follow, you will continue to configure and update the Auth0 application as well."
msgstr "Auth0 アプリケーションの作成と設定が完了したら、Quarkus エンドポイントの作成と設定を開始します。この後の手順では、Auth0 アプリケーションの設定と更新を行います。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:47
#, fuzzy, no-wrap
msgid "Create a Quarkus application"
msgstr "Quarkusアプリケーションの作成"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:50
#, fuzzy
msgid "Use the following Maven command to create a Quarkus RESTEasy Reactive application that can be secured with the Quarkus OIDC extension."
msgstr "以下のMavenコマンドを使用して、Quarkus OIDC拡張機能で保護できるQuarkus RESTEasy Reactiveアプリケーションを作成します。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:57
#, fuzzy
msgid "Create the application workspace and import it into your favorite IDE.  Let's add a Jakarta REST endpoint that can only be accessed by authenticated users:"
msgstr "アプリケーション・ワークスペースを作成し、お気に入りのIDEにインポートします。認証されたユーザーのみがアクセスできる Jakarta REST エンドポイントを追加しましょう："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:61
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:244
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:314
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:422
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:545
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:662
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:703
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:765
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:853
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:894
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:981
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:63
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:246
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:316
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:424
#, no-wrap
msgid "import org.eclipse.microprofile.jwt.JsonWebToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:71
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:254
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:324
#, no-wrap
msgid ""
"import io.quarkus.oidc.IdToken;\n"
"import io.quarkus.security.Authenticated;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:74
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:257
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:327
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:435
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:556
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:78
#, no-wrap
msgid ""
"    @Inject\n"
"    @IdToken                                        <1>\n"
"    JsonWebToken idToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:86
#, no-wrap
msgid ""
"    @GET\n"
"    @Authenticated                                  <2>\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello, \" + idToken.getName();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:89
#, fuzzy
msgid "The injected `JsonWebToken` (JWT) bean has an `@IdToken` qualifier, which means it represents not an access token but OIDC `ID token`.  `IdToken` provides information in the form of claims about the current user authenticated during the OIDC authorization code flow and you can use `JsonWebToken` API to access these claims."
msgstr "注入された `JsonWebToken` (JWT) ビーンには `@IdToken` 修飾子があり、これはアクセストークンではなく OIDC `ID token` を表すことを意味します。 `IdToken` は、OIDC 認証コードフロー中に認証された現在のユーザーに関するクレームの形で情報を提供し、 `JsonWebToken` API を使用してこれらのクレームにアクセスできます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:90
#, fuzzy
msgid "The `io.quarkus.security.Authenticated` annotation is added to the `hello()` method, which means that only authenticated users can access it."
msgstr "`hello()` メソッドには `io.quarkus.security.Authenticated` アノテーションが付加されており、認証されたユーザーのみがアクセスできる。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:95
#, fuzzy
msgid "The access token acquired during the authorization code flow, alongside the ID token, is not used directly by the endpoint but is used only to access downstream services on behalf of the currently authenticated user.  More to come on the topic of \"access tokens\", later in this tutorial."
msgstr "認証コードフローで取得されたアクセストークンは、IDトークンと並んで、エンドポイントで直接使用されることはなく、現在認証されているユーザーに代わって下流のサービスにアクセスするためにのみ使用されます。アクセストークン」については、このチュートリアルの後半で詳しく説明します。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:98
#, fuzzy
msgid "Configure OIDC in the Quarkus `application.properties` file by using the properties from the Auth0 application that you created earlier."
msgstr "先ほど作成したAuth0アプリケーションのプロパティを使用して、Quarkus `application.properties` ファイルでOIDCを設定します。"

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:106
#, no-wrap
msgid ""
"# Make sure the application domain is prefixed with 'https://'\n"
"quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
"quarkus.oidc.application-type=web-app\n"
"quarkus.oidc.client-id=sKQu1dXjHB6r0sra0Y1YCqBZKWXqCkly\n"
"quarkus.oidc.credentials.secret=${client-secret}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:110
#, fuzzy
msgid "In completing this step, you have just configured Quarkus to use the domain, client ID, and secret of your Auth0 application.  Setting the property `quarkus.oidc.application-type=web-app` instructs Quarkus to use the OIDC authorization code flow, but there are also other methods, which are discussed later on in the tutorial."
msgstr "このステップを完了すると、Auth0アプリケーションのドメイン、クライアントID、シークレットを使用するようにQuarkusを設定したことになります。 `quarkus.oidc.application-type=web-app` プロパティを設定すると、QuarkusはOIDC認証コードフローを使用するように指示されますが、他の方法もあります。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:112
#, fuzzy
msgid "The endpoint address will be \\http://localhost:8080/hello, which must also be registered as an allowed callback URL in your Auth0 application."
msgstr "エンドポイントアドレスはhttp://localhost:8080/hello、Auth0アプリケーションで許可されたコールバックURLとして登録する必要があります。"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:113
#, fuzzy, no-wrap
msgid "Auth0 allowed callback URL"
msgstr "Auth0で許可されたコールバックURL"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:113
#, no-wrap
msgid "auth0-allowed-callback.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:116
#, fuzzy
msgid "After completing this step, when you access the Quarkus \\http://localhost:8080/hello endpoint from a browser, Auth0 redirects you back to the same address after the authentication is completed."
msgstr "このステップを完了した後、ブラウザからQuarkus http://localhost:8080/hello エンドポイントにアクセスすると、認証完了後にAuth0から同じアドレスにリダイレクトされます。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:121
#, fuzzy
msgid "By default, Quarkus automatically uses the current request path as the callback path.  But you can override the default behavior and configure a specific callback path by setting the Quarkus `quarkus.oidc.authentication.redirect-path` property."
msgstr "デフォルトでは、Quarkusは自動的に現在のリクエストパスをコールバックパスとして使用します。しかし、Quarkus `quarkus.oidc.authentication.redirect-path` プロパティを設定することで、デフォルトの動作をオーバーライドし、特定のコールバックパスを設定することができます。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:124
#, fuzzy
msgid "In production, your application will most likely have a larger URL space, with multiple endpoint addresses available.  In such cases, you can set a dedicated callback (redirect) path and register this URL in the provider's dashboard, as outlined in the following configuration example:"
msgstr "本番環境では、アプリケーションの URL 空間が大きくなり、複数のエンドポイントアドレスが利用可能になる可能性が高いです。このような場合、次の設定例のように、専用のコールバック（リダイレクト）パスを設定し、プロバイダのダッシュボードにこのURLを登録することができます："

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:126
#, fuzzy
msgid "`quarkus.oidc.authentication.redirect-path=/authenticated-welcome`"
msgstr "`quarkus.oidc.authentication.redirect-path=/authenticated-welcome`"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:129
#, fuzzy
msgid "In the example scenario, Quarkus calls `/authenticated-welcome` after accepting a redirect from Auth0, completing the authorization code flow, and creating the session cookie.  Successfully authenticated users are also allowed to access other parts of the secured application space, without needing to authenticate again. For example, the endpoint callback method can use a JAX-RS API to redirect users to other parts of the secured application where a session cookie will be verified."
msgstr "このシナリオ例では、Quarkus は Auth0 からのリダイレクトを受け入れ、認証コードフローを完了し、セッションクッキーを作成した後、 `/authenticated-welcome` を呼び出します。認証に成功したユーザは、再度認証することなく、セキュリティで保護されたアプリケーション空間の他の部分にアクセスすることも許可されます。例えば、エンドポイントコールバックメソッドは、JAX-RS API を使用して、セッションクッキーが検証されるセキュアなアプリケーションの他の部分にユーザーをリダイレクトすることができます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:132
#, fuzzy
msgid "Now you are ready to start testing the endpoint."
msgstr "これでエンドポイントのテストを始める準備ができた。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:133
#, fuzzy, no-wrap
msgid "Test the Quarkus endpoint"
msgstr "Quarkusのエンドポイントをテストする"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:136
#, fuzzy
msgid "Start Quarkus in dev mode:"
msgstr "Quarkusを開発モードで起動します："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:140
#, no-wrap
msgid "$ mvn quarkus:dev\n"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:146
#, fuzzy
msgid "This is the only time during this tutorial when you are expected to manually start Quarkus in dev mode.  The configuration and code update steps in the remaining sections of this tutorial are automatically observed and processed by Quarkus without you needing to restart the application manually."
msgstr "このチュートリアルで、Quarkusを手動でdevモードで起動するのはこのときだけです。このチュートリアルの残りのセクションの設定とコード更新の手順は、Quarkusによって自動的に観察され、処理されます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:149
#, fuzzy
msgid "Open the browser and access http://localhost:8080/hello."
msgstr "ブラウザを開き、 link:http://localhost:8080/hello[http://localhost:8080/hello。]"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:151
#, fuzzy
msgid "You will be redirected to Auth0 and prompted to log in:"
msgstr "Auth0にリダイレクトされ、ログインを促されます："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:152
#, fuzzy, no-wrap
msgid "Auth0 Login"
msgstr "ログイン"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:152
#, no-wrap
msgid "auth0-login.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:155
#, fuzzy
msgid "and authorize the `QuarkusAuth0` application to access your account:"
msgstr "をクリックし、 `QuarkusAuth0` アプリケーションがお客様のアカウントにアクセスすることを承認します："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:156
#, fuzzy, no-wrap
msgid "Auth0 Authorize"
msgstr "Auth0 認証"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:156
#, no-wrap
msgid "auth0-authorize.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:160
#, fuzzy
msgid "Finally, you will be redirected back to the Quarkus endpoint which will return the following response: `Hello, auth0|60e5a305e8da5a006aef5471`"
msgstr "最後に、Quarkusエンドポイントにリダイレクトされ、以下のレスポンスを返します： `Hello, auth0|60e5a305e8da5a006aef5471`"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:165
#, fuzzy
msgid "Notice that the current username does not get returned.  To learn more about why this behavior occurs, you can use OIDC Dev UI as explained in the xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[Dev UI for all OpenID Connect Providers] section of the \"Dev Services and UI for OpenID Connect (OIDC)\" guide and the following section."
msgstr "現在のユーザー名が返されないことに注意してください。なぜこのような動作が発生するのかについては、\"Dev Services and UI for OpenID Connect (OIDC)\" ガイドの \" xref:security-openid-connect-dev-services.adoc#dev-ui-all-oidc-providers[Dev UI for all OpenID Connect Providers] \" セクションおよび以下のセクションで説明されている OIDC Dev UI を使用することができます。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:167
#, fuzzy, no-wrap
msgid "Looking at Auth0 tokens in the OIDC Dev UI"
msgstr "OIDC Dev UIでAuth0トークンを見る"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:172
#, fuzzy
msgid "Quarkus provides a great xref:dev-ui-v2.adoc[Dev UI] experience.  Specifically, Quarkus offers built-in support for developing and testing OIDC endpoints with a Keycloak container.  xref:security-openid-connect-dev-services.adoc#dev-services-for-keycloak[DevService for Keycloak] is automatically started and used if the address of the OIDC provider is not specified for the Quarkus `quarkus.oidc.auth-server-url` configuration property."
msgstr "Quarkusは優れた xref:dev-ui-v2.adoc[開発UIを] 提供します。特に、Quarkusには、Keycloakコンテナを使用したOIDCエンドポイントの開発とテストをサポートする機能が組み込まれています。Quarkus `quarkus.oidc.auth-server-url` の設定プロパティにOIDCプロバイダーのアドレスが指定されていない場合、 xref:security-openid-connect-dev-services.adoc#dev-services-for-keycloak[DevService for Keycloakが] 自動的に開始され、使用されます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:175
#, fuzzy
msgid "You can continue using the Quarkus OIDC Dev UI when the provider is already configured.  Use the following instructions to update your configuration:"
msgstr "プロバイダがすでに設定されている場合は、Quarkus OIDC Dev UIを引き続き使用できます。以下の手順を使用して、設定を更新してください："

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:177
#, fuzzy
msgid "First, change your Quarkus application type from `web-app` to `hybrid`, as follows:"
msgstr "まず、以下のように、Quarkusのアプリケーションタイプを `web-app` から `hybrid` に変更します："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:184
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
"quarkus.oidc.application-type=hybrid <1>\n"
"quarkus.oidc.client-id=sKQu1dXjHB6r0sra0Y1YCqBZKWXqCkly\n"
"quarkus.oidc.credentials.secret=${client-secret}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:187
#, fuzzy
msgid "Application type is changed to `hybrid` because OIDC Dev UI currently supports `SPA` (single-page application) mode only.  OIDC Dev UI single-page application, using its own Java Script, authenticates users to the OIDC provider and uses the access token as a Bearer token to access the Quarkus endpoint as a service."
msgstr "OIDC Dev UIは現在、 `SPA` （シングルページアプリケーション）モードのみをサポートしているため、アプリケーションタイプは `hybrid` に変更されています。OIDC Dev UIのシングルページアプリケーションは、独自のJavaスクリプトを使用して、ユーザーをOIDCプロバイダーに認証し、アクセストークンをベアラートークンとして使用して、サービスとしてQuarkusエンドポイントにアクセスします。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:189
#, fuzzy
msgid "Typically, Quarkus must be configured with `quarkus.oidc.application-type=service` to support `Bearer` token authentication, but it also supports a `hybrid` application type, which means it can support both the authorization code and bearer token flows at the same time."
msgstr "通常、Quarkusは `Bearer` トークン認証をサポートするために、 `quarkus.oidc.application-type=service` で設定する必要がありますが、 `hybrid` アプリケーションタイプもサポートしています。つまり、認証コードとベアラートークンの両方のフローを同時にサポートすることができます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:192
#, fuzzy
msgid "You also need to configure the Auth0 application to allow the callbacks to the OIDC Dev UI.  Use the following URL format:"
msgstr "また、OIDC Dev UI へのコールバックを許可するように Auth0 アプリケーションを設定する必要があります。以下のURLフォーマットを使用してください："

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:194
#, fuzzy
msgid "`http://localhost:8080/q/dev-ui/io.quarkus.quarkus-oidc/${provider-name}-provider`"
msgstr "`http://localhost:8080/q/dev-ui/io.quarkus.quarkus-oidc/${provider-name}-provider`"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:196
#, fuzzy
msgid "Where in this example, the `${provider-name}` is `auth0`"
msgstr "この例では、 `${provider-name}` 。 `auth0`"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:197
#, fuzzy, no-wrap
msgid "Auth0 Allowed Callbacks"
msgstr "Auth0で許可されたコールバック"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:197
#, no-wrap
msgid "auth0-allowed-callbacks.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:200
#, fuzzy
msgid "Now you are ready to use OIDC Dev UI with Auth0."
msgstr "これでAuth0でOIDC Dev UIを使う準備ができました。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:202
#, fuzzy
msgid "Open http://localhost:8080/q/dev/ in a browser session. An OpenId Connect card that links to an Auth0 provider SPA displays, as follows:"
msgstr "ブラウザセッションで http://localhost:8080/q/dev/ を開く。以下のように、Auth0 プロバイダ SPA にリンクする OpenId Connect カードが表示されます："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:203
#, fuzzy, no-wrap
msgid "Auth0 DevUI"
msgstr "Auth0 DevUI"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:203
#, no-wrap
msgid "auth0-devui.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:206
#, fuzzy
msgid "Click *Auth0 provider* followed by *Login into Single Page Application*:"
msgstr "*Auth0プロバイダを* クリックし、 *シングルページアプリケーションにログイン* する："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:207
#, fuzzy, no-wrap
msgid "Auth0 DevUI Login to SPA"
msgstr "Auth0 DevUIからSPAへのログイン"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:207
#, no-wrap
msgid "auth0-devui-login-to-spa.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:211
#, fuzzy
msgid "You will be redirected to Auth0 to log in.  You will then be redirected to the OIDC Dev UI dashboard, as follows:"
msgstr "ログインするために Auth0 にリダイレクトされます。その後、以下のようにOIDC Dev UIダッシュボードにリダイレクトされます："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:212
#, fuzzy, no-wrap
msgid "Auth0 DevUI Dashboard Without Name"
msgstr "Auth0 DevUIダッシュボード 名前なし"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:212
#, no-wrap
msgid "auth0-devui-dashboard-without-name.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:215
#, fuzzy
msgid "Here you can look at both ID and access tokens in the encoded and decoded formats, copy them to the clipboard or use them to test the service endpoint. We will test the endpoint later but for now let's check the ID token:"
msgstr "ここでは、エンコードされた形式とデコードされた形式の両方のIDトークンとアクセストークンを見たり、クリップボードにコピーしたり、サービスのエンドポイントをテストするために使用したりすることができます。エンドポイントのテストは後で行うが、今はIDトークンをチェックしてみよう："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:216
#, fuzzy, no-wrap
msgid "Auth0 IdToken without name"
msgstr "名前なしのAuth0 IdToken"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:216
#, no-wrap
msgid "auth0-idtoken-without-name.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:219
#, fuzzy
msgid "As you can see it does not have any claim representing a user name but if you check its `sub` (subject) claim you will see its value matches what you got in the response when you accessed the Quarkus endpoint directly from the browser, `auth0|60e5a305e8da5a006aef5471`."
msgstr "ご覧のように、ユーザー名を表すクレームはありませんが、 `sub` （件名）のクレームをチェックすると、その値が、ブラウザからQuarkusのエンドポイントに直接アクセスしたときにレスポンスで取得した値（ `auth0|60e5a305e8da5a006aef5471` ）と一致していることがわかります。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:221
#, fuzzy
msgid "Fix it by configuring Quarkus to request a standard OIDC `profile` scope during the authentication process which should result in the ID token including more information:"
msgstr "この問題は、認証プロセス中に標準的なOIDC `profile` スコープを要求するようにQuarkusを設定することで解決します。これにより、IDトークンに詳細な情報が含まれるようになります："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:228
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
"quarkus.oidc.application-type=hybrid\n"
"quarkus.oidc.client-id=sKQu1dXjHB6r0sra0Y1YCqBZKWXqCkly\n"
"quarkus.oidc.credentials.secret=${client-secret}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:230
#, no-wrap
msgid "quarkus.oidc.authentication.scopes=profile <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:232
#, fuzzy
msgid "Request `profile` scope in addition to the default `openid` scope."
msgstr "デフォルトの `openid` スコープに加えて、 `profile` スコープをリクエストする。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:234
#, fuzzy
msgid "Go back to http://localhost:8080/q/dev/, repeat the process of logging in to `Auth0` and check the ID token again, now you should see the ID token containing the `name` claim:"
msgstr "http://localhost:8080/q/dev/ に戻り link:http://localhost:8080/q/dev/[、] `Auth0` にログインするプロセスを繰り返し、もう一度 ID トークンを確認してください。今度は、 `name` のクレームを含む ID トークンが表示されるはずです："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:235
#, fuzzy, no-wrap
msgid "Auth0 IdToken with name"
msgstr "名前付きAuth0 IdToken"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:235
#, no-wrap
msgid "auth0-idtoken-with-name.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:238
#, fuzzy
msgid "You should get the name when you access the Quarkus endpoint directly from the browser. Clear the browser cookie cache, access http://localhost:8080/hello and yet again, you get `Hello, auth0|60e5a305e8da5a006aef5471` returned. Hmm, what is wrong ?"
msgstr "ブラウザからQuarkusのエンドポイントに直接アクセスすると、その名前が表示されるはずです。 `Hello, auth0|60e5a305e8da5a006aef5471` ブラウザのクッキーキャッシュをクリアして、 link:http://localhost:8080/hello[http://localhost:8080] /hello。うーん、何が間違っているのでしょうか？"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:240
#, fuzzy
msgid "The answer lies with the specifics of the `org.eclipse.microprofile.jwt.JsonWebToken#getName()` implementation, which, according to the https://github.com/eclipse/microprofile-jwt-auth[MicroProfile MP JWT RBAC specification], checks an MP JWT specific `upn` claim, trying `preferred_username` next and finally `sub` which explains why you get the `Hello, auth0|60e5a305e8da5a006aef5471` answer even with the ID token containing the `name` claim. We can fix it easily by changing the endpoint `hello()` method's implementation to return a specific claim value:"
msgstr "`org.eclipse.microprofile.jwt.JsonWebToken#getName()` この実装は、 link:https://github.com/eclipse/microprofile-jwt-auth[MicroProfile MP JWT RBAC 仕様に] よると、MP JWT 固有の `upn` クレームをチェックし、次に `preferred_username` を試し、最後に `sub` を試します。このため、 `name` クレームを含む ID トークンであっても、 `Hello, auth0|60e5a305e8da5a006aef5471` という答えが返ってくるのです。エンドポイント `hello()` メソッドの実装を変更して、特定のクレーム値を返すようにすれば、簡単に修正できます："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:261
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:331
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:439
#, no-wrap
msgid ""
"    @Inject\n"
"    @IdToken\n"
"    JsonWebToken idToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:269
#, no-wrap
msgid ""
"    @GET\n"
"    @Authenticated\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello, \" + idToken.getClaim(\"name\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:272
#, fuzzy
msgid "Now clear the browser cache, access http://localhost:8080/hello and finally the user name is returned."
msgstr "ブラウザのキャッシュをクリアし、 link:http://localhost:8080/hello[http://localhost:8080] /hello。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:273
#, fuzzy, no-wrap
msgid "Logout support"
msgstr "ログアウトのサポート"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:276
#, fuzzy
msgid "Now that you have the users signing in to Quarkus with the help from Auth0, you will likely would like to support a user initiated logout. Quarkus supports https://quarkus.io/guides/security-oidc-code-flow-authentication#logout-and-expiration[RP-initiated and other standard OIDC logout mechanisms, as well as the local session logout]."
msgstr "Auth0を使用してユーザーがQuarkusにサインインした後、ユーザーによるログアウトをサポートしたいと思うでしょう。Quarkusは、 link:https://quarkus.io/guides/security-oidc-code-flow-authentication#logout-and-expiration[ローカルセッションのログアウトだけでなく、RP主導のログアウトやその他の標準的なOIDCログアウトメカニズムも] サポートしています。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:278
#, fuzzy
msgid "Currently, Auth0 does not support the standard OIDC RP-initiated logout and does not provide an end session endpoint URL in its discoverable metadata, but it provides its own logout mechanism which works nearly exactly the same as the standard one."
msgstr "現在のところ、Auth0は標準的なOIDC RP主導のログアウトをサポートしておらず、発見可能なメタデータにセッション終了エンドポイントURLを提供していないが、標準的なものとほぼ同じ動作をする独自のログアウトメカニズムを提供している。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:280
#, fuzzy
msgid "It is easy to support it with Quarkus OIDC. You must configure an Auth0 end session endpoint URL and have Quarkus include both the `client-id` query parameter and the post logout URL as the `returnTo` query parameter in the RP-initated logout redirect request to Auth0:"
msgstr "Quarkus OIDCでこれをサポートするのは簡単です。Auth0の終了セッションエンドポイントURLを設定し、QuarkusがAuth0へのRP-initatedログアウトリダイレクトリクエストの `returnTo` クエリパラメータとして、 `client-id` クエリパラメータとログアウト後のURLの両方を含めるようにする必要があります："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:288
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
"quarkus.oidc.application-type=hybrid\n"
"quarkus.oidc.client-id=sKQu1dXjHB6r0sra0Y1YCqBZKWXqCkly\n"
"quarkus.oidc.credentials.secret=${client-secret}\n"
"quarkus.oidc.authentication.scopes=openid,profile\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:294
#, no-wrap
msgid ""
"quarkus.oidc.end-session-path=v2/logout <1>\n"
"quarkus.oidc.logout.post-logout-uri-param=returnTo <2>\n"
"quarkus.oidc.logout.extra-params.client_id=${quarkus.oidc.client-id} <3>\n"
"quarkus.oidc.logout.path=/logout <4>\n"
"quarkus.oidc.logout.post-logout-path=/hello/post-logout <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:297
#, no-wrap
msgid ""
"quarkus.http.auth.permission.authenticated.paths=/logout\n"
"quarkus.http.auth.permission.authenticated.policy=authenticated <6>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:299
#, fuzzy
msgid "Auth0 does not include the end session URL in its metadata, so complement it with manually configuring the Auth0 end session endpoint URL."
msgstr "Auth0はそのメタデータにエンドセッションURLを含まないので、Auth0のエンドセッションエンドポイントURLを手動で設定して補完する。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:300
#, fuzzy
msgid "Auth0 will not recognize a standard `post_logout_redirect_uri` query parameter and expects a parameter `returnTo` instead."
msgstr "Auth0は標準の `post_logout_redirect_uri` クエリ・パラメータを認識せず、代わりに `returnTo` パラメータを期待する。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:301
#, fuzzy
msgid "Auth0 expects `client-id` in the logout request."
msgstr "Auth0はログアウト要求に `client-id` 。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:302
#, fuzzy
msgid "Authenticated requests to `/logout` path will be treated as RP-inititated logout requests."
msgstr "`/logout` パスへの認証されたリクエストは、RPによるログアウトリクエストとして扱われる。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:303
#, fuzzy
msgid "This is a public resource to where the logged out user should be returned to."
msgstr "これは、ログアウトしたユーザーをどこに戻すかを示すパブリック・リソースです。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:304
#, fuzzy
msgid "Make sure the `/logout` path is protected."
msgstr "`/logout` のパスが保護されていることを確認する。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:306
#, fuzzy
msgid "Here we have customized the Auth0 end session endpoint URL and indicated to Quarkus that an `http://localhost:8080/logout` request must trigger a logout of the currently authenticated user. An interesting thing about the `/logout` path is that it is `virtual`, it is not supported by any method in the JAX-RS endpoint, so for Quarkus OIDC to be able to react to `/logout` requests we attach an `authenticated` https://quarkus.io/guides/security-authorize-web-endpoints-reference#authorization-using-configuration[HTTP security policy] to this path directly in the configuration."
msgstr "ここでは、Auth0エンドセッションエンドポイントのURLをカスタマイズし、Quarkusに次のように指示しています。 `http://localhost:8080/logout` リクエストが現在認証されているユーザーのログアウトをトリガーしなければならないことをQuarkusに示しています。 `/logout` `virtual` そのため、Quarkus OIDC が `/logout` リクエストに反応できるように、 `authenticated` link:https://quarkus.io/guides/security-authorize-web-endpoints-reference#authorization-using-configuration[HTTP セキュリティポリシーを] このパスに直接アタッチします。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:308
#, fuzzy
msgid "We also have configured Quarkus to return the logged out user to the public `/hello/post-logout` resource, and this path is included in the logout request as the Auth0 specific `returnTo` query parameter. Finally, the Quarkus application's `client-id` is included in the logout URL as well."
msgstr "また、ログアウトしたユーザーをパブリックリソース（ `/hello/post-logout` ）に返すようにQuarkusを設定しており、このパスはAuth0固有の `returnTo` クエリパラメータとしてログアウトリクエストに含まれています。最後に、ログアウトURLにQuarkusアプリケーションの `client-id` 。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:310
#, fuzzy
msgid "Update the endpoint to accept the post logout redirects:"
msgstr "ログアウト後のリダイレクトを受け付けるようにエンドポイントを更新する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:338
#, no-wrap
msgid ""
"    @GET\n"
"    @Authenticated\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello, \" + idToken.getClaim(\"name\");\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:346
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:454
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:574
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:800
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"post-logout\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String postLogout() {\n"
"        return \"You were logged out\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:349
#, fuzzy
msgid "Note the addition of the public `/hello/post-logout` resource method."
msgstr "public `/hello/post-logout` リソース・メソッドの追加に注目。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:351
#, fuzzy
msgid "Before we test the logout, make sure the `Auth0` application is configured to allow this post logout redirect back to Quarkus after the user has been logged out:"
msgstr "ログアウトをテストする前に、ユーザーがログアウトした後にQuarkusに戻るログアウト後のリダイレクトを許可するように、 `Auth0` アプリケーションが設定されていることを確認してください："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:352
#, fuzzy, no-wrap
msgid "Auth0 Allowed Logout"
msgstr "Auth0 ログアウトを許可"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:352
#, no-wrap
msgid "auth0-allowed-logout.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:355
#, fuzzy
msgid "Now, clear the browser cookie cache, access http://localhost:8080/hello, login to Quarkus with Auth0, get the user name returned, and go to `http://localhost:8080/logout`. You'll see the `You were logged out` message displayed in the browser."
msgstr "次に、ブラウザのクッキーキャッシュをクリアし、 link:http://localhost:8080/hello[http://localhost:8080/hello、] Auth0でQuarkusにログインし、返されたユーザー名を取得します。 `http://localhost:8080/logout` .ブラウザに表示される `You were logged out` 。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:357
#, fuzzy
msgid "Next, go to the http://localhost:8080/q/dev/, login to Auth0 from the Dev UI SPA and notice you can now logout from the OIDC Dev UI too, see the symbol representing the logout next to the `Logged in as Sergey Beryozkin` text:"
msgstr "次に、 link:http://localhost:8080/q/dev/[http://localhost:8080/q/dev/、] Dev UI SPAからAuth0にログインし、OIDC Dev UIからもログアウトできることに気づく。 `Logged in as Sergey Beryozkin` テキストの横にログアウトを表す記号が表示されている："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:358
#, fuzzy, no-wrap
msgid "Auth0 Dashboard with name and Logout"
msgstr "Auth0ダッシュボード（名前とログアウト付き"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:358
#, no-wrap
msgid "auth0-devui-dashboard-with-name.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:361
#, fuzzy
msgid "For the logout to work from OIDC DevUI, the Auth0 application's list of allowed logout callbacks has to be updated to include the OIDC DevUI endpoint:"
msgstr "OIDC DevUIからログアウトするためには、Auth0アプリケーションの許可されたログアウトコールバックリストを更新し、OIDC DevUIエンドポイントを含める必要があります："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:362
#, fuzzy, no-wrap
msgid "Auth0 Allowed Logouts"
msgstr "Auth0 許可されたログアウト"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:362
#, no-wrap
msgid "auth0-allowed-logouts.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:365
#, fuzzy
msgid "Now logout directly from OIDC Dev UI and login as a new user - add more users to the registered Auth0 application if required."
msgstr "ここで OIDC Dev UI から直接ログアウトし、新規ユーザーとしてログインします。必要に応じて、登録済みの Auth0 アプリケーションにユーザーを追加してください。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:367
#, fuzzy, no-wrap
msgid "Role Based Access Control"
msgstr "役割ベースのアクセス制御"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:370
#, fuzzy
msgid "We have confirmed that the Quarkus endpoint can be accessed by users who have authenticated with the help of `Auth0`."
msgstr "Quarkus エンドポイントには、 `Auth0` で認証されたユーザーがアクセスできることを確認しています。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:372
#, fuzzy
msgid "The next step is to introduce Role Based Access Control (RBAC) to have users in a specific role only, such as `admin`, be able to access the endpoint."
msgstr "次のステップは、役割ベースのアクセス制御（RBAC）を導入し、 `admin` のような特定の役割のユーザーのみがエンドポイントにアクセスできるようにすることである。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:374
#, fuzzy
msgid "See also the xref:permission-based-access-control[Permission Based Access Control] section below."
msgstr "以下の「 xref:permission-based-access-control[パーミッションに基づくアクセス制御] 」の項も参照のこと。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:376
#, fuzzy
msgid "Auth0 tokens do not include any claims containing roles by default, so, first, you must customize the `Login` flow of the `Auth0` application with a custom action which will add the roles to tokens. Select `Actions/Flows/Login` in the `Auth0` dashboard, choose `Add Action/Build Custom`, name it as `AddRoleClaim`:"
msgstr "Auth0 トークンには、デフォルトではロールを含むクレームが含まれないため、まず、 `Auth0` アプリケーションの `Login` フローを、トークンにロールを追加するカスタムアクションでカスタマイズする必要があります。 `Auth0` ダッシュボードで `Actions/Flows/Login` を選択し、 `Add Action/Build Custom` を選択して、 `AddRoleClaim` と名前を付けます："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:377
#, fuzzy, no-wrap
msgid "Auth0 Add Role Action"
msgstr "Auth0 役割の追加"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:377
#, no-wrap
msgid "auth0-add-role-action.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:380
#, fuzzy
msgid "Add the following action script to it:"
msgstr "そこに以下のアクションスクリプトを追加する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:390
#, no-wrap
msgid ""
"exports.onExecutePostLogin = async (event, api) => {\n"
"  const namespace = 'https://quarkus-security.com';\n"
"  if (event.authorization) {\n"
"    api.idToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n"
"    api.accessToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n"
"  }\n"
"};\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:393
#, fuzzy
msgid "Note a custom Auth0 claim has to be namespace qualified, so the claim which will contain roles will be named as \"https://quarkus-security.com/roles\". Have a look at the ID token content we analyzed in the previous sections and you will see how this claim is represented, for example:"
msgstr "カスタムAuth0クレームは名前空間修飾されなければならないので、ロールを含むクレームは \"https://quarkus-security.com/roles \"という名前になることに注意してください。前のセクションで分析したIDトークンのコンテンツを見てください："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:401
#, no-wrap
msgid ""
"{\n"
"  \"https://quarkus-security.com/roles\": [\n"
"      \"admin\"\n"
"  ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:404
#, fuzzy
msgid "The `Auth0` Login Flow diagramm should look like this now:"
msgstr "`Auth0` ログインフロー図はこのようになります："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:405
#, fuzzy, no-wrap
msgid "Auth0 Login Flow"
msgstr "Auth0ログインフロー"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:405
#, no-wrap
msgid "auth0-login-flow.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:408
#, fuzzy
msgid "You must add a role such as `admin` to the users registered in the `Auth0` application."
msgstr "`Auth0` アプリケーションに登録されているユーザーに、 `admin` などのロールを追加する必要があります。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:410
#, fuzzy
msgid "Create an `admin` role:"
msgstr "`admin` ロールを作成する："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:411
#, fuzzy, no-wrap
msgid "Auth0 Create Role"
msgstr "Auth0 役割の作成"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:411
#, no-wrap
msgid "auth0-create-role.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:414
#, fuzzy
msgid "and add it to the registered user:"
msgstr "を作成し、登録ユーザーに追加する："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:415
#, fuzzy, no-wrap
msgid "Auth0 Add Role to User"
msgstr "Auth0 ユーザーへの役割の追加"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:415
#, no-wrap
msgid "auth0-add-role-to-user.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:418
#, fuzzy
msgid "Next, update the Quarkus endpoint to require that only users with the `admin` role can access the endpoint:"
msgstr "次に、Quarkusエンドポイントを更新して、 `admin` ロールを持つユーザーのみがエンドポイントにアクセスできるようにします："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:432
#, no-wrap
msgid ""
"import io.quarkus.oidc.IdToken;\n"
"import jakarta.annotation.security.RolesAllowed;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:446
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"admin\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello, \" + idToken.getClaim(\"name\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:457
#, fuzzy
msgid "Open http://localhost:8080/hello, authenticate to Auth0 and get `403`. The reason you get `403` is because Quarkus OIDC does not know which claim in the `Auth0` tokens represents the roles information, by default a `groups` claim is checked, while Auth0 tokens are now expected to have an \"https://quarkus-security.com/roles\" claim."
msgstr "http://localhost:8080/hello を開き、Auth0 を認証して `403` を取得します。 `403` が表示されるのは、Quarkus OIDCが `Auth0` トークンのどのクレームがロール情報を表しているのかわからないためです。デフォルトでは、 `groups` のクレームがチェックされますが、Auth0 トークンは \"https://quarkus-security.com/roles\" のクレームを持つことが期待されます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:459
#, fuzzy
msgid "Fix it by telling Quarkus OIDC which claim must be checked to enforce RBAC:"
msgstr "Quarkus OIDCに、RBACを実施するためにどのクレームをチェックしなければならないかを指示することで、この問題を解決します："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:467
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:523
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:939
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
"quarkus.oidc.application-type=hybrid\n"
"quarkus.oidc.authentication.scopes=profile\n"
"quarkus.oidc.client-id=sKQu1dXjHB6r0sra0Y1YCqBZKWXqCkly\n"
"quarkus.oidc.credentials.secret=${client-secret}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:469
#, no-wrap
msgid "quarkus.oidc.roles.role-claim-path=\"https://quarkus-security.com/roles\" <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:478
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:535
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:746
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:841
#, no-wrap
msgid ""
"# Logout\n"
"quarkus.oidc.end-session-path=v2/logout\n"
"quarkus.oidc.logout.post-logout-uri-param=returnTo\n"
"quarkus.oidc.logout.extra-params.client_id=${quarkus.oidc.client-id}\n"
"quarkus.oidc.logout.path=/logout\n"
"quarkus.oidc.logout.post-logout-path=/hello/post-logout\n"
"quarkus.http.auth.permission.authenticated.paths=/logout\n"
"quarkus.http.auth.permission.authenticated.policy=authenticated\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:480
#, fuzzy
msgid "Point to the custom roles claim. The path to the roles claim is in double quotes because the claim is namespace qualified."
msgstr "カスタムロール要求を指定します。ロール・クレームへのパスは二重引用符で囲まれていますが、これはクレームが名前空間修飾されているためです。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:482
#, fuzzy
msgid "Now, clear the browser cookie cache, access http://localhost:8080/hello again, authenticate to Auth0 and get an expected user name."
msgstr "さて、ブラウザのクッキーキャッシュをクリアし、 link:http://localhost:8080/hello[http://localhost:8080/hello に] 再度アクセスし、Auth0に認証し、予想されるユーザー名を取得する。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:484
#, fuzzy, no-wrap
msgid "Access Quarkus with opaque Auth0 access tokens"
msgstr "不透明なAuth0アクセストークンでQuarkusにアクセスする"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:489
#, fuzzy
msgid "The main goal of this section is to explain how Quarkus can be tuned to accept `opaque` bearer Auth0 access tokens as opposed to Auth0 JWT access tokens because Auth0 access tokens issued during the authorization code flow are opaque by default and they can only be used to request `UserInfo` in addition to the information about the current user which is already available in ID token. Learning how to verify opaque tokens can be useful because many OIDC and OAuth2 providers will issue opaque access tokens only."
msgstr "このセクションの主な目的は、Auth0 JWT アクセストークンとは対照的に、 `opaque` ベアラ Auth0 アクセストークンを受け入れるように Quarkus をチューニングする方法を説明することです。なぜなら、認証コードフロー中に発行された Auth0 アクセストークンはデフォルトでは不透明であり、ID トークンですでに利用可能な現在のユーザーに関する情報に加えて、 `UserInfo` を要求するためにのみ使用できるからです。多くの OIDC や OAuth2 プロバイダは不透明なアクセストークンのみを発行するため、不透明なトークンを検証する方法を学ぶことは有益です。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:491
#, fuzzy
msgid "Please see the xref:token-propagation[Propagate access tokens to microservices] and xref:jwt-access-tokens[Access tokens in JWT format] sections below for more information on how to configure Auth0 and Quarkus to have authorization code access tokens issued in the JWT format and propagated to service endpoints."
msgstr "JWT形式で発行された認証コードのアクセストークンをサービスエンドポイントに伝播させるためのAuth0とQuarkusの設定方法については、以下の「 xref:token-propagation[Propagate access tokens to microservices] 」と「 xref:jwt-access-tokens[Access tokens in JWT format] 」のセクションを参照してください。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:494
#, fuzzy
msgid "So far we have only tested the Quarkus endpoint using OIDC authorization code flow. In this flow you use the browser to access the Quarkus endpoint, Quarkus itself manages the authorization code flow, a user is redirected to Auth0, logs in, is redirected back to Quarkus, Quarkus completes the flow by exchanging the code for the ID, access, and refresh tokens, and works with the ID token representing the successful user authentication. The access token is not relevant at the moment. As mentioned earlier, in the authorization code flow, Quarkus will only use the access token to access downstream services on behalf of the currently authenticated user."
msgstr "これまでのところ、OIDC認証コードフローを使用してQuarkusエンドポイントをテストしたのみです。このフローでは、ブラウザを使ってQuarkusエンドポイントにアクセスし、Quarkus自身が認証コードフローを管理し、ユーザーがAuth0にリダイレクトされ、ログインし、Quarkusにリダイレクトされて戻り、QuarkusがIDトークン、アクセストークン、リフレッシュトークンのコードを交換してフローを完了し、ユーザー認証に成功したIDトークンで動作します。アクセストークンは現時点では関係ありません。前述したように、認証コードフローでは、Quarkusはアクセストークンを使用して、現在認証されているユーザーに代わってダウンストリームサービスにアクセスするだけです。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:496
#, fuzzy
msgid "Lets imagine though that the Quarkus endpoint we have developed has to accept `Bearer` access tokens too: it may be that the other Quarkus endpoint which is propagating it to this endpoint or it can be SPA which uses the access token to access the Quarkus endpoint. And Quarkus OIDC DevUI SPA which we already used to analyze the ID token fits perfectly for using the access token available to SPA to test the Quarkus endpoint."
msgstr "しかし、私たちが開発したQuarkusエンドポイントは、 `Bearer` アクセストークンも受け入れなければならないとします。このエンドポイントにアクセストークンを伝播するのは、他のQuarkusエンドポイントかもしれませんし、アクセストークンを使用してQuarkusエンドポイントにアクセスするSPAかもしれません。Quarkus OIDC DevUI SPAは、IDトークンの分析に使用しましたが、SPAが利用可能なアクセストークンを使用してQuarkusエンドポイントをテストするのにぴったりです。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:498
#, fuzzy
msgid "Lets go again to http://localhost:8080/q/dev, select the `OpenId Connect` card, login to Auth0, and check the Access token content:"
msgstr "もう一度 link:http://localhost:8080/q/dev[http://localhost:8080/q/dev、] `OpenId Connect` カードを選択し、Auth0にログインして、アクセストークンの内容を確認します："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:499
#, fuzzy, no-wrap
msgid "Auth0 DevUI Access Token"
msgstr "Auth0 DevUI アクセストークン"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:499
#, no-wrap
msgid "auth0-devui-accesstoken.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:502
#, fuzzy
msgid "This access token, as opposed to the ID token we looked at earlier, can not be verified by Quarkus directly. This is because the access token is in `JWE` (encrypted) as opposed to `JWS` (signed) format. You can see from the decoded token headers that it has been encrypted directly with a secret key known to Auth0 only, and therefore its content can not be decrypted by Quarkus. From the Quarkus's perspective this access token is an `opaque` one, Quarkus can not use public Auth0 asymmetric verification keys to verify it."
msgstr "このアクセストークンは、先ほど説明したIDトークンとは異なり、Quarkusで直接検証することはできません。これは、アクセストークンが `JWS` （署名）形式ではなく、 `JWE` （暗号化）形式であるためです。復号化されたトークンのヘッダーを見ると、アクセストークンはAuth0だけが知っている秘密鍵で直接暗号化されていることがわかります。Quarkusの観点からは、このアクセストークンは `opaque` 、Quarkusは公開されているAuth0の非対称検証鍵を使用して検証することはできません。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:504
#, fuzzy
msgid "To confirm it, enter `/hello` as the `Service Address` in the `Test Service` area and press `With Access Token` and you will get the HTTP `401` status:"
msgstr "確認するには、 `Test Service` のエリアに `Service Address` として `/hello` を入力し、 `With Access Token` を押すと、HTTP `401` のステータスが表示されます："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:505
#, fuzzy, no-wrap
msgid "Auth0 Dev UI Test Access token 401"
msgstr "Auth0 Dev UI Test アクセストークン 401"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:505
#, no-wrap
msgid "auth0-devui-test-accesstoken-401.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:509
#, fuzzy
msgid "For Quarkus be able to accept such access tokens, one of the two options should be available.  The first option is to introspect the opaque token remotely using a provider's introspection endpoint. Token introspection is typically supported at the `OAuth2` level, and since `OIDC` is built on top of `OAuth2`, some OIDC providers such as Keycloak support the token introspection as well. However, Auth0 does not support the token introspection, you can check it by looking at the publicly available Auth0 metadata, add `/.well-known/openid-configuration` to the address of your configured Auth0 provider, and open the resulting URL, `https://dev-3ve0cgn7.us.auth0.com/.well-known/openid-configuration`. You will see that Auth0 does not have an introspection endpoint:"
msgstr "Quarkusがこのようなアクセストークンを受け入れるためには、2つのオプションのうち1つが利用可能でなければなりません。最初のオプションは、プロバイダのイントロスペクションエンドポイントを使用し て、リモートで不透明トークンをイントロスペクションすることである。トークンのイントロスペクションは通常、 `OAuth2` レベルでサポートされている。 `OIDC` は `OAuth2` の上に構築されているため、Keycloak などの OIDC プロバイダーもトークンのイントロスペクションをサポートしている。しかし、Auth0はトークンのイントロスペクションをサポートしていません。公開されているAuth0のメタデータを見て、設定したAuth0プロバイダーのアドレスに `/.well-known/openid-configuration` を追加し、結果のURLを開くことで確認できます、 `https://dev-3ve0cgn7.us.auth0.com/.well-known/openid-configuration` .Auth0がイントロスペクションエンドポイントを持っていないことがわかります："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:510
#, fuzzy, no-wrap
msgid "Auth0 Well Known Config"
msgstr "Auth0 よく知られたコンフィグ"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:510
#, no-wrap
msgid "auth0-well-known-config.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:513
#, fuzzy
msgid "Therefore the other option, indirect access token verification, where the access token is used to acquire `UserInfo` from Auth0 can be used to accept and verify opaque Auth0 tokens. This option works because OIDC providers have to verify access tokens before they can issue `UserInfo` and Auth0 has a `UserInfo` endpoint."
msgstr "したがって、もう1つのオプションである間接的なアクセストークン検証は、アクセストークンがAuth0から `UserInfo` 、不透明なAuth0トークンを受け入れ検証するために使用できる。OIDCプロバイダは、 `UserInfo` を発行する前にアクセストークンを検証する必要があり、Auth0は `UserInfo` エンドポイントを持っているため、このオプションは機能する。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:515
#, fuzzy
msgid "So lets configure Quarkus to request that the access tokens must be verified by using them to acquite `UserInfo`:"
msgstr "そこで、アクセストークンを使用して `UserInfo` を取得することで、アクセストークンの検証を要求するように Quarkus を設定します："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:526
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:737
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:832
#, no-wrap
msgid ""
"# Point to the custom roles claim\n"
"quarkus.oidc.roles.role-claim-path=\"https://quarkus-security.com/roles\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:537
#, no-wrap
msgid "quarkus.oidc.token.verify-access-token-with-user-info=true <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:539
#, fuzzy
msgid "Verify access tokens indirectly by using them to request `UserInfo`."
msgstr "アクセストークンを使って `UserInfo` をリクエストすることで、間接的にアクセストークンを検証する。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:541
#, fuzzy
msgid "Update the endpoint code to expect `UserInfo` as opposed to `ID token`:"
msgstr "`ID token` ではなく `UserInfo` を期待するようにエンドポイントのコードを更新する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:553
#, no-wrap
msgid ""
"import io.quarkus.oidc.UserInfo;\n"
"import jakarta.annotation.security.RolesAllowed;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:559
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:785
#, no-wrap
msgid ""
"    @Inject\n"
"    UserInfo userInfo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:566
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"admin\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello, \" + userInfo.getName();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:577
#, fuzzy
msgid "This code will now work both for the authorization code and bearer access token flows."
msgstr "このコードは、認証コードフローとベアラアクセストークンフローの両方で機能する。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:579
#, fuzzy
msgid "Let's go to the OIDC Dev UI where we looked at the access token, enter `/hello` as the `Service Address` in the `Test Service` area and press `With Access Token` and you will get `200`:"
msgstr "アクセストークンを見たOIDC Dev UIに移動し、 `Test Service` のエリアに `Service Address` として `/hello` を入力し、 `With Access Token` を押すと、 `200` が表示される："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:580
#, fuzzy, no-wrap
msgid "Auth0 Dev UI Test Access token"
msgstr "Auth0 Dev UI Test アクセストークン"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:580
#, no-wrap
msgid "auth0-devui-test-accesstoken-200.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:583
#, fuzzy
msgid "To confirm that it really does work, update the test endpoint to allow a `user` role only with `@RolesAllowed(\"user\")`. Try to access the endpoint from OIDC Dev UI again, and you will get the HTTP `403` error. Revert the code back to `@RolesAllowed(\"admin\")` to get the reassuring HTTP `200` status again."
msgstr "本当に動作することを確認するために、テストエンドポイントを更新して、 `@RolesAllowed(\"user\")` で `user` ロールのみを許可するようにしてください。再度OIDC Dev UIからエンドポイントにアクセスしようとすると、HTTP `403` エラーが表示されます。コードを `@RolesAllowed(\"admin\")` に戻すと、再び安心できる HTTP `200` ステータスになります。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:585
#, fuzzy
msgid "When verifying the opaque access token indirecly, by using it to request `UserInfo`, Quarkus will use `UserInfo` as the source of the roles information, if any. As it happens, Auth0 includes the custom role claim which was created earlier in the `UserInfo` response as well."
msgstr "不透明なアクセストークンを間接的に検証する場合、そのトークンを使用して `UserInfo` 、Quarkusはロール情報のソースとして `UserInfo` （もしあれば）を使用します。その結果、Auth0は `UserInfo` のレスポンスに、先に作成されたカスタムロールクレームを含める。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:589
#, fuzzy
msgid "As has already been mentioned in the introduction to this section, the main goal of this section is to explain how Quarkus can verify opaque access tokens. In general, propagating access tokens whose only purpose is to allow retrieving `UserInfo` to services should be avoided unless the frontend JAX-RS endpoint or SPA prefers to delegate UserInfo retrieval to the trusted service."
msgstr "このセクションの冒頭ですでに述べたように、このセクションの主な目的は、Quarkusが不透明なアクセストークンを検証する方法を説明することです。一般的に、 `UserInfo` を取得することのみを目的としたアクセストークンをサービスに伝搬することは、フロントエンドの JAX-RS エンドポイントや SPA が UserInfo の取得を信頼できるサービスに委ねることを好まない限り、避けるべきです。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:591
#, fuzzy
msgid "Please see the following xref:token-propagation[Propagate access tokens to microservices] and xref:jwt-access-tokens[Access tokens in JWT format] sections for a recommended approach of working with Auth0 access tokens."
msgstr "Auth0アクセストークンの推奨される扱い方については、以下の「 xref:token-propagation[Propagate access tokens to microservices] 」と「 xref:jwt-access-tokens[Access tokens in JWT format] 」のセクションを参照してください。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:596
#, fuzzy
msgid "Typically one uses access tokens to access remote services but OIDC DevUI SPA dashboard also offers an option to test with the ID token. This option is only available to emulate the cases where SPA delegates to the endpoint to verify and retrieve some information from the ID token for SPA to use - but ID token will still be sent to the endpoint as Bearer token by OIDC DevUI. Prefer testing with the access token in most cases."
msgstr "通常、リモートサービスへのアクセスにはアクセストークンを使用しますが、OIDC DevUI SPAダッシュボードでは、IDトークンでテストするオプションも提供しています。このオプションは、SPAがエンドポイントに委任して、SPAが使用するためにIDトークンからいくつかの情報を検証して取得するケースをエミュレートするためにのみ利用可能です - しかし、IDトークンは依然としてOIDC DevUIによってベアラートークンとしてエンドポイントに送信されます。ほとんどの場合、アクセストークンでテストすることをお勧めします。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:602
#, fuzzy
msgid "You can use SwaggerUI or GraphQL from OIDC DevUI for testing the service, instead of manually entering the service path to test.  For example, if you add"
msgstr "テストするサービスパスを手動で入力する代わりに、OIDC DevUIからSwaggerUIまたはGraphQLを使用してサービスをテストすることができます。例えば"

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:609
#, no-wrap
msgid ""
"<dependency>\n"
"   <groupId>io.quarkus</groupId>\n"
"   <artifactId>quarkus-smallrye-openapi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:612
#, fuzzy
msgid "to your application's pom then you will see a Swagger link in OIDC Dev UI:"
msgstr "をアプリケーションのpomに追加すると、OIDC Dev UIにSwaggerリンクが表示されます："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:613
#, fuzzy, no-wrap
msgid "Auth0 Dev UI Test with Swagger"
msgstr "Swaggerを使ったAuth0 Dev UIテスト"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:613
#, no-wrap
msgid "auth0-devui-testservice-swagger.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:616
#, fuzzy
msgid "Click on the Swagger link and start testing the service."
msgstr "Swaggerリンクをクリックし、サービスのテストを開始します。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:619
#, fuzzy, no-wrap
msgid "Propagate access tokens to microservices"
msgstr "アクセストークンをマイクロサービスに伝播する"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:622
#, fuzzy
msgid "Now that we have managed to use OIDC authorization code flow and used both ID token and UserInfo to access the user information, the next typical task is to propagate the current Auth0 access token to access the downstream service on behalf of the currently authenticated user."
msgstr "OIDC認証コードフローを使用し、IDトークンとUserInfoの両方を使用してユーザー情報にアクセスすることができたので、次の典型的なタスクは、現在認証されているユーザーの代わりにダウンストリームサービスにアクセスするために、現在のAuth0アクセストークンを伝播することです。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:624
#, fuzzy
msgid "In fact, the last code example, showing the injected `UserInfo`, is a concrete example of the access token propagation, in this case, Quarkus propagates the Auth0 access token to the Auth0 `UserInfo` endpoint to acquire `UserInfo`. Quarkus does it without users having to do anything themselves."
msgstr "実際、最後のコード例（注入された `UserInfo` ）は、アクセストークンの伝播の具体例です。この場合、QuarkusはAuth0アクセストークンをAuth0 `UserInfo` エンドポイントに伝播し、 `UserInfo` を取得します。この場合、QuarkusはAuth0アクセストークンをAuth0  エンドポイントに伝播し、 を取得します。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:626
#, fuzzy
msgid "But what about propagating access tokens to some custom services ? It is very easy to achieve in Quarkus, both for the authorization code and bearer token flows. All you need to do is to create a Reactive REST Client interface for calling the service requiring a Bearer token access and annotate it with `@AccessToken` and the access token arriving to the frontend endpoint as the Auth0 Bearer access token or acquired by Quarkus after completing the Auth0 authorization code flow, will be propagated to the target microservice. This is as easy as it can get."
msgstr "しかし、カスタムサービスへのアクセストークンの伝搬はどうでしょうか？Quarkusでは、認証コードとベアラートークンフローの両方で、非常に簡単に実現できます。必要なのは、ベアラートークンアクセスを必要とするサービスを呼び出すためのReactive REST Clientインターフェースを作成し、 `@AccessToken` 。Auth0ベアラアクセストークンとしてフロントエンドエンドポイントに到着したアクセストークン、またはAuth0認証コードフローを完了した後にQuarkusによって取得されたアクセストークンは、対象のマイクロサービスに伝搬されます。これは非常に簡単です。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:628
#, fuzzy
msgid "Please see xref:security-openid-connect-client-reference.adoc#reactive-token-propagation[OIDC token propagation] for more information about the token propagation and the following sections in this tutorial for a concrete example."
msgstr "トークン伝搬の詳細については xref:security-openid-connect-client-reference.adoc#reactive-token-propagation[OIDCトークン伝搬を] 、具体例についてはこのチュートリアルの以下のセクションを参照してください。"

#. type: Title ===
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:630
#, fuzzy, no-wrap
msgid "Access tokens in JWT format"
msgstr "JWT形式のアクセストークン"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:633
#, fuzzy
msgid "We have already looked in detail at how Quarkus OIDC can handle xref:opaque-access-tokens[Access Quarkus with opaque Auth0 access tokens], but we don't want to propagate Auth0 opaque tokens to micro services which do something useful on behalf on the currently authenticated user, beyond checking its UserInfo."
msgstr "QuarkusのOIDCが、 xref:opaque-access-tokens[不透明なAuth0アクセストークンを持つAccess Quarkusを] どのように処理できるかについては、すでに詳しく見てきましたが、現在認証されているユーザーのUserInfoをチェックするだけでなく、そのユーザーの代わりに何か役に立つことを行うマイクロサービスには、Auth0の不透明なトークンを伝播させたくありません。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:635
#, fuzzy
msgid "A microservice which the frontend Quarkus application will access by propagating authorization code flow access tokens to it is represented in the Auth0 dashboard as an `API`. Lets add it in the `Applications/APIs`:"
msgstr "フロントエンドの Quarkus アプリケーションがアクセスするマイクロサービスは、認証コードフローのアクセストークンを伝播することで、Auth0 ダッシュボードで `API` として表されます。 `Applications/APIs` に追加してみましょう："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:636
#, fuzzy, no-wrap
msgid "Auth0 API"
msgstr "Auth0 API"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:636
#, no-wrap
msgid "auth0-api.png"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:639
#, fuzzy
msgid "The `https://quarkus-auth0` identifier of the created `QuarkusAuth0API` will serve as this API's `audience`. Providing this audience as a query parameter in the authorization code flow redirect to Auth0 will ensure that Auth0 issues access tokens in the JWT format."
msgstr "作成された `https://quarkus-auth0` 作成された `QuarkusAuth0API` の識別子は、この API の `audience` として機能する。Auth0への認可コードフローのリダイレクトのクエリパラメータとしてこのオーディエンスを提供することで、Auth0はJWT形式のアクセストークンを確実に発行する。"

#. type: Title ===
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:640
#, fuzzy, no-wrap
msgid "API microservice"
msgstr "APIマイクロサービス"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:643
#, fuzzy
msgid "Add the following dependencies to the project to support OIDC token propagation and REST clients:"
msgstr "OIDC トークンの伝播と REST クライアントをサポートするために、以下の依存関係をプロジェクトに追加します："

#. type: Block title
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:645
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:959
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:655
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-rest-client-reactive-jackson</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"   <groupId>io.quarkus</groupId>\n"
"   <artifactId>quarkus-oidc-token-propagation-reactive</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:658
#, fuzzy
msgid "Create `ApiEchoService` service class:"
msgstr "`ApiEchoService` サービスクラスを作成する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:668
#, no-wrap
msgid ""
"import io.quarkus.security.Authenticated;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:671
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:862
#, no-wrap
msgid ""
"@Path(\"/echo\")\n"
"public class ApiEchoService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:679
#, no-wrap
msgid ""
"    @POST\n"
"    @Authenticated\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String echoUserName(String username) {\n"
"        return username;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:683
#, fuzzy
msgid "And configure it as an OIDC `service` application which will only fetch public verification keys from Auth0.  The configuration for this microservice should only have a single line:"
msgstr "そしてOIDC `service` アプリケーションとして構成し、Auth0から公開検証鍵のみを取得する。このマイクロサービスのコンフィギュレーションは1行だけでよい："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:687
#, no-wrap
msgid "quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:690
#, fuzzy
msgid "which is all what is needed for the OIDC `service` application to fetch Auth0 public verification keys and use them to verify Auth0 access tokens in JWT format."
msgstr "これは、OIDC `service` アプリケーションがAuth0公開検証鍵を取得し、JWT形式のAuth0アクセストークンを検証するために必要なものすべてである。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:694
#, fuzzy
msgid "In this tutorial you have already configured the OIDC `hybrid` application which can handle both authorization code and bearer token authentication flows. In production you will run microservices as separate servers but for the sake of simplicity `ApiEchoService` will not have to be started as a second server with its own configuration containing `quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com` only, and therefore the current configuration which already has the Auth0 dev tenant address configured will be reused."
msgstr "このチュートリアルでは、認証コードとベアラートークンの両方の認証フローを処理できる OIDC `hybrid` アプリケーションをすでに構成しています。本番環境では、マイクロサービスを別々のサーバーとして実行することになりますが、単純化のために `ApiEchoService` を `quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com` のみを含む独自の構成で第2のサーバーとして起動する必要はありません。したがって、すでに Auth0 dev テナントアドレスが構成されている現在の構成が再利用されます。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:696
#, fuzzy
msgid "The `hybrid` OIDC application type will ensure that `http://localhost:8080/hello` requests to `GreetingResource` initiate an Authorization code flow while `http://localhost:8080/echo` requests to `ApiEchoService`, initiated by `GreetingResource`, will lead to the authorization code flow tokens being propagated and accepted by `ApiEchoService` as bearer JWT access tokens."
msgstr "`hybrid` OIDCアプリケーションタイプは、以下のことを保証する。 `http://localhost:8080/hello` `GreetingResource` リクエストは認証コードフローを開始する。 `http://localhost:8080/echo` 一方、 `GreetingResource` によって開始される `ApiEchoService` へのリクエストは、認可コード・フロー・トークンが伝搬され、 `ApiEchoService` によってベアラ JWT アクセストークンとして受け入れられる。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:699
#, fuzzy
msgid "Next, add a REST client interface representing `ApiEchoService`:"
msgstr "次に、 `ApiEchoService` を表す REST クライアント・インターフェースを追加する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:708
#, no-wrap
msgid ""
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:711
#, no-wrap
msgid ""
"import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n"
"import io.quarkus.oidc.token.propagation.AccessToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:716
#, no-wrap
msgid ""
"@RegisterRestClient\n"
"@AccessToken <1>\n"
"@Path(\"/echo\")\n"
"public interface ApiEchoServiceClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:721
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    String echoUserName(String username);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:723
#, fuzzy
msgid "Propagate access token as an HTTP `Authorization: Bearer accesstoken` header"
msgstr "アクセストークンをHTTPの `Authorization: Bearer accesstoken` ヘッダーとして伝播する"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:725
#, fuzzy
msgid "And update the configuration for the Quarkus frontend application, `GreetingResource`, which has been created earlier, to request that an authorization code flow access token (as opposed to ID token) includes an `aud` (audience) claim targeting `ApiEchoService`, as well as configure the base URL for the `ApiEchoService` REST client:"
msgstr "そして、先に作成されたQuarkusのフロントエンドアプリケーション、 `GreetingResource` の設定を更新し、認証コードフローのアクセストークン（IDトークンとは異なります）に、 `ApiEchoService` をターゲットとする `aud` （オーディエンス）クレームが含まれていることを要求します。また、 `ApiEchoService` RESTクライアントのベースURLも設定します："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:734
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
"quarkus.oidc.application-type=hybrid\n"
"quarkus.oidc.authentication.scopes=profile\n"
"quarkus.oidc.authentication.extra-params.audience=https://quarkus-auth0 <1>\n"
"quarkus.oidc.client-id=sKQu1dXjHB6r0sra0Y1YCqBZKWXqCkly\n"
"quarkus.oidc.credentials.secret=${client-secret}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:748
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:843
#, no-wrap
msgid "quarkus.oidc.token.verify-access-token-with-user-info=true\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:750
#, no-wrap
msgid "org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:${port} <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:755
#, no-wrap
msgid ""
"quarkus.test.native-image-profile=test\n"
"%prod.port=8080\n"
"%dev.port=8080\n"
"%test.port=8081\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:758
#, fuzzy
msgid "Pass an extra `audience` query parameter to the Auth0 authorization endpoint during the authorization code flow redirect from Quarkus to Auth0.  It will ensure that the access token is issued in the JWT format and includes an `aud` (audience) claim which will contain `https://quarkus-auth0`."
msgstr "QuarkusからAuth0への認証コードフローのリダイレクト時に、追加の `audience` クエリパラメータをAuth0の認証エンドポイントに渡します。これにより、アクセストークンがJWT形式で発行され、 `aud` （オーディエンス）クレームが含まれることが保証されます。 `https://quarkus-auth0` ."

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:759
#, fuzzy
msgid "Point `ApiEchoServiceClient` to the `ApiEchoService` endpoint. HTTP port in the `org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:${port}` property is parameterized to ensure the correct URL is built in dev, test and prod modes."
msgstr "`ApiEchoServiceClient` を `ApiEchoService` エンドポイントに向ける。 `org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:${port}` プロパティの HTTP ポートは、dev、test、prod モードで正しい URL が構築されるようにパラメータ化されています。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:761
#, fuzzy
msgid "Finally update `GreetingResource` to request that `ApiEchoService` echoes a user name:"
msgstr "最後に、 `GreetingResource` を更新して、 `ApiEchoService` がユーザー名をエコーするようにリクエストする："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:774
#, no-wrap
msgid ""
"import io.quarkus.oidc.UserInfo;\n"
"import io.quarkus.security.Authenticated;\n"
"import jakarta.annotation.security.RolesAllowed;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:776
#, no-wrap
msgid "import org.eclipse.microprofile.rest.client.inject.RestClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:782
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class GreetingResource {\n"
"    @Inject\n"
"    @RestClient\n"
"    ApiEchoServiceClient echoClient; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:792
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"admin\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello, \" + echoClient.echoUserName(userInfo.getName()); <2>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:802
#, fuzzy
msgid "Inject `ApiEchoServiceClient` REST client"
msgstr "`ApiEchoServiceClient` REST クライアントを注入する"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:803
#, fuzzy
msgid "Use `ApiEchoServiceClient` to echo the user name."
msgstr "ユーザー名をエコーするには `ApiEchoServiceClient` 。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:805
#, fuzzy
msgid "Open a browser, access http://localhost:8080/hello and get your name displayed in the browser."
msgstr "ブラウザーを開き、 link:http://localhost:8080/hello[http://localhost:8080] /hello。"

#. type: Title ===
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:807
#, fuzzy, no-wrap
msgid "Permission Based Access Control"
msgstr "パーミッション・ベースのアクセス制御"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:810
#, fuzzy
msgid "We have discussed in the xref:role-based-access-control[Role Based Access Control] section how to get Quarkus to check a namespace qualified claim containing user roles and use this information to enforce Role Based Access Control. You have configured Auth0 to add the custom roles claim to both ID and access tokens."
msgstr "xref:role-based-access-control[ロールベースのアクセス制御の] セクションで、Quarkusにユーザのロールを含む名前空間修飾されたクレームをチェックさせ、この情報を使用してロールベースのアクセス制御を実施する方法について説明しました。あなたはAuth0を設定し、IDトークンとアクセストークンの両方にカスタムロールクレームを追加しました。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:812
#, fuzzy
msgid "However, Permission Based Access Control is better suited to the case where an access token is propagated by the frontend endpoint to a microservice which will check if a given access token has been authorized for this service to perform a concrete action, as opposed to this token vouching for a user be in a specific role. For example, being in the admin role does not necessarily mean the user is allowed to have a read and write access to some of this microservice's content."
msgstr "しかし、Permission Based Access Controlは、アクセストークンがフロントエンドエンドポイントからマイクロサービスに伝搬され、そのマイクロサービスがアクセストークンを使って具体的なアクションを実行することを許可されているかどうかをチェックする場合に適しています。たとえば、管理者ロールに属しているからといって、そのユーザがマイクロサービスのコンテンツへの読み書きアクセスを許可されているとは限りません。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:814
#, fuzzy
msgid "Let's see how Permission Based Access Control constraints can be applied to `ApiEchoService`."
msgstr "パーミッションに基づくアクセス制御の制約が、 `ApiEchoService` にどのように適用できるかを見てみよう。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:816
#, fuzzy
msgid "Go to the Auth0 dashboard, add an `echo:name` permission to the `QuarkusAuth0API` API:"
msgstr "Auth0ダッシュボードに行き、 `QuarkusAuth0API` APIに `echo:name` パーミッションを追加する："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:817
#, fuzzy, no-wrap
msgid "Auth0 API permissions"
msgstr "Auth0 APIパーミッション"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:817
#, no-wrap
msgid "auth0-api-permissions.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:820
#, fuzzy
msgid "The `echo:name` permission will be included in the access token as a standard OAuth2 `scope` claim value if this scope will also be requested during the authorization code flow. Update the configuration as follows:"
msgstr "このスコープが認可コードフロー中にも要求される場合、 `echo:name` パーミッションは、標準的な OAuth2 `scope` クレーム値としてアクセストークンに含まれます。以下のように設定を更新してください："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:829
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=https://dev-3ve0cgn7.us.auth0.com\n"
"quarkus.oidc.application-type=hybrid\n"
"quarkus.oidc.authentication.scopes=profile,echo:name <1>\n"
"quarkus.oidc.authentication.extra-params.audience=https://quarkus-auth0\n"
"quarkus.oidc.client-id=sKQu1dXjHB6r0sra0Y1YCqBZKWXqCkly\n"
"quarkus.oidc.credentials.secret=${client-secret}\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:845
#, no-wrap
msgid "org.acme.ApiEchoServiceClient/mp-rest/url=http://localhost:8080\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:847
#, fuzzy
msgid "An extra `echo:name` scope will be requested during the authorization code flow."
msgstr "認証コードフロー中に、 `echo:name` の追加スコープが要求される。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:849
#, fuzzy
msgid "Now update `ApiEchoService` to enforce Permission Based Access Control:"
msgstr "次に、 `ApiEchoService` を更新して、Permission Based Access Control を実施する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:859
#, no-wrap
msgid ""
"import io.quarkus.security.PermissionsAllowed;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:870
#, no-wrap
msgid ""
"    @POST\n"
"    @PermissionsAllowed(\"echo:name\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    String echoUserName(String username) {\n"
"        return username;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:873
#, fuzzy
msgid "This is all what is needed as Quarkus OIDC automatically associates `scope` claim values as permissions with the current security identity."
msgstr "Quarkus OIDCは、 `scope` のクレーム値をアクセス許可として現在のセキュリティIDに自動的に関連付けるため、必要なのはこれだけです。"

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:877
#, fuzzy
msgid "You can enforce both Role Based and Permission Based Access Controls in Quarkus by combining `@RolesAllowed` and `@PermissionsAllowed` annotations."
msgstr "Quarkusでは、 `@RolesAllowed` と `@PermissionsAllowed` アノテーションを組み合わせることで、ロールベースとパーミッションベースの両方のアクセス制御を実施できます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:880
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1053
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1074
#, fuzzy
msgid "Open a browser, access http://localhost:8080/hello and get the name displayed in the browser."
msgstr "ブラウザーを開き、 link:http://localhost:8080/hello[http://localhost:8080] /hello。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:882
#, fuzzy
msgid "To confirm the permission is correctly enforced, change it to `echo.name`: `@PermissionsAllowed(\"echo.name\")`. Clear the browser cache, access http://localhost:8080/hello again and you will get `403` reported by `ApiEchoService`. Now revert it back to `@PermissionsAllowed(\"echo:name\")`."
msgstr "パーミッションが正しく適用されていることを確認するには、 `echo.name` : `@PermissionsAllowed(\"echo.name\")` に変更してください。ブラウザのキャッシュをクリアし、 link:http://localhost:8080/hello[http://localhost:8080/hello に] 再度アクセスすると、 `403` に `ApiEchoService` が報告されます。 `@PermissionsAllowed(\"echo:name\")` に戻してください。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:883
#, no-wrap
msgid "Integration testing"
msgstr "統合テスト"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:886
#, fuzzy
msgid "You have already used OIDC DevUI SPA to login to Auth0 and test the Quarkus endpoint with the access token, updating the endpoint code along the way."
msgstr "すでにOIDC DevUI SPAを使用してAuth0にログインし、アクセストークンを使用してQuarkusエンドポイントをテストし、エンドポイントのコードを更新しています。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:888
#, fuzzy
msgid "However, running tests is also essential, lets see how we can test the endpoint and configuration which you have developed during the course of this tutorial, using xref:continuous-testing.adoc[Quarkus Continuous Testing] feature."
msgstr "xref:continuous-testing.adoc[Quarkus の継続的テスト] 機能を使用して、このチュートリアルの過程で開発したエンドポイントと設定をテストする方法を見てみましょう。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:890
#, fuzzy
msgid "Start with the following test code :"
msgstr "次のテスト・コードから始める："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:897
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:900
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:984
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:903
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:995
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:912
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"Hello, Sergey Beryozkin\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:914
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:917
#, fuzzy
msgid "If you recall, when the application was started in devmode, the following could be seen in the CLI window:"
msgstr "思い起こせば、アプリケーションをdevmodeで起動したとき、CLIウィンドウには次のように表示されていた："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:918
#, fuzzy, no-wrap
msgid "Auth0 DevMode started"
msgstr "Auth0 DevMode開始"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:918
#, no-wrap
msgid "auth0-devmode-started.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:921
#, fuzzy
msgid "Press `r` and notice this test failing with `403` which is expected because the test does not send a token to the endpoint:"
msgstr "`r` を押すと、このテストが `403` で失敗することに気づく。これは、このテストがエンドポイントにトークンを送信していないためである："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:922
#, fuzzy, no-wrap
msgid "Auth0 test failure 403"
msgstr "Auth0テストの失敗 403"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:922
#, no-wrap
msgid "auth0-test-failure-403.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:925
#, fuzzy
msgid "Before fixing the test, let's review the options available for testing Quarkus endpoints secured by OIDC. These options may vary depending on what flow your application supports and how you prefer to test. Endpoints which use OIDC authorization code flow can be tested using xref:security-oidc-code-flow-authentication#integration-testing[one of these options] and endpoints which use Bearer token authentication can be tested using xref:security-oidc-bearer-token-authentication#integration-testing[one of these options]."
msgstr "テストを修正する前に、OIDCによって保護されたQuarkusエンドポイントをテストするために利用可能なオプションを確認しましょう。これらのオプションは、アプリケーションがどのフローをサポートしているか、また、どのようにテストを行うかによって異なります。OIDC 認証コードフローを使用するエンドポイントは、 xref:security-oidc-code-flow-authentication.adoc#integration-testing[これらのオプションのいずれ] かを使用してテストでき、ベアラートークン認証 を使用するエンドポイントは、 xref:security-oidc-bearer-token-authentication.adoc#integration-testing[これらのオプションの] いずれかを使用してテストできます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:927
#, fuzzy
msgid "As you can see, testing of the endpoints secured with Auth0 can be done with the help of `Wiremock`, or `@TestSecurity` annotation. Please experiment with writing such tests on your own and reach out if you encounter any problems."
msgstr "ご覧のように、Auth0で保護されたエンドポイントのテストは、 `Wiremock` 、または `@TestSecurity` アノテーションの助けを借りて行うことができます。このようなテストを自分で書いてみて、問題があれば連絡してください。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:929
#, fuzzy
msgid "In this tutorial though, we will use a recently added `OidcTestClient` to support testing endpoints which use live Auth0 development tenants."
msgstr "しかし、このチュートリアルでは、最近追加された `OidcTestClient` を使用して、ライブの Auth0 開発用テナントを使用するテスト用エンドポイントをサポートします。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:931
#, fuzzy
msgid "Here is a related fragment of the configuration:"
msgstr "以下は関連するコンフィギュレーションの一部である："

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:942
#, fuzzy
msgid "In production, you will distinguish between prod and test level configuration with `%prod.` and `%test.` qualifiers. Lets assume that the above configuration will indeed be prefixed with `%test.` in your real application, with this configuration also including the `%prod.` qualified Auth0 production tenant configuration."
msgstr "本番環境では、 `%prod.` と `%test.` の修飾子で、prod と test レベルの構成を区別します。実際のアプリケーションでは、上記の構成の先頭に `%test.` が付くと仮定します。この構成には、 `%prod.` 修飾のAuth0本番テナント構成も含まれます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:944
#, fuzzy
msgid "Using `OidcTestClient` to test such configuration requires acquiring a token from the Auth0 dev tenant, using either OAuth2 `password` or `client_credentials` grant, we will try a `password` grant. Make sure the application registered in the Auth0 dashboard allows the `password` grant:"
msgstr "このような設定をテストするために `OidcTestClient` を使用するには、OAuth2 `password` または `client_credentials` グラントを使用して Auth0 dev テナントからトークンを取得する必要があります。ここでは `password` グラントを試してみます。Auth0 ダッシュボードに登録されているアプリケーションが `password` グラントを許可していることを確認してください："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:945
#, fuzzy, no-wrap
msgid "Auth0 password grant"
msgstr "Auth0 パスワード付与"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:945
#, no-wrap
msgid "auth0-password-grant.png"
msgstr ""

#. type: delimited block =
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:950
#, fuzzy
msgid "It is important to clarify that we do not recommend using the deprecated OAuth2 `password` token grant in production. However using it can help testing the endpoint with tokens acquired from the live dev Auth0 tenant."
msgstr "OAuth2 `password` のトークングラントを本番環境で使用することはお勧めしません。しかし、Auth0 テナントから取得したトークンを使ってエンドポイントをテストするのには役立ちます。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:953
#, fuzzy
msgid "`OidcTestClient` should be used to test applications accepting bearer tokens which will work for the endpoint developed in this tutorial as it supports both authorization code flow and bearer token authentication. You would need to use OIDC WireMock or `HtmlUnit` directly against the Auth0 dev tenant if only the authorization code flow was supported - in the latter case `HtmlUnit` test code would have to be aligned with how Auth0 challenges users to enter their credentials - please copy and paste an xref:security-oidc-code-flow-authentication#integration-testing-wiremock[HtmlUnit test fragment] from the documentation and experiment if you would like."
msgstr "`OidcTestClient` は、認証コードフローとベアラートークン認証の両方をサポートしているため、このチュートリアルで開発したエンドポイントで動作するベアラートークンを受け付けるアプリケーションのテストに使用する必要があります。認証コードフローのみをサポートしている場合は、OIDC WireMockを使用するか、Auth0開発テナントに対して直接 。後者の場合は、 。テストコードは、Auth0がユーザーに認証情報の入力を要求する方法に合わせる必要があります。ドキュメントにある `HtmlUnit` `HtmlUnit` xref:security-oidc-code-flow-authentication.adoc#integration-testing-wiremock[HtmlUnitテストフラグメントを] コピー＆ペーストして、実験してみてください。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:955
#, fuzzy
msgid "In meantime we will now proceed with fixing the currently failing test using `OidcTestClient`."
msgstr "その間に、 `OidcTestClient` を使って、現在失敗しているテストの修正を進めよう。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:957
#, fuzzy
msgid "First you must add the following dependency:"
msgstr "まず、以下の依存関係を追加する必要がある："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:966
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-oidc-server</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:969
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:972
#, no-wrap
msgid "testImplementation(\"io.quarkus:quarkus-test-oidc-server\")\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:975
#, fuzzy
msgid "which provides a utility class `io.quarkus.test.oidc.client.OidcTestClient` which can be used in tests for acquiring access tokens (This dependency also offers an OIDC WireMock support - please review the documentation how to use it for testing if you would like)."
msgstr "`io.quarkus.test.oidc.client.OidcTestClient` この依存関係はOIDC WireMockのサポートも提供しています - もしよろしければ、テストに使用する方法をドキュメントで確認してください）。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:977
#, fuzzy
msgid "Now update the test code like this:"
msgstr "テストコードを次のように更新する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:986
#, no-wrap
msgid "import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:989
#, no-wrap
msgid ""
"import org.junit.jupiter.api.AfterAll;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:992
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.oidc.client.OidcTestClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:997
#, no-wrap
msgid "    static OidcTestClient oidcTestClient = new OidcTestClient();\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1002
#, no-wrap
msgid ""
"    @AfterAll\n"
"    public static void close() {\n"
"        client.close();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1012
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .auth().oauth2(getAccessToken(`sberyozkin@gmail.com`, \"userpassword\"))\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"Hello, Sergey Beryozkin\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1019
#, no-wrap
msgid ""
"    private String getAccessToken(String name, String secret) {\n"
"        return oidcTestClient.getAccessToken(name, secret, <1>\n"
"            Map.of(\"audience\", \"https://quarkus-auth0\",\n"
"\t           \"scope\", \"openid profile\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1021
#, fuzzy
msgid "`OidcTestClient` is used to acquire an access token, using one of the registered user's name and password, as well as the `audience` and `scope` parameters."
msgstr "`OidcTestClient` はアクセストークンを取得するために使用され、登録されたユーザー名とパスワード、 と パラメーターのいずれかを使用する。 `audience` `scope` "

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1023
#, fuzzy
msgid "`OidcTestClient` will itself find out the `Auth0` token endpoint address, client id and secret."
msgstr "`OidcTestClient` は、 トークンのエンドポイントアドレス、クライアント ID、およびシークレットを調べます。 `Auth0` "

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1025
#, fuzzy
msgid "Press `r` again and have the test passing:"
msgstr "もう一度 `r` ："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1026
#, fuzzy, no-wrap
msgid "Auth0 test success"
msgstr "Auth0テスト成功"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1026
#, no-wrap
msgid "auth0-test-success.png"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1029
#, fuzzy
msgid "By the way, if you would like you can run the tests in Continuous mode directly from DevUI:"
msgstr "ちなみに、DevUIから直接Continuousモードでテストを実行することもできる："

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1030
#, fuzzy, no-wrap
msgid "Auth0 Continuous testing"
msgstr "Auth0 継続的テスト"

#. type: Target for macro image
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1030
#, no-wrap
msgid "auth0-continuous-testing.png"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1033
#, no-wrap
msgid "Production mode"
msgstr "プロダクションモード"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1038
#, fuzzy
msgid "You have developed and tested the Quarkus endpoint secured with Auth0 in the development mode.  The next step is to run your application in the production mode.  Choose between JVM and native modes."
msgstr "開発モードで、Auth0 で保護された Quarkus エンドポイントを開発し、テストしました。次のステップは、本番モードでアプリケーションを実行することです。JVM モードとネイティブモードのいずれかを選択します。"

#. type: Title ===
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1039
#, no-wrap
msgid "Run the Application in JVM mode"
msgstr "JVMモードでアプリケーションを実行"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1042
msgid "Compile the application:"
msgstr "アプリケーションをコンパイルします:"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1046
msgid "Run the application:"
msgstr "アプリケーションの実行:"

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1050
#, no-wrap
msgid "java -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Title ===
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1054
#, fuzzy, no-wrap
msgid "Run the application in native mode"
msgstr "ネイティブ・モードでアプリケーションを実行する"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1059
#, fuzzy
msgid "You can compile this same demo into native mode without needing any modifications.  This implies that you no longer need to install a JVM on your production environment.  The runtime technology is included in the produced binary and optimized to run with minimal resources required."
msgstr "この同じデモを、何の修正も必要とせずにネイティブ・モードにコンパイルすることができる。これは、本番環境にJVMをインストールする必要がないことを意味する。ランタイム・テクノロジーは生成されたバイナリに含まれており、必要最小限のリソースで実行できるように最適化されている。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1061
#, fuzzy
msgid "Compilation takes a bit longer, so this step is disabled by default."
msgstr "コンパイルには少し時間がかかるので、このステップはデフォルトでは無効になっている。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1063
#, fuzzy
msgid "Build your application again by enabling the `native` profile:"
msgstr "`native` プロファイルを有効にして、アプリケーションを再度構築してください："

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1067
#, fuzzy
msgid "Next run the following binary directly:"
msgstr "次に以下のバイナリを直接実行する："

#. type: delimited block -
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1071
#, no-wrap
msgid "./target/quarkus-auth0-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1075
#, fuzzy, no-wrap
msgid "Troubleshooting"
msgstr "トラブルシューティング"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1078
#, fuzzy
msgid "The steps described in this tutorial should work exactly as the tutorial describes. You may have to clear the browser cookies when accessing the updated Quarkus endpoint if you have already completed the authentication. You might need to restart the Quarkus application manually in devmode but it is not expected. Please get in touch with the Quarkus team if you need help completing this tutorial."
msgstr "このチュートリアルで説明されている手順は、チュートリアルの説明どおりに動作するはずです。すでに認証が完了している場合、更新されたQuarkusエンドポイントにアクセスする際にブラウザのクッキーをクリアする必要があるかもしれません。devmodeでQuarkusアプリケーションを手動で再起動する必要があるかもしれませんが、これは想定されていません。このチュートリアルを完了するためにサポートが必要な場合は、Quarkusチームに連絡してください。"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1079
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1088
#, fuzzy
msgid "This tutorial demonstrated how Quarkus endpoints can be secured with the `quarkus-oidc` extension and Auth0 using Authorization code and Bearer token authentication flows, with both flows being supported by the same endpoint code.  Without writing a single line of code, you have added support for the custom Auth0 logout flow and enabled role-based access control with a custom Auth0 namespace qualified claim.  Token propagation from the frontend endpoint to the microservice endpoint has been achieved by adding the `@AccessToken` annotation to the microservice REST client.  Microservice endpoint activated the permission-based access control with the `@PermissionsAllowed` annotation.  You used Quarkus dev mode to update the code and configuration without restarting the endpoint, and you also used the OIDC Dev UI to visualize and test Auth0 tokens.  You used the continuous testing feature of Quarkus to complement OIDC Dev UI tests with integration tests against the live Auth0 development tenant.  Finally, you have run the application in JVM and native modes."
msgstr "このチュートリアルでは、Authorization コードと Bearer トークン認証フローを使用して、 `quarkus-oidc` 拡張と Auth0 を使用して Quarkus エンドポイントを保護する方法を示しました。コードを1行も記述することなく、カスタムAuth0ログアウトフローのサポートが追加され、カスタムAuth0名前空間修飾クレームによるロールベースのアクセス制御が可能になりました。フロントエンドエンドポイントからマイクロサービスエンドポイントへのトークン伝搬は、 `@AccessToken` アノテーションをマイクロサービス REST クライアントに追加することで実現しました。マイクロサービスエンドポイントは、 `@PermissionsAllowed` アノテーションを使用して許可ベースのアクセス制御を有効にしました。Quarkusの開発モードを使用して、エンドポイントを再起動せずにコードと設定を更新し、OIDC Dev UIを使用してAuth0トークンを視覚化してテストしました。Quarkusの継続的テスト機能を使用して、OIDC Dev UIのテストを、Auth0開発用テナントに対する統合テストで補完しました。最後に、アプリケーションを JVM とネイティブモードで実行しました。"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1090
msgid "Enjoy!"
msgstr "楽しんで!"

#. type: Title ==
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1091
#, no-wrap
msgid "References"
msgstr "参照"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1093
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "xref:security-overview.adoc[Quarkus Securityの概要]"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1094
msgid "xref:security-oidc-code-flow-authentication.adoc[OIDC code flow mechanism for protecting web applications]"
msgstr "xref:security-oidc-code-flow-authentication.adoc[ウェブアプリケーションを保護するOIDCコードフローメカニズム]"

#. type: Plain text
#: upstream/_versions/main/guides/security-oidc-auth0-tutorial.adoc:1094
#, fuzzy
msgid "xref:security-openid-connect-providers.adoc[Configuring well-known OpenID Connect providers]"
msgstr "xref:security-openid-connect-providers.adoc[よく知られたOpenID Connectプロバイダーの設定]"
