msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This guide is a companion to the\n"
"xref:building-native-image.adoc[Building a Native Executable],\n"
"xref:native-and-ssl.adoc[Using SSL With Native Images],\n"
"and xref:writing-native-applications-tips.adoc[Writing Native Applications],\n"
"guides.\n"
"It explores advanced topics that help users diagnose issues,\n"
"increase the reliability and improve the runtime performance of native executables.\n"
"These are the high level sections to be found in this guide:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Memory management for Quarkus native executables is enabled by GraalVM’s SubstrateVM runtime system.\n"
"The memory management component in GraalVM is explained in detail\n"
"link:https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[here].\n"
"This guide complements the information available in the GraalVM website with further observations particularly relevant to Quarkus applications."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Serial GC, the default option in GraalVM and Quarkus, is a single-threaded non-concurrent GC, just like HotSpot’s Serial GC.\n"
"The implementation in GraalVM however is different from the HotSpot one,\n"
"and there can be significant differences in the runtime behavior."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"One of the key differences between HotSpot’s Serial GC and GraalVM’s Serial GC is the way they perform full GC cycles.\n"
"In HotSpot the algorithm used is mark-sweep-compact whereas in GraalVM it is mark-copy.\n"
"Both need to traverse all live objects,\n"
"but in mark-copy this traversal is also used to copy live objects to a secondary space or semi-space.\n"
"As objects are copied from one semi-space to another they’re also compacted.\n"
"In mark-sweep-compact, the compacting requires a second pass on the live objects.\n"
"This makes full GCs in mark-copy more time efficient (in terms of time spent in each GC cycle) than mark-sweep-compact.\n"
"The tradeoff mark-copy makes in order to make individual full GC cycles shorter is space.\n"
"The use of semi-spaces means that for an application to maintain the same GC performance that mark-sweep achieves (in terms of allocated MB per second),\n"
"it requires double the amount of memory."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The “adaptive” collection policy is based on HotSpot's ParallelGC adaptive size policy.\n"
"The main difference with HotSpot is GraalVM's focus on memory footprint.\n"
"This means that GraalVM’s adaptive GC policy tries to aggressively trigger GCs in order to keep memory consumption down."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Up to version 2.13, Quarkus used the “space/time” GC collection policy by default,\n"
"but starting with version 2.14, it switched to using the “adaptive” policy instead.\n"
"The reason why Quarkus initially chose to use \"space/time\" is because at that time it had considerable performance improvements over \"adaptive\".\n"
"Recent performance experiments, however, indicate that the \"space/time\" policy can result in worse out-of-the-box experience compared to the \"adaptive\" policy,\n"
"while at the same time the benefits it used to offer have diminished considerably after improvements made to the \"adaptive\" policy.\n"
"As a result, the \"adaptive\" policy appears to be the best option for most, if not all, Quarkus applications.\n"
"Full details on this switch can be read in link:https://github.com/quarkusio/quarkus/issues/28267[this issue]."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"It is still possible to change the GC collection policy using GraalVM’s `-H:InitialCollectionPolicy` flag.\n"
"Switching to the \"space/time\" policy can be done by passing the following via command line:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Escaping the `$` character is required to configure the \"space/time\" GC collection policy if passing via command line in Bash.\n"
"Other command line environments might have similar requirements."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Epsilon GC is a no-op garbage collector which does not do any memory reclamation.\n"
"From a Quarkus perspective, some of the most relevant use cases for this garbage collector are extremely short-lived jobs, e.g. serverless functions.\n"
"To build Quarkus native with epsilon GC, pass the following argument at build time:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Options to control maximum heap size, young space and other typical use cases found in the JVM can be found in\n"
"https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/optimizations-and-performance/MemoryManagement[the GraalVM memory management guide].\n"
"Setting the maximum heap size, either as a percentage or an explicit value, is generally recommended."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Multiple options exist to print information about garbage collection cycles, depending on the level of detail required.\n"
"The minimum detail is provided `-XX:+PrintGC`, which prints a message for each GC cycle that occurs:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"When you combine this option with `-XX:+VerboseGC` you still get a message per GC cycle,\n"
"but it contains extra information.\n"
"Also, adding this option shows the sizing decisions made by the GC algorithm at startup:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"It takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].\n"
"You can find instructions on how to quickly set up this application in this guide."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This guide builds and executes Quarkus native executables within a Linux environment.\n"
"To offer a homogeneous experience across all environments,\n"
"the guide relies on a container runtime environment to build and run the native executables.\n"
"The instructions below use Docker as example, but very similar commands should work on alternative container runtimes, e.g. podman."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Building native executables is an expensive process,\n"
"so make sure the container runtime has enough CPU and memory to do this.\n"
"A minimum of 4 CPUs and 4GB of memory is required."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Finally, this guide assumes the use of the link:https://github.com/graalvm/mandrel[Mandrel distribution] of GraalVM for building native executables,\n"
"and these are built within a container so there is no need for installing Mandrel on the host."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Start by creating a new Quarkus project.\n"
"Open a terminal and run the following command:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Some Quarkus configuration options will be used constantly throughout this debugging guide,\n"
"so to help declutter command line invocations,\n"
"it's recommended to add these options to the `application.properties` file.\n"
"So, go ahead and add the following options to that file:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Starting with 22.3, Mandrel does not provide a `-java11` version anymore.\n"
"Note, however,  that this doesn't mean that you may no longer produce native executables with Mandrel for Java 11 projects.\n"
"You can still compile your Java 11 projects using OpenJDK 11 and produce native executables from the resulting Java 11 bytecode using the `-java17` Mandrel builder images."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The rest of this section explores ways to build the native executable with extra information,\n"
"but first, stop the running application.\n"
"We can obtain this information while building the native executable by adding additional native-image build options using `-Dquarkus.native.additional-build-args`, e.g."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Note that `/project` is a folder within the container that is building the native executable.\n"
"So, this is not a folder that you will find in the host environment.\n"
"`/project` folder is mapped to `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar`,\n"
"so you will find the files under the `reports` folder in that directory."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The target info file contains information such as the target platform,\n"
"the toolchain used to compile the executable,\n"
"and the C library in use:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Even more detail can be obtained by passing in `--verbose` as an additional native-image build argument.\n"
"This option can be very useful in detecting whether the options that you pass at a high level via Quarkus are being passed down to the native executable production,\n"
"or whether some third party jar has some native-image configuration embedded in it that is reaching the native-image invocation:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The first is a very short Java process that does some basic validation and builds the arguments for the second process\n"
"(in a stock GraalVM distribution, this is executed as native code)."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The second Java process is where the main part of the native executable production happens.\n"
"The `--verbose` option shows the actual Java process executed.\n"
"You could take the output and run it yourself."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Remember that if an argument for `-Dquarkus.native.additional-build-args` includes the `,` symbol,\n"
"it needs to be escaped to be processed correctly, e.g. `\\\\,`."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Given a native executable, various Linux tools can be used to inspect it.\n"
"To allow supporting a variety of environments,\n"
"inspections will be done from within a Linux container.\n"
"Let's create a Linux container image with all the tools required for this guide:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Finally, using `readelf` we can inspect different sections of the binary.\n"
"For example, we can see how the heap and text sections take most of the binary:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Runtime containers produced by Quarkus to run native executables will not include the tools mentioned above.\n"
"To explore a native executable within a runtime container,\n"
"it's best to run the container itself and then `docker cp` the executable locally, e.g.:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The reports will be created under `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/`.\n"
"These reports are some of the most useful resources when encountering issues with missing methods/classes, or encountering forbidden methods by Mandrel."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"`call_tree` csv file reports are some of the default reports generated when the `-Dquarkus.native.enable-reports` option is passed in.\n"
"These csv files can be imported into a graph database, such as Neo4j,\n"
"to inspect them more easily and run queries against the call tree.\n"
"This is useful for getting an approximation on why a method/class is included in the binary."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Once the container is running,\n"
"you can access the link:http://localhost:7474[Neo4j browser].\n"
"Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"To import the CSV files,\n"
"we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Mandrel 22.0.0 contains a bug where the symbolic links used by the import cypher file are not correctly set when generating reports within a container\n"
"(for more details see link:https://github.com/oracle/graal/issues/4355[here]).\n"
"This can be worked around by copying the following script into a file and executing it:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Once the import completes (shouldn't take more than a couple of minutes), go to the link:http://localhost:7474[Neo4j browser],\n"
"and you'll be able to observe a small summary of the data in the graph:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The data above shows that there are ~60000 methods, and just over ~200000 edges between them.\n"
"The Quarkus application demonstrated here is very basic, so there’s not a lot we can explore, but here are some example queries you can run to explore the graph in more detail.\n"
"Typically, you’d start by looking for a given method:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Once you’ve located the node for the specific method you’re after, a typical question you’d want to get an answer for is:\n"
"why does this method get included in the call tree?\n"
"To do that, start from the method and look for incoming connections at a given depth,\n"
"starting from the end method.\n"
"For example, methods that directly call a method can be located via:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Then you can look for direct calls at depth of 2,\n"
"so you’d search for methods that call methods that call into the target method:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"You can continue going up layers,\n"
"but unfortunately if you reach a depth with too many nodes,\n"
"the Neo4j browser will be unable to visualize them all.\n"
"When that happens, you can alternatively run the queries directly against the cypher shell:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"For further information, check out this\n"
"link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[blog post]\n"
"that explores the Quarkus Hibernate ORM quickstart using the techniques explained above."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"`used_packages`, `used_classes` and `used_methods` text file reports come in handy when comparing different versions of the application,\n"
"e.g. why does the image take longer to build? Or why is the image bigger now?"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Mandrel can produce further reports beyond the ones that are enabled with the `-Dquarkus.native.enable-reports` option.\n"
"These are called expert options and you can learn more about them by running:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"These expert options are not considered part of the GraalVM native image API,\n"
"so they might change anytime."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Quarkus instructs Mandrel to initialize as much as possible at build time,\n"
"so that runtime startup can be as fast as possible.\n"
"This is important in containerized environments where the startup speed has a big impact on how quickly an application is ready to do work.\n"
"Build time initialization also minimizes the risk of runtime failures due to unsupported features becoming reachable through runtime initialization,\n"
"thus making Quarkus more reliable."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The most common examples of build-time initialized code are static variables and blocks.\n"
"Although Mandrel executes those at run-time by default,\n"
"Quarkus instructs Mandrel to run them at build-time for the reasons given."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This means that any static variables initialized inline, or initialized in a static block,\n"
"will keep the same value even if the application is restarted.\n"
"This is a different behaviour compared to what would happen if executed as Java."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"To see this in action with a very basic example,\n"
"add a new `TimestampResource` to the application that looks like this:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Run the application in one terminal\n"
"(make sure you stop any other native executable container runs before executing this):"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"to see how the current time has been baked into the binary.\n"
"This time was calculated when the binary was being built,\n"
"hence application restarts have no effect."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"In some situations, built time initializations can lead to errors when building native executables.\n"
"One example is when a value gets computed at build time which is forbidden to reside in the heap of the JVM that gets baked into the binary.\n"
"To see this in action, add this REST resource:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"So, what the message above is telling us is that our application caches a value that is supposed to be random as a constant.\n"
"This is not desirable because something that's supposed to be random is no longer so,\n"
"because the seed is baked in the image.\n"
"The message above makes it quite clear what is causing this,\n"
"but in other situations the cause might be more obfuscated.\n"
"As a next step, we'll add some extra flags to the native executable generation to get more information."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The error messages point to the code in the example,\n"
"but it can be surprising that a reference to `DnsClient` appears.\n"
"Why is that?\n"
"The key is in what happens inside `KeyPairGenerator.initialize()` method call.\n"
"It uses `JCAUtil.getSecureRandom()` which is why this is problematic,\n"
"but sometimes the tracing options can show some stack traces that do not represent what happens in reality.\n"
"The best option is to dig through the source code and use tracing output for guidance but not as full truth."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Moving the `KEY_PAIR_GEN.initialize(1024);` call to the run-time executed method `encryptDecrypt` is enough to solve this particular issue.\n"
"Rebuild the application and verify that encrypt/decrypt endpoint works as expected by sending any message and check if the reply is the same as the incoming message:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"In this exercise, we profile the runtime behaviour of some Quarkus application that was compiled to a native executable to determine where the bottleneck is.\n"
"Assume that you’re in a scenario where profiling the pure Java version is not possible, maybe because the issue only occurs with the native version of the application."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Add a REST resource with the following code\n"
"(example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"However, the question we’re trying to answer here is:\n"
"what would be the bottleneck of such code?\n"
"Is it appending the characters? Is it deleting it? Is it checking whether the thread is alive?"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Since we're dealing with a linux native executable,\n"
"we can use tools like `perf` directly.\n"
"To use `perf`,\n"
"go to the root of the project and start the tools container created earlier as a privileged user:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Note that in order to use `perf` to profile the native executables in the guide,\n"
"the container needs to run as privileged, or with `--cap-add sys_admin`.\n"
"Please note that privileged containers are **NOT** recommended in production, so use this flag with caution!"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The kernel modifications above also apply to Linux virtual machines.\n"
"If running on a bare metal Linux machine,\n"
"tweaking only `perf_event_paranoid` is enough."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The `perf record` command above takes `1009` samples per second.\n"
"Increasing this value means more samples are gathered,\n"
"which can end up affecting the runtime performance.\n"
"This also increases the amount of data generated.\n"
"The more data generated, the longer it takes to process it,\n"
"but the more precision you get on what the application is doing.\n"
"So, finding the right value is a balancing act."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"After a few seconds, halt the `perf record` process.\n"
"This will generate a `perf.data` file.\n"
"We could use `perf report` to inspect the perf data,\n"
"but you can often get a better picture showing that data as a flame graph.\n"
"To generate flame graphs, we will use\n"
"https://github.com/brendangregg/FlameGraph[FlameGraph GitHub repository],\n"
"which has already been installed inside the tools container."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The flame graph is a svg file that a web browser, such as Firefox, can easily display.\n"
"After the above two commands complete one can open `flamegraph.svg` in their browser:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"We see a big majority of time spent in what is supposed to be our main,\n"
"but we see no trace of the `StringBuilderResource` class,\n"
"nor the `StringBuilder` class we're calling.\n"
"We should look at the symbol table of the binary:\n"
"can we find symbols for our class and `StringBuilder`?\n"
"We need those in order to get meaningful data.\n"
"From within the tools container, query the symbol table:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"No output appears when querying the symbol table.\n"
"This is why we don't see any call graphs in the flame graphs.\n"
"This is a deliberate decision that native-image makes.\n"
"By default, it removes symbols from the binary."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"To regain the symbols, we need to rebuild the binary instructing GraalVM not to delete the symbols.\n"
"On top of that, enable DWARF debug info so that the stack traces can be populated with that information.\n"
"From outside the tools container, execute:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Next, re-enter the tools container if you exited,\n"
"and inspect the native executable with `objdump`,\n"
"and see how the symbols are now present:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Then, run the executable through perf,\n"
"*indicating that the call graph is dwarf*:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The flamegraph now shows where the bottleneck is.\n"
"It's when `StringBuilder.delete()` is called which calls `System.arraycopy()`.\n"
"The issue is that 1 million characters need to be shifted in very small increments:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Multithreaded programs might require special attention when trying to understand their runtime behaviour.\n"
"To demonstrate this, add this `MulticastResource` code to your project\n"
"(example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The flamegraph produced looks odd. Each thread is treated independently even though they all do the same work.\n"
"This makes it difficult to have a clear picture of the bottlenecks in the program."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This is happening because from a `perf` perspective, each thread is a different command.\n"
"We can see that if we inspect `perf report`:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This can be worked around by applying some modifications to the perf output,\n"
"in order to make all threads have the same name. E.g."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"When you open the flamegraph, you will see all threads' work collapsed into a single area.\n"
"Then, you can clearly see that there's some locking that could affect performance."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"One of the drawbacks of using native executables is that they cannot be debugged using the standard Java debuggers,\n"
"instead we need to debug them using `gdb`, the GNU Project debugger.\n"
"To demonstrate how to do this,\n"
"we are going to generate a native Quarkus application that crashes due to a Segmentation Fault when accessing http://localhost:8080/crash.\n"
"To achieve this, add the following REST resource to the project:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This code will try to copy 256 bytes from address `0x0` to `0x80` resulting in a Segmentation Fault.\n"
"To verify this, compile and run the example application:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The omitted output above contains clues to what caused the issue,\n"
"but in this exercise we are going to assume that no information was provided.\n"
"Let’s try to debug the segmentation fault using `gdb`.\n"
"To do that, go to the root of the project and enter the tools container:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This is because we didn’t compile the Quarkus application with `-Dquarkus.native.debug.enabled`,\n"
"so `gdb` cannot find debugging symbols for our native executable,\n"
"as indicated by the \"_No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" message in the beginning of `gdb`."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Recompiling the Quarkus application with `-Dquarkus.native.debug.enabled` and rerunning it through `gdb` we are now able to get a backtrace making clear what caused the crash.\n"
"On top of that, add `-H:-OmitInlinedMethodDebugLineInfo` option to avoid inlined methods being omitted from the backtrace:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"We already see that `gdb` is able to tell us which method caused the crash and where it’s located in the source code.\n"
"We can also get a backtrace of the call graph that led us to this state:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"This is because `gdb` is not aware of the location of the source files.\n"
"We are running the executable outside the target directory.\n"
"To fix this we can either rerun `gdb` from the target directory or,\n"
"run `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` e.g.:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"We can now examine line `169` and get a first hint of what might be wrong\n"
"(in this case we see that it fails at the first read from src which contains the address `0x0000`),\n"
"or walk up the stack using `gdb`’s `up` command to see what part of our code led to this situation.\n"
"To learn more about using gdb to debug native executables see\n"
"https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/[here]."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Native executable generation is a multi-step process.\n"
"The analysis and compile steps are the most expensive of all and hence the ones that dominate the time spent generating the native executable."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"In the analysis phase, a static points-to analysis starts from the main method of the program to find out what is reachable.\n"
"As new classes are discovered, some of them will be initialized during this process depending on the configuration.\n"
"In the next step, the heap is snapshotted and checks are made to see which types need to be available at runtime.\n"
"The initialization and heap snapshotting can cause new types to be discovered, in which case the process is repeated.\n"
"The process stops when a fixed point is reached, that is when the reachable program grows no more."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The time spent in analysis and compilation phases depends on how big the application is.\n"
"The bigger the application, the longer it takes to compile it.\n"
"However, there are certain features that can have an exponential effect.\n"
"For example, when registering types and methods for reflection access,\n"
"the analysis can’t easily see what’s behind those types or methods,\n"
"so it has to do more work to complete the analysis step."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Building native executables is not only time consuming, but it also takes a fair amount of memory.\n"
"For example, building a sample native Quarkus JPA application such as the Hibernate quickstart,\n"
"may use 6GB to 8GB resident set size in memory.\n"
"A big chunk of this memory is Java heap,\n"
"but extra memory is required for other aspects of the JVM that runs the native building process.\n"
"It is still possible to build such applications in environments that have total memory close to the limits,\n"
"but to do that it is necessary to shrink the maximum heap size of the GraalVM native image process.\n"
"To do that, set a maximum heap size using the `quarkus.native.native-image-xmx` property.\n"
"For example, we can instruct GraalVM to use 5GB of maximum heap size by passing in\n"
"`-Dquarkus.native.native-image-xmx=5g` in the command line."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Building native executables this way might have the side effect of requiring more time to complete.\n"
"This is due to garbage collection having to work harder for native image generation to have free space to do its job."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Note that typical applications are likely bigger than quickstarts,\n"
"so the memory requirements will also likely be higher."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"As with most things in life there are some trade-offs involved when choosing native compilation over JVM mode.\n"
"So depending on the application the runtime performance of a native application might be slower compared to JVM mode,\n"
"though that’s not always the case."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"JVM execution of an application includes runtime optimization of the code that profits from profile information built up during execution.\n"
"That includes the opportunities to inline a lot more of the code,\n"
"locate hot code on direct paths (i.e. ensure better instruction cache locality)\n"
"and cut out a lot of the code on cold paths (on the JVM a lot of code does not get compiled until something tries to execute it -- it is replaced with a trap that causes deoptimization and recompilation).\n"
"Removal of cold paths provides many more optimization opportunities than are available for ahead of time compilation because it significantly reduces the branch complexity and combinatorial logic of the smaller amount of hot code that is compiled."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"By contrast, native executable compilation has to cater for all possible execution paths when it compiles code offline since it does not know which are the hot or cold paths and cannot use the trick of planting a trap and recompiling if it is hit. For the same reason it cannot load the dice to ensure that code cache conflicts are minimized by co-locating hot paths adjacent.\n"
"Native executable generation is able to remove some code because of the closed world hypothesis but that is often not enough to make up for all the benefits that profiling and runtime deopt & recompile provides to the JVM JIT compiler."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"An implication of 1) is that for small, short-lived applications a native executable may well be a better bet.\n"
"Although the compiled code is not as well optimized it is available straight away."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The reason for 2) is that the JVM is essentially running the compiler at runtime in parallel with the application itself.\n"
"In the case of native executables the compiler is run ahead of time removing the need to run the compiler in parallel with the application."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"There are several reasons for 3). The JVM does not have a closed world assumption.\n"
"So, it has to be able to recompile code if loading of new classes implies that it needs to revise optimistic assumptions made at compile time.\n"
"For example, if an interface has only one implementation it can make a call jump directly to that code.\n"
"However, in the case where a second implementation class is loaded the call site needs to be patched to test the type of the receiver instance and jump to the code that belongs to its class.\n"
"Supporting optimizations like this one requires keeping track of a lot more details of the class base than a native executable,\n"
"including recording the full class and interface hierarchy,\n"
"details of which methods override other methods, all method bytecode etc.\n"
"In a native executable most of the details of class structure and bytecode can be ignored at run time."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The JVM also has to cope with changes to the class base or execution profiles that result in a thread going down a previously cold path.\n"
"At that point the JVM has to jump out of the compiled code into the interpreter and recompile the code to cater for a new execution profile that includes the previously cold path.\n"
"That requires keeping runtime info that allow a compiled stack frame to be replaced with one or more interpreter frames.\n"
"It also requires runtime extensible profile counters to be allocated and updated to track what has or has not been executed."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Native executables include not only the application code but also, library code, and JDK code.\n"
"As a result a more fair comparison would be to compare the native executable’s size with the size of the application,\n"
"plus the size of the libraries it uses, plus the size of the JDK.\n"
"Especially the JDK part is not negligible even in simple applications like HelloWorld.\n"
"To get a glance on what is being pulled in the image one can use `-H:+PrintUniverse` when building the native executable."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Some features are always included in a native executable even though they might never be actually used at run time.\n"
"An example of such a feature is garbage collection.\n"
"At compile time we can’t be sure whether an application will need to run garbage collection at run time,\n"
"so garbage collection is always included in native executables increasing their size even if not necessary.\n"
"Native executable generation relies on static code analysis to identify which code paths are reachable,\n"
"and static code analysis can be imprecise leading to more code getting into the image than what’s actually needed."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"There is a https://github.com/oracle/graal/issues/287[GraalVM upstream issue]\n"
"with some interesting discussions about that topic."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Starting with GraalVM 22.2.0 it is possible to create heap dumps upon request,\n"
"e.g. `kill -SIGUSR1 <pid>`.\n"
"Support for dumping the heap dump upon an out of memory error will follow up."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Yes you can.\n"
"In fact, debugging native executables on a Linux bare metal box offers the best possible experience.\n"
"In this kind of environments, root access is not needed except to install packages required to run some debug steps,\n"
"or to enable `perf` to gather events at the kernel."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"There are multiple ways in which a native executable produced by Mandrel can be profiled.\n"
"All the methods require you to pass in the `-H:-DeleteLocalSymbols` option."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The method shown in this reference guide generates a binary with DWARF debug information,\n"
"runs it via `perf record` and then uses `perf script` and flame graph tooling to generate the flamegraphs.\n"
"However, the `perf script` post-processing step done on this binary can appear to be slow or can show some DWARF errors."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"An alternative method to generate flame graphs is to pass in `-H:+PreserveFramePointer` when generating the native executable instead of generating the DWARF debug information.\n"
"It instructs the binary to use an extra register for the frame pointer.\n"
"This enables `perf` to do stack walking to profile the runtime behaviour.\n"
"To generate the native executable using these flags, do the following:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The recommended method for generating runtime profiling information is using the debug information rather than generating a binary that preserves the frame pointer.\n"
"This is because adding debug information to the native executable build process has no negative runtime performance whereas preserving the frame pointer does."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"DWARF debug info is generated in a separate file and can even be omitted in the default deployment and only be transferred and used on demand,\n"
"for profiling or debugging purposes.\n"
"Furthermore, the presence of debug info enables `perf` to show us the relevant source code lines as well,\n"
"hence it does not bloat the native executable itself.\n"
"To do that, simply call `perf report` with an extra parameter to show source code lines:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The performance penalty of preserving the frame pointer is due to using the extra register for stack walking,\n"
"particularly in `x86_64` compared to `aarch64` where there are fewer registers available.\n"
"Using this extra register reduces the number of registers that are available for other work,\n"
"which can lead to performance penalties."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Although it is possible to remote debug processes within containers,\n"
"it might be easier to step-by-step debug native-image by installing Mandrel locally and adding it to the path of the shell process."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Native executable generation is the result of two Java processes that are executed sequentially.\n"
"The first process is very short and its main job is to set things up for the second process.\n"
"The second process is the one that takes care of most of the work.\n"
"The steps to debug one process or the other vary slightly."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"Let’s discuss first how to debug the second process,\n"
"which is the one you most likely to want to debug.\n"
"The starting point for the second process is the `com.oracle.svm.hosted.NativeImageGeneratorRunner` class.\n"
"To debug this process, simply add `--debug-attach=*:8000` as an additional build time argument:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"The starting point for the first process is the `com.oracle.svm.driver.NativeImages` class.\n"
"In GraalVM CE distributions, this first process is a binary, so debugging it in the traditional way with a Java IDE is not possible.\n"
"However, Mandrel distributions (or locally built GraalVM CE instances) keep this as a normal Java process,\n"
"so you can remote debug this process by adding the `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` as an additional build argument, e.g."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] and\n"
"https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)]\n"
"can be used to profile native binaries since GraalVM CE 21.2.0.\n"
"However, JFR in GraalVM is currently significantly limited in capabilities compared to HotSpot.\n"
"The custom event API is fully supported, but many VM level features are unavailable.\n"
"They will be added in future releases. Current limitations are:"
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"To use JFR add the application property: `-Dquarkus.native.enable-vm-inspection=true`.\n"
"E.g."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"In this situation, switching to JVM mode would be the best thing to try first.\n"
"If the performance issues continue after switching to JVM mode,\n"
"you can use more established and mature tooling to figure out the root cause.\n"
"If the performance issue is limited to native mode only,\n"
"you might not be able to use `perf`,\n"
"so JFR is the only way to gather any information in this situation.\n"
"As JFR support for native expands,\n"
"the ability to detect root causes of performance issues directly in production will improve."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"To fix classpath, class initialization or forbidden API errors at build time it's best to use <<native-reports,build time reports>> to understand the closed world universe.\n"
"A complete picture of the universe, along with the relationships between the different classes and methods will help uncover and fix most of the issues."
msgstr ""

#: /home/ynojima/playground/ja.quarkus.io/build/jekyll-source/_versions/2.16/guides/native-reference.adoc
msgid ""
"To fix runtime native specific errors,\n"
"it's best to have <<debug-info,debug info builds>> of the native executables around,\n"
"so that `gdb` can be hooked up quickly to debug the issue.\n"
"If you also add local symbols to the debug info builds,\n"
"you will obtain precise <<profiling,profiling information>> as well."
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/2.16/guides/native-reference.adoc:6
#, no-wrap
msgid "Native Reference Guide"
msgstr "ネイティブリファレンスガイド"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:20
msgid "<<native-memory-management,Native Memory Management>>"
msgstr "<<native-memory-management,ネイティブメモリ管理>>"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:21
msgid "<<inspecting-and-debugging,Inspecting and Debugging Native Executables>>"
msgstr "<<inspecting-and-debugging,ネイティブ実行可能ファイルの検査とデバッグ>>"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:22
msgid "<<native-faq,Frequently Asked Questions>>"
msgstr "<<native-faq,よくある質問>>"

#. type: Title ==
#: upstream/_versions/2.16/guides/native-reference.adoc:24
#, no-wrap
msgid "Native Memory Management"
msgstr "ネイティブメモリ管理"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:30
#, no-wrap
msgid "Garbage Collectors"
msgstr "ガベージコレクター"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:32
msgid "The garbage collectors available for Quarkus users are currently Serial GC and Epsilon GC."
msgstr "Quarkusのユーザーが利用できるガベージコレクタは、現在、Serial GCとEpsilon GCです。"

#. type: Title ====
#: upstream/_versions/2.16/guides/native-reference.adoc:33
#, no-wrap
msgid "Serial GC"
msgstr "シリアルGC"

#. type: Title =====
#: upstream/_versions/2.16/guides/native-reference.adoc:49
#, no-wrap
msgid "GC Collection Policy"
msgstr "GCコレクションポリシー"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:52
msgid "GraalVM's Serial GC implementation offers a choice between two different collection policies, the default is called \"adaptive\" and the alternative is called \"space/time\"."
msgstr "GraalVMのシリアルGC実装は、2つの異なる収集ポリシー間の選択を提供します。デフォルトは \"adaptive\" と呼ばれ、代替は \"space/time\"と呼ばれます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:74
msgid "Or adding this to the `application.properties` file:"
msgstr "または、 `application.properties` ファイルにこれを追加します。"

#. type: Title ====
#: upstream/_versions/2.16/guides/native-reference.adoc:86
#, no-wrap
msgid "Epsilon GC"
msgstr "Epsilon GC"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:96
#, no-wrap
msgid "Memory Management Options"
msgstr "メモリ管理オプション"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:102
#, no-wrap
msgid "GC Logging"
msgstr "GCロギング"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:139
msgid "Beyond these two options, `-XX:+PrintHeapShape` and `-XX:+TraceHeapChunks` provide even lower level details about memory chunks on top of which the different memory regions are constructed."
msgstr "この2つのオプションの他に、 `-XX:+PrintHeapShape` と `-XX:+TraceHeapChunks` は、異なるメモリ領域を構築するためのメモリチャンクに関するさらに低いレベルの詳細を提供します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:141
msgid "The most up-to-date information on GC logging flags can be obtained by printing the list of flags that can be passed to native executables:"
msgstr "GCロギングフラグについての最新情報は、ネイティブ実行可能ファイルに渡すことができるフラグのリストを表示することで得ることができます:"

#. type: Title ==
#: upstream/_versions/2.16/guides/native-reference.adoc:157
#, no-wrap
msgid "Inspecting and Debugging Native Executables"
msgstr "ネイティブ実行可能ファイルの検査とデバッグ"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:159
msgid "This debugging guide provides further details on debugging issues in Quarkus native executables that might arise during development or production."
msgstr "このデバッグガイドでは、開発中または生産中に発生する可能性のあるQuarkusネイティブ実行可能ファイルの問題のデバッグについて、さらに詳しく説明します。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:163
#, no-wrap
msgid "Requirements and Assumptions"
msgstr "要件と前提条件"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:166
msgid "This debugging guide has the following requirements:"
msgstr "このデバッグガイドには、次の要件があります。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:168
msgid "JDK 11 installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 11 がインストールされ、 `JAVA_HOME`  が適切に設定されていること"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:169
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:170
msgid "A working container runtime (Docker, podman)"
msgstr "動作するコンテナーランタイム(Docker, podman)"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:186
#, no-wrap
msgid "Bootstrapping the project"
msgstr "プロジェクトのブートストラップ"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:192
msgid "For Linux & MacOS users"
msgstr "Linux および MacOS ユーザー向け"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:199
msgid "For Windows users"
msgstr "Windows ユーザー向け"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:201
msgid "If using cmd , (don't use backward slash `\\` and put everything on the same line)"
msgstr "cmd を使用する場合は、バックスラッシュ `\\` は使わず、一行で実行します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:202
msgid "If using Powershell , wrap `-D` parameters in double quotes e.g. `\"-DprojectArtifactId=debugging-native\"`"
msgstr "Powershell を使用する場合は、`-D` パラメーターを二重引用符で囲みます。例: `\"-DprojectArtifactId=debugging-native\"`"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:203
#, no-wrap
msgid "Configure Quarkus properties"
msgstr "Quarkus のプロパティーを設定する"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:225
#, no-wrap
msgid "First Debugging Steps"
msgstr "最初のデバッグ手順"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:228
msgid "As a first step, change to the project directory and build the native executable for the application:"
msgstr "最初のステップとして、プロジェクトディレクトリーに移動し、アプリケーションのネイティブ実行可能ファイルをビルドします。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:235
msgid "Run the application to verify it works as expected. In one terminal:"
msgstr "アプリケーションを実行して、期待通りに動作することを確認します。一つの端末で以下を実行します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:242
msgid "In another:"
msgstr "別のターミナルで以下を実行します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:259
msgid "Executing that will produce additional output lines like this:"
msgstr "これを実行すると、次のような追加の出力行が得られます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:294
msgid "The native library info file contains information on the static libraries added to the binary and the other libraries dynamically linked to the executable:"
msgstr "ネイティブライブラリ情報ファイルには、バイナリに追加されるスタティックライブラリと、実行可能ファイルに動的にリンクされるその他のライブラリの情報が含まれています。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:322
msgid "Running with `--verbose` demonstrates how the native-image building process is two sequential java processes:"
msgstr "`--verbose` で実行すると、ネイティブイメージのビルドプロセスが2つの連続したJavaプロセスであることが分かります。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:330
msgid "One may also combine multiple native build options by separating with a comma, e.g.:"
msgstr "また、複数のネイティブ・ビルド・オプションをコンマで区切って組み合わせることもできます。例:"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:343
#, no-wrap
msgid "Inspecting Native Executables"
msgstr "ネイティブ実行可能ファイルの検査"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:371
msgid "Using docker in the non-Linux environment, you can create an image using this Dockerfile via:"
msgstr "Linux 以外の環境で docker を使用する場合は、以下を実行し、この Dockerfile を使用してイメージを作成できます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:378
msgid "Then, go to the root of the project and run the Docker container we have just created as:"
msgstr "次に、プロジェクトの root に移動し、先ほど作成した Docker コンテナーを以下のように実行します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:385
msgid "`ldd` shows the shared library dependencies of an executable:"
msgstr "`ldd` は、実行可能ファイルの共有ライブラリの依存関係を表示します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:392
msgid "`strings` can be used to look for text messages inside the binary:"
msgstr "`strings` は、バイナリ内のテキストメッセージを探すのに使用できます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:399
msgid "Using `strings` you can also get Mandrel information given the binary:"
msgstr "`strings` を使えば、指定されたバイナリのMandrel情報を得ることもできます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:426
msgid "From there, you can either inspect the executable directly or use a tools container like above."
msgstr "そこから、実行可能ファイルを直接検査するか、上記のようなツールコンテナーを使用することができます。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:429
#, no-wrap
msgid "Native Reports"
msgstr "ネイティブレポート"

#. type: delimited block =
#: upstream/_versions/2.16/guides/native-reference.adoc:432
msgid "Optionally, the native build process can generate reports that show what goes into the binary:"
msgstr "オプションとして、ネイティブビルドプロセスでは、バイナリに何が入っているかを示すレポートを生成することができます。"

#. type: Title ====
#: upstream/_versions/2.16/guides/native-reference.adoc:442
#, no-wrap
msgid "Call Tree Reports"
msgstr "コールツリーレポート"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:450
msgid "Let’s see this in action."
msgstr "実際に見てみましょう。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:452
msgid "First, start a Neo4j instance:"
msgstr "まず、Neo4jのインスタンスを起動します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:515
msgid "Copy and paste the contents of the script into a file called `import.cypher`."
msgstr "スクリプトの内容を `import.cypher` というファイルにコピー＆ペーストします。"

#. type: delimited block =
#: upstream/_versions/2.16/guides/native-reference.adoc:556
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr "次に、インポートサイファースクリプトとCSVファイルをNeo4jのインポートフォルダにコピーします。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:567
msgid "After copying all the files, invoke the import script:"
msgstr "すべてのファイルをコピーしたら、インポートスクリプトを起動します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:588
msgid "From there, you can narrow down to a given method on a specific type:"
msgstr "そこから、特定の型の特定のメソッドに絞ることができます。"

#. type: Title ====
#: upstream/_versions/2.16/guides/native-reference.adoc:628
#, no-wrap
msgid "Used Packages/Classes/Methods Reports"
msgstr "使用されているパッケージ/クラス/メソッドのレポート"

#. type: Title ====
#: upstream/_versions/2.16/guides/native-reference.adoc:633
#, no-wrap
msgid "Further Reports"
msgstr "更なるレポート"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:650
msgid "To use these expert options, add them comma separated to the `-Dquarkus.native.additional-build-args` parameter."
msgstr "これらのエキスパートオプションを使用するには、 `-Dquarkus.native.additional-build-args` パラメータにコンマで区切って追加します。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:651
#, no-wrap
msgid "Build-time vs Run-time Initialization"
msgstr "ビルド時と実行時の初期化"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:693
msgid "Rebuild the binary using:"
msgstr "次のようにバイナリを再ビルドします。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:708
msgid "Send a `GET` request multiple times from another terminal:"
msgstr "別のターミナルから `GET` リクエストを複数回送信してみましょう。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:773
msgid "When trying to rebuild the application, you’ll encounter an error:"
msgstr "アプリケーションを再ビルドしようとすると、エラーが発生します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:802
msgid "As suggested by the message, let's start by adding an option to track object instantiation:"
msgstr "メッセージにあるように、まずはオブジェクトのインスタンス化を追跡するためのオプションを追加してみましょう。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:856
msgid "Additional information on which classes are initialized and why can be obtained by passing in the `-H:+PrintClassInitialization` flag via `-Dquarkus.native.additional-build-args`."
msgstr "どのクラスがどのように初期化されるかについての追加情報は、 `-Dquarkus.native.additional-build-args` を通じて `-H:+PrintClassInitialization` フラグを渡すことで得ることができます。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:858
#, no-wrap
msgid "Profile Runtime Behaviour"
msgstr "実行時動作のプロファイリング"

#. type: Title ====
#: upstream/_versions/2.16/guides/native-reference.adoc:860
#, no-wrap
msgid "Single Thread"
msgstr "シングルスレッド"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:898
msgid "Recompile the application, rebuild the binary and run it. Attempting a simple curl will never complete, as expected:"
msgstr "アプリケーションを再コンパイルし、バイナリを再ビルドして実行します。単純なcurlを試みても、期待通り完了しません。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:930
msgid "Once the container is running, you need to ensure that the kernel is ready for the profiling exercises:"
msgstr "コンテナが稼働したら、カーネルがプロファイリングの演習に対応できるようにしておく必要があります。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:945
msgid "Then, from inside the tools container we execute:"
msgstr "次に、ツールコンテナー内から以下を実行します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:963
msgid "While `perf record` is running, open another window and access the endpoint:"
msgstr "`perf record` の実行中に、別のウィンドウを開き、エンドポイントにアクセスします。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:978
msgid "Next, generate a flame graph using the data captured via `perf record`:"
msgstr "次に、`perf record` を介してキャプチャされたデータを使用してフレームグラフを生成します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1032
msgid "You should see a long list of symbols that match that pattern."
msgstr "そのパターンに一致するシンボルの長いリストが表示されるはずです。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1042
msgid "Run the curl command once again, stop the binary, generate the flamegraphs and open it:"
msgstr "もう一度curlコマンドを実行し、バイナリを停止し、フレームグラフを生成して開きます。"

#. type: Title ====
#: upstream/_versions/2.16/guides/native-reference.adoc:1054
#, no-wrap
msgid "Multi-Thread"
msgstr "マルチスレッド"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1126
msgid "Build the native executable with debug info:"
msgstr "デバッグ情報付きでネイティブ実行可能ファイルをビルドします。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1135
msgid "From inside the tools container (as privileged user) run the native executable through `perf`:"
msgstr "ツールコンテナー内から (特権ユーザーとして)、`perf` を介してネイティブ実行可能ファイルを実行します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1142
msgid "Invoke the endpoint to send the multicast packets:"
msgstr "エンドポイントを呼び出して、マルチキャストパケットを送信します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1149
msgid "Make and open a flamegraph:"
msgstr "フレームグラフを作成して開いてください。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1189
#, no-wrap
msgid "Debugging Native Crashes"
msgstr "ネイティブ・クラッシュのデバッグ"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1242
msgid "This will result in the following output:"
msgstr "これにより、次のような出力が得られます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1262
msgid "Then start the application in `gdb` and execute `run`."
msgstr "続いて、`gdb` でアプリケーションを起動し、`run` を実行します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1274
msgid "Next, try to access http://localhost:8080/crash:"
msgstr "次に、http://localhost:8080/crash へのアクセスを試みます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1280
#: upstream/_versions/2.16/guides/native-reference.adoc:1324
msgid "This will result in the following message in `gdb`:"
msgstr "これにより、 `gdb` に次のようなメッセージが表示されます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1289
msgid "If we try to get more info about the backtrace that led to this crash we will see that there is not enough information available."
msgstr "このクラッシュの原因となったバックトレースの情報を得ようとすると、十分な情報が得られないことがわかります。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1352
msgid "Similarly, we can get a backtrace of the call graph of other threads."
msgstr "同様に、他のスレッドのコールグラフのバックトレースを取得できます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1354
msgid "First, we can list the available threads with:"
msgstr "まず、利用可能なスレッドを以下のように一覧表示できます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1368
msgid "select the thread we want to inspect, e.g. thread 1:"
msgstr "検査するスレッドを選択します (例: スレッド 1)。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1378
msgid "and, finally, print the stack trace:"
msgstr "そして最後に、スタックトレースを出力します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1409
msgid "Alternatively, we can list the backtraces of all threads with a single command:"
msgstr "または、1 つのコマンドですべてのスレッドのバックトレースを一覧表示することもできます。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1459
msgid "Note, however, that despite being able to get a backtrace we can still not list the source code at point with the `list` command."
msgstr "ただし、バックトレースを取得できるにもかかわらず、`list` コマンドを使用してソースコードをある点で引き続き一覧表示できないことに注意してください。"

#. type: Title ==
#: upstream/_versions/2.16/guides/native-reference.adoc:1495
#, no-wrap
msgid "Frequently Asked Questions"
msgstr "よくある質問"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1497
#, no-wrap
msgid "Why is the process of generating a native executable slow?"
msgstr "ネイティブ実行可能ファイルを生成するプロセスが遅いのはなぜですか？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1509
msgid "The compilation step is pretty straightforward, it simply compiles all the reachable code."
msgstr "コンパイルのステップは非常に簡単で、到達可能なすべてのコードを単純にコンパイルします。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1517
#, no-wrap
msgid "I get an `OutOfMemoryError` (OOME) building native executables, what can I do?"
msgstr "ネイティブ実行可能ファイルをビルドする際に OutOfMemoryError (OOME) が発生しました。どうすればよいですか?"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1536
#, no-wrap
msgid "Why is runtime performance of a native executable inferior compared to JVM mode?"
msgstr "JVMモードと比較して、ネイティブ実行可能ファイルのランタイムパフォーマンスが劣るのはなぜですか？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1552
msgid "Note, however, that there is a price you pay for that potentially higher JVM speed, and that price is in increased resource usage (both CPU and memory) and startup time because:"
msgstr "ただし、JVMの速度が向上する可能性があるため、その代償として、リソース（CPUとメモリの両方）の使用量と起動時間が増加することに注意してください。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1554
msgid "it takes some time before the JIT kicks in and fully optimizes the code."
msgstr "JITが作動してコードを完全に最適化するまでに時間がかかります。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1555
msgid "the JIT compiler consumes resources that could be utilized by the application."
msgstr "JIT コンパイラは、アプリケーションが利用できるリソースを消費します。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1556
msgid "the JVM has to retain a lot more metadata and compiler/profiler data to support the better optimizations that it can offer."
msgstr "JVMは、より良い最適化をサポートするために、より多くのメタデータやコンパイラ/プロファイラのデータを保持しなければなりません。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1558
msgid "The reason for 1) is that code needs to be run interpreted for some time and, possibly, to be compiled several times before all potential optimizations are realized to ensure that:"
msgstr "1)の理由は、コードはしばらくの間、インタプリタ実行する必要があり、場合によっては、以下を担保する全ての潜在的な最適化が実現される前に、何度もコンパイルする必要があるからです。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1560
msgid "it’s worth compiling that code path, i.e. it’s being executed enough times, and that"
msgstr "そのコードパスをコンパイルする価値があります。つまり、十分な回数実行されています。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1561
msgid "we have enough profiling data to perform meaningful optimizations."
msgstr "意味のある最適化を行うための十分なプロファイリングデータがあります。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1582
#, no-wrap
msgid "Why are native executables “big”?"
msgstr "なぜネイティブ実行可能ファイルは大きいのですか？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1585
msgid "This can be attributed to a number of different reasons:"
msgstr "これには様々な理由があります。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1601
#, no-wrap
msgid "What version of Mandrel was used to generate a binary?"
msgstr "バイナリの生成に使用したMandrelのバージョンは？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1604
msgid "One can see which Mandrel version was used to generate a binary by inspecting the binary as follows:"
msgstr "どのバージョンのMandrelを使ってバイナリを生成したかは、バイナリを以下のように検査すればわかります。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1611
#, no-wrap
msgid "How do I enable GC logging in native executables?"
msgstr "ネイティブ実行可能ファイルでGCロギングを有効にするにはどうすればいいですか？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1614
msgid "See <<gc-logging,Native Memory Management GC Logging section>> for details."
msgstr "詳細は <<gc-logging,ネイティブメモリ管理GCロギングセクション>> をご覧ください。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1615
#, no-wrap
msgid "Can I get a heap dump of a native executable? e.g. if it runs out of memory"
msgstr "ネイティブ実行可能ファイルのヒープダンプを取得することはできますか？ 例えば、メモリ不足になった場合などです。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1621
#, no-wrap
msgid "Can I build and run this examples outside a container in Linux?"
msgstr "このサンプルをコンテナーの外で Linux でビルドして実行することは可能ですか？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1629
msgid "These are the packages you'll need on your Linux environment to run through the different debugging sections:"
msgstr "これらのパッケージは、異なるデバッグセクションを実行するために、Linux環境で必要となるものです。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1638
#, no-wrap
msgid "Generating flame graphs is slow, or produces errors, what can I do?"
msgstr "フレームグラフの生成に時間がかかったり、エラーが発生したりするのですが、どうすればいいですか？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1659
msgid "To get runtime profiling information out of the native executable, simply do:"
msgstr "実行時プロファイリング情報をネイティブ実行可能ファイルから取得するには、単純に次のようにします。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1690
#, no-wrap
msgid "I think I’ve found a bug in native-image, how can I debug it with the IDE?"
msgstr "native-imageのバグを見つけたようなのですが、IDEでどのようにデバッグすればいいのでしょうか？"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1722
#, no-wrap
msgid "Can I use JFR/JMC to debug or profile native binaries?"
msgstr "JFR/JMCを使って、ネイティブバイナリのデバッグやプロファイリングはできますか？"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1732
msgid "Minimal VM level events"
msgstr "最小限の VM レベルのイベント"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1733
msgid "No old object sampling"
msgstr "oldオブジェクトのサンプリングはありません"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1734
msgid "No stacktrace tracing"
msgstr "スタックトレースのトレースがありません"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1735
msgid "No Streaming API for JDK 17"
msgstr "JDK 17 のストリーミング API なし"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1747
msgid "Once the image is compiled, enable and start JFR via runtime flags: `-XX:+FlightRecorder` and `-XX:StartFlightRecording`. For example:"
msgstr "イメージのコンパイルが完了したら、ランタイムフラグ `-XX:+FlightRecorder` と `-XX:StartFlightRecording` を使ってJFRを有効にし、起動します。例えば、以下のようになります。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1756
msgid "For more details on using JFR, see https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/JFR/[here]."
msgstr "JFR の使い方の詳細は、https://www.graalvm.org/{graalvm-version}/reference-manual/native-image/debugging-and-diagnostics/JFR/[こちら] をご覧ください。"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1757
#, no-wrap
msgid "How can we troubleshoot performance problems only reproducible in production?"
msgstr "本番環境でのみ再現可能なパフォーマンスの問題をどのようにトラブルシューティングできますか?"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1768
#, no-wrap
msgid "What information helps most debug issues that happen either at build-time or run-time?"
msgstr "ビルド時または実行時に発生するほとんどの問題のデバッグに役立つ情報は何ですか?"

#. type: Title ===
#: upstream/_versions/2.16/guides/native-reference.adoc:1779
#, no-wrap
msgid "Build stalled for minutes, barely using any CPU"
msgstr "ビルドが数分間停止し、CPU をほとんど使用していない"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1782
msgid "It might so happen that the build gets stalled and even ends up with:"
msgstr "ビルドが停止し、次のような状態で終了する場合もあるかもしれません:"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1789
msgid "One of the possible explanations could be a lack of entropy, e.g. on an entropy constrained VM, if such a source is needed as it is the case with Bouncycastle at build time."
msgstr "考えられる説明の 1 つは、エントロピーの欠如です。 例えば、エントロピーに制約のある VM で、Bouncycastle のビルド時のようにそのようなソースが必要な場合。"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1791
msgid "One can check the available entropy on a Linux system with:"
msgstr "Linuxシステムでは、利用可能なエントロピーは次のようにして確認することができます:"

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1797
msgid "If the amount is not in hundreds, it could be a problem. A possible workaround is to compromise, acceptable for testing, and set:"
msgstr "量が百単位でない場合、問題になる可能性があります。回避策として考えられるのは、テストでは許容される妥協をし、次のように設定することです："

#. type: Plain text
#: upstream/_versions/2.16/guides/native-reference.adoc:1801
msgid "The proper solution is to increase the entropy available for the system. That is specific for each OS vendor and virtualization solution though."
msgstr "適切な解決策は、システムで利用可能なエントロピーを増やすことです。それはOSベンダーや仮想化ソリューションごとに固有な方法を必要とします。"
