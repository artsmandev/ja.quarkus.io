<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.3.3" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライセンスは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0] でライセンスされているオープンソースプロジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どこから入手できますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはMaven Centralで公開されています。必要な link:/extensions[which extensions] を確認し、`pom.xml` にインポートするだけでQuarkusを入手できます。link:/get-started[Getting Started guides] からQuarkusの体験を始めることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, we consider Quarkus stable. Remember 95% of the features Quarkus apps use are provided by the ecosystem like Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy, etc. These libraries are rock solid :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、Quarkusは安定していると考えています。Quarkusのアプリが使用する機能の95%は、Hibernate ORM、Eclipse Vert.x、Netty、RESTEasyなどのエコシステムによって提供されていることを忘れないでください。これらのライブラリは極めて盤石です:)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to https://code.quarkus.io/[code.quarkus.io] to see if a particular extension is _stable_ (default) or _preview_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://code.quarkus.io/[code.quarkus.io]にアクセスして、特定のエクステンションが_安定_(デフォルト)か_プレビュー_かを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの主な目標の1つは、拡張性の容易さと活気のあるエコシステムの構築です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションはプロジェクトの依存関係だと考えてください。エクステンションは、フレームワークまたはテクノロジーをQuarkusアプリケーションに構成、起動、および統合します。また、アプリケーションをネイティブにコンパイルするために、GraalVMに適切な情報を提供するという面倒な作業もすべて行います。これにより、サードパーティのプロジェクトは、GraalVMをターゲットにしやすくするために我々が行った作業を簡単に利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションステータスとは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、Quarkusエコシステムに入る際に、さまざまな成熟度を持ちます。ステータスは、信頼度の期待値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Stable*: backward compatibility and presence in the ecosystem are taken very seriously. An application can safely rely on these extensions. Extensions not marked as preview or experimental (the majority) are stable.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*安定*:下位互換性とエコシステムでの存在感が非常に重要視されています。アプリケーションはこれらのエクステンションに安全に依存できます。プレビューまたは実験的(大部分)としてマークされていないエクステンションは安定しています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*プレビュー*:下位互換性とエコシステム内での存在感は保証されません。特定の改善には、構成またはAPIの変更が必要になる場合があり、_安定_になる計画が進行中です。このようなエクステンションは、成熟プロセスの途中です。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Experimental*: early feedback is requested to mature the idea. There is no guarantee of stability nor long term presence in the platform until the solution matures. Such extensions are at the beginning of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*実験的*:アイデアを成熟させるために、早期のフィードバックが必要です。ソリューションが成熟するまで、プラットフォーム内での安定性や長期的な存在は保証されません。このようなエクステンションは、成熟プロセスの初期段階にあります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションステータスは、https://code.quarkus.io[code.quarkus.io] またはエクステンション link:/guides/[guides] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを作成できますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論です! Quarkusの「初期」チームの外部でかなりの数のエクステンションが作成されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an open ecosystem and we hope to see all the extensions people need to write their apps. We are working as we speak to allow an extension to be published in separate repos and separate GAVs and thus published in Maven repos independently of Quarkus core. This will greatly simplify the publication process. Expect news soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはオープンエコシステムであり、人々がアプリを作成するために必要なすべてのエクステンションが存在することを期待しています。エクステンションを個別のリポジトリと個別のGAVで公開し、Quarkusコアとは独立してMavenリポジトリで公開できるようにするために取り組んでいます。これにより、公開プロセスが大幅に簡素化されます。近いうちのニュースを期待してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our https://quarkus.io/community/#discussions[mailing list] to discuss your ideas and get help. And you can start reading our https://quarkus.io/guides/writing-extensions[Writing extensions guide] as well or more simply get inspiration from the https://github.com/quarkusio/quarkus/tree/master/extensions[existing ones].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の制限の1つは、エクステンションはOpenJDKとGraalVMの両方のネイティブ実行可能ファイルで機能する必要があるということです。これは、Quarkusユーザーに提供する保証です(アプリのクロスコンパイル)。エクステンションを改善して完全に「Quarked」し、Quarkusの恩恵を受けるための成熟度モデルがあり、すべて段階的に実行されます。 https://quarkus.io/community/#discussions[メーリングリスト] にアクセスして、アイデアについて話し合い、サポートを受けてください。また、https://quarkus.io/guides/writing-extensions[エクステンションガイドの作成] を読み始めることも、 https://github.com/quarkusio/quarkus/tree/master/extensions[既存のエクステンション] からインスピレーションを得ることもできます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.graalvm.org[GraalVM] is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://www.graalvm.org[GraalVM] は、さまざまな異なる言語で記述されたアプリケーションを実行するためのユニバーサル仮想マシンであり、JVMバイトコードをネイティブ実行可能ファイルにコンパイルする機能を提供します(このネイティブ実行可能ファイルは、SubstrateVMと呼ばれる特別な仮想マシンを実行します)。これらのネイティブ実行可能ファイルは、従来のJVMよりもはるかに高速に起動し、使用するメモリーを大幅に削減できますが、すべてのJVM機能がサポートされているわけではなく、一部は通常よりも制限されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、デフォルトでは、クラス/メンバーがリフレクション用に明示的に登録されていない限り、GraalVMでのリフレクションは機能しません。これは通常、すべてのクラス、メソッド、フィールド、コンストラクターをJSONファイルにリストし、これをパラメーターとしてネイティブイメージビルドに渡すことで実現されます。これは、最も些細なプロジェクトを除いて、明らかに非常に面倒になります。 Quarkusは、これらの注釈を簡単に回避し、何を登録するかをプログラムで決定できるフレームワークを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 命令型プログラミングとリアクティブプログラミングをどのように統合しますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/continuum[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/continuum[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/container-first[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/container-first[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 標準についてどう考えていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/standards[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/standards[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 開発者の満足度を向上させるために何に取り組んでいますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/developer-joy[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/developer-joy[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>貢献</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>License</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライセンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to create your first Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのQuarkusアプリケーションを作成する方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through First Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのアプリケーションを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about developing reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用したリアクティブアプリケーションの開発については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with Reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ入門</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build native executables with GraalVM or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMやMandrelを使ってネイティブの実行可能ファイルをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Native Executables</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-native-image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/building-native-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの開発を非常に高速で楽しいものにするQuarkus開発者ツールチェーンをご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツールの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>core</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>core</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードの中でハードコードされた値を使用することはできません (たとえ誰もがどこかの時点でそうしていたとしても ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to configure your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを設定する為の詳細について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/config-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List all the configuration properties per extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションごとのすべての設定プロパティのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての設定プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/all-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、アプリケーションの停止時や起動時に通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Initialization and Termination</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの初期化と終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lifecycle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/lifecycle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのDIソリューションは、 [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec )仕様に基づいています。このガイドでは、CDIの基本を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cdi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go more in depth into the Quarkus implementation of CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDIのQuarkus実装についてさらに詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>arc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cdi-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の内容をカバーしています：
* JVM モードでのテスト 
* ネイティブモードでのテスト 
* テストへのリソースの注入
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains logging and how to configure it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ロギングとその設定方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Logging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/logging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains how to develop command line applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファレンスガイドでは、Quarkusを使用してコマンドラインアプリケーションを開発する方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Mode Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native images to support SSL, as native images don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ネイティブイメージがそのままではSSLをサポートしていないため、ネイティブイメージをSSLに対応させる方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL With Native Images</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージでのSSLの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can pass contextual information with our implementation of MicroProfile Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile Context Propagation の実装を使ってコンテキスト情報を渡す方法の詳細については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context Propagation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキストの伝搬</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/context-propagation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/context-propagation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、アプリケーションをネイティブ実行可能ファイルにコンパイルする際に遭遇する問題を解決するためのヒントをまとめたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Native Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ウェブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON は現在、マイクロサービス間の共通言語となっています。このガイドでは、REST サービスが JSON ペイロードを消費して生成する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-json</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-json</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to develop highly scalable reactive REST services with JAX-RS and RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSとRESTEasyReactiveを使用して拡張性の高いリアクティブRESTサービスを開発する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Highly Scalable Reactive REST Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>高度にスケーラブルなリアクティブRESTサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM REST Data with Panacheは、JAX-RSとHibernate ORMをベースにしたCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple REST CRUD Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなREST CRUDサービスの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation in your REST services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、RESTサービスでHibernate Validator/Bean Validationを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client in order to interact with REST APIs (JSON and other) with very little effort.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST Clientを使ってREST API(JSONなど)とほとんど手間をかけずにやりとりする方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTクライアントを使う（JSONを含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client to send multipart REST requests, typically to upload documents.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST クライアントを使用してマルチパート REST リクエストを送信する方法、典型的にはドキュメントをアップロードする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client with Multipart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチパートでのRESTクライアントの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can utilize MicroProfile JWT RBAC to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アプリケーションがMicroProfile JWT RBACを利用してJAX-RSエンドポイントへのセキュアなアクセスを提供する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがWeb Socketを利用してインタラクティブなウェブアプリケーションを作成する方法を説明します。定型的なWeb Socketアプリケーションなので、簡単なチャットアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/websockets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/websockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenAPI エクステンションを使用して OpenAPI ディスクリプタを生成し、Swagger UI フロントエンドを取得して REST エンドポイントをテストする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのVert.xベースのHTTPレイヤーの設定についての詳細と、サーブレットを使用している場合のUndertowについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/http-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/http-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Fault Tolerance specification through the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Fault Toleranceエクステンションを使用してMicroProfile Fault Tolerance仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フォールトトレランスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use reactive routes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、リアクティブルートの使用方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブルートの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-routes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-routes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage Eclipse MicroProfile GraphQL to consume and implement GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Eclipse MicroProfile GraphQL を活用して GraphQL サービスを利用したり、実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, you can easily configure a datasource, or several if need be.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用すると、データソースを簡単に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの完全な息吹を提供します。Quarkusでは見事に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Panache focuses on making your entities trivial and fun to write.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの全幅を提供します。
複雑なマッピングを可能にしますが、単純で一般的なマッピングをつまらなくするものではありません。
Panacheは、エンティティを些細なことではなく、書いていて楽しいものにすることに焦点を当てています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This explain the specifics of using Hibernate ORM with Panache in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>KotlinプロジェクトでHibernate ORMをPanacheで使う場合に固有の事情について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate Searchは、Elasticsearchクラスタ内のエンティティをインデックス化し、Hibernate ORMベースのすべてのアプリケーションで簡単に全文検索を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはTransaction Managerが付属しており、これを使用してアプリケーションにトランザクションを調整して公開します。
永続性を扱う各エクステンションは、これと統合されます。
そして、CDIを介して明示的にトランザクションと対話することになります。
このガイドでは、これらすべてについて説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/transaction</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/transaction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Blaze-Persistence to simplify your data and DTO layers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Blaze-Persistenceを使用してデータとDTOレイヤーを簡素化する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to cache expensive method calls of your CDI beans using simple annotations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、シンプルなアノテーションを使用してCDI Beanの高価なメソッド呼び出しをキャッシュする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache your application data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションデータのキャッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Flyway extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Flyway エクステンションを使用してスキーマのマイグレーションを管理する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/flyway</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Liquibase extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、スキーマのマイグレーションを管理するための Liquibase エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/liquibase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanは、アプリケーションプロセス以外のサーバーでの実行を可能にするメモリー内データグリッドです。このエクステンションは、Quarkusで実行しているときに、クライアントがサーバーに接続できるようにする機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/infinispan-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/infinispan-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Reactive SQL Clients for MySQL and PostgreSQL in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusのMySQLおよびPostgreSQL用のReactive SQLクライアントの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ SQL クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、低レベルまたは高レベルのRESTクライアントを使用してElasticsearchクラスタを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use MongoDB in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでMongoDBを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アクティブなレコードやリポジトリを使ったMongoDBの使い方について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use a Redis datastore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでRedisデータストアを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Neo4j graph database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでNeo4jグラフデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/neo4j</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/neo4j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Apache Cassandra NoSQL database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでApache Cassandra NoSQLデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cassandra</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cassandra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon DynamoDB database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon DynamoDBデータベースを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon DynamoDB</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon DynamoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon S3 cloud storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon S3クラウドストレージの使い方を紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-s3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-s3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of Software Transactional Memory (STM)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ソフトウェア・トランザクション・メモリ(STM)の使用法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Software Transactional Memory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソフトウェア・トランザクション・メモリの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>messaging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging 利用して Apache Kafka とやりとりする仕組みを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを利用してAMQPと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AMQP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメッセージングでのAMQPの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amqp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus アプリケーションが MicroProfile Reactive Messaging を使用して HTTP メッセージを消費および生成する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがApache Kafka Streams APIを利用して、Apache Kafkaベースのストリーム処理アプリケーションを実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-streams</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kafka-streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how different beans can interact using the event bus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、イベントバスを使用して異なるBeanがどのように相互作用するかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the event bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントバスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが、Apache Qpid JMSを使用してAMQP 1.0でJMSメッセージングを使用する方法、またはApache ActiveMQ Artemis JMSを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/jms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the entry point for everything security in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、Quarkusのすべてのセキュリティに関するエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Overview</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティの概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a .properties file to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが.propertiesファイルを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with .properties File</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>.propertiesファイルでセキュリティを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してHibernate ORMを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jpa</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jdbc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jdbc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがLDAPディレクトリを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-ldap</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-ldap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Keycloak to protect your JAX-RS applications using bearer token authorization, where these tokens are issued by a Keycloak server.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloakを使用して、ベアラートークン認証を使用してJAX-RSアプリケーションを保護する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sso</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>sso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect Extension to protect your web application based on the Authorization Code Flow using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusを使用してAuthorization Code Flowに基づいてWebアプリケーションを保護するためにOpenID Connect Extensionを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、単一のアプリケーションから複数のテナントにサービスを提供できるように、OpenID Connectアプリケーションがマルチテナントをサポートする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloak認可サービスを使用して保護されたリソースへのアクセスを認可する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenID ConnectとOAuth2クライアント、フィルタを使用してアクセストークンを取得、更新、伝播する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがOAuth2トークンを利用して、JAX-RSエンドポイントへのセキュアなアクセスを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-oauth2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、HashiCorp Vaultを使用してQuarkusにクレデンシャルを安全に保存する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault for "encryption as a service".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、HashiCorp Vaultを「サービスとしての暗号化」に利用する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault Transit Secret Engine</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヴォールトトランジットシークレットエンジンの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-transit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-transit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep confidential your database credentials by storing them in Vault.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースの資格情報をVaultに保存して、機密を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains the various methods supported by Quarkus to authenticate to your Vault.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusがサポートする、Vaultへの認証を行うためのさまざまな方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-auth</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-auth</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides explains how to use the Vault credentials provider or implement your own custom one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vault の資格情報プロバイダを使用する方法、または独自のカスタムのものを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>資格情報プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/credentials-provider</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/credentials-provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>business-automation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>business-automation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business Automation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビジネスオートメーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKogitoを使用してビジネスオートメーションを追加し、ビジネスプロセスとルールでパワーアップする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OptaPlannerの制約解決人工知能（AI）を使用してQuarkusアプリケーションを作成するプロセスを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/optaplanner</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/optaplanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the systems integration with Apache Camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Apache Camel でのシステム統合について説明します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command-line</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>command-line</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplify command line applications creation with the Picocli extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli エクステンションでコマンドラインアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Picocli</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/picocli</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Quarkus-based scripting with jbang.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangを使った簡単なQuarkusベースのスクリプティング方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scripting</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scripting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのビルドの一部として、Jib、S2I、またはDockerを使用してコンテナイメージをビルドしてプッシュする方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Container Images</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドコンテナイメージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/container-image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/container-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Kubernetes上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenShift上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ConfigMaps as a configuration source for your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsをQuarkusアプリケーションの設定ソースとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Fabric8 Kubernetes クライアントを使用して Kubernetes クラスタと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションをMicrosoft Azure Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAzure Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Amazon Lambdas.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusベースのAmazon Lambdasをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAmazon Lambdaとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションをGoogle Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusベースのGoogle Cloud Functionsを導入する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをGoogle Cloud Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Funqyフレームワークの基本、シンプルなポータブルクロスプロバイダーCloud Function APIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのHTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのAmazon Lambdaバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのAmazon Lambda HTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Knative Events binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのKnative Eventsバインディングについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Azure Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのAzure Functions HTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのGoogle Cloud Platform Functionsバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのGoogle Cloud Platform FunctionsのHTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Key Management Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon Key Management Serviceの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon KMS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon KMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-kms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-kms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Identity and Access Management in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon Identity and Access Managementの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon IAM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-iam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-iam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Email Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Mail Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SES</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-ses</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-ses</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Notification Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Notification Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SNS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SNS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sns</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-sns</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Queue Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Queue Serviceを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SQS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SQS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>observability</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observability</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Health specification through the SmallRye Health extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Healthエクステンションを使用してMicroProfile Health仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Health Check</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヘルスチェックの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-health</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがOpenTracingを利用してインタラクティブなウェブアプリケーションのための分散トレースを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentracing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/opentracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicrometerエクステンションを使用してメトリクスを収集する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/micrometer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/micrometer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Metrics specification through the SmallRye Metrics extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Metricsエクステンションを使用してMicroProfile Metrics仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Sentry to monitor your application and be notified when exceptions occur.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Sentry を使ってアプリケーションを監視し、例外が発生したときに通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging-sentry</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/logging-sentry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Graylog Extended Log Format (GELF) を使用して Logstash または Fluentd でログを集中管理する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Centralized Log Management</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>集中ログ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>serialization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シリアル化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to start using gRPC in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with gRPC</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCを始めるには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to implement gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションにgRPCサービスを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing gRPC Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to consume gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCサービスを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスを消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の内容について説明します。
* Maven の設定 
* 新しいプロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/maven-tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/maven-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下の内容をカバーしています。
* Gradle の設定 
* 新規プロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to measure the test coverage of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションのテストカバレッジを測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの適用範囲の測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>compatibility</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションにはCDIアノテーションを使用することが推奨されていますが、Quarkusはspring-diエクステンションの形でSpring依存性インジェクション用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-di</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-di</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントの定義にはJAX-RSアノテーションを使用することが推奨されていますが、QuarkusはSpring-webエクステンションという形でSpring Webとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データレイヤーにはHibernate ORM with Panacheを使用することが推奨されていますが、Quarkusはspring-data-jpaエクステンションの形でSpring Data JPAの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Spring Data RESTは、当社のSpring Data互換性レイヤをベースにCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのセキュリティレイヤーを使用してアプリケーションを保護することが推奨されていますが、Quarkusはspring-securityのエクステンションの形でSpring Securityとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションレベルのキャッシングにはCacheエクステンションを使用することが推奨されていますが、QuarkusはSpring Cacheエクステンションの形でSpring Cacheの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SchedulerやQuartzのエクステンションを使ってタスクをスケジュールすることが推奨されていますが、QuarkusはSpring-scheduledエクステンションの形でSpring Scheduledとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile Config アノテーションの代わりに Spring Boot の `@ConfigurationProperties`  を使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、Spring-cloud-config-clientエクステンションの形でSpring Cloud Config用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>miscellaneous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>miscellaneous</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクをスケジュールする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Periodic Tasks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>定期的なタスクのスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scheduler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the Scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラーエクステンションの詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたタスクにクラスタリングのサポートが必要ですか？このガイドでは、そのための Quartz エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quartz</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can send email from a Quarkus application with our reactive email client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメールクライアントを使用してQuarkusアプリケーションからメールを送信する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Emails</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メールの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can use templating in your applications with the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteのテンプレートエンジンを使ったアプリケーションでのテンプレートの使用方法については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn everything you need to know about the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteのテンプレートエンジンについて知りたい方は、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/qute-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you extract content from documents using the Apache Tika toolkit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Tika ツールキットを使ってドキュメントからコンテンツを抽出する方法についての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tika</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tika</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Vert.x in Quarkus to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでVert.xを使用してリアクティブアプリケーションを構築する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vertx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can access Git repositories with JGit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、JGitを使ってGitリポジトリにアクセスする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jgit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/jgit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from Consul.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが実行時にConsulから設定プロパティを読み取る方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/consul-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/consul-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to best measure the footprint of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションのフットプリントを最適に測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring Performance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パフォーマンスの測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/performance-measure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/performance-measure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>alternative-languages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>alternative-languages</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Languages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Kotlin.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Kotlinの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kotlin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>writing-extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn step by step how to build a simple extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>簡単なエクステンションを構築する方法をステップバイステップで学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building My First Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのエクステンションのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>building-my-first-extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>building-my-first-extension</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをQuarkusのCDIコンテナに統合する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cdi-integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cdi-integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを Dev UI に機能貢献させる方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dev-ui</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>dev-ui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore all the BuildItems you can consume/produce in your extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションで消費/生産できるすべての BuildItems を調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All BuildItems</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのビルドアイテム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all-builditems</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>all-builditems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションは、可能な限り多くの作業をビルド処理にプッシュすることで、アプリケーションを最適化します。このガイドでは、Quarkusエクステンションの根拠を説明し、独自のエクステンションを作成する方法を説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Your Own Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自のエクステンションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus class loading infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusクラスのローディングインフラストラクチャについてはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class Loading Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスローディングリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about what we call a Platform in the Quarkus world.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの世界でプラットフォームと呼ばれているものについては、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Understanding the Platform concept</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォームのコンセプトを理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/platform</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: security
title: Security
permalink: /security/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: security
title: セキュリティー
permalink: /security/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのチームとコミュニティは、すべてのセキュリティーバグを非常に深刻に受け止めています。ポリシーとセキュリティー開示に関するQuarkusのガイドラインはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reporting security issues</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー問題の報告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone can post to this list. The subscribers are only trusted individuals from the Quarkus community who will handle the resolution of any reported security issues in confidence. In your report, please note how you would like to be credited for discovering the issue and the details of any embargo you would like to impose. Currently the security response teams for the following distributions are subscribed to this list and will respond to your report:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリストには誰でも投稿できます。このリストの購読者は、Quarkusコミュニティの信頼できる個人のみで、報告されたセキュリティー問題の解決を秘密を守って処理します。報告においては、問題を発見したことについてどのようにクレジットされたいか、またエンバーゴ処理を適用したい場合はその詳細を記載してください。現在、以下のディストリビューションのセキュリティー対応チームがこのリストに登録されており、あなたのレポートに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ecosystem</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エコシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an ecosystem made from many extensions and many libraries (like Eclipse Vert.x, Hibernate, Apache Camel and more), most of them not under the direct responsibility of the Quarkus team. If you find a security bug possibly rooted in one of these libraries, you can either disclose to them directly or disclose them to the Quarkus team (following this process) and we will responsibly disclose the issue to the respective extension or library maintainer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、多くのエクステンションと多くのライブラリ(Eclipse Vert.x、Hibernate、Apache Camelなど)からなるエコシステムであり、そのほとんどはQuarkusチームの直接の責任下にはありません。これらのライブラリに根ざしている可能性のあるセキュリティーバグを見つけた場合は、それらのライブラリに直接開示するか、Quarkusチームに開示することが出来(このプロセスに従ってください)、その場合、責任を持ってそれぞれのエクステンションまたはライブラリのメンテナに開示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロセスに従う理由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the sensitive nature of security bugs, the disclosure process is more constrained than a regular bug. We appreciate you following these industry accepted guidelines, which gives time for a proper fix and limit the time window of attack.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーバグは機密性が高いため、通常のバグよりも開示プロセスに制約があります。我々は、適切な修正のための時間を与え、攻撃の時間枠を制限する、業界で認められたこれらのガイドラインに従っていただけることに感謝します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Versions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コミュニティは、https://quarkus.io/get-started/ で公開されている最新の major.minor バージョンのセキュリティーバグを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We may fix the vulnerability to older versions depending on the severity of the issue and the age of the release, but we are only committing to the latest version released.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題の深刻度やリリースの経過時間によっては、古いバージョンへの脆弱性を修正する場合がありますが、コミットしているのは、リリースされた最新バージョンのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling security issues</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー問題への対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you represent a Quarkus extension or a Quarkus platform, you are welcome to subscribe to the security at quarkus.io mailing list. Your subscription will only be approved if you can demonstrate that you will handle issues in confidence and properly credit reporters for discovering issues (e.g. experience with embargoe process).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのエクステンションやQuarkusのプラットフォームを代表している場合は、security at quarkus.ioのメーリングリストを購読することを歓迎します。あなたの購読は、あなたが問題を秘密を守って処理し、問題を発見した報告者を適切にクレジット出来ると証明できる場合にのみ承認されます(例:エンバーゴ処理の経験)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers the ability to automatically generate Kubernetes resources based on sane defaults and user-supplied configuration using https://github.com/dekorateio/dekorate/[dekorate].  It currently supports generating resources for vanilla &lt;&lt;#kubernetes,Kubernetes&gt;&gt;, &lt;&lt;#openshift,OpenShift&gt;&gt; and &lt;&lt;#knative,Knative&gt;&gt;.  Furthermore, Quarkus can deploy the application to a target Kubernetes cluster by applying the generated manifests to the target cluster's API Server.  Finally, when either one of container image extensions is present (see the link:container-image[container image guide] for more details), Quarkus has the ability to create a container image and push it to a registry *before* deploying the application to the target platform.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、 link:https://github.com/dekorateio/dekorate/[dekorate] を使用して、妥当なデフォルトとユーザーが提供する設定に基づいてKubernetesリソースを自動的に生成する機能を提供しています。現在、バニラ link:#kubernetes[Kubernetes] 、 link:#openshift[OpenShift] 、 link:#knative[Knative] のリソース生成をサポートしています。さらに、Quarkusは、生成されたマニフェストをターゲットクラスターのAPI Serverに適用することで、ターゲットKubernetesクラスターにアプリケーションをデプロイすることができます。最後に、コンテナーイメージエクステンションのいずれかが存在する場合(詳細は link:container-image[コンテナーイメージガイド] を参照)、Quarkusでは、ターゲットプラットフォームにアプリケーションをデプロイする *前* に、 コンテナーイメージを作成してレジストリーにプッシュする機能があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide, you need:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドを完成させるには、以下が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 1.8+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>access to a Kubernetes cluster (Minikube is a viable option)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes クラスターへのアクセス (Minikube も選択可能なオプションです)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create a new project that contains both the Kubernetes and Jib extensions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes エクステンションとJib エクステンションの両方を含む新しいプロジェクトを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This added the following dependencies to the `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、以下の依存関係が `pom.xml`に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding these dependencies, we enable the generation of Kubernetes manifests each time we perform a build while also enabling the build of a container image using Jib.  For example, following the execution of `./mvnw package`, you will notice amongst the other files that are created, two files named `kubernetes.json` and `kubernetes.yml` in the `target/kubernetes/` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの依存関係を追加することで、ビルドを実行するたびに Kubernetes のマニフェストを生成できるようになり、同時に Jib を使用したコンテナーイメージのビルドも可能になります。例えば、 `./mvnw package` を実行すると、作成される他のファイルの中に `kubernetes.json` と `kubernetes.yml` という名前のファイルが `target/kubernetes/` ディレクトリーにあることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at either file you will see that it contains both a Kubernetes `Deployment` and a `Service`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらのファイルを見ても、Kubernetes `Deployment` と `Service` 両方が含まれていることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source of the `kubernetes.json` file looks something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`kubernetes.json` ファイルの完全なソースはこんな感じです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifest can be applied to the cluster from the project root using `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストは、 `kubectl` を使用してプロジェクトのルートからクラスターに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An important thing to note about the `Deployment` is that is uses `yourDockerUsername/test-quarkus-app:1.0.0-SNAPSHOT` as the container image of the `Pod`.  The name of the image is controlled by the Jib extension and can be customized using the usual `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Deployment` について注意すべき重要なことは、 `Pod` のコンテナーイメージとして `yourDockerUsername/test-quarkus-app:1.0-SNAPSHOT` を使用していることです。イメージの名前は Jib エクステンションによって制御され、通常の `application.properties` を利用してカスタマイズできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example with a configuration like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、次のような設定の場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The image that will be used in the generated manifests will be `quarkus/demo-app:1.0`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストで使用されるイメージは `quarkus/demo-app:1.0` となります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Namespace</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前空間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus omits the namespace in the generated manifests, rather than enforce the `default` namespace. That means that you can apply the manifest to your chosen namespace when using `kubctl`, which in the example below is `test`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusは生成されたマニフェストの名前空間を省略し、 `default` 名前空間を強制しません。つまり、 `kubctl` (以下の例では `test` )を使用している場合は、選択したネームスペースにマニフェストを適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify the namespace in your manifest customize with the following property in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マニフェストで名前空間を指定するには、 `application.properties` の中で次のプロパティによってカスタマイズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding this property along with the rest of the container image properties of the previous section, the generated manifests will use the image `my.docker-registry.net/quarkus/demo-app:1.0`.  The image is not the only thing that can be customized in the generated manifests, as will become evident in the following sections.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のセクションで説明したコンテナーイメージプロパティーと一緒にこのプロパティーを追加すると、生成されるマニフェストではイメージ `my.docker-registry.net/quarkus/demo-app:1.0` を使用するようになります。次のセクションで明らかになるように、生成されるマニフェストでカスタマイズできるのはイメージだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels and Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラベルとアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifests use the Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[recommended labels].  These labels can be customized using `quarkus.kubernetes.name`, `quarkus.kubernetes.version` and `quarkus.kubernetes.part-of`.  For example by adding the following configuration to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストには、Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[推奨のラベル]が使用されます。これらのラベルは、 `quarkus.kubernetes.name`, `quarkus.kubernetes.version` および `quarkus.kubernetes.part-of` を使用してカスタマイズすることができます。例えば、 `application.properties` に以下の設定を追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is described in detail in the &lt;&lt;#openshift, OpenShift&gt;&gt; section, customizing OpenShift (or Knative) properties is done in the same way, but replacing `kubernetes` with `openshift` (or `knative`). The previous example for OpenShift would look like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#openshift[OpenShift] のセクションで詳しく説明しているように、OpenShift (または Knative) のプロパティーのカスタマイズは同じ方法で行いますが、 `kubernetes` を `openshift` (または `knative` ) に置き換えます。OpenShiftに対する先ほどの例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The labels in generated resources will look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースのラベルは次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Labels</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Custom Labels</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add additional custom labels, for example `foo=bar` just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のカスタムラベルを追加するには、例えば `foo=bar` を設定する場合、以下の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the `quarkus-container-image-jib` extension to build a container image, then any label added via the aforementioned property will also be added to the generated container image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-container-image-jib` エクステンションモジュールを使用してコンテナーイメージを作成する場合、前述のプロパティーを介して追加されたラベルも生成されたコンテナーイメージに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Out of the box, the generated resources will be annotated with version control related information that can be used either by tooling, or by the user for troubleshooting purposes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースにはバージョン管理に関連する情報がアノテーションされ、ツールによって、またはユーザーがトラブルシューティングの目的で使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom annotations can be added in a way similar to labels.For example to add the annotation `foo=bar` and `app.quarkus/id=42` just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、注釈 `foo=bar` と `app.quarkus/id=42` を追加するには、次の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes provides multiple ways of defining environment variables:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesでは、環境変数を定義する方法が複数用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import all values from a Secret or ConfigMap</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Secret または ConfigMap からすべての値をインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>interpolate a single value identified by a given field in a Secret or ConfigMap</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Secret または ConfigMap の指定されたフィールドで識別される単一の値を補間する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from key/value pairs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キー/値のペアからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a key/value pair as an environment variable in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースに環境変数としてキーとバリューのペアを追加する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command above will add `MY_ENV_VAR=foobar` as an environment variable.  Please note that the key `my-env-var` will be converted to uppercase and dashes will be replaced by underscores resulting in `MY_ENV_VAR`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のコマンドは `MY_ENV_VAR=foobar` を環境変数として追加します。キー `my-env-var` は大文字に変換され、ダッシュはアンダースコアに置き換えられて `MY_ENV_VAR` となることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from Secret</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add all key/value pairs of `Secret` as environment variables just apply the following configuration, separating each `Secret` to be used as source by a comma (`,`):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Secret` のすべてのキーと値のペアを環境変数として追加するには、以下の設定を適用し、ソースとして使用する各 `Secret` をカンマ ( `,` ) で区切ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which would generate the following in the container definition:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>とすると、コンテナーの定義に以下のようなものが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following extracts a value identified by the `keyName` field from the `my-secret` Secret into a `foo` environment variable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、 `my-secret` Secret から `keyName` フィールドで識別される値を `foo` 環境変数に抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This would generate the following in the `env` section of your container:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、コンテナーの `env` セクションに以下のようなものが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add all key/value pairs from `ConfigMap` as environment variables just apply the following configuration, separating each `ConfigMap` to be used as source by a comma (`,`):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ConfigMap` からのすべてのキーと値のペアを環境変数として追加するには、以下の設定を適用し、ソースとして使用する各 `ConfigMap` をカンマ ( `,` ) で区切ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following extracts a value identified by the `keyName` field from the `my-config-map` ConfigMap into a `foo` environment variable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、 `my-config-map` ConfigMap から `keyName` フィールドで識別される値を `foo` 環境変数に抽出したものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from fields</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フィールドからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's also possible to use the value from another field to add a new environment variable by specifying the path of the field to be used as a source, as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下のように、ソースとして使用するフィールドのパスを指定することで、別のフィールドの値を使用して新しい環境変数を追加することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is described in detail in the &lt;&lt;#openshift, OpenShift&gt;&gt; section, customizing OpenShift properties is done in the same way, but replacing `kubernetes` with `openshift`. The previous example for OpenShift would look like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#openshift[OpenShift] の項で詳しく説明していますが、OpenShift のプロパティーのカスタマイズも同じ方法で行いますが、 `kubernetes` を `openshift` に置き換えます。OpenShiftの先ほどの例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A conflict between two definitions, e.g. mistakenly assigning both a value and specifying that a variable is derived from a field, will result in an error being thrown at build time so that you get the opportunity to fix the issue before you deploy your application to your cluster where it might be more difficult to diagnose the source of the issue.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、誤って両方の値を代入したり、変数がフィールドから派生したものであることを指定したりするなど、2つの定義の間で競合が発生すると、ビルド時にエラーが発生します。そのため、問題の原因を診断するのが困難なクラスターにアプリケーションをデプロイする前に問題を修正する機会を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, two redundant definitions, e.g. defining an injection from the same secret twice, will not cause an issue but will indeed report a warning to let you know that you might not have intended to duplicate that definition.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同様に、同じシークレットからのインジェクションを2回定義するなど、2つの冗長な定義があっても問題は発生しませんが、その定義を複製することを意図していなかった可能性があることを知らせる警告が実際に報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Backwards compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>下位互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Previous versions of the Kubernetes extension supported a different syntax to add environment variables.The older syntax is still supported but is deprecated and it's advised that you migrate to the new syntax.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes エクステンションの以前のバージョンでは、環境変数を追加するための異なる構文をサポートしていました。古い構文はまだサポートされていますが、非推奨ですので、新しい構文に移行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Old vs. new syntax</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>古い構文と新しい構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Old</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>旧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Plain variable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>素の変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.vars.my-env-var=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env.vars.my-env-var=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From field</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フィールドから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All from `ConfigMap`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての `ConfigMap` から</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.configmaps=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env.configmaps=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All from `Secret`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての `Secret` から</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.xxx.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars.xxx.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From one `Secret` field</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ある `Secret` フィールドから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.foo.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars.foo.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.foo.value=field`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars.foo.value=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.mapping.foo.with-key=field`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env.mapping.foo.with-key=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From one `ConfigMap` field</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ある `ConfigMap` フィールドから</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars.foo.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars.foo.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you redefine the same variable using the new syntax while keeping the old syntax, **ONLY** the new version will be kept and a warning will be issued to alert you of the problem.For example, if you define both `quarkus.kubernetes.env-vars.my-env-var.value=foobar` and `quarkus.kubernetes.env.vars.my-env-var=newValue`, the extension will only generate an environment variable `MY_ENV_VAR=newValue` and issue a warning.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>古い文法を残した状態で新しい文法を使って同じ変数を再定義した場合、 新しいバージョン **のみ** が保持され、問題を通知するために警告が発せられます。例えば、`quarkus.kubernetes.env-vars.my-env-var.value=foobar` と `quarkus.kubernetes.env.vars.my-env-var=newValue` の両方を定義した場合、エクステンションは環境変数 `MY_ENV_VAR=newValue` のみを生成して警告を発します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mounting volumes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ボリュームのマウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kubernetes extension allows the user to configure both volumes and mounts for the application.  Any volume can be mounted with a simple configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes エクステンションを使用すると、アプリケーションのボリュームとマウントの両方を設定することができます。 簡単な設定で任意のボリュームをマウントすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add a mount to the pod for volume `my-volume` to path `/where/to/mount`.  The volumes themselves can be configured as shown in the sections below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、Pod のパス `/where/to/mount` にボリューム `my-volume` のマウントを追加します。 ボリューム自体は、以下のセクションに示すように設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret volumes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットのボリューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing application configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション設定の受け渡し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports passing configuration from external locations (via Smallrye Config). This usually requires setting an additional environment variable or system propertiy.  When you need to use a secret or a config map for the purpose of application configuration, you need to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、外部の場所から（Smallrye Config経由で）設定を渡すことをサポートしています。これには通常、追加の環境変数やシステムの適切性を設定する必要があります。 アプリケーションの設定の目的で Secret や ConfigMap を使用する必要がある場合は、以下のようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To simplify things, quarkus provides single step alternative:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>物事を単純化するために、Quarkus はシングルステップの代替手段を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When these properties are used, the generated manifests will contain everything required.  The application config volumes will be created using path: `/mnt/app-secret` and `/mnt/app-config-map` for secrets and configmaps respectively.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのプロパティを使用すると、生成されたマニフェストには必要なものがすべて含まれます。 アプリケーションのコンフィグボリュームは、Secret と ConfigMap にそれぞれパスを使用して作成されます。Secret と ConfigMap  はそれぞれ `/mnt/app-secret` と `/mnt/app-config-map` を使用して作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: Users may use both properties at the same time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注：ユーザーは両方のプロパティを同時に使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the number of replicas:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レプリカ数を変更する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To change the number of replicas from 1 to 3:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レプリカ数を1から3に変更するためには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add readiness and liveness probes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>rediness および liveness プローブを追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Kubernetes resources do not contain readiness and liveness probes in the generated `Deployment`. Adding them however is just a matter of adding the SmallRye Health extension like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Kubernetesリソースは、生成された `Deployment` の中に readiness と liveness のプローブを含みません。しかし、これらを追加するには、以下のように SmallRye Health エクステンションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values of the generated probes will be determined by the configured health properties: `quarkus.smallrye-health.root-path`, `quarkus.smallrye-health.liveness-path` and `quarkus.smallrye-health.readiness-path`.  More information about the health extension can be found in the relevant link:microprofile-health[guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されるプローブの値は、設定されたヘルスプロパティによって決定されます。`quarkus.smallrye-health.root-path`, `quarkus.smallrye-health.liveness-path`, `quarkus.smallrye-health.readiness-path` で決定されます。 health エクステンションの詳細については、関連リンク:microprofile-health[ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing the readiness probe:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>rediness プローブのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To set the initial delay of the probe to 20 seconds and the period to 45:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プローブの初期遅延を 20 秒、周期を 45 秒に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add hostAliases</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>hostAliases の追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add entries to a Pod's `/etc/hosts` file (more information can be found in https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/[Kubernetes documentation]), just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Podの`/etc/hosts`ファイルにエントリを追加するには(詳細は https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/[Kubernetes documentation] )、以下の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This would generate the following `hostAliases` section in the `deployment` definition:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、`deployment`定義の中に以下の `hostAliases` セクションが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Resources Management</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナリソース管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CPU &amp; Memory limits and requests can be applied to a `Container` (more info in https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/[Kubernetes documentation]) using the following configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CPUやメモリの制限やリクエストは、以下の設定で `Container` (詳細は https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/[Kubernetes documentation] を参照) に適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This would generate the following entry in the `container` section:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、`container`セクションに以下のエントリが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications that are deployed to Kubernetes and need to access the API server will usually make use of the `kubernetes-client` extension:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesにデプロイされ、APIサーバにアクセスする必要があるアプリケーションは、通常 `kubernetes-client` エクステンションを利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To access the API server from within a Kubernetes cluster, some RBAC related resources are required (e.g. a ServiceAccount, a RoleBinding etc.).  So, when the `kubernetes-client` extension is present, the `kubernetes` extension is going to create those resources automatically, so that application will be granted the `view` role.  If more roles are required, they will have to be added manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesクラスタ内からAPIサーバにアクセスするためには、RBAC関連のリソース(ServiceAccountやRoleBindingなど)が必要である。 そのため、`kubernetes-client` エクステンションが存在する場合、`kubernetes` エクステンションはこれらのリソースを自動的に作成し、アプリケーションに `view` ロールを付与します。 より多くのロールが必要な場合は、手動で追加しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/kubernetes/minikube[Minikube] is quite popular when a Kubernetes cluster is needed for development purposes. To make the deployment to Minikube experience as frictionless as possible, Quarkus provides the `quarkus-minikube` extension. This extension can be added to a project like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/kubernetes/minikube[Minikube] は、開発目的でKubernetesクラスタが必要な場合に非常に人気があります。Minikubeへのデプロイをできるだけ摩擦のないものにするために、Quarkusは `quarkus-minikube` エクステンションを提供しています。このエクステンションは、以下のようなプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of this extension is to generate Kubernetes manifests (`minikube.yaml` and `minikube.json`) that are tailored to Minikube.  This extension assumes a couple things:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションの目的は、Minikube に合わせた Kubernetes マニフェスト (`minikube.yaml` と `minikube.json`) を生成することです。 このエクステンションはいくつかのことを前提としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users won't be using an image registry and will instead make their container image accessible to the Kubernetes cluster by building it directly into Minikube's Docker daemon. To use Minikube's Docker daemon you must first execute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーはイメージレジストリを使用せず、コンテナイメージをMinikubeのDockerデーモンに直接ビルドしてKubernetesクラスタにアクセスできるようにします。MinikubeのDockerデーモンを使用するには、まず実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications deployed to Kubernetes won't be accessed via a Kubernetes `Ingress`, but rather as a `NodePort` `Service`.  The advantage of doing this is that the URL of an application can be retrieved trivially by executing:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesにデプロイされたアプリケーションは、Kubernetesの `Ingress` ではなく、`NodePort` `Service` としてアクセスされます。 この方法の利点は、アプリケーションのURLを実行することで、アプリケーションのURLを簡単に取得できることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the https://kubernetes.io/docs/concepts/services-networking/service/#nodeport[nodePort] that is used in this case, users can set `quarkus.kubernetes.node-port`.  Note however that this configuration is entirely optional because Quarkus will automatically use a proper (and non-changing) value if none is set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合に使用される https://kubernetes.io/docs/concepts/services-networking/service/#nodeport[nodePort] を制御するために、ユーザーは `quarkus.kubernetes.node-port` を設定することができます。 しかし、何も設定されていない場合、Quarkusは自動的に適切な（変更されない）値を使用するため、この設定は完全に任意であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is highly discouraged to use the manifests generated by the Minikube extension when deploying to production as these manifests are intended for development purposes only. When deploying to production, consider using the vanilla Kubernetes manifests (or the OpenShift ones when targeting OpenShift).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番環境へのデプロイ時に Minikube エクステンションで生成されたマニフェストを使用することはまったくお勧めできません。本番環境にデプロイする場合は、バニラ Kubernetes マニフェスト (または OpenShift をターゲットにしている場合は OpenShift マニフェスト) の使用を検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the assumptions the Minikube extension makes don't fit your workflow, nothing prevents you from using the regular Kubernetes extension to generate Kubernetes manifests and apply those to your Minikube cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Minikube エクステンションが想定している前提がワークフローに合わない場合、通常の Kubernetes エクステンションを使用して Kubernetes マニフェストを生成し、それを Minikube クラスタに適用することを妨げるものは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tuning the generated resources using application.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>application.properties を使用して生成されたリソースをチューニングする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kubernetes extension allows tuning the generated manifest, using the `application.properties` file.  Here are some examples:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes のエクステンションでは、`application.properties` ファイルを使用して生成されたマニフェストをチューニングすることができます。 ここではいくつかの例を紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The table below describe all the available configuration options.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の表は、利用可能なすべての設定オプションについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>String</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.kubernetes.resources.limits.cpu</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>\</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties that use non-standard types, can be referenced by expanding the property.  For example to define a `kubernetes-readiness-probe` which is of type `Probe`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非標準型を使用するプロパティーは、プロパティーを展開することで参照することができます。例えば、 `Probe` 型の  `kubernetes-readiness-probe` を定義するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example `initial-delay` and `period` are fields of the type `Probe`.  Below you will find tables describing all available types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、 `initial-delay` と `period` は `Probe` タイプのフィールドです。以下に、利用可能なすべてのタイプを説明した表を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基本的なタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Allowed values: `cluster-ip`, `node-port`, `load-balancer`, `external-name`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>許可される値: `cluster-ip` , `node-port` , `load-balancer` . `external-name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One way to deploy an application to OpenShift is to use s2i (source to image) to create an image stream from the source and then deploy the image stream:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを OpenShift にデプロイする方法の1つとして、s2i(source to image)を使用してソースからイメージストリームを作成し、イメージストリームをデプロイする方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See further information in link:deploying-to-openshift[Deploying to OpenShift].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は「 link:deploying-to-openshift[OpenShiftへのデプロイ] 」を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A description of OpenShift resources and customisable properties is given below alongside Kubernetes resources to show similarities where applicable.   This includes an alternative to  `oc new-app ...` above, i.e. `oc apply -f target/kubernetes/openshift.json` .
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShiftリソースとカスタマイズ可能なプロパティーの説明を以下にKubernetesリソースと一緒に記載し、該当する場合には類似性を示します。これには、上記の `oc new-app …` の代替、すなわち `oc apply -f target/kubernetes/openshift.json` を含みます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to generate resources for both platforms (vanilla Kubernetes and OpenShift), then you need to include both (comma separated).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>両方のプラットフォーム(バニラKubernetesとOpenShift)のリソースを生成する必要がある場合は、両方を含める必要があります(カンマ区切り)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the execution of `./mvnw package -Dquarkus.container-image.build=true ` you will notice amongst the other files that are created, two files named `openshift.json` and `openshift.yml` in the `target/kubernetes/` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Dquarkus.container-image.build=true` の実行後に、 `target/kubernetes/` ディレクトリーに `openshift.json` と `openshift.yml` という名前の2つのファイルが作成されたことに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These manifests can be deployed as is to a running cluster, using `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのマニフェストは、 `kubectl` を使用して、実行中のクラスターにそのままデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift users might want to use `oc` instead of `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShiftユーザーは、 `kubectl` の代わりに `oc` を使用した方が良いかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides the link:deploying-to-openshift[OpenShift] extension. This extension is basically a wrapper around the Kubernetes extension and relieves OpenShift users of the necessity of setting the `deployment-target` property to `openshift`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは link:deploying-to-openshift[OpenShift] エクステンションも提供しています。このエクステンションは基本的に Kubernetes エクステンションのラッパーであり、OpenShiftユーザーが `deployment-target` プロパティーを `openshift` に設定する必要性を緩和します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenShift resources can be customized in a similar approach with Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesと同様のアプローチでOpenShiftのリソースをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Knative</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable the generation of Knative resources, you need to include Knative in the target platforms:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative リソースの生成を可能にするには、ターゲットプラットフォームに Knative を含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the execution of `./mvnw package` you will notice amongst the other files that are created, two files named `knative.json` and `knative.yml` in the `target/kubernetes/` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package` の実行後、作成された他のファイルの中に `knative.json` と `knative.yml` という名前のファイルが `target/kubernetes/` ディレクトリーにあることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at either file you will see that it contains a Knative `Service`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらかのファイルを見ると、Knative `Service` が含まれることが確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source of the `knative.json` file looks something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`knative.json` ファイルの完全なソースはこんな感じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifest can be deployed as is to a running cluster, using `kubectl`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストは、 `kubectl` を使用して、実行中のクラスターにそのままデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated service can be customized using the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたサービスは、以下のプロパティーを使用してカスタマイズすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expose a dedicated url for referncing this target</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このターゲットを参照するための専用URLを公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally provided to indicate that the latest revision should be used for this traffic target</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この Traffic ターゲットに最新のリビジョンを使用することを示すためにオプションで提供される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates the percent of traffic that is be routed to this revision</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリビジョンにルーティングされる Traffic の割合を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment targets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイメントターゲット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mentioned in the previous sections was the concept of `deployment-target`. This concept allows users to control which Kubernetes manifests will be generated and deployed to a cluster (if `quarkus.kubernetes.deploy` has been set to `true`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のセクションで述べたのは `deployment-target` という概念です。この概念により、ユーザーはどの Kubernetes マニフェストを生成してクラスターにデプロイするかを制御することができます ( `quarkus.kubernetes.deploy` が `true` に設定されている場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when no `deployment-target` is set, then only vanilla Kubernetes resources are generated and deployed. When multiple values are set (for example `quarkus.kubernetes.deployment-target=kubernetes,openshift`) then the resources for all targets are generated, but only the resources that correspond to the *first* target are applied to the cluster (if deployment is enabled).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `deployment-target` が設定されていない場合は、バニラ Kubernetes リソースのみが生成され、デプロイされます。複数の値が設定されている場合 (例: `quarkus.kubernetes.deployment-target=kubernetes,openshift` )、すべてのターゲットのリソースが生成されますが、 *最初* のターゲットに対応するリソースのみがクラスターに適用されます (デプロイが有効な場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of wrapper extensions like OpenShift and Minikube, when these extensions have been explicitly added to the project, the default `deployment-target` is set by those extensions. For example if `quarkus-minikube` has been added to a project, then `minikube` becomes the default deployment target and its resources will be applied to the Kubernetes cluster when deployment via `quarkus.kubernetes.deploy` has been set.  Users can still override the deployment-targets manually using `quarkus.kubernetes.deployment-target`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShiftやMinikubeのようなラッパーエクステンションの場合、これらのエクステンションがプロジェクトに明示的に追加されているときは、それらのエクステンションによってデフォルトの `deployment-target` が設定されます。例えば、 `quarkus-minikube` がプロジェクトに追加されている場合、 `minikube` がデフォルトのデプロイメントターゲットになり、 `quarkus.kubernetes.deploy` 経由のデプロイメントが設定されていると、そのリソースが Kubernetes クラスターに適用されます。ユーザーは、 `quarkus.kubernetes.deployment-target` を使用して手動でディプロイメント ターゲットを上書きすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecated configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非推奨の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following categories of configuration properties have been deprecated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のカテゴリの構成プロパティーは非推奨となりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties without the quarkus prefix</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus接頭辞のないプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In earlier versions of the extension, the `quarkus.` was missing from those properties. These properties are now deprecated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以前のバージョンのエクステンションでは、これらのプロパティーに `quarkus.` がありませんでした。これらのプロパティーは現在非推奨となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties for configuring `docker` and `s2i` are also deprecated in favor of the new container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`docker` と `s2i` を設定するためのプロパティーも非推奨となり、新しいコンテナーイメージエクステンションが採用されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config group arrays</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンフィググループ配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties referring to config group arrays (e.g. `kubernetes.labels[0]`, `kubernetes.env-vars[0]` etc) have been converted to maps, to align with the rest of the Quarkus ecosystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンフィググループ配列を参照するプロパティー(例: `kubernetes.labels[0]` 、 `kubernetes.env-vars[0]` など)は、Quarkusのエコシステムの他の部分と一致するようにマップに変換されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `labels` config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードは `labels` の設定を変更した様子を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `env-vars` config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードは `env-vars` の設定を変更した様子を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.kubernetes.env-vars` are deprecated (though still currently supported as of this writing) and the new declaration style should be used instead.  See &lt;&lt;#env-vars&gt;&gt; and more specifically &lt;&lt;env-vars-backwards&gt;&gt; for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kubernetes.env-vars` は非推奨です(この記事を書いている時点ではまだサポートされていますが)ので、代わりに新しい宣言スタイルを使うべきです。詳細は link:#env-vars[[env-vars]] とより具体的には link:#env-vars-backwards[[env-vars-backwards] を] 参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger building and deploying a container image you need to enable the `quarkus.kubernetes.deploy` flag (the flag is disabled by default - furthermore it has no effect during test runs or dev mode).  This can be easily done with the command line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージをビルドしてデプロイするには、 `quarkus.kubernetes.deploy` フラグを有効にする必要があります (このフラグはデフォルトでは無効になっています - さらに、テスト実行中や開発モードでは何の効果もありません)。これはコマンドラインで簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a container image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a container image is possible, using any of the 3 available `container-image` extensions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージのビルドは、利用可能な3つの `container-image` エクステンションのいずれかを使用して可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each time deployment is requested, a container image build will be implicitly triggered (no additional properties are required when the Kubernetes deployment has been enabled).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイが要求されるたびに、暗黙のうちにコンテナーイメージのビルドがトリガーされます(Kubernetes のデプロイが有効になっている場合は、追加のプロパティーは必要ありません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When deployment is enabled, the Kubernetes extension will select the resources specified by `quarkus.kubernetes.deployment.target` and deploy them.  This assumes that a `.kube/config` is available in your user directory that points to the target Kubernetes cluster.  In other words the extension will use whatever cluster `kubectl` uses. The same applies to credentials.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイを有効にすると、Kubernetes エクステンションは `quarkus.kubernetes.deployment.target` で指定されたリソースを選択してデプロイします。これは、ターゲットの Kubernetes クラスターを指す `.kube/config` がユーザーディレクトリーで利用可能であることを前提としています。言い換えれば、エクステンションは `kubectl` が使用しているクラスターを使用します。クレデンシャルについても同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment no additional options are provided for further customization.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、さらなるカスタマイズのための追加オプションは提供されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using existing resources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のリソースの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it's desirable to either provide additional resources (e.g. a ConfigMap, a Secret, a Deployment for a database etc) or provide custom ones that will be used as a `base` for the generation process.  Those resources can be added under `src/main/kubernetes` directory and can be named after the target environment (e.g. kubernetes.json, openshift.json, knative.json, or the yml equivalents). Each of these files may contain one or more Kubernetes resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、追加のリソース(例えば、ConfigMap、Secret、データベースのデプロイメントなど)を提供するか、生成プロセスのために `base` として使用されるカスタムのリソースを提供することが望ましい場合があります。これらのリソースは `src/main/kubernetes` ディレクトリーの下に追加することができ、ターゲット環境にちなんだ名前をつけることができます (例: kubernetes.json、openshift.json、knative.json、または yml 等価のもの)。これらのファイルのそれぞれには、1つ以上のKubernetesリソースが含まれている可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any resource found will be added in the generated manifests. Global modifications (e.g. labels, annotations etc) will also be applied to those resources.  If one of the provided resources has the same name as one of the generated ones, then the generated resource will be created on top of the provided resource, respecting existing content when possible (e.g. existing labels, annotations, environment variables, mounts, replicas etc).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>見つかったリソースは、生成されたマニフェストに追加されます。グローバルな変更(ラベルや注釈など)は、それらのリソースにも適用されます。提供されたリソースの一つが、生成されたリソースの一つと同じ名前を持つ場合、生成されたリソースは提供されたリソースの上に作成され、可能な限り既存のコンテンツ(既存のラベル、アノテーション、環境変数、マウント、レプリカなど)を尊重します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the resource is determined by the application name and may be overridden by `quarkus.kubernetes.name`, `quarkus.openshift.name` and `quarkus.knative.name`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースの名前はアプリケーション名によって決定され、 `quarkus.kubernetes.name` 、 `quarkus.openshift.name` 、 `quarkus.knative.name` で上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, in the `kubernetes-quickstart` application, we can add a `kubernetes.yml` file in the `src/main/kubernetes` that looks like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `kubernetes-quickstart` アプリケーションでは、 `src/main/kubernetes` の中に `kubernetes.yml` のようなファイルを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated `kubernetes.yml` will look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `kubernetes.yml` は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided replicas &lt;1&gt;, labels &lt;2&gt; and environment variables &lt;3&gt; were retained. However, the image &lt;4&gt; and container port &lt;5&gt; were modified. Moreover, the default annotations have been added.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>提供されたレプリカ &lt;1&gt;, ラベル &lt;2&gt;, 環境変数 &lt;3&gt; はそのまま引き継がれました。ただし、イメージ &lt;4&gt; とコンテナーポート &lt;5&gt; は変更されました。また、デフォルトのアノテーションが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the resource name does not match the application name (or the overridden name) instead of reusing the resource a new one will be added. Same goes for the container.  If the name of the container does not match the application name (or the overridden name), container specific configuration will be ignored.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソース名がアプリケーション名(またはオーバーライドされた名前)と一致しない場合は、リソースを再利用する代わりに新しいリソースが追加されます。コンテナーについても同様です。コンテナーの名前がアプリケーション名 (またはオーバーライドされた名前) と一致しない場合、コンテナー固有の設定は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `kubernetes-client` extension which enables the use of the https://github.com/fabric8io/kubernetes-client[Fabric8 Kubernetes Client] in native mode while also making it easier to work with.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、 link:https://github.com/fabric8io/kubernetes-client[Fabric8 Kubernetesクライアント] をネイティブモードで使用できるようにする `kubernetes-client` エクステンションが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having a Kubernetes Client extension in Quarkus is very useful in order to unlock the power of Kubernetes Operators.  Kubernetes Operators are quickly emerging as a new class of Cloud Native applications.  These applications essentially watch the Kubernetes API and react to changes on various resources and can be used to manage the lifecycle of all kinds of complex systems like databases, messaging systems and much much more.  Being able to write such operators in Java with the very low footprint that native images provide is a great match.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes Operatorsのパワーを引き出すためには、QuarkusにKubernetesクライアントエクステンションがあると非常に便利です。Kubernetes Operatorsは、クラウドネイティブアプリケーションの新しい種類として急速に台頭してきています。これらのアプリケーションは、基本的にKubernetes APIを監視し、様々なリソースの変更に反応し、データベースやメッセージングシステムなど、あらゆる種類の複雑なシステムのライフサイクルを管理するために使用することができます。ネイティブイメージが提供する非常に低いフットプリントで、このようなOperatorをJavaで書くことができるということは、非常にマッチしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `kubernetes-client` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで次のコマンドを実行して、 `kubernetes-client` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `pom.xml` に以下が追加されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus configures a Bean of type `KubernetesClient` which can be injected into application code using the well known CDI methods.  This client can be configured using various properties as can be seen in the following example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、よく知られたCDIメソッドを使用してアプリケーションコードに注入できる `KubernetesClient` タイプのBeanを設定します。このクライアントは、以下の例にあるように、さまざまなプロパティーを使用して設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the full list of properties is available in the https://github.com/quarkusio/quarkus/blob/master/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーの完全なリストは、 link:https://github.com/quarkusio/quarkus/blob/master/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] クラスで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overriding</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension also allows application code to override either of `io.fabric8.kubernetes.client.Config` or `io.fabric8.kubernetes.client.KubernetesClient` which are normally provided by the extension by simply declaring custom versions of those beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、このエクステンションでは、アプリケーションコードは、単にそれらのBeanのカスタムバージョンを宣言することで、通常はエクステンションによって提供される `io.fabric8.kubernetes.client.Config` や `io.fabric8.kubernetes.client.KubernetesClient` のいずれかをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of this can be seen in the following snippet:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例は、次のスニペットの通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's assume we have a REST endpoint defined like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようにRESTエンドポイントが定義されているとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We could write a test for this endpoint very easily like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエンドポイントのテストは次のように簡単に書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that to take advantage of these features, the `quarkus-test-kubernetes-client` dependency needs to be added, for example like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの機能を利用するには、例えば次のように `quarkus-test-kubernetes-client` 依存関係を追加する必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and use this in your other test classes as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、これを次のように他のテストクラスで使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, to get a mock server that replies with empty lists by default (instead of getting 404 responses from the Kubernetes API), you can use the `EmptyDefaultKubernetesMockServerTestResource.class` instead of `KubernetesMockServerTestResource.class`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、デフォルトで空のリストで応答するモックサーバーを取得するには(Kubernetes APIから404の応答を取得するのではなく)、 `KubernetesMockServerTestResource.class` の代わりに `EmptyDefaultKubernetesMockServerTestResource.class` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the restrictions imposed by GraalVM, extra care needs to be taken when implementing an `io.fabric8.kubernetes.client.Watcher` if the application is intended to work in native mode.  Essentially every `Watcher` implementation needs to specify the Kubernetes model class that it handles via the ``Watcher``'s generic type at class definition time.  To better understand this, suppose we want to watch for changes to Kubernetes `Pod` resources. There are a couple ways to write such a `Watcher` that are guaranteed to work in native:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMによって課せられた制限のため、アプリケーションがネイティブモードで動作することを意図している場合、 `io.fabric8.kubernetes.client.Watcher` を実装する際には特に注意が必要です。基本的にすべての `Watcher` の実装は、クラス定義時に `Watcher` のジェネリック型を介して扱う Kubernetes モデルクラスを指定する必要があります。これをよりよく理解するために、例えばKubernetes `Pod` リソースの変更を監視したいとします。このような `Watcher` を書くには、ネイティブでの動作が保証されている方法がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that defining the generic type via a class hierarchy similar to the following example will also work correctly:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の例のようにクラス階層を介してジェネリック型を定義した場合も、正しく動作することに注目してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example will **not** work in native mode because the generic type of watcher cannot be determined by looking at the class and method definitions thus making Quarkus unable to properly determine the Kubernetes model class for which reflection registration is needed:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の例では、クラスやメソッドの定義を見てウォッチャーのジェネリック型を判断できないため、Quarkusはリフレクション登録が必要なKubernetesモデルクラスを適切に判断できないため、ネイティブモードでは動作 *しません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In many cases in order to access the Kubernetes API server a `ServiceAccount`, `Role` and `RoleBinding` will be necessary.  An example that allows listing all pods could look something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの場合、Kubernetes API サーバーにアクセスするには `ServiceAccount` 、 `Role` 、 `RoleBinding` が必要になります。すべてのPodをリスト可能な例は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replace `&lt;applicationName&gt;` and `&lt;namespace&gt;` with your values.  Have a look at https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[Configure Service Accounts for Pods] to get further information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`&lt;applicationName&gt;` と `&lt;namespace&gt;` は値に置き換えてください。 link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[PodのService Accountの設定] を参照して、詳細な情報を入手してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the targeted Kubernetes cluster is an OpenShift cluster, it is possible to access it through the `openshift-client` extension, in a similar way. This leverages the dedicated fabric8 openshift client, and provides access to `OpenShift` proprietary objects (e.g. `Route`, `ProjectRequest`, `BuildConfig` ...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>対象となるKubernetesクラスターがOpenShiftクラスターであれば、同様の方法で、 `openshift-client` エクステンションを利用してアクセスすることが可能です。これは専用の fabric8 openshift クライアントを利用し、 `OpenShift` 固有のオブジェクト(例: `Route` , `ProjectRequest` , `BuildConfig` ...)へのアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the configuration properties are shared with the `kubernetes-client` extension. In particular they have the same `quarkus.kubernetes-client` prefix.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティーは `kubernetes-client` エクステンションと共有されていることに注意してください。特に、これらは同じ `quarkus.kubernetes-client` プレフィックスを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the extension with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコマンドでエクステンションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `openshift-client` extension has a dependency on the `kubernetes-client` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`openshift-client` エクステンションは `kubernetes-client` エクステンションに依存していることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the client, inject an `OpenShiftClient` instead of the `KubernetesClient`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントを使用するには、 `KubernetesClient` の代わりに `OpenShiftClient` を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to override the default `OpenShiftClient`, provide a producer such as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトの `OpenShiftClient` を上書きする必要がある場合は、次のようなプロデューサーを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock support is also provided in a similar fashion:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>モックサポートも同様の方法で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, you have to add a dependency on `quarkus-test-openshift-client`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用するには、 `quarkus-test-openshift-client` に依存関係を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `pom.xml`, add the following dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml` で、以下の依存関係を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お使いの JDBC ドライバーエクステンション ( `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Query parameters</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クエリパラメーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Persistence Units</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の永続性ユニット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:http://camel.apache.org/[Apache Camel]は、10年以上の歴史とユーザーや開発者の活発なコミュニティを持つ、異種システムを統合するためのスイスアーミーナイフです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus上のApache Camelのサポートは、 link:https://github.com/apache/camel-quarkus[Apache Camel Quarkusプロジェクト]によって提供されています。詳細は link:https://camel.apache.org/camel-quarkus/latest/[彼らのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for properties file based authentication that is intended for development and testing purposes. It is not recommended that this be used in production as at present only plaintext and MD5 hashed passwords are used, and properties files are generally too limited to use in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、開発とテストを目的としたプロパティーファイルベースの認証をサポートしています。現在のところ、平文とMD5ハッシュ化されたパスワードしか使用されておらず、プロパティーファイルは一般的に本番環境で使用するには制限が多すぎるため、本番環境で使用することはお勧めできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下を `pom.xml` に追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elytron-security-properties-file extension currently supports two different realms for the storage of authentication and authorization information. Both support storage of this information in properties files. The following sections detail the specific configuration properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>elytron-security-properties-file エクステンションは、現在、認証と認可情報の保存のための2つの異なる領域をサポートしています。どちらもこの情報のプロパティーファイルへの保存をサポートしています。以下のセクションでは、特定の設定プロパティーについて詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties Files Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーファイルレルム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties files realm supports mapping of users to password and users to roles with a combination of properties files. They are configured with properties starting with `quarkus.security.users.file`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーファイルのレルムは、プロパティーファイルの組み合わせを使用して、ユーザーをパスワードに、ユーザーをロールにマッピングすることをサポートしています。これらは `quarkus.security.users.file` で始まるプロパティーで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーズプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.security.users.file.users` configuration property specifies a classpath resource which is a properties file with a user to password mapping, one per line. The following &lt;&lt;test-users-example&gt;&gt; illustrates the format:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.security.users.file.users` 設定プロパティーは、クラスパスリソースを指定します。これは、1行に1つずつ、ユーザーとパスワードをマッピングしたプロパティーファイルです。以下の link:#test-users-example[test-users-example] はそのフォーマットを示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password defined as `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` のパスワードは `jb0ss` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has password defined as `p4ssw0rd`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `jdoe` のパスワードは `p4ssw0rd` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルには、ユーザー名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roles.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Roles.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has been assigned the roles `Admin`, `admin`, `Tester` and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester` および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has been assigned the role `NoRolesUser`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `jdoe` に役割が割り当てられています。 `NoRolesUser`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has been assigned the roles `admin` and `user`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` には `admin` と `user` の役割が割り当てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンベデッドレルムの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The embedded realm also supports mapping of users to password and users to roles. It uses the main `application.properties` Quarkus configuration file to embed this information. They are configured with properties starting with `quarkus.security.users.embedded`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>埋め込まれたレルムは、ユーザーのパスワードへのマッピングやユーザーのロールへのマッピングもサポートしています。この情報を埋め込むには、メインの `application.properties` Quarkus設定ファイルを使用します。これらは、 `quarkus.security.users.embedded` で始まるプロパティーで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example application.properties file section illustrating the embedded realm configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、組み込みレルムの設定を示すapplication.propertiesファイルのセクションの例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the first example this file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の例と同様に、このファイルにはユーザー名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上記の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Users</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>組込ユーザー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to password mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;`. The following &lt;&lt;password-example&gt;&gt; illustrates the syntax with 4 user to password mappings:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーからパスワードへのマッピングは、 `application.properties` ファイル内で `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;` 形式のプロパティーキーで指定します。以下の link:#password-example[password-example] は]、4 つのユーザーからパスワードへのマッピングの構文を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Passwords</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスワードの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` はパスワード `jb0ss` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has password `test`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` はパスワード `test` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Roles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>組込ロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to role mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.roles.&lt;user&gt;=role1[,role2[,role3[,...]]]`. The following &lt;&lt;roles-example&gt;&gt; illustrates the syntax with 4 user to role mappings:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーとロールのマッピングは、 `application.properties` ファイルで `quarkus.security.users.embedded.roles.&amp;amp;lt;user&amp;amp;gt;=role1[,role2[,role3[,…​]]]` 形式のプロパティー・キーで指定されます。以下の link:#roles-example[[role-example]]は、4つのユーザーとロールをマッピングした構文を示しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Roles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロールの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has roles `Admin`, `admin`, `Tester`, and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester`, および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has roles `admin` and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` には `admin` と `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>References</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PostgreSQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class Fruit {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class Fruit {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Fruit() {
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public Fruit() {
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, you can manually add this to the dependencies section of your `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そうでなければ、 `pom.xml` ファイルの依存関係セクションに手動で追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vault</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行する場合は、GraalVM がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project. Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>services:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>services:
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once created, run `docker-compose up`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成したら、`docker-compose up` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a development cluster, do not use in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは開発クラスターであり、本番では使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price generator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格ジェネレーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import java.time.Duration;
import java.util.Random;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import java.time.Duration;
import java.util.Random;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.enterprise.context.ApplicationScoped;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.enterprise.context.ApplicationScoped;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.mutiny.Multi;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private Random random = new Random();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private Random random = new Random();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Outgoing("generated-price")                        // &lt;1&gt;
    public Multi&lt;Integer&gt; generate() {                  // &lt;2&gt;
        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))
                .onOverflow().drop()
                .map(tick -&gt; random.nextInt(100));
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Outgoing("generated-price")                        // &lt;1&gt;
    public Multi&lt;Integer&gt; generate() {                  // &lt;2&gt;
        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))
                .onOverflow().drop()
                .map(tick -&gt; random.nextInt(100));
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Reactive Messaging to dispatch the items from returned stream to `generated-price`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>返されたストリームから `generated-price` にアイテムをディスパッチするように Reactive Messaging に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ every 5 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、5 秒ごとにランダムな _価格_ を生成する Mutiny _ストリーム_ (`Multi`) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price converter</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格 (price) コンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private static final double CONVERSION_RATE = 0.88;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private static final double CONVERSION_RATE = 0.88;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the item are dispatched to all _subscribers_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイテムがすべての _サブスクライバー_ に発送されていることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Channel;
import org.reactivestreams.Publisher;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Channel;
import org.reactivestreams.Publisher;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injects the `my-data-stream` channel using the `@Channel` qualifier</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Channel` の修飾子を使って `my-data-stream` チャンネルを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the content is sent using `Server Sent Events`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Server Sent Events` を使用してコンテンツが送信されたことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Returns the stream (_Reactive Stream_)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ストリーム (_Reactive Stream_) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mp.messaging.[outgoing|incoming].{channel-name}.property=value`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `channel-name` segment must match the value set in the `@Incoming` and `@Outgoing` annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`channel-name` セグメントは、 `@Incoming` および `@Outgoing` アノテーションで設定された値と一致する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`generated-price` -&gt; sink in which we write the prices</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`generated-price` -&gt; sink (価格の書き込み先)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`prices` -&gt; source in which we read the prices</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`prices` -&gt; source (価格の読み取り先)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about `my-data-stream`? This is an in-memory stream, not connected to a message broker.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`my-data-stream` はどうでしょうか? これはインメモリストリームであり、メッセージブローカーには接続されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Final touch, the HTML page reading the converted prices using SSE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、SSE を使って変換された価格を読み込む HTML ページです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/prices.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/resources/META-INF/resources/prices.html` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Prices&lt;/title&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Prices&lt;/title&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css"&gt;
    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css"&gt;
    &lt;link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly-additions.min.css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="container"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    &lt;h2&gt;Last price&lt;/h2&gt;
    &lt;div class="row"&gt;
    &lt;p class="col-md-12"&gt;The last price is &lt;strong&gt;&lt;span id="content"&gt;N/A&lt;/span&gt;&amp;nbsp;&amp;euro;&lt;/strong&gt;.&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var source = new EventSource("/prices/stream");
    source.onmessage = function (event) {
        document.getElementById("content").innerHTML = event.data;
    };
&lt;/script&gt;
&lt;/html&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    &lt;h2&gt;Last price&lt;/h2&gt;
    &lt;div class="row"&gt;
    &lt;p class="col-md-12"&gt;The last price is &lt;strong&gt;&lt;span id="content"&gt;N/A&lt;/span&gt;&amp;nbsp;&amp;euro;&lt;/strong&gt;.&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src="https://code.jquery.com/jquery-3.3.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    var source = new EventSource("/prices/stream");
    source.onmessage = function (event) {
        document.getElementById("content").innerHTML = event.data;
    };
&lt;/script&gt;
&lt;/html&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing spectacular here. On each received price, it updates the page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に目を見張るようなものは何もありません。受信した価格ごとに、ページが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get it running</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/prices.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザーで `http://localhost:8080/prices.html` を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Native</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build the native executable with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下ででネイティブ実行ファイルをビルドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw package -Pnative
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw package -Pnative
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令的な使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, you can use an `Emitter`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合には `Emitter` が利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import org.eclipse.microprofile.reactive.messaging.Channel;
import org.eclipse.microprofile.reactive.messaging.Emitter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Consumes;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.inject.Inject;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Consumes;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject @Channel("price-create") Emitter&lt;Double&gt; priceEmitter;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject @Channel("price-create") Emitter&lt;Double&gt; priceEmitter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(price);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void addPrice(Double price) {
        priceEmitter.send(price);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非推奨</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.reactive.messaging.annotations.Emitter`、`io.smallrye.reactive.messaging.annotations.Channel`、`io.smallrye.reactive.messaging.annotations.OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.eclipse.microprofile.reactive.messaging.Emitter`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.eclipse.microprofile.reactive.messaging.Channel`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.eclipse.microprofile.reactive.messaging.OnOverflow`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると、`CompletionStage` の完了を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going further</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go further check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく知りたい場合は、Quarkusで使用されている実装である link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging] のドキュメントを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use link:funqy-http[Funqy HTTP] on Azure Functions.  This allows you to invoke on multiple Funqy functions using HTTP deployed as one Azure Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure Functions 上で link:funqy-http[Funqy HTTP] を使用することができます。これにより、1つの Azure Functions としてデプロイされた複数の Funqy function をHTTPを使用して呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP + Azure Functions binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable cross a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Route link:azure-functions-http[support] instead.  They also work with Quarkus and Azure Functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy HTTP + Azure FunctionsバインディングはHTTP上のRESTの代わりではありません。Funqyは多くの異なるプロトコルや関数プロバイダを横断してポータブルである必要があるため、HTTPバインディングは非常にミニマムであり、リンクのようなREST機能やキャッシュコントロールや条件付きGETのようなHTTP機能を活用する機能を失うことになります。代わりに、QuarkusのJAX-RS、Spring MVC、またはVert.x Web Reactive Routeの link:azure-functions-http[サポート] を使用することを検討するとよいでしょう。また、QuarkusやAzure Functionsとも連携しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follow the link:azure-functions-http[Azure Functions Http Guide].  It walks through using a variety of HTTP frameworks on Azure Functions.  Including Funqy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:azure-functions-http[Azure Functions Http Guide] に従ってください。これは、Azure Functions上で、Funqyを含む様々なHTTPフレームワークを使用する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - MicroProfile Metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - MicroProfile Metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MicroProfile Metrics allows applications to gather various metrics and statistics that provide insights into what is happening inside the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile Metricsは、アプリケーションで様々なメトリクスや統計情報を収集して、アプリケーション内で何が起こっているかについての洞察を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The metrics can be read remotely using JSON format or the OpenMetrics format, so that they can be processed by additional tools such as Prometheus, and stored for analysis and visualisation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように、JSON 形式または OpenMetrics 形式を使用してメトリクスをリモートで読み取ることができるため、Prometheus などの追加ツールで処理したり、分析や可視化のために保存したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apart from application-specific metrics, which are described in this guide, you may also utilize built-in metrics exposed by various Quarkus extensions. These are described in the guide for each particular extension that supports built-in metrics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドで説明するアプリケーション固有のメトリクスとは別に、Quarkusのさまざまなエクステンションによって公開されているビルトインメトリクスを利用することもできます。これらについては、ビルトインメトリクスをサポートしている各エクステンションのガイドで説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:micrometer[Micrometer] is the recommended approach to metrics for Quarkus.  Use the MicroProfile Metrics extension when it's required to retain MicroProfile specification compatibility.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:micrometer[Micrometerは] 、Quarkusのメトリクスへの推奨アプローチです。MicroProfile仕様の互換性を維持する必要がある場合は、MicroProfile Metricsエクステンションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers one REST endpoint and that endpoint serves for determining whether a number is prime. The implementation class is annotated with some metric annotations so that while responding to user's requests, some metrics are gathered. The meaning of each metric will be explained later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、1つのRESTエンドポイントを提供する非常にシンプルなマイクロサービスを構築し、そのエンドポイントは数値が素数であるかどうかを判断するのに役立ちます。実装クラスは、ユーザーのリクエストに応答している間に、いくつかのメトリクスが収集されるように、いくつかのメトリックアノテーションが付与されています。各メトリックの意味は後ほど説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `microprofile-metrics-quickstart` {quickstarts-tree-url}/microprofile-metrics-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `microprofile-metrics-quickstart` {quickstarts-tree-url}/microprofile-metrics-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `smallrye-metrics` extension which is an implementation of the MicroProfile Metrics specification used in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、Quarkusで使用されているMicroProfile Metrics仕様の実装である `smallrye-metrics` エクステンションをインポートして、Mavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-metrics` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-metrics` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application consists of a single class that implements an algorithm for checking whether a number is prime.  This algorithm is exposed over a REST interface. Additionally, we need a few annotations to make sure that our desired metrics are calculated over time and can be exported for manual analysis or processing by additional tooling.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションは、数値が素数であるかどうかをチェックするアルゴリズムを実装した単一のクラスで構成されています。このアルゴリズムは、RESTインターフェースを介して公開されています。さらに、必要なメトリクスが時間の経過とともに計算され、手動分析や追加のツールによる処理のためにエクスポートできることを確認するために、いくつかのアノテーションが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The metrics that we will gather are these:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>集めようとしているメトリクスは、以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`performedChecks`: A counter which is increased by one each time the user asks about a number.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`performedChecks` : ユーザーが数字を尋ねるたびに1つ増えるカウンター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`highestPrimeNumberSoFar`: This is a gauge that stores the highest number that was asked about by the user and which was determined to be prime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`highestPrimeNumberSoFar` : ユーザーから質問されて素数と判断された最高の数字を保存するゲージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checksTimer`: This is a timer, therefore a compound metric that benchmarks how much time the primality tests take. We will explain that one in more details later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`checksTimer` : これはタイマーであり、したがって、プライマリテストにどれだけの時間がかかるかをベンチマークする複合メトリックです。これについては後ほど詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source code looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なソースコードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running and using the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの実行と使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run the microservice in dev mode, use `./mvnw clean compile quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マイクロサービスをdevモードで実行するには、次のようにします。 `./mvnw clean compile quarkus:dev`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generate some values for the metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メトリクスの値を生成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, ask the endpoint whether some numbers are prime numbers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、ある数が素数であるかどうかをエンドポイントに問います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application will respond that 350 is not a prime number because it can be divided by 2.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリでは、350は2で割れるので素数ではないと回答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now for some large prime number so that the test takes a bit more time:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、テストにもう少し時間がかかるように、いくらか大きな素数で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application will respond that 629521085409773 is a prime number.  If you want, try some more calls with numbers of your choice.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリは629521085409773が素数であることを回答します。お好みで、好きな番号でもう何回か呼び出してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Review the generated metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたメトリクスを確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To view the metrics, execute `curl -H"Accept: application/json" localhost:8080/q/metrics/application` You will receive a response such as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メトリクスを表示するには、 `curl -H"Accept: application/json" localhost:8080/q/metrics/application` を実行します。実行すると次のようなレスポンスが表示されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's explain the meaning of each metric:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それぞれのメトリックの意味を説明しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checksTimer`: This is a timer, therefore a compound metric that benchmarks how much time the primality tests take. All durations are measured in milliseconds. It consists of these values:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`checksTimer` : これはタイマーであり、したがって、プライマリテストにどれだけの時間がかかるかをベンチマークとする複合メトリックです。すべての持続時間はミリ秒単位で測定されます。これらの値で構成されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`min`: The shortest duration it took to perform a primality test, probably it was performed for a small number.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`min` : 素数チェックを行うのにかかった時間の最短所要時間、おそらく小さな数に対して行われたものではないかと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`max`: The longest duration, probably it was with a large prime number.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`max` : 最長所要時間、おそらく大きな素数に対して行われたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mean`: The mean value of the measured durations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mean` : 計測された所要時間の平均値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`stddev`: The standard deviation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`stddev` : 標準偏差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`count`: The number of observations (so it will be the same value as `performedChecks`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`count` : 試行回数(なので `performedChecks` と同じ値になります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`p50, p75, p95, p99, p999`: Percentiles of the durations. For example the value in `p95` means that 95 % of the measurements were faster than this duration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`p50, p75, p95, p99, p999` : 所要時間のパーセンタイル。例えば、 `p95` の値は、試行の95%がこの所要時間よりも速いことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`meanRate, oneMinRate, fiveMinRate, fifteenMinRate`: Mean throughput and one-, five-, and fifteen-minute exponentially-weighted moving average throughput.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`meanRate, oneMinRate, fiveMinRate, fifteenMinRate` : 平均スループットと 1、5、および 15 分間の指数関数的に加重された移動平均スループット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer an OpenMetrics export rather than the JSON format, remove the `-H"Accept: application/json"` argument from your command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON形式ではなくOpenMetricsのエクスポートを希望する場合は、コマンドラインから `-H"Accept: application/json"` 引数を削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before anything can be done you must first install a JVMCI build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何かをする前に、まずJVMCIビルドをインストールしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be downloaded from OTN http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[here]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは link:http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[ここ]でOTNからダウンロードすることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, if you are installing on an alternative system, you can use the developer tools on chrome or firefox to capture a direct URL with an auth param.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のシステムにインストールする場合は、ChromeやFirefoxの開発者ツールを使用して、auth パラメーターを指定して直接 URL をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After obtaining the download install it and set `JAVA_HOME`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ダウンロードした後、インストールして `JAVA_HOME` をセットします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get the latest version available as graal tends to keep updating the minimum requirements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>graalは最小要件を更新し続ける傾向があるので、最新版を入手しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to install Graal’s special build tool, `mx`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今、あなたはGraalの特別なビルドツール `mx` をインストールする必要があります、.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito is a next generation business automation toolkit that originates from well known Open Source projects Drools (for business rules) and jBPM (for business processes). Kogito aims at providing another approach to business automation where the main message is to expose your business knowledge (processes, rules and decisions)  in a domain specific way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kogitoは、有名なオープンソースプロジェクトであるDrools (ビジネスルール用)とjBPM (ビジネスプロセス用)から生まれた次世代のビジネスオートメーションツールキットです。Kogitoは、ビジネスナレッジ(プロセス、ルール、意思決定)をドメイン固有の方法で公開することを主なメッセージとするビジネスオートメーションへの別のアプローチを提供することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE (Eclipse is preferred with the BPMN modeller plugin)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE (BPMN モデラープラグインを使用したEclipseが望ましい)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kogito Tooling is currently supported in Eclipse and VSCode:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kogito Toolingは現在EclipseとVSCodeでサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VSCode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VSCode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Online</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Online</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers one REST endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、1つのRESTエンドポイントを提供する非常にシンプルなマイクロサービスを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/persons`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/persons`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then run it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、以下を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qute is a templating engine designed specifically to meet the Quarkus needs.  The usage of reflection is minimized to reduce the size of native images.  The API combines both the imperative and the non-blocking reactive style of coding.  In the development mode, all files located in `src/main/resources/templates` are watched for changes and modifications are immediately visible.  Furthermore, we try to detect most of the template problems at build time.  In this guide, you will learn how to easily render templates in your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteは、Quarkus のニーズを満たすために特別に設計されたテンプレートエンジンです。ネイティブイメージのサイズを小さくするために、リフレクションの使用は最小限に抑えられています。API は、命令型とノンブロッキングリアクティブ型の両方のスタイルのコーディングを組み合わせています。開発モードでは、 `src/main/resources/templates` にあるすべてのファイルが変更のために監視され、変更はすぐに表示されます。さらに、ビルド時にテンプレートの問題のほとんどを検出するようにしています。このガイドでは、アプリケーションでテンプレートを簡単にレンダリングする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Qute in your JAX-RS application, you need to add the `quarkus-resteasy-qute` extension first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS アプリケーションで Qute を使用する場合は、まず `quarkus-resteasy-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに以下を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll start with a very simple template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずはとてもシンプルなテンプレートから:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{name}` is a value expression that is evaluated when the template is rendered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{name}` は、テンプレートがレンダリングされたときに評価される値の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, all files located in the `src/main/resources/templates` directory and its subdirectories are registered as templates. Templates are validated during startup and watched for changes in the development mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `src/main/resources/templates` ディレクトリーとそのサブディレクトリーにあるすべてのファイルがテンプレートとして登録されます。開発モードではテンプレートは起動時に検証され、変更が監視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's inject the "compiled" template in the resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、リソースクラスに「コンパイル済み」テンプレートを注入してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no `@ResourcePath` qualifier provided, the field name is used to locate the template. In this particular case, we're injecting a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ResourcePath` の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この特定のケースでは、パスが `templates/hello.txt` であるテンプレートを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Template.data()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Template.data()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` の下に置きます。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we don't trigger the rendering - this is done automatically by a special `ContainerResponseFilter` implementation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レンダリングをトリガーしないことに注意してください - これは特別な `ContainerResponseFilter` の実装によって自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application is running, you can request the endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが動作している場合は、エンドポイントを要求することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's an alternate way to declare your templates in your Java code, which relies on the following convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java コードでテンプレートを宣言する別の方法もあり、以下の規約に依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Organise your template files in the `/src/main/resources/templates` directory, by grouping them into one directory per resource class. So, if your `ItemResource` class references two templates `hello` and `goodbye`, place them at `/src/main/resources/templates/ItemResource/hello.txt` and `/src/main/resources/templates/ItemResource/goodbye.txt`. Grouping templates per resource class makes it easier to navigate to them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートファイルを `/src/main/resources/templates` ディレクトリーに整理し、リソースクラスごとに 1 つのディレクトリーにグループ化します。つまり、 `ItemResource` クラスが `hello` と `goodbye` の 2 つのテンプレートを参照している場合は、 `/src/main/resources/templates/ItemResource/hello.txt` と `/src/main/resources/templates/ItemResource/goodbye.txt` に配置します。リソースクラスごとにテンプレートをグループ化することで、テンプレートへのナビゲートが容易になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In each of your resource class, declare a `@CheckedTemplate static class Template {}` class within your resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各リソースクラスで、リソースクラス内で `@CheckedTemplate static class Template {}` クラスを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare one `public static native TemplateInstance method();` per template file for your resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リ ソ ース のテ ン プ レー ト フ ァ イ ルごとに `public static native TemplateInstance method();` を 1 つずつ宣言 し ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use those static methods to build your template instances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートインスタンスを構築するには、これらの静的メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's the previous example, rewritten using this style:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどの例を、このスタイルで書き換えてみました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's declare and use those templates in the resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、これらのテンプレートをリソースクラスで宣言して使ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/HelloResource/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パス `templates/HelloResource/hello.txt` でテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Templates.hello()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Templates.hello()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` の下に置きます。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have declared a `@CheckedTemplate` class, we will check that all its methods point to existing templates, so if you try to use a template from your Java code and you forgot to add it, we will let you know at build time :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CheckedTemplate` クラスを宣言したら、すべてのメソッドが既存のテンプレートを指しているかどうかをチェックしますので、もし Java コードからテンプレートを使おうとして追加するのを忘れてしまった場合は、ビルド時にお知らせします :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind this style of declaration allows you to reference templates declared in other resources too:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このスタイルの宣言では、他のリソースで宣言されたテンプレートも参照できることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Top-level type-safe templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トップレベルのタイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, if you want to declare templates at the top-level, directly in `/src/main/resources/templates/hello.txt`, for example, you can declare them in a toplevel (non-nested) `Templates` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当然のことながら、トップレベルでテンプレートを宣言したい場合、例えば `/src/main/resources/templates/hello.txt` で直接宣言したい場合は、トップレベル(非入れ子)の `Templates` クラスで宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パス `templates/hello.txt` のテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Parameter Declarations </seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートパラメーター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you declare a *parameter declaration* in a template then Qute attempts to validate all expressions that reference this parameter and if an incorrect expression is found the build fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートで *パラメーター宣言* を宣言した場合、Quteはこのパラメーターを参照するすべての式の検証を試み、間違った式が見つかった場合はビルドが失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose we have a simple class like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなシンプルなクラスがあったとしましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Item.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Item.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we'd like to render a simple HTML page that contains the item name and price.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、商品名と価格が記載されたシンプルな HTML ページをレンダリングしたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start again with the template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>改めてテンプレートから始めてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource/item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ItemResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is validated. Try to change the expression to `{item.nonSense}` and the build should fail.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この式は検証済みです。式を `{item.nonSense}` に変更するとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is also validated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これも検証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class with type-safe templates:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、タイプセーフなテンプレートを使ってリソースクラスを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ItemResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a method that gives us a `TemplateInstance` for `templates/ItemResource/item.html` and declare its `Item item` parameter so we can validate the template.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`templates/ItemResource/item.html` に対して `TemplateInstance` を与えるメソッドを宣言し、その `Item item` パラメーターを宣言することで、テンプレートを検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make the `Item` object accessible in the template.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート内で `Item` オブジェクトにアクセスできるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template parameter declaration inside the template itself</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート内部のテンプレートパラメーター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can declare your template parameters in the template file itself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、テンプレートファイル自体でテンプレートパラメーターを宣言することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional parameter declaration. Qute attempts to validate all expressions that reference the parameter `item`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションのパラメーター宣言。Qute は、パラメーター `item` を参照するすべての式の検証を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、リソースクラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the template with path `templates/item.html`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスが `templates/item.html` のテンプレートを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Extension Methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート拡張メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Template extension methods* are used to extend the set of accessible properties of data objects.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*テンプレート拡張メソッド* は 、データオブジェクトのアクセス可能なプロパティーのセットを拡張するために使用されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you're not in control of the classes that you want to use in your template, and you cannot add methods to them. Template extension methods allows you to declare new method for those classes that will be available from your templates just as if they belonged to the target class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、テンプレートで使用したいクラスをコントロールできず、それらのクラスにメソッドを追加できないことがあります。テンプレート拡張メソッドを使うと、テンプレートから利用できるようになるクラスのメソッドを、あたかもターゲットクラスに属しているかのように宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's keep extending on our simple HTML page that contains the item name, price and add a discounted price.  The discounted price is sometimes called a "computed property".  We will implement a template extension method to render this property easily.  Let's update our template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイテム名、価格、値引き価格を含むシンプルな HTML ページを拡張していきましょう。値引き価格は「計算プロパティー」と呼ばれることがあります。このプロパティーを簡単にレンダリングするためのテンプレート拡張メソッドを実装します。テンプレートを更新してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`if` is a basic control flow section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`if` は、基本的な制御フローのセクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is also validated against the `Item` class and obviously there is no such property declared. However, there is a template extension method declared on the `TemplateExtensions` class - see below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この式は `Item` クラスに対しても検証されており、明らかにそのようなプロパティーは宣言されていません。しかし、 `TemplateExtensions` クラスにはテンプレート拡張メソッドが宣言されています - 以下を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a class where we put all our extension methods:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、すべての拡張メソッドを置くクラスを作りましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TemplateExtensions.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>TemplateExtensions.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A static template extension method can be used to add "computed properties" to a data class. The class of the first parameter is used to match the base object and the method name is used to match the property name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>静的テンプレート拡張メソッドを使用して、データクラスに「計算プロパティー」を追加することができます。最初のパラメーターのクラスはベースオブジェクトと一致するように使用され、メソッド名はプロパティー名と一致するように使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can place template extension methods in every class if you annotate them with `@TemplateExtension` but we advise to keep them either grouped by target type, or in a single `TemplateExtensions` class by convention.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート拡張メソッドは、 `@TemplateExtension` でアノテーションを付ければ、すべてのクラスに配置することができますが、規約上、ターゲットタイプでグループ化するか、 `TemplateExtensions` クラスにまとめておくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rendering Periodic Reports</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>定期レポートのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templating engine could be also very useful when rendering periodic reports.  You'll need to add the `quarkus-scheduler` and `quarkus-qute` extensions first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレーティングエンジンは、定期的なレポートをレンダリングする際にも非常に便利かもしれません。最初に `quarkus-scheduler` と `quarkus-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose the have a `SampleService` bean whose `get()` method returns a list of samples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SampleService` Beanがあり、その `get()` メソッドがサンプルのリストを返すとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sample.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The template is simple:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートはシンプルです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The loop section makes it possible to iterate over iterables, maps and streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ループセクションでは、イテレーション、マップ、ストリームの反復処理が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This value expression is using the https://en.wikipedia.org/wiki/Elvis_operator[elvis operator] - if the name is null the default value is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この値式は link:https://en.wikipedia.org/wiki/Elvis_operator[elvis 演算子] を使用します - nameが NULL の場合はデフォルト値が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ReportGenerator.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ReportGenerator.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use the `@ResourcePath` qualifier to specify the template path: `templates/reports/v1/report_01.html`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、 `@ResourcePath` の修飾子を使用してテンプレートのパスを指定します: `templates/reports/v1/report_01.html` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to execute this method on the half hour. For more information see the link:scheduler[Scheduler] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` アノテーションを使用して、Quarkusにこのメソッドを30分に実行するよう指示します。詳細については、 link:scheduler[スケジューラーガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `TemplateInstance.render()` method triggers rendering. Note that this method blocks the current thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`TemplateInstance.render()` メソッドはレンダリングをトリガします。このメソッドは現在のスレッドをブロックすることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive and Asynchronous APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブと非同期API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates can be rendered as a `CompletionStage&lt;String&gt;` (completed with the rendered output asynchronously) or as `Publisher&lt;String&gt;` containing the rendered chunks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートは、 `CompletionStage&lt;String&gt;` (非同期にレンダリングされた出力で完了)としてレンダリングすることも、レンダリングされたチャンクを含む `Publisher&lt;String&gt;` としてレンダリングすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of a `Publisher`, the template is rendered chunk by chunk following the requests from the subscriber.  The rendering is not started until a subscriber requests it.  The returned `Publisher` is an instance of `io.smallrye.mutiny.Multi`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Publisher` の場合、テンプレートはサブスクライバーからのリクエストに応じてチャンクごとにレンダリングされます。レンダリングは、サブスクライバーがリクエストするまで開始されません。返された `Publisher` は `io.smallrye.mutiny.Multi` のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create an instance of `io.smallrye.mutiny.Uni` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように、 `io.smallrye.mutiny.Uni` のインスタンスを作成することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the rendering only starts once the subscriber requests it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、サブスクライバーが要求した場合にのみレンダリングが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about Qute, please refer to the link:qute-reference[Qute reference guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Qute について詳しく知りたい方は、 link:qute-reference[Qute リファレンスガイド] を参考にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native compilation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable fails on macOS with `error: unknown type name 'uint8_t'`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS でのネイティブ実行ファイルが `error: unknown type name 'uint8_t'` で失敗する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your macOS has the wrong `*.h` files compared to the OS and no gcc compilation will work.  This can happen when you migrate from versions of the OS.  See https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お使いの macOS には、その OS とは異なる `*.h` ファイルがあるため、gcc コンパイルが動作しません。この問題は、その OS の別のバージョンから移行したときに起こる可能性があります。 https://stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-unknown-type-name-uint8-t を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is to</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>解決策は、以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reinstall XCode for good measure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>念のため Xcode を再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>generally reinstall your brew dependencies with native compilation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常は、ネイティブコンパイルで brew の依存関係を再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable should work now.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、実行ファイルが動作するようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus gRPC</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://grpc.io/[gRPC] is a high-performance RPC framework.  It can efficiently connect services implemented using various languages and frameworks.  It is also applicable in the last mile of distributed computing to connect devices, mobile applications, and browsers to backend services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://grpc.io/[gRPC] は高性能なRPCフレームワークです。様々な言語やフレームワークを使って実装されたサービスを効率的に接続することができます。また、デバイスやモバイルアプリケーション、ブラウザとバックエンドサービスを接続するために、分散コンピューティングのラストワンマイルにも適用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, gRPC uses HTTP/2, TLS, and https://developers.google.com/protocol-buffers[Protobuf (Protocol Buffers)].  In a microservice architecture, gRPC is an efficient, type-safe alternative to HTTP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的に、gRPCはHTTP/2、TLS、 link:https://developers.google.com/protocol-buffers[Protobuf(プロトコルバッファ)] を使用します。マイクロサービスアーキテクチャでは、gRPCはHTTPに代わる効率的で型安全な代替手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus gRPC extension integrate gRPC in Quarkus application.  It:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのgRPCエクステンションは、QuarkusアプリケーションにgRPCを統合します。それは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>supports implementing gRPC services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスの実装をサポートしています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>supports consuming gRPC services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPC サービスの利用をサポートしています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integrates with the reactive engine from Quarkus as well as the reactive development model</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのリアクティブエンジンやリアクティブ開発モデルと統合されています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>allows plain-text communication as well as TLS, and TLS with mutual authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>平文通信に加えてTLS、相互認証付きのTLSも可能です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus gRPC is based on https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus gRPCは link:https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC] をベースにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your AWS Lambdas.  Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-amazon-lambda` エクステンションを使うと、Quarkusを使ってAWS Lambda を構築することができます。Lambda では、CDIやSpringからのインジェクションアノテーションや、必要に応じてQuarkusの他の機能を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus lambdas can be deployed using the Amazon Java Runtime, or you can build a native executable and use Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの Lambda は、Amazon Javaランタイムを使用してデプロイすることもできますが、より小さなメモリーフットプリントとより高速なコールドブート起動時間が必要な場合は、ネイティブの実行ファイルをビルドしてAmazonのカスタムランタイムを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>less than 30 minutes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>三十分以内</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] 、ローカルテスト用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Gradle projects please &lt;&lt;gradle,see below&gt;&gt;, or for further reference consult the guide in the link:gradle-tooling[Gradle setup page].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle プロジェクトに対しては &lt;&lt;gradle,こちらを参照する&gt;&gt; か、さらに詳しい解説が必要な場合には link:gradle-tooling[Gradle セットアップ] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a maven archetype and deploying it to AWS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、mavenのArchetypeを使用してJavaプロジェクトのサンプルを生成し、AWSにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS CLI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWSのすべてのツールをインストールすることは、おそらくこのガイドでは最も難しいことです。AWS CLIをインストールするためのすべての手順に従っていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Maven Deployment Project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイ用のMavenプロジェクトを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the Quarkus AWS Lambda maven project using our Maven Archetype.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven Archetypeを使用してQuarkus AWS Lambda mavenプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use Gradle, you can quickly and easily generate a Gradle project via https://code.quarkus.io/[code.quarkus.io] adding the `quarkus-amazon-lambda` extension as a dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleを使いたい場合は、 link:https://code.quarkus.io/[code.quarkus.io] を使って、 `quarkus-amazon-lambda` エクステンションを依存関係として追加することで、素早く簡単にGradleプロジェクトを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the build.gradle, gradle.properties and settings.gradle into the above generated Maven archetype project, to follow along with this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>build.gradle、gradle.properties、settings.gradleを上記の生成されたMavenのアーキタイププロジェクトにコピーして、このガイドに従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Execute: gradle wrapper to setup the gradle wrapper (recommended).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Execute: gradle wrapper を実行して gradle wrapper を設定します(推奨)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The dependency for `quarkus-test-amazon-lambda` will also need to be added to your build.gradle.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-test-amazon-lambda` の依存関係も build.gradle に追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For full Gradle details &lt;&lt;gradle, see below&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleの詳細は link:#gradle[こちらを参照してください] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda` extension scans your project for a class that directly implements the Amazon `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler` interface.  It must find a class in your project that implements this interface or it will throw a build time failure.  If it finds more than one handler class, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-amazon-lambda` エクステンションは、Amazon `RequestHandler&lt;?, ?&gt;` または `RequestStreamHandler` インターフェイスを直接実装しているクラスをプロジェクト内でスキャンします。このインターフェイスを実装しているクラスがプロジェクト内で見つかるようにしなければならず、そうでない場合にはビルド時に例外がスローされます。複数のハンドラークラスを見つけた場合にも、ビルド時の例外がスローされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one project and use configuration or an environment variable to pick the handler you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、時にはコードを共有するいくつかの関連する Lambda があって、複数の maven モジュールを作成することは、やりたくないオーバーヘッドに過ぎないことがあるかもしれません。 `quarkus-amazon-lambda` エクステンションを使用すると、1 つのプロジェクトに複数のラムダをバンドルし、設定または環境変数を使用してデプロイしたいハンドラーを選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project has three lambdas within it.  Two that implement the `RequestHandler&lt;?, ?&gt;` interface, and one that implements the `RequestStreamHandler` interface. One that is used and two that are unused.  If you open up `src/main/resources/application.properties` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたプロジェクトは、その中に3つの Lambda を持っています。 `RequestHandler&lt;?, ?&gt;` インターフェイスを実装したものが 2 つ、 `RequestStreamHandler` インターフェイスを実装したものが 1 つ。1つは使用され、2つは未使用です。 `src/main/resources/application.properties` を開くと、このようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.lambda.handler` property tells Quarkus which lambda handler to deploy. This can be overridden with an environment variable too.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.lambda.handler` プロパティーは、デプロイする Lambda ハンドラーをQuarkusに伝えます。これは環境変数でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the three generated handler classes in the project, you'll see that they are `@Named` differently.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト内で生成された3つのハンドラークラスを見てみると、異なる `@Named` が指定されていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the handler class must match the value specified within the `quarkus.lambda.handler` property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ハンドラークラスのCDI名は、 `quarkus.lambda.handler` プロパティー内で指定された値と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a few steps to get your lambda running on AWS.  The generated maven project contains a helpful script to create, update, delete, and invoke your lambdas for pure Java and native deployments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Lambda をAWS上で動作させるには、いくつかのステップがあります。生成されたmavenプロジェクトには、pure Java とネイティブデプロイメント用の Lambda を作成、更新、削除、呼び出しするための便利なスクリプトが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドとデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the project using maven.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mavenを使ってプロジェクトをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or, if using Gradle:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、Gradleを使用している場合は</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile and package your code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでコードがコンパイルされ、パッケージ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define a `LAMBDA_ROLE_ARN` environment variable in your profile or console window, Alternatively, you can edit the `manage.sh` script that is generated by the build and put the role value directly there:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWS CLIを使った Lambda のデプロイ方法については、 link:https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] を参照してください。具体的には、 `Execution Role` を作成していることを確認してください。プロファイルやコンソールウィンドウで `LAMBDA_ROLE_ARN` 環境変数を定義する必要があります。また、ビルドで生成される `manage.sh` スクリプトを編集して、そこに直接ロール値を置くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extra Build Generated Files</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時に追加生成されるファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the `quarkus-amazon-lambda` extension.  These files are in the the build directory: `target/` for maven, `build/` for gradle.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドを実行すると、 `quarkus-amazon-lambda` のエクステンションで生成されるいくつかの追加ファイルがあります。これらのファイルはビルドディレクトリーにあります: mavenなら `target/` 、gradleなら `build/` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`function.zip` - lambda deployment file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`function.zip` - Lambda デプロイファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`manage.sh` - wrapper around aws lambda cli calls</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`manage.sh` - aws Lambda CLI の呼び出しのラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.jvm.yaml` - (optional) for use with sam cli and local testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sam.jvm.yaml` - (オプション) SAM CLI やローカル・テスト用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.native.yaml` - (optional) for use with sam cli and native local testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sam.native.yaml` - (オプション) SAM CLI やネイティブ・ローカル・テスト用(オプション)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `target/manage.sh` script is for managing your lambda using the AWS Lambda Java runtime.  This script is provided only for your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`target/manage.sh` スクリプトは、AWS Lambda Java ランタイムを使用して Lambda を管理するためのものです。このスクリプトは利便性のためだけに提供されています。Lambda の作成、削除、更新のためにどのようなawsコマンドが実行されるかを知りたい場合は、 `manage.sh` スクリプトの出力を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`manage.sh` supports four operation: `create`, `delete`, `update`, and `invoke`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`manage.sh` は、 `create` , `delete` , `update` , `invoke` の 4 つの操作をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys, and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.  A usage statement will be printed to guide you accordingly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWS CLIがインストールされていること、AWSアクセスキーのためのaws configureを実行していること、 `LAMBDA_ROLE_ARN` 環境変数を設定していること(上記の通り)を確認するには、 `manage.sh` をパラメーターなしで実行してください。それに応じて利用方法のガイドが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Gradle, the path to the binaries in the `manage.sh` must be changed from `target` to `build`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleを使用している場合、 `manage.sh` のバイナリーへのパスを `target` から `build` に変更しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `usage` statement, and validate AWS configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`usage` を参照したり、AWS の設定を検証するためには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can `create` your function using the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のコマンドを使って、 Function を `create` します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you do not have `LAMBDA_ROLE_ARN` already defined in this shell:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、このシェルで既に `LAMBDA_ROLE_ARN` が定義されていない場合にはこうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ハンドラースイッチを変更しないでください。これは、 `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest` にハードコードする必要があります。このハンドラは、Quarkusをブートストラップし、インジェクションを実行できるように実際のハンドラをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there are any problems creating the function, you must delete it with the `delete` function before re-running the `create` command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Function の作成に問題がある場合は、 `delete` で Function を削除してから `create` コマンドを再実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Commands may also be stacked:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドはスタックすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `invoke` command to invoke your function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Function を呼び出すには `invoke` コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example lambda takes input passed in via the `--payload` switch which points to a json file in the root directory of the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サンプルの Lambda は、プロジェクトのルートディレクトリーにある json ファイルを指す `--payload` スイッチを介して渡された入力を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The lambda can also be invoked locally with the SAM CLI like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Lambda は、以下のようにSAM CLI によってローカルで呼び出すこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are working with your native image build, simply replace the template name with the native version:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージのビルドで作業している場合は、テンプレート名をネイティブバージョンに置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the `update` command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お好きなように Java コードを更新することができます。リビルドしたら、 `update` コマンドを実行することで、Lambda を再配備できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Lambda のメモリーフットプリントを減らし、初期化時間を短縮したい場合は、Javaコードをネイティブの実行ファイルにコンパイルすることができます。 `-Pnative` スイッチでプロジェクトをリビルドすることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Linux hosts execute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Linuxホストの場合は以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a docker build as Amazon Lambda requires linux binaries.  You can do this by passing this property to your Maven build: `-Dnative-image.docker-build=true`, or for Gradle: `--docker-build=true`.  This requires you to have docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非 Linux システムでビルドしている場合は、Amazon Lambda が linux バイナリーを必要とするため、quarkus に docker ビルドを使用するように指示するプロパティーを渡す必要があります。これは、このプロパティーを Maven ビルドに渡すことで行うことができます: `-Dnative-image.docker-build=true` , または Gradle の場合: `--docker-build=true` .ただし、この場合はローカルに docker がインストールされている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.  This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda Custom (Provided) Runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのコマンドのいずれかがコンパイルされ、ネイティブの実行イメージが作成されます。また、zip ファイル `target/function.zip` も生成されます。このzipファイルには、 `bootstrap` にリネームされたネイティブ実行イメージが含まれています。これはAWS Lambda Custom (Provided) Runtimeの要件です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instructions here are exactly as above with one change: you'll need to add `native` as the first parameter to the `manage.sh` script:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでの説明は上記と全く同じですが、1つ変更点があります: `manage.sh` スクリプトの最初のパラメーターとして `native` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish to work with native image builds.  The script will take care of the rest of the details necessary to manage your native image function deployments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のように、コマンドはスタックすることができます。唯一の要件は、ネイティブイメージビルドで作業したい場合、最初のパラメーターとして `native` を指定することです。このスクリプトは、ネイティブイメージ Function のデプロイメントを管理するために必要な残りの詳細を処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the output of the `manage.sh` script if you want to learn what aws commands are executed to create, delete, and update your lambdas.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Lambda を作成、削除、更新するためにどのようなawsコマンドが実行されるかを知りたい場合は、 `manage.sh` スクリプトの出力を調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One thing to note about the create command for native is that the `aws lambda create-function` call must set a specific environment variable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ用のcreateコマンドについて注意すべき点は、 `aws lambda create-function` 呼び出しで特定の環境変数を設定しなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda` and `quarkus-test-amazon-lambda` extensions as a dependencies.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>POM には、 `quarkus-amazon-lambda` と `quarkus-test-amazon-lambda` エクステンションが依存関係として含まれていること以外に特別なことは何もありません。このエクステンションは、Lambda のデプロイに必要なものをすべて自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In previous versions of this extension you had to set up your pom or gradle to zip up your executable for native deployments, but this is not the case anymore.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションの以前のバージョンでは、ネイティブデプロイメントのために実行ファイルを zip 化するように pom や gradle を設定しなければなりませんでしたが、今はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly for Gradle projects, you also just have to add the `quarkus-amazon-lambda` and `quarkus-test-amazon-lambda` dependencies.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle プロジェクトの場合も同様に、 `quarkus-amazon-lambda` と `quarkus-test-amazon-lambda` の依存関係を追加するだけです。このエクステンションは、Lambda のデプロイに必要なすべてのものを自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Gradle dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleの依存関係の例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Amazon Lambda extension has a matching test framework that provides functionality to execute standard JUnit tests on your AWS Lambda function, via the integration layer that Quarkus provides.  This is true for both JVM and native modes.  It provides similar functionality to the SAM CLI, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのAmazon Lambdaエクステンションには、Quarkusが提供するインテグレーションレイヤーを介して、AWS Lambda関数上で標準的なJUnitテストを実行するための機能を提供するマッチングテストフレームワークがあります。これはJVMモードとネイティブモードの両方に当てはまります。これは、DockerのオーバーヘッドなしでSAM CLIと同様の機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate, the project generated by the Maven archetype, generates a JUnit test for the `RequestHandler&lt;?, ?&gt;` implementation, which is shown below.  The test replicates the execution environment, for the function that is selected for invocation, as described &lt;&lt;choose, above&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>説明のために、Maven のアーキタイプで生成されたプロジェクトは、 `RequestHandler&lt;?, ?&gt;` の実装用の JUnit テストを生成します。このテストは、 link:#choose[上] で説明したように、呼び出しのために選択された関数の実行環境を複製しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the integration tests in your project there is a required property, in `src/test/resources/application.properties`. If not included, the integration tests will be in a constant loop.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトで統合テストを使用するには、 `src/test/resources/application.properties` に必須のプロパティーがあります。これが含まれていない場合、統合テストは固定のループになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are following along with the example Maven archetype project for AWS Lambda in this guide, it includes the required property `quarkus.lambda.enable-polling-jvm-mode=true` in the test `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドのAWS Lambda用のMaven archetypeプロジェクトの例に従う場合、テストの `application.properties` に必要なプロパティー `quarkus.lambda.enable-polling-jvm-mode=true` が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, if you are using a `RequestStreamHandler` implementation, you can add a matching JUnit test, like below, which aligns to the generated `StreamLambda` class in the generated project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同様に、 `RequestStreamHandler` の実装を使用している場合は、以下のように一致する JUnit テストを追加することで、生成されたプロジェクトで生成された `StreamLambda` クラスに合わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, these two types of tests are mutually exclusive.  You must have a test that corresponds to the implemented AWS Lambda interfaces, whether `RequestHandler&lt;?, ?&gt;` or `RequestStreamHandler`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>明らかに、これら2種類のテストは相互に排他的です。 `RequestHandler&lt;?, ?&gt;` と `RequestStreamHandler` のいずれか、実装されているAWS Lambdaインターフェースに対応したテストを用意しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two versions of the Test for `RequestStreamHandler` are presented below.  You can use either, depending on the needs of your Unit test.  The first is obviously simpler and quicker.  Using Java streams can require more coding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下に、 `RequestStreamHandler` 用のテストの 2 つのバージョンを紹介します。ユニットテストの必要性に応じて、どちらを使用しても構いません。前者の方が明らかにシンプルで速いです。Java ストリームを使用すると、より多くのコーディングが必要になることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code uses CDI injection, this too will be executed, along with mocking functionality, see the link:getting-started-testing[Test Guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードが CDI インジェクションを使用している場合、これもモッキング機能とともに実行されます。詳細は link:getting-started-testing[テストガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add JUnit functionality for native tests, add the `@NativeImageTest` annotation to a subclass of your test class, which will execute against your native image, and can be leveraged in an IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブテストに JUnit の機能を追加するには、テストクラスのサブクラスに `@NativeImageTest` アノテーションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] を利用すると、Lambda をシミュレートした環境でラップトップ上のローカルで Lambda を実行することができます。これには link:https://www.docker.com/products/docker-desktop[docker] のインストールが必要です。これは、利用することを選択した場合のオプションのアプローチです。それ以外の場合は、Quarkus JUnitの統合でほとんどのニーズを満たすことができるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A starter template has been generated for both JVM and native execution modes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMとネイティブ実行モードの両方に対応したスターターテンプレートが生成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the following SAM CLI command to locally test your lambda function, passing the appropriate SAM `template`.  The `event` parameter takes any JSON file, in this case the sample `payload.json`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の SAM CLI コマンドを実行して、適切な SAM `template` を渡して Lambda Function をローカルでテストします。 `event` パラメーターには任意の JSON ファイルを指定します。この場合はサンプル `payload.json` を指定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Gradle, the path to the binaries in the YAML templates must be changed from `target` to `build`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle を使用している場合、YAML テンプレートのバイナリーへのパスを `target` から `build` に変更しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native image can also be locally tested using the `sam.native.yaml` template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージは、 `sam.native.yaml` テンプレートを使ってローカルでテストすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modifying `function.zip`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`function.zip` の修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated by the build.  To do this create a `zip.jvm` or `zip.native` directory within `src/main`.  Create `zip.jvm/` if you are doing a pure Java lambda.  `zip.native/` if you are doing a native deployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドによって生成された `function.zip` Lambda デプロイメントにいくつかの追加を加えなければならない場合があります。これを行うには、 `src/main` 内に `zip.jvm` または `zip.native` ディレクトリーを作成します。Pure Java Lambda を実行している場合は `zip.jvm/` を、ネイティブディプロイメントを実行している場合は `zip.native/` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any you files and directories you create under your zip directory will be included within `function.zip`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>zipディレクトリーの下に作成したファイルやディレクトリーは、すべて `function.zip` に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom `bootstrap` script</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム `bootstrap` スクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are times you may want to set a specific system properties or other arguments when lambda invokes your native quarkus lambda deployment.  If you include a `bootstrap` script file within `zip.native`, the quarkus extension will automatically rename the executable to `runner` within `function.zip` and set the unix mode of the `bootstrap` script to executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラムダがネイティブの quarkus ラムダデプロイメントを起動する際に、特定のシステムプロパティーやその他の引数を設定したい場合があるかもしれません。 `zip.native` 内に `bootstrap` スクリプトファイルを含めると、Quarkus エクステンションは自動的に実行ファイルの名前を `function.zip` 内の `runner` に変更し、 `bootstrap` スクリプトの unix モードを実行ファイルに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable must be referenced as `runner` if you include a custom `bootstrap` script.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム `bootstrap` スクリプトを含む場合は、ネイティブ実行ファイルを `runner` として参照する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension generates an example script within `target/bootstrap-example.sh`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、サンプルのスクリプト `target/bootstrap-example.sh` を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージをビルドしていて、Lambda で link:https://aws.amazon.com/xray[AWS X-Ray Tracing] を使いたい場合は、 `quarkus-amazon-lambda-xray` を依存関係として pom に含める必要があります。AWS X-Ray ライブラリは GraalVM との完全な互換性がないため、これを動作させるためにいくつかの統合作業をしなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, remember to enable the AWS X-Ray tracing parameter in `manage.sh`, in the `cmd_create()` function.  This can also be set in the AWS Management Console.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、 `manage.sh` の `cmd_create()` 関数で AWS X-Ray tracing パラメーターを有効にすることを忘れないでください。これはAWSマネジメントコンソールでも設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the sam template files, add the following to the YAML function Properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SAM テンプレートファイルの場合は、YAML の Function Properties に以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AWS X-Ray does add many classes to your distribution, do ensure you are using at least the 256MB AWS Lambda memory size.  This is explicitly set in `manage.sh` `cmd_create()`. Whilst the native image potentially can always use a lower memory setting, it would be recommended to keep the setting the same, especially to help compare performance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWS X-Ray はディストリビューションに多くのクラスを追加しますが、最低でも256MBのAWS Lambdaメモリーサイズを使用していることを確認してください。これは `manage.sh` `cmd_create()` で明示的に設定されています。ネイティブイメージは常により低いメモリー設定を使用できる可能性がありますが、特にパフォーマンスを比較するためには同じ設定にしておくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your code makes HTTPS calls, such as to a micro-service (or AWS service), you will need to add configuration to the native image, as GraalVM will only include the dependencies when explicitly declared.  Quarkus, by default enables this functionality on extensions that implicitly require it.  For further information, please consult the link:native-and-ssl[Quarkus SSL guide]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードがマイクロサービス(またはAWSサービス)などの HTTPS 呼び出しを行う場合、GraalVM は明示的に宣言された場合にのみ依存関係を含むため、ネイティブイメージに設定を追加する必要があります。Quarkus は、デフォルトでは、この機能を暗黙的に必要とするエクステンションでこの機能を有効にします。詳細については、 link:native-and-ssl[Quarkus SSLガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open src/main/resources/application.properties and add the following line to enable SSL in your native image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>src/main/resources/application.properties を開き、以下の行を追加してネイティブイメージでSSLを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now has extensions for DynamoDB, S3, SNS and SQS (more coming). Please check those guides on how to use the various AWS Services with Quarkus, as opposed to wiring manually like below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはDynamoDB、S3、SNS、SQS (他にも追加中) のエクステンションが追加されました。以下のように手動でワイヤリングするのではなく、Quarkusを使って様々なAWSサービスを利用する方法については、それらのガイドを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With minimal integration, it is possible to leverage the AWS Java SDK v2, which can be used to invoke services such as SQS, SNS, S3 and DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最小限のインテグレーションで、AWSのJava SDK v2を活用し、SQS、SNS、S3、DynamoDBなどのサービスを呼び出すことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For native image, however the URL Connection client must be preferred over the Apache HTTP Client when using synchronous mode, due to issues in the GraalVM compilation (at present).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかしながら、ネイティブイメージに対しては、同期モードを使用する場合は、GraalVMのコンパイルの問題のため、Apache HTTPクライアントよりもURL接続クライアントを優先する必要があります(現在のところ)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add `quarkus-jaxb` as a dependency in your Maven `pom.xml`, or Gradle `build.gradle` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-jaxb` を依存関係として Maven `pom.xml` または Gradle `build.gradle` ファイルに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must also force your AWS service client for SQS, SNS, S3 et al, to use the URL Connection client, which connects to AWS services over HTTPS, hence the inclusion of the SSL enabled property, as described in the &lt;&lt;https&gt;&gt; section above.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、SQS, SNS, S3などのAWSサービスクライアントでは、 link:#https[HTTPS] でAWSサービスに接続するURL Connectionクライアントを強制的に使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Maven, add the following to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenの場合は、 `pom.xml` に以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>if you see `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` or similar SSL error, due to the current status of GraalVM, there is some additional work to bundle the `function.zip`, as below.  For more information, please see the link:native-and-ssl[Quarkus Native SSL Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もし、 `java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty` 、または同様のSSLエラーが表示された場合、GraalVMの現状のため、 `function.zip` 、以下のようにバンドルするための追加作業があります。詳しくは、 link:native-and-ssl[Quarkus Native SSLガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional requirements for client SSL</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントSSLの追加要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable requires some additional steps to enable client ssl that S3 and other aws libraries need.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルは、S3や他のawsライブラリが必要とするクライアントSSLを有効にするために、いくつかの追加の手順が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A custom `bootstrap` script</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム `bootstrap` スクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`libsunec.so` must be added to `function.zip`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`function.zip` に `libsunec.so` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`cacerts` must be added to `function.zip`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`function.zip` に `cacerts` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, first create a directory `src/main/zip.native/` with your build.  Next create a shell script file called `bootstrap` within `src/main/zip.native/`, like below. An example is create automatically in your build folder (target or build), called `bootstrap-example.sh`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを行うには、まず、ビルドでディレクトリー `src/main/zip.native/` を作成します。次に `src/main/zip.native/` 内に `bootstrap` という名前のシェルスクリプトファイルを作成します。サンプル `bootstrap-example.sh` がビルドフォルダー(ターゲットまたはビルド)内に自動的に作成されます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional set `-Djavax.net.ssl.trustStorePassword=changeit` if your `cacerts` file is password protected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`cacerts` ファイルがパスワードで保護されている場合は、追加で `-Djavax.net.ssl.trustStorePassword=changeit` を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next you must copy some files from your GraalVM distribution into `src/main/zip.native/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、GraalVM ディストリビューションから `src/main/zip.native/` にいくつかのファイルをコピーする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM versions can have different paths for these files, and whether you using the Java 8 or 11 version. Adjust accordingly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 8 か 11 バージョンのいずれか、GraalVM バージョンによって、これらのファイルのパスが異なる場合があります。それに応じて調整してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run the native build all these files will be included within `function.zip`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブビルドを実行すると、これらのファイルはすべて `function.zip` に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a Docker image to build, then you must extract these files from this image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dockerイメージを使ってビルドする場合は、このイメージからこれらのファイルを抽出する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To extract the required ssl, you must start up a Docker container in the background, and attach to that container to copy the artifacts.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要な SSL を抽出するには、バックグラウンドでDockerコンテナーを起動し、そのコンテナーにアタッチしてアーティファクトをコピーする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's start the GraalVM container, noting the container id output.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、GraalVMコンテナーを起動して、コンテナーIDの出力に注目してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, libsunec.so, the C library used for the SSL implementation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、SSLの実装に使用するC言語のライブラリである libsunec.so です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, cacerts, the certificate store.  You may need to periodically obtain an updated copy, also.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つ目は、cacerts(証明書ストア)です。また、定期的に更新されたコピーを取得する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your final archive will look like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最終的なアーカイブは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use Alexa with Quarkus native, please add the following extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Alexa を Quarkus ネイティブで使用するには、以下のエクステンションを追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create your Alexa handler, as normal, by sub-classing the abstract `com.amazon.ask.SkillStreamHandler`, and add your request handler implementation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常通り、抽象クラス `com.amazon.ask.SkillStreamHandler` をサブクラス化して Alexa ハンドラーを作成し、リクエストハンドラーの実装を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's all there is to it!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それだけだよ!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.  Each extension dealing with persistence will integrate with it for you.  And you will explicitly interact with transactions via CDI.  This guide will walk you through all that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはTransaction Managerが付属しており、これを使用してトランザクションを調整してアプリケーションに公開します。永続性を扱う各エクステンションは、これと統合されます。そして、CDIを介して明示的にトランザクションと対話することになります。このガイドでは、これらすべてについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting it up</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.  Hibernate ORM for example will include the transaction manager and set it up properly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを必要とするエクステンションは単に依存関係として追加するだけなので、ほとんどの場合、設定について心配する必要はありません。例えばHibernate ORMはトランザクションマネージャーを含んでおり、適切に設定してくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.  Add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Hibernate ORMを使用せずに直接トランザクションを使用している場合は、明示的に依存関係として追加する必要があるかもしれません。以下を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting and stopping transactions: defining your boundaries</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの開始と停止:境界線の定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your transaction boundaries the easy way, or the less easy way :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの境界を定義するには、簡単な方法と比較的簡単ではない方法があります :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declarative approach</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>宣言的アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to define your transaction boundaries is to use the `@Transactional` annotation on your entry method (`javax.transaction.Transactional`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの境界を定義する最も簡単な方法は、エントリーメソッド ( `javax.transaction.Transactional` ) で `@Transactional` アノテーションを使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation defines your transaction boundaries and will wrap this call within a transaction.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、トランザクションの境界を定義し、トランザクション内でこの呼び出しをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `RuntimeException` crossing the transaction boundaries will rollback the transaction.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`RuntimeException` がトランザクションの境界を越えると、トランザクションがロールバックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.  That includes REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional` は、メソッドレベルまたはクラスレベルで、すべてのメソッドがトランザクションであることを保証するために、任意の CDI Bean のトランザクション境界を制御するために使用することができます。これにはRESTエンドポイントも含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can control whether and how the transaction is started with parameters on `@Transactional`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional` のパラメーターを使用して、トランザクションを開始するかどうか、どのように開始するかを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional(REQUIRED)` (デフォルト): 何も開始されていない場合はトランザクションを開始し、そうでない場合は既存のトランザクションを維持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional(REQUIRES_NEW)` : 何も開始されていない場合はトランザクションを開始し、既存のトランザクションが開始されている場合はそれを一時停止し、そのメソッドの境界で新しいトランザクションを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(MANDATORY)`: fails if no transaction was started ; works within the existing transaction otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional(MANDATORY)` : トランザクションが開始されていない場合は失敗し、そうでない場合は既存のトランザクション内で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(SUPPORTS)`: if a transaction was started, joins it ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional(SUPPORTS)` : トランザクションが開始されている場合、それに参加します。開始されていない場合はトランザクションなしで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NOT_SUPPORTED)`: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional(NOT_SUPPORTED)` : トランザクションが開始されている場合、それを一時停止し、メソッドの境界ではトランザクションなしで動作します。開始されていない場合は、トランザクションなしで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(NEVER)`: if a transaction was started, raises an exception ; otherwise works with no transaction.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Transactional(NEVER)` : トランザクションが開始されている場合は例外を発生させます。開始されていない場合はトランザクションなしで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transaction Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクション設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is 60 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト値は60秒です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring transaction node name identifier</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションノード名識別子の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why always having a transaction manager?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜ常にトランザクションマネージャーを持っているのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK の `CompletableFuture` オブジェクトと Netty HTTP クライアントをベースにした link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[非同期プログラミング]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an AWS profile for your local instance using AWS CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWS CLIを使ってローカルインスタンスのAWSプロファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Apache HTTP client instead, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代わりにApache HTTPクライアントを使用したい場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next steps</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With GraalVM installed, you can also create a native executable binary: `./mvnw clean package -Dnative`.  Depending on your system, that will take some time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMをインストールした状態で、ネイティブの実行バイナリーを作成することもできます: `./mvnw clean package -Dnative` お使いのシステムにもよりますが、時間がかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going asynchronous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the asynchronous programming model out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションで使われているAWS SDK v2.xのおかげで、非同期プログラミングモデルをすぐに使えるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While users are encouraged to use link:cache[Quarkus annotations for caching], Quarkus nevertheless provides a compatibility layer for Spring Cache annotations in the form of the `spring-cache` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーは link:cache[キャッシュ用のQuarkusアノテーション] を使用することが推奨されていますが、Quarkusはそれにもかかわらず、 `spring-cache` エクステンションの形でSpring Cacheアノテーションの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how a Quarkus application can leverage the well known Spring Cache annotations to enable application data caching for their Spring beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがよく知られているSpring Cacheアノテーションを活用して、Spring Beanのアプリケーションデータのキャッシュを可能にする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project with a REST endpoint and imports the `spring-cache` and `spring-di` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `spring-cache` と `spring-di` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `spring-cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service which will simulate an extremely slow call to an external meteorological service.  Create `src/main/java/org/acme/spring/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは、外部の気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/spring/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is where the slowness comes from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅さの原因はここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class which contains the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/spring/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、ユーザーが3日間の天気予報を聞いてきたときに、ユーザーに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/spring/cache/WeatherForecast.java` をこのように作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we just need to update the generated `WeatherForecastResource` class to use the service and response:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あとは、サービスとレスポンスを使用するために生成された `WeatherForecastResource` クラスを更新するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `daysInFuture` query parameter is omitted, the three days weather forecast will start from the current day.  Otherwise, it will start from the current day plus the `daysInFuture` value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`daysInFuture` クエリパラメーターが省略された場合、3 日間の天気予報は現在の日から始まります。それ以外の場合は、現在の日に `daysInFuture` の値を加えたものから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We're all done! Let's check if everything's working.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>終わりました!すべて上手く動いているか確認してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, run the application using `./mvnw compile quarkus:dev` from the project directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、プロジェクトディレクトリーから `./mvnw compile quarkus:dev` を使ってアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, call `http://localhost:8080/weather?city=Raleigh` from a browser.  After six long seconds, the application will answer something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、ブラウザから `http://localhost:8080/weather?city=Raleigh` を呼び出します。6秒ほど長い時間が経過すると、アプリケーションはこのような回答をします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response content may vary depending on the day you run the code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードを実行する日によってレスポンスの内容が異なる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can try calling the same URL again and again, it will always take six seconds to answer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何度も同じURLを呼び出してみても、必ず6秒で返事が返ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling the cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュの有効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションが稼働しているので、外部の気象サービスのレスポンスをキャッシュすることで、レスポンスタイムを大幅に改善してみましょう。 `WeatherForecastService` クラスを以下のように更新します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We only added this annotation (and the associated import of course).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーション(もちろん関連するインポートも)を追加しただけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try to call `http://localhost:8080/weather?city=Raleigh` again.  You're still waiting a long time before receiving an answer.  This is normal since the server just restarted and the cache was empty.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`http://localhost:8080/weather?city=Raleigh` をもう一度呼び出して確認してみてください。返事が来るまでにまだ長い時間待たされています。これはサーバーが再起動したばかりでキャッシュが空になっているので正常です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wait a second! The server restarted by itself after the `WeatherForecastService` update? Yes, this is one of Quarkus amazing features for developers called `live coding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ちょっと待って!? `WeatherForecastService` のアップデート後、サーバーが勝手に再起動した?はい、これは、 `live coding` と呼ばれる開発者のためのQuarkusの驚くべき機能の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the cache was loaded during the previous call, try calling the same URL.  This time, you should get a super fast answer with an `executionTimeInMs` value close to 0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前回の呼び出しでキャッシュが読み込まれたので、同じ URL を呼び出してみてください。今度は、 `executionTimeInMs` の値が 0 に近い超高速な応答が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see what happens if we start from one day in the future using the `http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` URL.  You should get an answer two seconds later since two of the requested days were already loaded in the cache.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>URL `http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` を使って未来のある日から始めるとどうなるか見てみましょう。要求された日のうち2つはすでにキャッシュに読み込まれていたので、2秒後に回答が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also try calling the same URL with a different city and see the cache in action again.  The first call will take six seconds and the following ones will be answered immediately.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、同じURLを別の都市で呼び出してみて、再度キャッシュの動作を確認することもできます。最初の呼び出しには6秒ほどかかり、次の呼び出しにはすぐに出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Congratulations! You just added application data caching to your Quarkus application with a single line of code!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おめでとうございます。たった1行のコードでQuarkusアプリケーションにアプリケーションデータのキャッシングを追加できました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされている機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Cacheable`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Cacheable`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@CachePut`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CachePut`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@CacheEvict`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CacheEvict`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in this first version of the Spring Cache annotations extension, not all features of these annotations are supported (with proper errors being logged when trying to use an unsupported feature).  However, additional features are planned for future releases.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この最初のバージョンの Spring Cache アノテーションエクステンションでは、これらのアノテーションのすべての機能がサポートされているわけではないことに注意してください (サポートされていない機能を使用しようとすると、適切なエラーがログに記録されます)。しかし、今後のリリースでは追加機能が計画されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Spring guides</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のSpringガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has more Spring compatibility features. See the following guides for more details:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、より多くのSpring互換機能があります。詳細については、以下のガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package and run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをパッケージ化して実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  Open your browser to http://localhost:8080/greeting.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行するには、次の手順を実行します: `./mvnw compile quarkus:dev` 。ブラウザで http://localhost:8080/greeting を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation for:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の場合のHibernate Validator/Bean Validation の使用方法について説明します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the input/output of your REST services;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST サービスの入出力の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the parameters and return values of the methods of your business services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビジネスサービスのメソッドのパラメーターと戻り値の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple. The user fills a form on a web page.  The web page sends the form content to the `BookResource` as JSON (using Ajax). The `BookResource` validates the user input and returns the _result_ as JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドで構築されたアプリケーションは非常にシンプルです。ユーザーはウェブページ上でフォームを入力します。Web ページはフォームの内容を JSON として `BookResource` に送信します (Ajax を使用)。 `BookResource` はユーザーの入力を検証し、 _結果_ をJSON として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson and Hibernate Validator/Bean Validation extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RS、Jackson、およびHibernate Validator/Bean ValidationエクステンションをインポートするMavenディレクトリー構造を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `hibernate-validator` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `hibernate-validator` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the Validator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデータへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.validation.BookResource` class, and inject the `Validator` object as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.validation.BookResource` クラスを編集し、以下のように `Validator` オブジェクトを注入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Validator` allows checking constraints on a specific object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Validator` では、特定のオブジェクトに対する制約をチェックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this application, we are going to test an elementary object, but we support complicated constraints and can validate graphs of objects.  Create the `org.acme.validation.Book` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のアプリケーションでは、基本のオブジェクトをテストすることになりますが、複雑な制約にも対応しており、オブジェクトのグラフを検証することができます。以下の内容で `org.acme.validation.Book` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints are added on fields, and when an object is validated, the values are checked.  The getter and setter methods are also used for JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フィールドに制約を加え、オブジェクトが検証されると値がチェックされます。ゲッターメソッドとセッターメソッドはJSONマッピングにも使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to the `BookResource` class.  Add the following method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BookResource` クラスに戻り、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes it does not compile, `Result` is missing, but we will add it very soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、これはコンパイル出来ません。 `Result` がありませんが、私たちはすぐに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter (`book`) is created from the JSON payload automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドパラメーター( `book` )は、JSONペイロードから自動的に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method uses the `Validator` to check the payload.  It returns a set of violations.  If this set is empty, it means the object is valid.  In case of failures, the messages are concatenated and sent back to the browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは `Validator` を使用してペイロードをチェックします。これは違反のセットを返します。このセットが空の場合は、オブジェクトが有効であることを意味します。失敗した場合は、メッセージを連結してブラウザに送り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create the `Result` class as an inner class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、 `Result` クラスをインナークラスとして作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public String getMessage() {
        return message;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public String getMessage() {
        return message;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class is very simple and only contains 2 fields and the associated getters and setters.  Because we indicate that we produce JSON, the mapping to JSON is made automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは非常にシンプルで、2つのフィールドとそれに関連するゲッターとセッターだけが含まれています。JSONを生成することを示しているので、JSONへのマッピングは自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While using the `Validator` manually might be useful for some advanced usage, if you simply want to validate the parameters or the return value or your REST end point, you can annotate it directly, either with constraints (`@NotNull`, `@Digits`...)  or with `@Valid` (which will cascade the validation to the bean).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Validator` を手動で使用することは、高度な使用法には便利かもしれませんが、単にパラメーターや戻り値、RESTのエンドポイントを検証したい場合は、制約( `@NotNull`, `@Digits`...)や `@Valid` (Beanに検証をカスケードします)を使用して直接アノテーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an end point validating the `Book` provided in the request:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストで提供された `Book` を検証するエンドポイントを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, we don't have to manually validate the provided `Book` anymore as it is automatically validated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご覧のように、提供された `Book` は自動的に検証されるので、もう手動で検証する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a validation error is triggered, a violation report is generated and serialized as JSON as our end point produces a JSON output.  It can be extracted and manipulated to display a proper error message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>検証エラーが発生した場合、違反レポートが生成され、そしてエンドポイントがJSON出力を生成することによってJSONとしてシリアライズされます。これを抽出して操作することで、適切なエラーメッセージを表示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service method validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスメソッドの検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might not always be handy to have the validation rules declared at the end point level as it could duplicate some business validation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデーションルールをエンドポイントレベルで宣言するのは、必ずしも便利とは限りません。ビジネスバリデーションと重複する可能性があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best option is then to annotate a method of your business service with your constraints (or in our particular case with `@Valid`):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最良の選択肢は、ビジネスサービスのメソッドに制約をアノテーションすることです(私たちの場合は `@Valid` ):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling the service in your rest end point triggers the `Book` validation automatically:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントでサービスを呼び出すと、自動的に `Book` の検証が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that, if you want to push the validation errors to the frontend, you have to catch the exception and push the information yourselves as they will not be automatically pushed to the JSON output.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>検証エラーをフロントエンドにプッシュしたい場合は、例外をキャッチして自分で情報をプッシュしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that you usually don't want to expose to the public the internals of your services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あなたは通常、あなたのサービスの内部を公開したくないことを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and especially not the validated value contained in the violation object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に違反オブジェクトに含まれる検証された値は公開したくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A frontend</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フロントエンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add the simple web page to interact with our `BookResource`.  Quarkus automatically serves static resources contained in the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, replace the `index.html` file with the content from this {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、 `BookResource`.Quarkusと対話するためのシンプルなウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーに含まれる静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーで、 `index.html` ファイルをこの {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] ファイルの内容で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's see our application in action. Run it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、実際にアプリケーションを見てみましょう。以下のように実行してみてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open your browser to http://localhost:8080/:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、ブラウザで http://localhost:8080/ を開いてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the book details (valid or invalid)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>書籍の詳細を入力してください(有効または無効)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the _Try me..._ buttons to check if your data is valid using one of the methods we presented above.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_Try me..._ ボタンをクリックして、上記で紹介した方法のいずれかを使用してデータが有効かどうかを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Hibernate Validator extension is tightly integrated with CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ValidatorエクステンションはCDIと緊密に統合されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you might need to configure the behavior of the `ValidatorFactory`, for instance to use a specific `ParameterNameProvider`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、 `ValidatorFactory` の動作を設定する必要があるかもしれません。例えば、特定の `ParameterNameProvider` を使用するためなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the `ValidatorFactory` is instantiated by Quarkus itself, you can very easily tweak it by declaring replacement beans that will be injected in the configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ValidatorFactory` は、Quarkus 自体によってインスタンス化されていますが、設定に注入される代わりのBeanを宣言することで、非常に簡単に微調整することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you create a bean of the following types in your application, it will automatically be injected into the `ValidatorFactory` configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションで以下のタイプのBeanを作成すると、自動的に `ValidatorFactory` の設定に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to wire anything.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何も設定しなくても大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, for each listed type, you can declare only one bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論、リストされた各型に対して、宣言することができるのは1つのBeanだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These beans should be declared as `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのBeanは、 `@ApplicationScoped` として宣言する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can declare your constraint validators as CDI beans:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約バリデータをCDI Beanとして宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When initializing a constraint validator of a given type, Quarkus will check if a bean of this type is available and, if so, it will use it instead of instantiating one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定された型の制約バリデータを初期化する際、Quarkusはこの型のBeanが利用可能かどうかをチェックし、利用可能な場合はインスタンスを作成する代わりにそれを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, as demonstrated in our example, you can fully use injection in your constraint validator beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように、例で示したように、制約バリデータBeanでインジェクションを完全に使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except in very specific situations, it is recommended to make the said beans `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非常に特定の状況を除いて、このBeanは `@ApplicationScoped` として作ることをお勧めします.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation and localization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデーションとローカリゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, constraint violation messages will be returned in the build system locale.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、制約違反のメッセージはビルドシステムのロケールで返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure this behavior by adding the following configuration in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、以下の設定を `application.properties` に追加することで変更することが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy, in the context of a JAX-RS endpoint, Hibernate Validator will automatically resolve the optimal locale to use from the `Accept-Language` HTTP header, provided the supported locales have been properly specified in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyを使用している場合、JAX-RSエンドポイントのコンテキストでは、 サポートされるロケールが `application.properties` で適切に指定されている場合、Hibernate Validatorが使用する最適なロケールを `Accept-Language` HTTPヘッダから自動的に解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client in order to interact with REST APIs with very little effort.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST Clientを使用して、ほとんど手間をかけずにREST APIとやりとりする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need to write server link:rest-json[JSON REST APIs].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバー link:rest-json[JSON REST API] を書く必要がある場合は、別のガイドがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `rest-client` と `resteasy-jackson` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `resteasy` and `resteasy-jackson` extensions for the REST server support;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST サーバーのサポートのために `resteasy` と `resteasy-jackson` のエクステンションを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `rest-client` and `rest-client-jackson` extensions for the REST client support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST クライアントのサポートのために `rest-client` と `rest-client-jackson` のエクステンションを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `rest-client` and the `rest-client-jackson` extensions to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、 `rest-client` と `rest-client-jackson` のエクステンションをプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up the model</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>モデルのセットアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will be demonstrating how to consume part of the REST API supplied by the link:https://restcountries.eu[restcountries.eu] service.  Our first order of business is to setup the model we will be using, in the form of a `Country` POJO.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:https://restcountries.eu[restcountries.eu] サービスが提供するREST APIの一部を利用する方法をデモします。まず最初に、 `Country` POJO の形式で使用するモデルをセットアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `src/main/java/org/acme/rest/client/Country.java` file and set the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/rest/client/Country.java` ファイルを作成し、以下の内容を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The model above is only a subset of the fields provided by the service (thus the `@JsonIgnoreProperties` annotation), but it suffices for the purposes of this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のモデルは、サービスによって提供されるフィールドのサブセットに過ぎません(`@JsonIgnoreProperties` アノテーションによる)が、このガイドの目的には十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the interface</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターフェースの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations. In our case the interface should be created at `src/main/java/org/acme/rest/client/CountriesService.java` and have the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile REST Client を使うのは、適切な JAX-RS と MicroProfile アノテーションを使ってインターフェースを作成するのと同じくらい簡単です。私たちの場合、インターフェイスは `src/main/java/org/acme/rest/client/CountriesService.java` で作成され、次のような内容になっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `getByName` method gives our code the ability to query a country by name from the REST Countries API. The client will handle all the networking and marshalling leaving our code clean of such technical details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getByName` メソッドは、私たちのコードに、REST Countries API から名前を指定して国を問い合わせる機能を与えます。クライアントがすべてのネットワーキングとマーシャリングを処理してくれるので、このような技術的な詳細は一切ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of the annotations in the code above is the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のコードのアノテーションの目的は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@RegisterRestClient` allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@RegisterRestClient` により、Quarkusは、このインターフェイスがRESTクライアントとしてCDIインジェクションに利用可能であることを知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Path`, `@GET` and `@PathParam` are the standard JAX-RS annotations used to define how to access the service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Path` 、 `@GET` 、 `@PathParam` は、サービスへのアクセス方法を定義するために使用される標準的な JAX-RS アノテーションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Produces` defines the expected content-type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Produces` は、期待されるコンテンツタイプを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-rest-client-jackson` or `quarkus-rest-client-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-rest-client-jackson` や `quarkus-rest-client-jsonb` などの JSON エクステンションがインストールされている場合、メディアタイプが `@Produces` や `@Consumes` アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` メディアタイプをデフォルトで使用します( `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` と `application/octet-stream` がデフォルトとなっています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want JSON by default you can set `quarkus.resteasy-json.default-json=false` and the default will change back to being auto-negotiated. If you set this you will need to add `@Produces(MediaType.APPLICATION_JSON)` and `@Consumes(MediaType.APPLICATION_JSON)` to your endpoints in order to use JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでJSONを使用したくない場合は、 `quarkus.resteasy-json.default-json=false` を設定すると、デフォルトは自動ネゴシエーションに戻ります。これを設定した場合、JSON を使用するためには `@Produces(MediaType.APPLICATION_JSON)` と `@Consumes(MediaType.APPLICATION_JSON)` をエンドポイントに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't rely on the JSON default, it is heavily recommended to annotate your endpoints with the `@Produces` and `@Consumes` annotations to define precisely the expected content-types.  It will allow to narrow down the number of JAX-RS providers (which can be seen as converters) included in the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON のデフォルトに頼らない場合は、エンドポイントに `@Produces` や `@Consumes` のアノテーションを付けて、期待されるコンテンツタイプを正確に定義することを強くお勧めします。これにより、ネイティブ実行ファイルに含まれる JAX-RS プロバイダ (コンバータとみなすことができます) の数を絞り込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンフィグレーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to determine the base URL to which REST calls will be made, the REST Client uses configuration from `application.properties`.  The name of the property needs to follow a certain convention which is best displayed in the following code:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST 呼び出しが行われるベース URL を決定するために、REST クライアントは `application.properties` からの設定を使用します。プロパティーの名前は、以下のコードで表示される特定の規則に従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having this configuration means that all requests performed using `org.acme.rest.client.CountriesService` will use `https://restcountries.eu/rest` as the base URL.  Using the configuration above, calling the `getByName` method of `CountriesService` with a value of `France` would result in an HTTP GET request being made to `https://restcountries.eu/rest/v2/name/France`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定をすると、 `org.acme.rest.client.CountriesService` を使用して実行されるすべてのリクエストが `https://restcountries.eu/rest` をベースURLとして使用します。上記の設定を使用して、 `CountriesService` の `getByName` メソッドを `France` の値で呼び出すと、HTTP GET リクエストが `https://restcountries.eu/rest/v2/name/France` に対して実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having this configuration means that the default scope of `org.acme.rest.client.CountriesService` will be `@Singleton`. Supported scope values are `@Singleton`, `@Dependent`, `@ApplicationScoped` and `@RequestScoped`. The default scope is `@Dependent`.  The default scope can also be defined on the interface.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定をすると、 `org.acme.rest.client.CountriesService` のデフォルトのスコープは `@Singleton` になります。サポートされているスコープの値は `@Singleton` , `@Dependent` , `@ApplicationScoped` および `@RequestScoped` です。既定のスコープは `@Dependent` です。デフォルトのスコープはインターフェイス上で定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that `org.acme.rest.client.CountriesService` _must_ match the fully qualified name of the `CountriesService` interface we created in the previous section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.rest.client.CountriesService` は、前のセクションで作成した `CountriesService` インターフェイスの完全修飾名と _一致しなければならない_ ことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To facilitate the configuration, you can use the `@RegisterRestClient` `configKey` property that allows to use another configuration root than the fully qualified name of your interface.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構成を容易にするために、 `@RegisterRestClient` `configKey` プロパティーを使用して、インターフェイスの完全修飾名とは別の構成ルートを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling Hostname Verification</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホスト名の検証を無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To disable the SSL hostname verification for a specific REST client, add the following property to your configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のRESTクライアントのSSLホスト名検証を無効にするには、次のプロパティーを構成に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/rest/client/CountriesResource.java` file and update it with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/rest/client/CountriesResource.java` ファイルを開き、以下の内容で更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in addition to the standard CDI `@Inject` annotation, we also need to use the MicroProfile `@RestClient` annotation to inject `CountriesService`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>標準の CDI `@Inject` アノテーションに加えて、MicroProfile `@RestClient` アノテーションを使用して `CountriesService` を注入する必要があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the functional test to reflect the changes made to the endpoint.  Edit the `src/test/java/org/acme/rest/client/CountriesResourceTest.java` file and change the content of the `testCountryNameEndpoint` method to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、エンドポイントに加えられた変更を反映させるために、機能テストを更新する必要があります。 `src/test/java/org/acme/rest/client/CountriesResourceTest.java` ファイルを編集し、 `testCountryNameEndpoint` メソッドの内容を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code above uses link:http://rest-assured.io/[REST Assured]'s link:https://github.com/rest-assured/rest-assured/wiki/GettingStarted#jsonpath[json-path] capabilities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のコードでは、 link:http://rest-assured.io/[REST Assured] の link:https://github.com/rest-assured/rest-assured/wiki/GettingStarted#jsonpath[json-path] 機能を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Async Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期サポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest client supports asynchronous rest calls.  Async support comes in 2 flavors: you can return a `CompletionStage` or a `Uni` (requires the `quarkus-rest-client-mutiny` extension).  Let's see it in action by adding a `getByNameAsync` method in our `CountriesService` REST interface. The code should look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>rest クライアントは非同期の rest 呼び出しをサポートしています。非同期のサポートには、 `CompletionStage` と `Uni` ( `quarkus-rest-client-mutiny` のエクステンションが必要です) の 2 種類があります。 `CountriesService` REST インタフェースに `getByNameAsync` メソッドを追加してみましょう。コードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test asynchronous methods, add the test method below in `CountriesResourceTest`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期メソッドをテストするには、`CountriesResourceTest` に以下のテストメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Uni` version is very similar:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` 版は非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CountriesResource` becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountriesResource` は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous snippet uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のスニペットでは、Mutinyのリアクティブタイプを使用していますが、もし慣れていない場合は、まず link:getting-started-reactive#mutiny[Getting Started with Reactiveガイド] を読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When returning a `Uni`, every _subscription_ invokes the remote service.  It means you can re-send the request by re-subscribing on the `Uni`, or use a `retry` as follow:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` を返すとき、すべての _サブスクリプション_ は 、リモートサービスを呼び出します。つまり、 `Uni` で再購読してリクエストを再送信するか、以下のように `retry` を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use a `CompletionStage`, you would need to call the service's method to retry.  This difference comes from the laziness aspect of Mutiny and its subscription protocol.  More details about this can be found in https://smallrye.io/smallrye-mutiny/#_uni_and_multi[the Mutiny documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CompletionStage` を使用する場合は、サービスのメソッドを呼び出して再試行する必要があります。この違いは、Mutinyとそのサブスクリプションプロトコルの lazy 性の側面から来ています。これについての詳細は Mutiny の link:https://smallrye.io/smallrye-mutiny/#_uni_and_multi[ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom headers support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムヘッダーのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile REST client allows amending request headers by registering a `ClientHeadersFactory` with the `@RegisterClientHeaders` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile REST クライアントでは、 `ClientHeadersFactory` を `@RegisterClientHeaders` アノテーションで登録することで、リクエストヘッダを修正することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see it in action by adding a `@RegisterClientHeaders` annotation pointing to a `RequestUUIDHeaderFactory` class in our `CountriesService` REST interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountriesService` REST インタフェースに `@RegisterClientHeaders` アノテーションを追加して、 `RequestUUIDHeaderFactory` クラスを指すようにしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And the `RequestUUIDHeaderFactory` would look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `RequestUUIDHeaderFactory` は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any CDI bean matching the declared factory class will be picked up and can of course benefit from the usual CDI infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>宣言されたファクトリークラスにマッチする CDI Bean は、ピックアップされ、もちろん通常のCDIインフラストラクチャの恩恵を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  Open your browser to http://localhost:8080/country/name/greece.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` でアプリケーションを実行します。ブラウザで http://localhost:8080/country/name/greece を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see a JSON object containing some basic information about Greece.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ギリシャに関する基本情報を含む JSON オブジェクトが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the REST Client extension and link:rest-json[the RESTEasy extension] share the same infrastructure.  One important consequence of this consideration is that they share the same list of providers (in the JAX-RS meaning of the word).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、RESTクライアントエクステンションと link:rest-json[RESTEasyエクステンション] は同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、(JAX-RSの意味での)プロバイダーのリストを共有しているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, if you declare a `WriterInterceptor`, it will by default intercept both the servers calls and the client calls, which might not be the desired behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `WriterInterceptor` を宣言した場合、デフォルトではサーバーの呼び出しとクライアントの呼び出しの両方をインターセプトしますが、これは望ましい動作ではないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can change this default behavior and constrain a provider to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、このデフォルトの動作を変更してプロバイダを制約することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *client* calls by adding the `@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 *クライアント* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *server* calls by adding the `@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 *サーバー* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a Mock HTTP Server for tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストにモックHTTPサーバーを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up a mock HTTP server, against which tests are run, is a common testing pattern.  Examples of such servers are link:http://wiremock.org/[Wiremock] and link:https://docs.hoverfly.io/projects/hoverfly-java/en/latest/index.html[Hoverfly].  In this section we'll demonstrate how Wiremock can be leveraged for testing the `CountriesService` which was developed above.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを実行するためのモックHTTPサーバーを設定することは、一般的なテストパターンです。そのようなサーバーの例としては、 link:http://wiremock.org/[Wiremock] や link:https://docs.hoverfly.io/projects/hoverfly-java/en/latest/index.html[Hoverfly] があります。このセクションでは、上で開発した `CountriesService` をテストするために Wiremock をどのように活用できるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, Wiremock needs to be added as a test dependency. For a Maven project that would happen like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず第一に、Wiremockをテスト依存関係として追加する必要があります。Mavenプロジェクトの場合は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a proper Wiremock version. All available versions can be found link:https://search.maven.org/artifact/com.github.tomakehurst/wiremock-jre8[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>適切なWiremockのバージョンを使用してください。利用可能なすべてのバージョンは link:https://search.maven.org/artifact/com.github.tomakehurst/wiremock-jre8[ここで]  見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus tests when some service needs to be started before the Quarkus tests are ran, we utilize the `@io.quarkus.test.common.QuarkusTestResource` annotation to specify a `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` which can start the service and supply configuration values that Quarkus will use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのテストを実行する前にサービスを開始する必要がある場合、Quarkusのテストでは、 `@io.quarkus.test.common.QuarkusTestResource` アノテーションを利用して、サービスを開始できる `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を指定し、Quarkusが使用する設定値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more details about `@QuarkusTestResource` refer to link:getting-started-testing#quarkus-test-resource[this part of the documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusTestResource` の詳細については、 link:getting-started-testing#quarkus-test-resource[ドキュメントのこの部分] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an implementation of `QuarkusTestResourceLifecycleManager` called `WiremockCountries` like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように `QuarkusTestResourceLifecycleManager` の実装である `WiremockCountries` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Statically importing the methods in the Wiremock package makes it easier to read the test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Wiremockパッケージのメソッドを静的にインポートすると、テストを読みやすくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `start` method is invoked by Quarkus before any test is run and returns a `Map` of configuration properties that apply during the test execution.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`start` メソッドは、テストを実行する前にQuarkusによって呼び出され、テスト実行中に適用される設定プロパティーの `Map` を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch Wiremock.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Wiremockを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Wiremock to stub the calls to `/v2/name/GR` by returning a specific canned response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Wiremockが特定の定型文を返すことで、 `/v2/name/GR` への呼び出しをスタブするように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All HTTP calls that have not been stubbed are handled by calling the real service. This is done for demonstration purposes, as it is not something that would usually happen in a real test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタブ化されていないすべての HTTP 呼び出しは、実際のサービスを呼び出すことで処理されます。これは、実際のテストでは通常発生しないことなので、デモンストレーションのために行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the `start` method returns configuration that applies for tests, we set the rest-client property that controls the base URL which is used by the implementation of `CountriesService` to the base URL where Wiremock is listening for incoming requests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`start` メソッドはテストに適用される設定を返すので、 `CountriesService` の実装で使用されるベースURLを制御する rest-client プロパティーを、Wiremock がリクエストの着信をリッスンするベースURLに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When all tests have finished, shutdown Wiremock.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのテストが終了したら、Wiremockをシャットダウンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CountriesResourceTest` test class needs to be annotated like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountriesResourceTest` テストクラスには、このようなアノテーションが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@QuarkusTestResource` applies to all tests, not just `CountriesResourceTest`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusTestResource` は `CountriesResourceTest` だけでなく、すべてのテストに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further reading</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数 - `AWS_ACCESS_KEY_ID` と `AWS_SECRET_ACCESS_KEY`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての AWS SDK および AWS CLI で共有される、デフォルトの場所( `~/.aws/credentials` )にある資格情報プロファイルのファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials delivered through the Amazon ECS if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` 環境変数が設定されていて、セキュリティーマネージャーがその変数にアクセスする権限を持っている場合に、Amazon ECS を通して配信されるクレデンシャル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional blocking code uses link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`]
 variables to store contextual objects in order to avoid
passing them as parameters everywhere. Many Quarkus extensions require those contextual objects to operate
properly: link:rest-json[RESTEasy], link:cdi-reference[ArC] and link:transaction[Transaction]
for example.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>従来のブロッキングコードでは  link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`] 変数を使用してコンテキストオブジェクトを格納します。多くのQuarkusエクステンションは、適切に動作するためにこれらのコンテキストオブジェクトを必要とします。例えば、 link:rest-json[RESTEasy]、 link:cdi-reference[ArC]、 link:transaction[Transaction]などです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you write reactive/async code, you have to cut your work into a pipeline of code blocks that get executed "later", and in practice after the method you defined them in have returned. As such, `try/finally` blocks as well as `ThreadLocal` variables stop working, because your reactive code gets executed in another thread, after the caller ran its `finally` block.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ/非同期コードを書く場合、「後で」実行されるコードブロックのパイプラインに作業を切り 込まなければならず、実際には、定義したメソッドがreturnされた後に実行されます。そのため、 `try/finally` ブロックや `ThreadLocal` 変数は動作しなくなります。なぜならば、呼び出し元が `finally` ブロックを実行した後に、 リアクティブコードは別のスレッドで実行されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] was made to make those Quarkus extensions work properly in reactive/async settings. It works by capturing those contextual values that used to be in thread-locals, and restoring them when your code is called.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] は、リアクティブ/非同期設定でQuarkusエクステンションが正しく動作するようにするために作られました。これは、スレッドローカルにあったコンテキスト値を取得し、コードが呼び出されたときにそれらを復元することで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:http://smallrye.io/smallrye-mutiny[Mutiny] (the `quarkus-mutiny` extension), you just need to add the the `quarkus-smallrye-context-propagation` extension to enable context propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:http://smallrye.io/smallrye-mutiny[Mutiny] ( `quarkus-mutiny` のエクステンション) を使用している場合は、コンテキストの伝播を有効にするために `quarkus-smallrye-context-propagation` のエクステンションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, add the following dependencies to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、以下の依存関係を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, you will get context propagation for ArC, RESTEasy and transactions, if you are using them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、ArC、RESTEasy、トランザクションを使用している場合は、コンテキストの伝播を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このセクションでは、Mutinyのリアクティブタイプ を使用しています。慣れていない場合は、 link:getting-started-reactive#mutiny[Getting Started with Reactive guide] を先にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a REST endpoint that reads the next 3 items from a link:kafka[Kafka topic], stores them in a database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client, you can do it like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:kafka[Kafkaトピック] から次の3つのアイテムを読み込んで、 link:hibernate-orm-panache[Hibernate ORM with Panache] を使ってデータベースに保存してからクライアントに返すRESTエンドポイントを書いてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that thanks to Mutiny support for context propagation, this works out of the box.  The 3 items are persisted using the same transaction and this transaction is committed when the stream completes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキストの伝播のための Mutiny サポートのおかげで、これは、そのまま直ぐに動作することに注目してください。3つのアイテムは同じトランザクションを使用して保持され、このトランザクションはストリームが完了するとコミットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage example for `CompletionStage`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CompletionStage` の使用例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`] you need manual context propagation. You can do that by injecting a `ThreadContext` or `ManagedExecutor` that will propagate every context. For example, here we use the link:vertx[Vert.x Web Client] to get the list of Star Wars people, then store them in the database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client as JSON using link:rest-json[Jackson or JSON-B]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`]を使用する場合、手動でコンテキストを伝播させる必要があります。 `ThreadContext` や `ManagedExecutor` を注入することで、すべてのコンテキストを伝播させることができます。例えば、ここでは link:vertx[Vert.x Web Client] を使用してスターウォーズの登場人物のリストを取得し、 link:hibernate-orm-panache[Hibernate ORM with Panache を]使用して(全て同じトランザクション内で) データベースに保存します。その後、 link:rest-json[Jackson または JSON-B] を使用して JSON としてクライアントに返します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `ThreadContext` or `ManagedExecutor` you can wrap most useful functional types and `CompletionStage` in order to get context propagated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ThreadContext` または `ManagedExecutor` を使用することで、ほとんどの有用な関数型と `CompletionStage` をラップしてコンテキストを伝播させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected `ManagedExecutor` uses the Quarkus thread pool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注入された `ManagedExecutor` は、Quarkus のスレッドプールを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In terms of CDI, `@RequestScoped`, `@ApplicationScoped` and `@Singleton` beans get propagated and are available in other threads.  `@Dependent` beans as well as any custom scoped beans cannot be automatically propagated via CDI Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI の観点からは、 `@RequestScoped`, `@ApplicationScoped`, `@Singleton` Beanは伝播され、他のスレッドで利用可能です。 `@Dependent` BeanやカスタムスコープされたBeanは、CDI コンテキスト伝播を介して自動的に伝播されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` and `@Singleton` beans are always active scopes and as such are easy to deal with - context propagation tasks can work with those beans so long as the CDI container is running.  However, `@RequestScoped` beans are a different story. They are only active for a short period of time which can be bound either to HTTP request or some other request/task when manually activated/deactivated.  In this case user must be aware that once the original thread gets to an end of a request, it will terminate the context, calling `@PreDestroy` on those beans and then clearing them from the context.  Subsequent attempts to access those beans from other threads can result in unexpected behaviour.  It is therefore recommended to make sure all tasks using request scoped beans via context propagation are performed in such a manner that they don't outlive the original request duration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ApplicationScoped` と `@Singleton` のBeanは常にアクティブなスコープであり、そのため対処が簡単です - コンテキスト伝播タスクは、CDI コンテナーが動作している限り、これらのBeanで動作します。しかし、 `@RequestScoped` Beanは話が違います。手動で有効化/無効化すると、HTTP リクエストや他のリクエスト/タスクにバインドされます。この場合、元のスレッドがリクエストの終了に到達すると、コンテキストを終了し、それらのBeanで `@PreDestroy` を呼び出し、コンテキストからクリアされることに注意しなければなりません。その後、他のスレッドからこれらのBeanにアクセスしようとすると、予期せぬ動作をすることがあります。したがって、コンテキストの伝播を介してリクエストスコープされたBeanを使用するすべてのタスクは、元のリクエストの持続時間を超えないような方法で実行されることを確認することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the above described behavior, it is recommended to avoid using `@PreDestroy` on `@RequestScoped` beans when working with Context Propagation in CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記で説明した動作のため、CDI で Context Propagation を使用する際には `@PreDestroy` を `@RequestScoped` Beanで使用しないことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サンプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling streams</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ストリームの取り扱い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to configure Quarkus to log to Sentry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusがSentryにログ送信するように設定する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry is a really easy way to be notified of errors happening in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentryは、Quarkusアプリケーションで発生したエラーを通知する本当に簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a self-hosted and cloud-based error monitoring that helps software teams discover, triage, and prioritize errors in real-time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セルフホスト型か、クラウドベースのエラーモニターリングで、ソフトウェアチームがリアルタイムでエラーを発見し、トリアージし、優先順位をつけるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They offer a free starter price for cloud-based or you can self host it for free.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドベースの場合は無料のスターター価格を提供してくれますし、セルフホストでも無料で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry's Java SDK is open source, but recently sentry.io https://blog.sentry.io/2019/11/06/relicensing-sentry[changed the license] for their backend to the non-open source https://github.com/getsentry/sentry/blob/master/LICENSE[BSL license]. This might or might not be an issue for your project and product.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentry の Java SDK はオープンソースですが、最近 sentry.io はバックエンドの link:https://blog.sentry.io/2019/11/06/relicensing-sentry[ライセンス] を非オープンソースの link:https://github.com/getsentry/sentry/blob/master/LICENSE[BSL ライセンス]に link:https://blog.sentry.io/2019/11/06/relicensing-sentry[変更しました]。これはあなたのプロジェクトや製品にとって問題になるかもしれませんし、ならないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start with, you need to get a Sentry DSN either by https://sentry.io/signup/[creating a Sentry account] or https://docs.sentry.io/server/[installing your own self-hosted Sentry].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>手始めに、Sentry link:https://sentry.io/signup/[アカウントを作成する]か、自前のSentry link:https://docs.sentry.io/server/[をインストール] してSentry DSNを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“In Application” Stack Frames</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"in Application" スタックフレーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry differentiates stack frames that are directly related to your application (“in application”) from stack frames that come from other packages such as the standard library, frameworks, or other dependencies. The difference is visible in the Sentry web interface where only the “in application” frames are displayed by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentry は、アプリケーションに直接関連するスタックフレーム("in application")と、標準ライブラリやフレームワーク、その他の依存関係のあるパッケージから来るスタックフレームを区別します。この違いは、SentryのWebインタフェースでは、デフォルトでは "in application" フレームのみが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure which package prefixes your application uses with the `in-app-packages` option, which takes a comma separated list of packages:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`in-app-packages` オプションで、アプリケーションが使用するパッケージの接頭辞を設定できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don’t want to use this feature but want to disable the warning, simply set it to `*`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用したくないが警告を無効にしたい場合は、 `*` をセットしてください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors and warnings occurring in any of the packages will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いずれかのパッケージで発生したすべてのエラーや警告は、DSNと共にSentryに送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors occurring in the package `org.example` will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージ `org.example` で発生したすべてのエラーは、DSN と共にSentry に送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is configured through the standard `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、標準の `application.properties` ファイルを介して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.liquibase.org/[Liquibase] is an open source tool for database schema change management.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://www.liquibase.org/[Liquibase] はデータベーススキーマ変更管理のためのオープンソースツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Liquibase as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、このガイドで説明するように、Liquibaseを使用するためのファーストクラスのサポートを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start using Liquibase with your project, you just need to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liquibase をプロジェクトで使い始めるためには、以下のことを行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your changeLog to the `{change-log}` file as you usually do with Liquibase</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liquibase で通常行うように、変更ログを `{change-log}` ファイルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Liquibase` object and run your migration as you normally do.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`migrate-at-start` オプションを有効にしてスキーマを自動的に移行するか、 `Liquibase` オブジェクトをインジェクトして通常通りにマイグレーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Liquibase extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liquibaseエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase support relies on the Quarkus datasource config.  It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.  First, you need to add the datasource config to the `{config-file}` file in order to allow Liquibase to manage the schema.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liquibaseのサポートは、Quarkusのデータソース設定に依存しています。この設定は、デフォルトのデータソースだけでなく、すべての link:#multiple-datasources[名前付きデータソース] 用にカスタマイズすることができます。まず、Liquibaseがスキーマを管理できるようにするために、 `{config-file}` ファイルにデータソース設定を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example for the `{config-file}` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{config-file}` ファイルの例は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a changeLog file to the default folder following the Liquibase naming conventions: `{change-log}` The yaml, json, xml and sql changeLog file formats are also supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liquibase の命名規則に従って、デフォルトのフォルダーに changeLog ファイルを追加します: `{change-log}` yaml, json, xml, sql changeLog ファイル形式もサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Liquibase's update method according to your config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを起動することが出来るようになり、Quarkusはあなたの設定に従ってLiquibaseの更新メソッドを実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension provides a factory to initialize a Liquibase instance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションは、Liquibaseインスタンスを初期化するためのファクトリーを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Quarkus liquibase factory if you want to use the liquibase methods directly</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liquibaseメソッドを直接使用したい場合は、QuarkusのLiquibaseファクトリーをインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase can be configured for multiple datasources.  The Liquibase properties are prefixed exactly the same way as the named datasources, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liquibase は複数のデータソースに対して設定することができます。Liquibase のプロパティーは、例えば、名前のついたデータソースと全く同じように接頭辞が付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:default
quarkus.datasource.jdbc.max-size=13
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:default
quarkus.datasource.jdbc.max-size=13
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:tcp://localhost/mem:users
quarkus.datasource.users.jdbc.max-size=11
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:tcp://localhost/mem:users
quarkus.datasource.users.jdbc.max-size=11
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:tcp://localhost/mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:tcp://localhost/mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.  The syntax is as follows: `quarkus.liquibase.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キーに余分なビットがあることに注意してください。構文は以下の通りです。 `quarkus.liquibase.[optional name.][datasource property]` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without configuration, Liquibase is set up for every datasource using the default settings.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定をしないと、Liquibaseはデフォルトの設定で各データソースに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are interested in using the `Liquibase` object directly, you can inject it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `Liquibase` オブジェクトを直接使いたい場合は、以下のように注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enabled the `quarkus.liquibase.migrate-at-start` property, by the time you use the Liquibase instance, Quarkus will already have run the migrate operation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.liquibase.migrate-at-start` プロパティーを有効にした場合、Liquibase インスタンスを使用する時点で、Quarkus はすでにマイグレーション操作を実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Liquibase for named datasources using the Quarkus `LiquibaseDataSource` qualifier</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus `LiquibaseDataSource` 修飾子を使用して、指定されたデータソースに Liquibase を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Liquibase for named datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定されたデータソースに Liquibase を注入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List of applied or not applied liquibase ChangeSets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>適用された、または適用されていない liquibase ChangeSets のリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Keycloak and Bearer tokens then also see the link:security-keycloak-authorization[Using Keycloak to Centralize Authorization] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Keycloak と Bearer トークンを使用する場合は、 link:security-keycloak-authorization[Using Keycloak to Centralize Authorization]ガイドも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers three endpoints:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、3つのエンドポイントを提供する非常にシンプルなマイクロサービスを構築します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/users/me`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/users/me`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/admin`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/admin`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple. The main difference here is that we are using a `@RolesAllowed` annotation to make sure that only users granted with the `admin` role can access the endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/admin` エンドポイントのソースコードも非常にシンプルです。ここでの主な違いは、 `admin` ロールで付与されたユーザーだけがエンドポイントにアクセスできるように `@RolesAllowed` アノテーションを使用していることです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションは、コアサービスに開発者向けの新しい動作を追加するもので、ビルド時の拡張とランタイムコンテナという2つの異なる部分から構成されています。拡張部分は、アノテーションやXML記述子の読み込みなど、すべてのメタデータ処理を担当します。この拡張フェーズの出力は、関連するランタイムサービスを直接インスタンス化するためのバイトコードとして記録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that metadata is only processed once at build time, which both saves on startup time, and also on memory usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、メタデータがビルド時に一度だけ処理されることを意味し、起動時間の節約と、処理に使用されるクラスなどがランタイムJVMにロードされない（あるいは存在しない）ため、メモリ使用量の節約の両方を実現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an in-depth documentation, see the link:building-my-first-extension[building my first extension] if you need an introduction.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、詳細に踏み込むドキュメントです。入門ドキュメントが必要な場合は、 link:building-my-first-extension[初めてのエクステンションの作成]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension philosophy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション哲学</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section is a work in progress and gathers the philosophy under which extensions should be designed and written.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このセクションは作業中であり、エクステンションがどのように設計され、どのように書かれるべきかの哲学を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why an extension framework</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜエクステンションフレームワークなのか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus’s mission is to transform your entire application including the libraries it uses, into an artifact that uses significantly less resources than traditional approaches. These can then be used to build native applications using GraalVM.  To do this you need to analyze and understand the full "closed world" of the application.  Without the full and complete context, the best that can be achieved is partial and limited generic support.  By using the Quarkus extension approach, we can bring Java applications in line with memory footprint constrained environments like Kubernetes or cloud platforms.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの使命は、使用するライブラリを含むアプリケーション全体を、従来のアプローチよりも大幅に少ないリソースしか使用しないアーティファクトに変換することです。これらを使用して、GraalVMを使用してネイティブアプリケーションを構築することができます。これを行うためには、アプリケーションの完全な「クローズドワールド」を分析し、理解する必要があります。完全で完璧なコンテキストがなければ、達成可能なものは最高でも部分的で限定的、一般的なサポートです。Quarkusのエクステンションアプローチを使用することで、Kubernetesやクラウドプラットフォームのようなメモリフットプリントに制約のある環境にJavaアプリケーションを合わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension framework results in significantly improved resource utilization even when GraalVM is not used (e.g. in HotSpot).  Let’s list the actions an extension performs:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションフレームワークは、GraalVMを使用していない場合（HotSpotなど）でも、リソース利用率を大幅に改善します。エクステンションが実行するアクションをリストアップしてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Gather build time metadata and generate code</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時のメタデータを収集し、コードを生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This part has nothing to do with GraalVM, it is how Quarkus starts frameworks “at build time”</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この部分はGraalVMとは何の関係もありませんが、Quarkusがフレームワークを"ビルド時" に起動する方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension framework facilitates reading metadata, scanning classes as well as generating classes as needed</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションフレームワークは、必要に応じてメタデータの読み込み、クラスのスキャン、クラスの生成を容易にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A small part of the extension work is executed at runtime via the generated classes, while the bulk of the work is done at build time (called deployment time)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>拡張作業のごく一部は生成されたクラスを介して実行時に実行され、作業の大部分はビルド時に行われます (デプロイメント時と呼ばれます)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enforce opinionated and sensible defaults based on the close world view of the application (e.g. an application with no `@Entity` does not need to start Hibernate ORM)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの近い世界観に基づいて、定見に基づいた賢明なデフォルトを強制（例えば、 `@Entity` のないアプリケーションは、Hibernate ORM を起動する必要はありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An extension hosts Substrate VM code substitution so that libraries can run on GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは Substrate VM のコード置換をホストし、ライブラリを GraalVM 上で実行できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most changes are pushed upstream to help the underlying library run on GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ほとんどの変更は、基礎となるライブラリがGraalVM上で動作するようにupstreamにプッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Not all changes can be pushed upstream, extensions host Substrate VM substitutions - which is a form of code patching - so that libraries can run</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての変更をupstreamにプッシュできるわけではないので、エクステンションは Substrate VM 置換をホスト。これはコードパッチの一形態で、ライブラリが実行できるようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Host Substrate VM code substitution to help dead code elimination based on the application needs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Substrate VMコード置換のホストにより、アプリケーションのニーズに基づいたデッドコードの排除を支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is application dependant and cannot really be shared in the library itself</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはアプリケーションに依存しており、ライブラリ自体で共有することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, Quarkus optimizes the Hibernate code because it knows it only needs a specific connection pool and cache provider</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、Quarkusは、特定の接続プールとキャッシュプロバイダだけが必要であることを知っているため、Hibernateコードを最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send metadata to GraalVM for example classes in need of reflection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メタデータをGraalVMに送信。例えば、リフレクションに必要なクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This information is not static per library (e.g. Hibernate) but the framework has the semantic knowledge and knows which classes need to have reflection (for example @Entity classes)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この情報はライブラリ(Hibernateなど)ごとに静的ではありませんが、フレームワークはセマンティックな知識を持っており、どのクラスがリフレクションを必要とするかを知っています(例えば@Entityクラスなど)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Favor build time work over runtime work</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムワークよりもビルドタイムワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible favor doing work at build time (deployment part of the extension) as opposed to let the framework do work at startup time (runtime).  The more is done there, the smaller Quarkus applications using that extension will be and the faster they will load.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>可能な限り、フレームワークに起動時（ランタイム）に作業をさせるのではなく、ビルド時（エクステンションのデプロイメント部分）に作業を行うことをお勧めします。そこでの作業が多いほど、そのエクステンションを使用しているQuarkusアプリケーションは小さくなり、ロードが速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to expose configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定を公開する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus simplifies the most common usages.  This means that its defaults might be different than the library it integrates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、最も一般的な使用法を簡略化しています。つまり、そのデフォルトは、統合されているライブラリとは異なる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make the simple experience easiest, unify the configuration in `application.properties` via MicroProfile Config.  Avoid library specific configuration files, or at least make them optional: e.g. `persistence.xml` for Hibernate ORM is optional.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルな体験を最も簡単にするために、MicroProfile Configを経由して `application.properties` で設定を統一してください。ライブラリ固有の設定ファイルは避けるか、少なくともオプションにしてください: 例: Hibernate ORMの為の `persistence.xml` はオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions should see the configuration holistically as a Quarkus application instead of focusing on the library experience.  For example `quarkus.database.url` and friends are shared between extensions as defining a database access is a shared task (instead of a `hibernate.` property for example).  The most useful configuration options should be exposed as `quarkus.[extension].` instead of the natural namespace of the library.  Less common properties can live in the library namespace.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、ライブラリの体験に焦点を当てるのではなく、Quarkusアプリケーションとして全体的に設定を見るべきです。例えば、データベースアクセスの定義が共有タスクであるように、 `quarkus.database.url` 等々がエクステンション間で共有されます（例えば `hibernate.` プロパティを使用される代わりに）。最も便利な設定オプションは、ライブラリの自然な名前空間ではなく、 `quarkus.[extension].` として公開されるべきです。あまり一般的ではないプロパティは、ライブラリの名前空間に置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To fully enable the close world assumptions that Quarkus can optimize best, it is better to consider configuration options as build time settled vs overridable at runtime.  Of course properties like host, port, password should be overridable at runtime.  But many properties like enable caching or setting the JDBC driver can safely require a rebuild of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusが最適化できる閉じた世界の仮定を完全に有効にするには、ビルド時に設定された設定オプションと実行時にオーバーライド可能な設定オプションのどちらを採用するか検討するべきでしょう。もちろん、ホスト、ポート、パスワードなどのプロパティは、実行時にオーバーライド可能でなければなりません。しかし、キャッシングを有効にしたり、JDBCドライバを設定したりするような多くのプロパティは、アプリケーションの再構築を安全に要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since CDI is the central programming model when it comes to component composition, frameworks and extensions should expose their components as beans that are easily consumable by user applications.  For example, Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the connection pool exposes `DataSource` beans etc.  Extensions must register these bean definitions at build time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI がコンポーネントの構成に関して中心的なプログラミングモデルであるため、フレームワークやエクステンションはそのコンポーネントを、ユーザアプリケーションが容易に消費できるBeanとして公開しなければなりません。例えば、Hibernate ORM は `EntityManagerFactory` と `EntityManager` の Bean を公開し、コネクションプールは `DataSource` のBeanを公開します。エクステンションは、ビルド時にこれらのBean定義を登録しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans backed by classes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスに裏付けられたBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An extension can produce an &lt;&lt;cdi-reference.adoc#additional_beans,`AdditionalBeanBuildItem`&gt;&gt; to instruct the container to read a bean definition from a class as if it was part of the original application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは link:cdi-reference.html#additional_beans[`AdditionalBeanBuildItem`] コンテナに、元のアプリケーションの一部であるかのようにクラスからBeanの定義を読み込むように指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Class Registered by `AdditionalBeanBuildItem`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>登録されている Bean クラス `AdditionalBeanBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a bean registered by an `AdditionalBeanBuildItem` does not specify a scope then `@Dependent` is assumed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AdditionalBeanBuildItem` で登録された Bean がスコープを指定しない場合は `@Dependent` とする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All other beans can inject such a bean:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のすべての Bean は、このような Bean を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AdditionalBeanBuildItem` によって構築された Bean をインジェクトするBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And vice versa - the extension bean can inject application beans and beans provided by other extensions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、その逆に、 エクステンション Bean は、他のエクステンションによって提供されるアプリケーション Bean やアプリケーション Bean を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Bean Injection Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション Bean インジェクト例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject a bean provided by other extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のエクステンションで提供されているBeanをインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject all beans matching the type `List&lt;String&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイプ `List&lt;String&gt;` に一致するすべてのBeanを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some components may require additional initialization based on information collected during augmentation.  The most straightforward solution is to obtain a bean instance and call a method directly from a build step.  However, it is _illegal_ to obtain a bean instance during the augmentation phase.  The reason is that the CDI container is not started yet.  It's started during the &lt;&lt;bootstrap-three-phases,Static init bootstrap phase&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンポーネントによっては、拡張中に収集された情報に基づいて、追加の初期化が必要になる場合があります。最も簡単な解決策は、Bean のインスタンスを取得し、ビルドステップから直接メソッドを呼び出すことです。しかし、拡張フェーズ中にBeanインスタンスを取得することは _違反_ です。理由は、CDIコンテナがまだ起動していないからです。CDIコンテナは link:#bootstrap-three-phases[Static initブートストラップフェーズ] の間に起動されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in any bean. `RUN_TIME` config roots should only be injected after the bootstrap though.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BUILD_AND_RUN_TIME_FIXED` と `RUN_TIME` 設定ルートは、どのBeanにも注入することができます。 `RUN_TIME` 設定ルールは、ブートストラップの後にのみ注入すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to invoke a bean method from a &lt;&lt;bytecode-recording,recorder method&gt;&gt; though.  If you need to access a bean in a `@Record(STATIC_INIT)` build step then is must either depend on the `BeanContainerBuildItem` or wrap the logic in a `BeanContainerListenerBuildItem`.  The reason is simple - we need to make sure the CDI container is fully initialized and started.  However, it is safe to expect that the CDI container is fully initialized and running in a `@Record(RUNTIME_INIT)` build step.  You can obtain a reference to the container via `CDI.current()` or Quarkus-specific `Arc.container()`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、 link:#bytecode-recording[recorderメソッド] からBeanメソッドを呼び出すことは可能です。 `@Record(STATIC_INIT)` ビルドステップで Bean にアクセスする必要がある場合は、 `BeanContainerBuildItem` に依存するか、 `BeanContainerListenerBuildItem` でロジックをラップしなければなりません。理由は簡単で、CDIコンテナが完全に初期化されて起動していることを確認する必要があるからです。しかし、CDI コンテナは `@Record(RUNTIME_INIT)` ビルドステップで完全に初期化されて実行されていると思っておいた方が安全です。コンテナへの参照は、 `CDI.current()` またはQuarkus固有の `Arc.container()` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to make sure the bean state guarantees the visibility, e.g. via the `volatile` keyword.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanの状態が可視性を保証していることを担保することを忘れないでください。たとえば、`volatile` キーワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one significant drawback of this "late initialization" approach.  An _uninitialized_ bean may be accessed by other extensions or application components that are instantiated during bootstrap.  We'll cover a more robust solution in the &lt;&lt;synthetic_beans&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この「遅延初期化」アプローチには、1つの重大な欠点があります。 _初期化されていない_ Beanは、ブートストラップ中にインスタンス化された他のエクステンションやアプリケーションコンポーネントからアクセスされる可能性があります。 link:#synthetic_beans[synthetic_beans]] で、よりロバストな解決策を取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very useful pattern of creating such beans but also giving application code the ability to easily override some of the beans with custom implementations, is to use the `@DefaultBean` that Quarkus provides.  This is best explained with an example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このような Bean を作成しつつ、アプリケーションコードにカスタム実装で Bean の一部を簡単にオーバーライドする機能を与えるという非常に便利なパターンは、Quarkusが提供している `@DefaultBean` を使用することです。これは例を挙げて説明するのが一番です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let us assume that the Quarkus extension needs to provide a `Tracer` bean which application code is meant to inject into its own beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、Quarkusエクステンションが `Tracer` Bean を提供する必要があると仮定して、アプリケーションコードがそれ自身の Bean に注入することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Dependent
public class TracerConfiguration {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Dependent
public class TracerConfiguration {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    public Tracer tracer(Reporter reporter, Configuration configuration) {
        return new Tracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    public Tracer tracer(Reporter reporter, Configuration configuration) {
        return new Tracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @DefaultBean
    public Configuration configuration() {
        // create a Configuration
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    @DefaultBean
    public Configuration configuration() {
        // create a Configuration
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @DefaultBean
    public Reporter reporter(){
        // create a Reporter
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    @DefaultBean
    public Reporter reporter(){
        // create a Reporter
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for example application code wants to use `Tracer`, but also needs to use a custom `Reporter` bean, such a requirement could easily be done using something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、アプリケーションコードが `Tracer` を使用したいが、カスタムの `Reporter` Bean を使用する必要がある場合、そのような要件は、次のようなものを使用して簡単に行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Dependent
public class CustomTracerConfiguration {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Dependent
public class CustomTracerConfiguration {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    public Reporter reporter(){
        // create a custom Reporter
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    public Reporter reporter(){
        // create a custom Reporter
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although `@DefaultBean` is the recommended approach, it is also possible for application code to override beans provided by an extension by marking beans as a CDI `@Alternative` and including `@Priority` annotation.  Let's show a simple example.  Suppose we work on an imaginary "quarkus-parser" extension and we have a default bean implementation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@DefaultBean` が推奨されていますが、CDI `@Alternative` としてBeanをマークし、 `@Priority` アノテーションを含めることで、アプリケーションコードがエクステンションによって提供されるBeanをオーバーライドすることも可能です。簡単な例を示しましょう。架空の"quarkus-parser"エクステンションで作業をしていて、デフォルトのBeanの実装を持っているとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And our extension also consumes this parser:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、私たちのエクステンションはこのパーサも消費します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, if a user or even some other extension needs to override the default implementation of the `Parser` the simplest solution is to use CDI `@Alternative` + `@Priority`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、ユーザーや他のエクステンションが `Parser` のデフォルトの実装を上書きする必要がある場合、最も簡単な解決策は CDI `@Alternative` + `@Priority` を使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`MyParser` is an alternative bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`MyParser` は代替 Beanです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables the alternative. The priority could be any number to override the default bean but if there are multiple alternatives the highest priority wins.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替 Beanを有効にします。優先度はデフォルトの Bean を上書きするために任意の数値を指定できますが、複数の代替 Bean がある場合は、最も高い優先度のものが優先されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI alternatives are only considered during injection and type-safe resolution. For example the default implementation would still receive observer notifications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI の代替 Beanは、インジェクションと型安全解決の間のみ考慮されます。例えば、デフォルトの実装では、オブザーバー通知を受け取ることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>合成Bean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes it is very useful to be able to register a synthetic bean.  Bean attributes of a synthetic bean are not derived from a java class, method or field.  Instead, the attributes are specified by an extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>合成 Beanを登録できると非常に便利なことがあります。合成 Beanのビーン属性は，javaクラス，メソッド，フィールドから派生したものではありません。その代わりに、属性はエクステンションによって指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the CDI container does not control the instantiation of a synthetic bean the dependency injection and other services (such as interceptors) are not supported.  In other words, it's up to the extension to provide all required services to a synthetic bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDIコンテナは合成Beanのインスタンス化を制御しないので、依存性注入や他のサービス(インターセプタなど)はサポートされていません。言い換えれば、合成 Bean のインスタンスに必要なすべてのサービスを提供するのはエクステンション次第ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to register a &lt;&lt;cdi-reference.adoc#synthetic_beans,synthetic bean&gt;&gt; in Quarkus.  In this chapter, we will cover a use case that can be used to initialize extension beans in a safe manner (compared to &lt;&lt;bean_init&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusで link:cdi-reference.html#synthetic_beans[合成Bean] を登録する方法はいくつかあります。この章では、（ link:#bean_init[[bean_init]] と比較して）安全な方法でエクステンションBeanを初期化できるユースケースを取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `SyntheticBeanBuildItem` can be used to register a synthetic bean:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SyntheticBeanBuildItem` で合成 Bean を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>whose instance can be easily produced through a &lt;&lt;bytecode-recording,recorder&gt;&gt;,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのインスタンスは、 link:#bytecode-recording[レコーダー] を介して簡単に生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>to provide a "context" bean that holds all the information collected during augmentation so that the real components do not need any "late initialization" because they can inject the context bean directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実際のコンポーネントはコンテキスト Beanを直接注入することができるので"遅延初期化"を必要としないように、拡張中に収集されたすべての情報を保持する"コンテキスト" Beanを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instance Produced Through Recorder</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レコーダーを通して生成されたインスタンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The string value is recorded in the bytecode and used to initialize the instance of `Foo`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>文字列の値はバイトコードに記録され、 `Foo` のインスタンス初期化に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"Context" Holder</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"コンテキスト"ホルダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The "real" components can inject the `TestContext` directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>「本物の」コンポーネントは、 `TestContext` を直接注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some types of extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There exist multiple stereotypes of extension, let's list a few.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの定型的なタイプは複数存在しますが、いくつか挙げてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bare library running</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベアライブラリの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the less sophisticated extension.  It consists of a set of patches to make sure a library runs on GraalVM.  If possible, contribute these patches upstream, not in extensions.  Second best is to write Substrate VM substitutions, which are patches applied during native image compilation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはあまり洗練されていないエクステンションです。これは、ライブラリがGraalVM上で動作するようにするためのパッチのセットで構成されています。可能であれば、これらのパッチはエクステンションの中ではなく、アップストリームで貢献してください。二番目に良いのは、ネイティブイメージのコンパイル時に適用されるパッチである Substrate VM 置換を書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get a framework running</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行中のフレームワークを取得する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A framework at runtime typically reads configuration, scan the classpath and classes for metadata (annotations, getters etc), build a metamodel on top of which it runs, find options via the service loader pattern, prepare invocation calls (reflection), proxy interfaces, etc. + These operations should be done at build time and the metamodel be passed to the recorder DSL that will generate classes that will be executed at runtime and boot the framework.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時のフレームワークは通常、設定を読み込み、クラスパスとクラスをスキャンしてメタデータ(アノテーションやゲッターなど)を探し、その上にメタモデルを構築し、サービスローダパターンを介してオプションを見つけ、実行呼び出し(リフレクション)やプロキシインターフェイスなどを準備します。これらの操作はビルド時に行われ、メタモデルは実行時に実行されるクラスを生成するレコーダDSLに渡され、フレームワークを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI portable extension model is very flexible.  Too flexible to benefit from the build time boot promoted by Quarkus.  Most extension we have seen do not make use of these extreme flexibility capabilities.  The way to port a CDI extension to Quarkus is to rewrite it as a Quarkus extension which will define the various beans at build time (deployment time in extension parlance).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDIポータブルエクステンションモデルは非常に柔軟性が高いです。Quarkusが推進するビルドタイムブートの恩恵を受けるには、あまりにも柔軟性が高すぎます。私たちが見てきたほとんどのエクステンションは、このような極端な柔軟性の機能を利用していません。CDIエクステンションをQuarkusに移植する方法は、ビルド時（エクステンションの言い方ではデプロイ時）に様々なBeanを定義するQuarkusエクステンションとして書き換えることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Technical aspect</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>技術的な側面</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are three distinct bootstrap phases of a Quarkus app:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリには、3つの異なるブートストラップフェーズがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Augmentation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Static Init</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタティック初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runtime Init</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイム初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above `maven-compiler-plugin` configuration requires version 3.5+.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の `maven-compiler-plugin` の設定には、バージョン 3.5+ が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `create-extension` mojo of `io.quarkus:quarkus-maven-plugin` can be used to generate stubs of Maven modules needed for implementing a new Quarkus extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus:quarkus-maven-plugin` の `create-extension` mojo は、新しい Quarkus エクステンションの実装に必要な Maven モジュールのスタブを生成するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creates four new Maven modules:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>4つの新しいMavenモジュールを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; a basic `MyExtProcessor` class is generated in this module.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`extensions/my-ext/deployment` ディレクトリに `quarkus-my-ext-deployment` ; 基本的な `MyExtProcessor` クラスはこのモジュールで生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/deployment` directory; an empty JAX-RS Resource class and two test classes (for JVM mode and native mode) are generated in this module.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`integration-tests/my-ext/deployment` ディレクトリに `quarkus-my-ext-integration-test` ; 空の JAX-RS Resource クラスと 2 つのテストクラス (JVM モードとネイティブモード用) がこのモジュールで生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Links these three modules where necessary:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要に応じて、これらの3つのモジュールをリンクします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext` is added to the `&lt;dependencyManagement&gt;` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのBOM（Bill of Materials） `bom/application/pom.xml` の `&lt;dependencyManagement&gt;` に `quarkus-my-ext` が追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-my-ext-deployment` is added to the `&lt;dependencyManagement&gt;` of the Quarkus BOM (Bill of Materials) `bom/application/pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのBOM（Bill of Materials） `bom/application/pom.xml` の `&lt;dependencyManagement&gt;` に `quarkus-my-ext-deployment` が追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enum values (config items) are translated to skewed-case (hyphenated) by default. The table below illustrates an enum name and their canonical equivalence:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>列挙型の値(設定項目)は、デフォルトではスキュード・ケース(ハイフン付き)に変換されます。以下の表は、列挙型名とその正規の同等表現を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java enu</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java enu</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Canonical equivalent</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>正規の同等表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>discard</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>discard</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>read-uncommitted</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>read-uncommitted</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sigusr1</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>sigusr1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JavaEnum</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JavaEnum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>java-enum</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>java-enum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MAKING_LifeDifficult</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MAKING_LifeDifficult</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>making-life-difficult</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>making-life-difficult</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YeOldeJBoss</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>YeOldeJBoss</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ye-olde-jboss</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ye-olde-jboss</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>camelCaseEnum</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>camelCaseEnum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>camel-case-enum</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>camel-case-enum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the default behaviour which is based on implicit converter or a custom defined one add `@DefaultConverter` annotation to the configuration item</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>暗黙のコンバータまたはカスタム定義されたコンバータに基づくデフォルトの動作を使用するには、設定項目に `@DefaultConverter` アノテーションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the default converter (built in or a custom converter) to convert `Level.class` enum.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Level.class` enum を変換するには、デフォルトのコンバータ（内蔵またはカスタムコンバータ）を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primitives</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プリミティブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Health Check</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Health checks are provided via the `quarkus-smallrye-health` extension. It provides both liveness and readiness checks capabilities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヘルスチェックは `quarkus-smallrye-health` のエクステンションを介して提供されます。これは、livenessとreadinessのチェック機能の両方を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing an extension, it's beneficial to provide health checks for the extension, that can be automatically included without the developer needing to write their own.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを書くときには、開発者が自分で書かなくても自動的に含まれるようにすることができるエクステンションのヘルスチェックを提供することが有益です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to provide a health check, you should do the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヘルスチェックを行うためには、以下のようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Import the `quarkus-smallrye-health` extension as an **optional** dependency in your runtime module so it will not impact the size of the application if health check is not included.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-health` ヘルスチェックを *オプションの* 依存関係としてランタイムモジュールにインポートすることで、ヘルスチェックが含まれていない場合でもアプリケーションのサイズに影響を与えないようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension Metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションメトリクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` extension provide support for collecting metrics.  As a compatibility note, the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer library primitives, so the `quarkus-micrometer` extension can be enabled without breaking code that relies on the MP Metrics API.  Note that the metrics emitted by Micrometer are different, see the `quarkus-micrometer` extension documentation for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-micrometer` エクステンションと `quarkus-smallrye-metrics` エクステンションは、メトリクスを収集するためのサポートを提供します。互換性についての注意点として、 `quarkus-micrometer` エクステンションは MP Metrics API を Micrometer ライブラリのプリミティブに適応させているので、MP Metrics API に依存しているコードを壊すことなく `quarkus-micrometer` エクステンションを有効にすることができます。Micrometer が出力するメトリクスは異なることに注意してください。詳細は `quarkus-micrometer` エクステンションのドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The compatibility layer for MP Metrics APIs will move to a different extension in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MP Metrics API の互換性レイヤは、将来的には別のエクステンションに移行する予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When adding metrics for your extension, you may find yourself in one of the following situations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのメトリクスを追加するとき、以下のいずれかの状況に陥ることがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Case 3: It is necessary to collect metrics within the extension code</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ケース3：エクステンションコード内でメトリクスを収集する必要がある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing JSON handling from an extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションからJSON処理をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions often need to register serializers and/or deserializers for types the extension provides.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションはしばしば、エクステンションが提供する型のシリアライザやデシリアライザを登録する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this, both Jackson and JSON-B extensions provide a way to register serializer/deserializer from within an extension deployment module.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このため、Jackson 拡張モジュールと JSON-B 拡張モジュールの両方で、エクステンション内からシリアライザ/デシリアライザを登録する方法を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that not everybody will need JSON, so you need to make it optional.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての人がJSONを必要とするわけではないことを覚えておいてください。そのため、オプションとする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an extension intends to provide JSON related customization, it is strongly advised to provide customization for both Jackson and JSON-B.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションがJSON関連のカスタマイズを提供しようとする場合は、JacksonとJSON-Bの両方のカスタマイズを提供することを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add an *optional* dependency to `quarkus-jackson` on your extension's runtime module.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、エクステンションのランタイムモジュールに `quarkus-jackson` への *オプションの* 依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then create a serializer or a deserializer (or both) for Jackson, an example of which can be seen in the `mongodb-panache` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、Jackson 用のシリアライザまたはデシリアライザ (またはその両方) を作成します。 `mongodb-panache` のエクステンションで例を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Jackson extension will then use the produced build item to register a module within Jackson automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、Jackson エクステンションは、生成されたビルドアイテムを使用して、Jackson 内で自動的にモジュールを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing of Quarkus extensions should be done with the `io.quarkus.test.QuarkusUnitTest` JUnit 5 extension.  This extension allows for Arquillian-style tests that test specific functionalities.  It is not intended for testing user applications, as this should be done via `io.quarkus.test.junit.QuarkusTest`.  The main difference is that `QuarkusTest` simply boots the application once at the start of the run, while `QuarkusUnitTest` deploys a custom Quarkus application for each test class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus エクステンションのテストは `io.quarkus.test.QuarkusUnitTest` JUnit 5 拡張モジュールを使用してください。このエクステンションを使用すると、特定の機能をテストする Arquillian スタイルのテストを行うことができます。ユーザーアプリケーションのテストは `io.quarkus.test.junit.QuarkusTest` を経由して行う必要があるため、ユーザーアプリケーションのテストを目的としたものではありません。主な違いは、 `QuarkusTest` は実行開始時にアプリケーションを起動するだけで、 `QuarkusUnitTest` は各テストクラスごとにカスタムの Quarkus アプリケーションを展開するという点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `QuarkusUnitTest` extension must be used with a static field. If used with a non-static field, the test application is not started.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusUnitTest` エクステンションは、静的フィールドと一緒に使用する必要があります。静的でないフィールドで使用した場合、テストアプリケーションは開始されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells JUnit that the Quarkus deployment should fail with a specific exception</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus のデプロイが特定の例外で失敗することを JUnit に伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing hot reload</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホットリロードのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to write tests that verify an extension works correctly in development mode and can correctly handle updates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードでエクステンションが正しく動作し、アップデートを正しく処理できるかどうかを検証するテストを書くことも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For most extensions this will just work 'out of the box', however it is still a good idea to have a smoke test to verify that this functionality is working as expected. To test this we use `QuarkusDevModeTest`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ほとんどのエクステンションでは、これは「箱から出してすぐに」動作しますが、この機能が期待通りに動作しているかどうかを確認するためにスモークテストを行うことをお勧めします。このテストには `QuarkusDevModeTest` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method modifies a static resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは静的リソースを変更します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method adds a new static resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは新しい静的リソースを追加します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Includes static resources into the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルに静的なリソースをインクルードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Includes directory's static resources into the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディレクトリの静的リソースをネイティブ実行ファイルにインクルードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that all charsets should be enabled in native image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージですべての文字セットを有効にすることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A convenient way to tell Quarkus that the extension requires SSL and it should be enabled during native image build.  When using this feature, remember to add your extension to the list of extensions that offer SSL support automatically on the https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションがSSLを必要とし、ネイティブイメージのビルド中に有効にする必要があることをQuarkusに伝える便利な方法です。この機能を使用する場合は、 link:https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/native-and-ssl.adoc[ネイティブおよびsslガイド] の、自動的にSSLサポートを提供するエクステンションのリストに、作成したエクステンションを追加することを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only particular aspect of writing Quarkus extensions in Eclipse is that APT (Annotation Processing Tool) is required as part of extension builds, which means you need to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>EclipseでQuarkusエクステンションを書く際の唯一の特別な点は、エクステンションのビルドの一部としてAPT（Annotation Processing Tool）が必要であることです。つまり、以下が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://marketplace.eclipse.org/content/m2e-apt から `m2e-apt` をインストール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define this property in your `pom.xml`: `&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;`, although if you rely on `io.quarkus:quarkus-build-parent` you will get it for free.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml` にこのプロパティを追加します : `&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;` 。`io.quarkus:quarkus-build-parent` に依存している場合、既に追加済です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Troubleshooting / Debugging Tips</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トラブルシューティング / デバッグのヒント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dump the Generated Classes to the File System</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたクラスをファイルシステムにダンプする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the augmentation phase Quarkus extensions generate new and modify existing classes for various purposes.  Sometimes you need to inspect the generated bytecode to debug or understand an issue.  There are three system properties that allow you to dump the classes to the filesystem:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>拡張フェーズでは、Quarkusのエクステンションは、さまざまな目的のために既存のクラスを新規に生成したり変更したりします。デバッグや問題の理解のために、生成されたバイトコードを検査する必要がある場合もあります。クラスをファイルシステムにダンプするための3つのシステムプロパティがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.debug.generated-classes-dir` - to dump the generated classes, such as bean metadata</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.debug.generated-classes-dir` - Beanのメタデータのような、生成されたクラスをダンプします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e.g. Panache entities</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.debug.transformed-classes-dir` - Panache エンティティのような、変換されたクラスをダンプします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Test Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サンプルテストエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特徴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manage Non-CDI Service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非CDIサービスの管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a Non-CDI Service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非CDIサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting a Service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスの開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting/Stopping a Non-CDI Service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非CDIサービスの開始/停止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We consume a ShutdownContextBuildItem to register the service shutdown.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ShutdownContextBuildItemを消費してサービスのシャットダウンを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Startup and Shutdown Events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタートアップとシャットダウンのイベント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Object Substitution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オブジェクトの置換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering an Object Substitution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オブジェクト置換の登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replacing Classes in the Native Image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージにおいてクラスを置換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Graal SDK supports substitutions of classes in the native image. An example of how one could replace the `XmlConfig/XmlData` classes with versions that have no JAXB annotation dependencies is shown in these example classes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Graal SDK は、ネイティブイメージ内のクラスの置換をサポートしています。 `XmlConfig/XmlData` のクラスを、JAXB アノテーションに依存しないバージョンのクラスに置き換える方法の例を以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration reference documentation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定リファレンスドキュメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is an important part of each extension and therefore needs to be properly documented.  Each configuration property should have a proper Javadoc comment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定は各エクステンションの重要な部分なので、適切に文書化する必要があります。それぞれの設定プロパティには、適切な Javadoc コメントが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it is handy to have the documentation available when coding, this configuration documentation must also be available in the extension guides.  The Quarkus build automatically generates the configuration documentation for you based on the Javadoc comments but you need to explicitly include it in your guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コーディング時にドキュメントを利用できるようにしておくと便利ですが、この設定ドキュメントはエクステンションガイドでも利用できるようにしておく必要があります。Quarkusのビルドでは、Javadocのコメントに基づいて設定ドキュメントが自動的に生成されますが、ガイドに明示的に含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we will explain everything you need to know about the configuration reference documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このセクションでは、設定リファレンスドキュメントについて知っておくべきことをすべて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the documentation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each configuration property, you need to write some Javadoc explaining its purpose.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それぞれの設定プロパティに対して、その目的を説明するJavadocを書く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Always make the first sentence meaningful and self-contained as it is included in the summary table.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サマリーテーブルに記載されるので、必ず最初の一文に意味を持たせ、自己完結させましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can either use standard Javadoc comments or Asciidoc directly as a Javadoc comment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>標準のJavadocコメントかAsciidocを直接Javadocコメントとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We assume you are familiar with writing Javadoc comments so let's focus on our Asciidoc support.  While standard Javadoc comments are perfectly fine for simple documentation (recommended even), if you want to include tips, source code extracts, lists... Asciidoc comes in handy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、Javadocのコメントを書くことに慣れていることを前提としているので、Asciidocのサポートに焦点を当ててみましょう。標準的なJavadocのコメントは単純な文書化には完全に適していますが（推奨されています）、もしあなたがTipsやソースコードの抜粋、リストなどを含めたい場合は、Asciidocが便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is a typical configuration property commented with Asciidoc:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、Asciidocでコメントされた典型的な設定プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the simple case: you just have to write Asciidoc and mark the comment with the `@asciidoclet` tag.  This tag has two purposes: it is used as a marker for our generation tool but it is also used by the `javadoc` process for proper Javadoc generation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは簡単なケースです: Asciidoc を書いて、コメントに `@asciidoclet` タグを付ければいいだけです。このタグには2つの目的があります: 生成ツールのマーカーとして使用されますが、 `javadoc` のプロセスで適切な Javadoc 生成のためにも使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's consider a more complicated example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、もう少し複雑な例を考えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few comments on this one:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これについてのコメントをいくつか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every time you will need the indentation to be respected in the Javadoc comment (think list items spread on multiple lines or indented source code), you will need to disable temporarily the automatic Eclipse formatter (this, even if you don't use Eclipse as the formatter is included in our build).  To do so, use the `// @formatter:off`/`// @formatter:on` markers.  Note the fact that they are separate comments and there is a space after the `//` marker. This is required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javadocのコメントでインデントを尊重する必要がある場合（複数行にまたがるリスト項目やインデントされたソースコードを考えてみてください）には、Eclipseの自動フォーマッタを一時的に無効にする必要があります（これはEclipseを使用していない場合でも同様です。私たちのビルドにはフォーマッタが含まれている為です）。これを行うには、 `// @formatter:off` / `// @formatter:on` マーカーを使用してください。これらは別々のコメントであり、 `//` マーカーの後にスペースがあることに注意してください。これは必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, you can use the full power of Asciidoctor (except for the limitation below)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>見ての通り、Asciidoctorのフルパワーが使えます（以下の制限を除く）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot use open blocks (`--`) in your Asciidoctor documentation.  All the other types of blocks (source, admonitions...) are supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Asciidoctor のドキュメントでは、オープンブロック ( `--` ) を使用することはできません。他のすべてのタイプのブロック (ソース、アドミッション...) がサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the doc generator will use the hyphenated field name as the key of a `java.util.Map` configuration item.  To override this default and have a user friendly key (independent of implementation details), you may use the `io.quarkus.runtime.annotations.ConfigDocMapKey` annotation.  See the following example,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、doc ジェネレータは `java.util.Map` 設定項目のキーとしてハイフンで囲まれたフィールド名を使用します。このデフォルトを上書きして（実装の詳細とは無関係に）ユーザーフレンドリーなキーを持つためには、 `io.quarkus.runtime.annotations.ConfigDocMapKey` アノテーションを使用することができます。以下の例を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will generate a configuration map key named `quarkus.some."cache-name"` instead of `quarkus.some."namespace"`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `quarkus.some."namespace"` の代わりに `quarkus.some."cache-name"` という名前の設定マップキーが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing section documentation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セクションのドキュメントを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to generate configuration section of a given `@ConfigGroup`, Quarkus has got you covered with the `@ConfigDocSection` annotation.  See the code example below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ある `@ConfigGroup` の設定セクションを生成したい場合は、 `@ConfigDocSection` アノテーションで対応できます。以下のコード例を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating the documentation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating the documentation is easy:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントの生成は簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running `./mvnw clean install -DskipTests -DskipITs` will do.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw clean install -DskipTests -DskipITs` を実行すればOKです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can either do it globally or in a specific extension directory (e.g. `extensions/mailer`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グローバルに行うことも、特定のエクステンションディレクトリ ( `extensions/mailer` など) で行うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The documentation is generated in the global `target/asciidoc/generated/config/` located at the root of the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントはプロジェクトのルートにあるグローバル `target/asciidoc/generated/config/` で生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including the documentation in the extension guide</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションガイドにドキュメントを含める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that you have generated the configuration reference documentation for your extension, you need to include it in your guide (and review it).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、あなたのエクステンションの設定参照ドキュメントが生成されたので、それをガイドに含める必要があります (そして、それをレビューする必要があります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is simple, include the generated documentation in your guide:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは簡単で、ガイドで生成されたドキュメントを含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in including the generated documentation for the config group, you can use the include statement below</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定グループのために生成されたドキュメントを含めたい場合は、以下のinclude文を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` configuration group will be generated in a file named `quarkus-vertx-http-config-group-form-auth-config.adoc`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `io.quarkus.vertx.http.runtime.FormAuthConfig` 設定グループは `quarkus-vertx-http-config-group-form-auth-config.adoc` という名前のファイルに生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few recommendations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>幾つかの推奨事項:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`opts=optional` is mandatory as we don't want the build to fail if only part of the configuration documentation has been generated</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`opts=optional` は、設定ドキュメントの一部しか生成されていない場合にビルドを失敗させたくないので必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The documentation is generated with a title level of 2 (i.e. `==`).  You usually need to adjust it.  It can be done with `leveloffset=+N`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントはタイトルレベルが2(例: `==` )で生成されます。通常はこれを調整する必要があります。これは `leveloffset=+N` で行うことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, at the end of your documentation, include the extensive documentation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、文書の最後には、エクステンションのドキュメントをインクルードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, generate the documentation and check it out.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後にドキュメントを生成して確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Continuous testing of your extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの継続的なテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to make it easy for extension authors to test their extensions daily against the latest snapshot of Quarkus, Quarkus has introduced the notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README.adoc[README] has all the details on how to set up a GitHub Actions job to take advantage of this capability, while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides an overview of what the process looks like.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの作者が、Quarkusの最新のスナップショットに対して自分のエクステンションを毎日簡単にテストできるようにするために、QuarkusはエコシステムCIという概念を導入しました。Ecosystem CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README.adoc[README] には、この機能を利用するためのGitHub Actionsジョブの設定方法の詳細がすべて記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle support is considered preview.  You can use Gradle to create Quarkus projects as outlined in our guides. If you go beyond there will be cases where the Gradle tasks https://github.com/quarkusio/quarkus/issues/5101[does not behave as expected].  This is just a caution, and we recommend if you like Gradle you try it out and give us feedback.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の Gradle サポートはプレビューとされています。このガイドで Gradle を使用して Quarkus プロジェクトを作成する方法の概要を説明しています。これを超えると、Gradleのタスクが link:https://github.com/quarkusio/quarkus/issues/5101[期待通りに動作しない場合があります] 。これはあくまでも注意事項であり、Gradle が好きな方は試してみてフィードバックをいただくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新規プロジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to scaffold a Gradle project, is currently to use the Quarkus Maven plugin like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleプロジェクトをスキャフォールドにする最も簡単な方法は、現在のところ、このようにQuarkus Mavenプラグインを使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you just launch `mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create` the Maven plugin asks for user inputs. You can disable (and use default values) this interactive mode by passing `-B` to the Maven command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create`  を起動するだけで、Maven プラグインはユーザー入力を要求します。 `-B`  を Maven コマンドに渡すことで、この対話型モードを無効にすることができます (デフォルト値を使用します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus project scaffolding automatically installs the Gradle wrapper (`./gradlew`) in your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトのスキャフォールドは、プロジェクトにGradleラッパー( `./gradlew` )を自動的にインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use a standalone Gradle installation, please use Gradle {gradle-version}.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタンドアロンのGradleを使用したい場合は、Gradle {gradle-version} を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table lists the attributes you can pass to the `create` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の表は、 `create`  コマンドに渡すことができる属性の一覧です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Attribute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`projectGroupId`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`projectGroupId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.sample`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.sample`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The group id of the created project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成されたプロジェクトのグループID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`projectArtifactId`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`projectArtifactId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The artifact id of the created project. Not passing it triggers the interactive mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成されたプロジェクトのアーティファクトID。これを渡さないと、インタラクティブモードがトリガされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`projectVersion`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`projectVersion`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version of the created project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成されたプロジェクトのバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`className`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`className`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Not created if omitted_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_省略された場合は作成されない_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fully qualified name of the generated resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースの完全修飾名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`path`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/hello`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/hello`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The resource path, only relevant if `className` is set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースパス、 `className` が設定されている場合のみ関連します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`extensions`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`extensions`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of extensions to add to the project (comma-separated)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトに追加するエクステンションのリスト (カンマ区切り)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you decide to generate a REST resource (using the `className` attribute), the endpoint is exposed at: `http://localhost:8080/$path`.  If you use the default `path`, the URL is: http://localhost:8080/hello.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST リソースを生成することにした場合 ( `className` 属性を使用)、エンドポイントは次の場所で公開されます: `http://localhost:8080/$path` 。デフォルトの `path` を使用する場合、URL は http://localhost:8080/hello です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is either generated in the current directory or in a directory named after the passed artifactId.  If the current directory is empty, the project is generated in-place.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトは、カレント・ディレクトリーに生成されるか、渡されたartifactIdにちなんだ名前のディレクトリーに生成されます。カレントディレクトリーが空の場合,プロジェクトはその場で生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A pair of Dockerfiles for native and jvm mode are also generated in `src/main/docker`.  Instructions to build the image and run the container are written in those Dockerfiles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードと jvm モード用の Dockerfile も `src/main/docker`  に生成されています。イメージのビルドとコンテナーの実行の指示は、これらの Dockerfile に書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom test configuration profile in JVM mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMモードでのカスタムテスト構成プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus tests in JVM mode are run using the `test` configuration profile. If you are not familiar with Quarkus configuration profiles, everything you need to know is explained in the link:config#configuration-profiles[Configuration Profiles Documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、JVMモードでのQuarkusテストは、 `test`  設定プロファイルを使用して実行されます。Quarkusの設定プロファイルについてよく知らない場合は、必要な情報はすべて link:config#configuration-profiles[設定プロファイルのドキュメント]で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Gradle build configuration shown below.  This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、以下に示す Gradle ビルド設定でテスト用のカスタム設定プロファイルを使用することは可能です。これは例えば、デフォルトのテストデータベースではない特定のデータベースを使ってテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `foo` configuration profile will be used to run the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`foo`  設定プロファイルがテストの実行に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to use a custom test configuration profile in native mode for now. Native tests are always run using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ、ネイティブモードでカスタムテスト設定プロファイルを使用することはできません。ネイティブテストは常に `prod`  プロファイルを使用して実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションへの対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From inside a Quarkus project, you can obtain a list of the available extensions with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトの内部から、利用可能なエクステンションのリストを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enable an extension using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下を使ってエクステンションを有効化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions are passed using a comma-separated list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、カンマ区切りのリストを使用して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension name is the GAV name of the extension: e.g. `io.quarkus:quarkus-agroal`.  But you can pass a partial name and Quarkus will do its best to find the right extension.  For example, `agroal`, `Agroal` or `agro` will expand to `io.quarkus:quarkus-agroal`.  If no extension is found or if more than one extensions match, you will see a red check mark ❌ in the command result.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus:quarkus-agroal` エクステンション名は、エクステンションのGAV名です。しかし、部分的な名前を渡すことができ、Quarkusは適切なエクステンションを見つけるために最善を尽くします。例えば、 `agroal`  、 `Agroal`  、 `agro`  は `io.quarkus:quarkus-agroal`  に展開されます。エクステンションが見つからなかったり、複数のエクステンションが一致した場合は、コマンドの結果に赤いチェックマーク❌が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グロブパターンに一致するエクステンションをすべてインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a built-in development mode.  Run your application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには開発モードが組み込まれています。以下でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then update the application sources, resources and configurations.  The changes are automatically reflected in your running application.  This is great to do development spanning UI and database as you see changes reflected immediately.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、アプリケーションのソース、リソース、および設定を更新することができます。変更は実行中のアプリケーションに自動的に反映されます。変更がすぐに反映されるので、UIやデータベースにまたがった開発をするのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkusDev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkusDev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティーファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CTRL+C`  を叩いてアプリケーションを停止させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the working directory the development environment runs on:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発環境が動作する作業ディレクトリーを変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `quarkusDev` task uses `compileJava` compiler options. These can be overridden by setting the `compilerArgs` property in the task.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quarkusDev`  タスクは `compileJava`  コンパイラ・オプションを使用します。これらは、タスクの `compilerArgs`  プロパティーを設定することで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `quarkusDev` sets the debug host to `localhost` (for security reasons). If you need to change this, for example to enable debugging on all hosts, you can use the `-DdebugHost` option like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quarkusDev` はデバッグホストを `localhost` に設定します (セキュリティー上の理由から)。これを変更する必要がある場合、例えばすべてのホストでデバッグを有効にしたい場合は、 `-DdebugHost` オプションを次のように使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to use development mode remotely, so that you can run Quarkus in a container environment (such as OpenShift)  and have changes made to your local files become immediately visible.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードをリモートで使用することができるので、コンテナー環境(OpenShiftなど)でQuarkusを実行して、ローカルファイルに加えられた変更をすぐに確認できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to develop in the same environment you will actually run your app in, and with access to the same services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、実際にアプリを実行するのと同じ環境で、同じサービスにアクセスしながら開発することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production applications in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must have the `quarkus-undertow-websockets` extension installed:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行するためには、 `quarkus-undertow-websockets` エクステンションがインストールされている必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must also have the following config properties set:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下の設定プロパティーを設定しておく必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.live-reload.password`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.live-reload.password`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.live-reload.url`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.live-reload.url`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be set via `application.properties`, or any other way (e.g. system properties, environment vars etc). The password must be set on both the local and remote processes, while the url only needs to be set on the local host.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは `application.properties`  やその他の方法で設定できます (例: システムのプロパティー、環境変数など)。パスワードはローカルプロセスとリモートプロセスの両方で設定しなければなりませんが、 url はローカルホストでのみ設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Quarkus in dev mode on the remote host. Now you need to connect your local agent to the remote host:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモートホストでQuarkusをdevモードで起動します。ここで、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでブラウザを更新するたびに、ローカルで行った変更がリモートアプリにすぐに表示されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In development mode, Quarkus starts by default with debug mode enabled, listening to port `5005` without suspending the JVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードでは、Quarkusはデフォルトでデバッグモードを有効にして起動し、JVMをサスペンドせずにポート `5005`  をリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be changed by giving the `debug` system property one of the following values:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、 `debug` システム・プロパティーに以下の値のいずれかを与えることで変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`false` - the JVM will start with debug mode disabled</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`false`  - JVMはデバッグモードを無効にして起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true` - The JVM is started in debug mode and will be listening on port `5005`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`true`  - JVM はデバッグモードで起動され、 `5005`ポートをリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client` - the JVM will start in client mode and attempt to connect to `localhost:5005`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`client`  - JVM はクライアントモードで起動し、 `localhost:5005`に接続を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{port}` - The JVM is started in debug mode and will be listening on `{port}`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{port}` - JVM はデバッグモードで起動されています。 `{port}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An additional system property `suspend` can be used to suspend the JVM, when launched in debug mode. `suspend` supports the following values:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のシステム・プロパティー `suspend` は、デバッグ・モードで起動されたときに JVM をサスペンドするために使用できます。 `suspend` は以下の値をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`y` or `true` - The debug mode JVM launch is suspended</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`y` または `true` - デバッグモードの JVM 起動が中断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`n` or `false` - The debug mode JVM is started without suspending</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`n` または `false` - デバッグモードの JVM をサスペンドせずに起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run a Quarkus application in debug mode with a suspended JVM using `./gradlew quarkusDev -Dsuspend -Ddebug` which is a shorthand for `./gradlew quarkusDev -Dsuspend=true -Ddebug=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew quarkusDev -Dsuspend -Ddebug`  を使用して、サスペンドされたJVMでQuarkusアプリケーションをデバッグモードで実行することもできます。 `./gradlew quarkusDev -Dsuspend=true -Ddebug=true` の短縮版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, attach your debugger to `localhost:5005`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、デバッガーを `localhost:5005`  にアタッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#project-creation[プロジェクトを生成] したら、お気に入りのIDEでインポートすることができます。唯一の条件は、Gradleプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Eclipse**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Eclipse**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Gradle -&gt; Existing Gradle Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Gradle → Existing Gradle Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish`  をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./gradlew quarkusDev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末で `./gradlew quarkusDev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**IntelliJ**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**IntelliJ**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From inside IntelliJ select `File -&gt; New -&gt; Project From Existing Sources...` or, if you are on the welcome dialog, select `Import project`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJの内部から `File → New → Project From Existing Sources…​`  を選択するか、ウェルカム・ダイアログであれば `Import project`  を選択してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select the project root</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのルートを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Gradle`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Import project from external model`  を選択して `Gradle`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the last screen click on Finish</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後の画面でFinishをクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末または埋め込み端末で、 `./gradlew quarkusDev`  を実行してください。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `File -&gt; Open Project`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`File → Open Project` を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on `Open Project`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Open Project` をクリックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./gradlew quarkusDev`  を実行します。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VS Codeでプロジェクトディレクトリーを開きます。Java Extension Pack(Javaエクステンションのセットをグループ化したもの)をインストールしている場合、プロジェクトはGradleプロジェクトとして読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルの構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executables make Quarkus applications ideal for containers and serverless workloads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルにより、Quarkusアプリケーションはコンテナーやサーバーレスのワークロードに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(必ずGraalVMのJava 11バージョンを使用してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./gradlew build -Dquarkus.package.type=native`.  A native executable will be present in `build/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew build -Dquarkus.package.type=native` を実行し、ネイティブ実行ファイルを作成します。ネイティブ実行ファイルは `build/` に存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `buildNative` task has been deprecated in favor of `build -Dquarkus.package.type=native`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`buildNative` タスクは非推奨となり、 `build -Dquarkus.package.type=native` に代わりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native related properties can either be added in `application.properties` file, as command line arguments or in the `quarkusBuild` task.  Configuring the `quarkusBuild` task can be done as following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ関連のプロパティーは、 `application.properties`  ファイルにコマンドライン引数として追加するか、 `quarkusBuild`  タスクに追加することができます。 `quarkusBuild`  タスクの設定は以下のように行います:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or if you are using the Gradle Kotlin DSL:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、Gradle Kotlin DSLを使用している場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.containerBuild` property to `true`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.containerBuild`  プロパティーを `true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.buildImage` property to `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.buildImage`  プロパティーを `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the Gradle Groovy DSL, property keys must follow lower camel case notation.  e.g. `container-build` is not valid, and should be replaced by `containerBuild`.  This limitation does not apply to the Gradle Kotlin DSL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle Groovy DSL を使用する場合、プロパティーキーは小文字のキャメルケース表記に従わなければなりません。例: `container-build` は無効なので、 `containerBuild` で置き換えてください。この制限は Gradle Kotlin DSL には適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build a container friendly executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーフレンドリーな実行ファイルをビルドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable will be specific to your operating system.  To create an executable that will run in a container, use the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルは、お使いのオペレーティングシステムに固有のものになります。コンテナー内で実行される実行ファイルを作成するには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a Docker container.  Note that in this case the build itself runs in a Docker container too, so you don't need to have GraalVM installed locally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成される実行ファイルは64bitのLinux実行ファイルになるので、OSによっては実行できなくなる可能性があります。しかし、Dockerコンテナーにコピーするので問題ありません。この場合、ビルド自体もDockerコンテナー内で動作するので、ローカルにGraalVMをインストールする必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the native executable will be generated using the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` Docker image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`  Dockerイメージを使用してネイティブ実行ファイルが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to build a native executable with a different Docker image (for instance to use a different GraalVM version), use the `-Dquarkus.native.builder-image=&lt;image name&gt;` build argument.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるDockerイメージでネイティブ実行ファイルをビルドしたい場合(例えば、異なるGraalVMのバージョンを使用するなど)、 `-Dquarkus.native.builder-image=&lt;image name&gt;` のbuild引数を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of the available Docker images can be found on https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io].  Be aware that a given Quarkus version might not be compatible with all the images available.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なDockerイメージのリストは、 link:https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io]にあります。特定のQuarkusのバージョンは、利用可能なすべてのイメージと互換性がない場合があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running native tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブテストの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the native tests using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のようにネイティブテストを実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This task depends on `quarkusBuild`, so it will generate the native image before running the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このタスクは `quarkusBuild`  に依存しているので、テストを実行する前にネイティブイメージを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `--ignored-entry` argument:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>UberJar を作成する際に、 `--ignored-entry`  引数を使用して生成された jar から除外したいエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entries are relative to the root of the generated Uber-Jar. You can specify multiple entries by adding extra `--ignored-entry` arguments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エントリーは、生成された Uber-Jar のルートからの相対的なものです。追加の `--ignored-entry`  引数を追加することで、複数のエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module projects</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトでの作業</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus will not discover CDI beans inside another module.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusは別のモジュール内のCDI Bean を検出しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include a `META-INF/beans.xml` file, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトのモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されていない限り、`META-INF/beans.xml`  ファイルをインクルードすることです。モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されている場合は、自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, there is some unofficial link:https://plugins.gradle.org/search?term=jandex[Gradle Jandex plugins] that can be used instead of the `META-INF/beans.xml` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、 `META-INF/beans.xml` ファイルの代わりに使える非公式の link:https://plugins.gradle.org/search?term=jandex[Gradle Jandex プラグイン] もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on this topic can be found on the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このトピックの詳細については、CDIガイドの link:cdi-reference#bean_discovery[Bean Discovery]セクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with `./gradlew build`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew build` によるビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting from 1.1.0.Final, `./gradlew build` will no longer build the native image. Add `-Dquarkus.package.type=native` build argument explicitly as explained above if needed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.1.1.0.Final から、 `./gradlew build`  はネイティブイメージをビルドしなくなりました。必要であれば、上記で説明したように `-Dquarkus.package.type=native`  のビルド引数を明示的に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは以下をカバーしています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence offers a fluent query builder API on top of JPA with a deep Hibernate ORM integration that enables the use of advanced SQL features like Common Table Expressions while staying in the realm of the JPA model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistenceは、Hibernate ORMとの深い統合により、JPAの上に流れるようなクエリビルダAPIを提供し、JPAモデルの範囲内でありながら、共通テーブル式のような高度なSQL機能の使用を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On top of that, the Blaze-Persistence Entity-View module allows for DTO definitions that can be applied to business logic queries which are then transformed to optimized queries that only fetch the data that is needed to construct the DTO instances.  The same DTO definitions can further be used for applying database updates, leading to a great reduction in boilerplate code and removing the need for object mapping tools.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、Blaze-Persistence Entity-Viewモジュールは、ビジネスロジッククエリに適用出来るDTO定義を可能にし、そのクエリはDTOインスタンスを構築するために必要なデータのみを取得する最適化されたクエリに変換されます。同じDTO定義をデータベースの更新にも使用することができます。これにより、ボイラプレートコードが大幅に削減され、オブジェクトマッピングツールの必要性がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Inject` `CriteriaBuilderFactory` or `EntityViewManager` and use it</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` または `EntityViewManager` を `@Inject` し、使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following dependencies to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の依存関係をプロジェクトに追加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Blaze-Persistence extension: `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistence エクステンション: `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jackson` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson] の為に `blaze-persistence-integration-jackson`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jaxrs` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]の為に `blaze-persistence-integration-jaxrs`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use in native images requires a dependency on the entity view annotation processor that may be extracted into a separate `native` profile:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージでの使用には、別の `native` プロファイルに抽出される可能性のあるエンティティービューアーノテーションプロセッサーへの依存関係が必要です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then access these beans via injection:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、注入によってこれらのBeanにアクセスすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CriteriaBuilderFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityViewManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityViewManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark your CDI bean method as `@Transactional` so that a transaction is started or joined.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションが開始またはトランザクションに参加されるように、CDI Beanメソッドを `@Transactional` としてマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンティティーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity-View</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンティティービューの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example updatable Entity-View</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>更新可能なEntity-Viewの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are various optional properties useful to refine your `EntityViewManager` and `CriteriaBuilderFactory` or guide guesses of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityViewManager` と `CriteriaBuilderFactory` を洗練させたり、またはQuarkusの推測をガイドするのに便利な様々なオプションのプロパティーがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no required properties, as long as the Hibernate ORM extension is configured properly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMエクステンションが適切に設定されている限り、必須のプロパティーはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When no property is set, the Blaze-Persistence defaults apply.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーが設定されていない場合は、Blaze-Persistenceのデフォルトが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration properties listed here allow you to override such defaults, and customize and tune various aspects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここに記載されている設定プロパティーでは、このようなデフォルトを上書きしたり、様々な面をカスタマイズしたり調整したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limitations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約事項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Derby</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Derby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence currently does not come with support for Apache Derby.  This limitation could be lifted in the future, if there's a compelling need for it and if someone contributes it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistenceは現在、Apache Derbyをサポートしていません。切実なニーズが存在し、誰かがコントリビュートしてくれれば、この制限は、将来的には解除されるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with link:hibernate-orm[Hibernate ORM] or link:hibernate-orm-panache[Hibernate ORM with Panache].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用し、 link:hibernate-orm[Hibernate ORM]または link:hibernate-orm-panache[Hibernate ORM with Panache]を使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/public`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/public` endpoint can be accessed anonymously.  The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) where only users granted with the `admin` role can access. At this endpoint, we use the `@RolesAllowed` annotation to declaratively enforce the access constraint.  The `/api/users/me` endpoint is also protected with RBAC (Role-Based Access Control) where only users granted with the `user` role can access. As a response, it returns a JSON document with details about the user.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public` エンドポイントは匿名でアクセスできます。 `/api/admin` エンドポイントは RBAC (Role-Based Access Control) で保護されており、 `admin` の役割を与えられたユーザーのみがアクセスできます。このエンドポイントでは、 `@RolesAllowed` アノテーションを使用して、アクセス制約を宣言的に強制します。 `/api/users/me` エンドポイントも RBAC (Role-Based Access Control) で保護されており、 `user` ロールで付与されたユーザーのみがアクセスできます。レスポンスとして、ユーザーに関する詳細を含むJSONドキュメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to add the database connector library of choice. Here we are using PostgreSQL as identity store.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>選択したデータベースコネクタライブラリを追加することを忘れないでください。ここでは、PostgreSQLをIDストアとして使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `security-jpa` extension which allows you to map your security source to JPA entities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、セキュリティー ソースを JPA エンティティーにマップできる `security-jpa` エクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `security-jpa` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `security-jpa` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/public` endpoint. As you can see from the source code below, it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public` エンドポイントの実装から始めましょう。以下のソースコードから分かるように、通常のJAX-RSリソースです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's consider the `/api/users/me` endpoint. As you can see from the source code below, we are trusting only users with the `user` role.  We are using `SecurityContext` to get access to the current authenticated Principal and we return the user's name. This information is loaded from the database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、 `/api/users/me` エンドポイントを考えてみましょう。下のソースコードを見ればわかるように、 `user` の役割を持つユーザのみを信頼しています。現在認証されているプリンシパルへのアクセスを得るために `SecurityContext` を使用しており、ユーザーの名前を返します。この情報はデータベースから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining our user entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーエンティティーの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now describe how our security information is stored in our model by adding a few annotations to our `User` entity:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、 `User` エンティティーにいくつかのアノテーションを追加することで、セキュリティー情報がモデルにどのように保存されているかを説明することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension is only initialized if there is a single entity annotated with `@UserDefinition`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`security-jpa` エクステンションは、 `@UserDefinition` でアノテーションされた単一のエンティティーがある場合にのみ初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation must be present on a single entity. It can be a regular Hibernate ORM entity or a Hibernate ORM with Panache entity as in this example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、単一のエンティティーに存在しなければなりません。この例のように、通常のHibernate ORMエンティティーまたはHibernate ORM with Panacheエンティティーにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the user name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ユーザー名に使用されるフィールドを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the password. This defaults to using bcrypt hashed passwords, but you can also configure it for clear text passwords.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パスワードに使用するフィールドを示します。これはデフォルトでは bcrypt ハッシュ化されたパスワードを使用するように設定されていますが、クリアテキストパスワード用に設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the comma-separated list of roles added to the target Principal representation attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、対象のプリンシパル表現属性に追加されたロールのコンマ区切りリストを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to add users while hashing the password with the proper bcrypt hash.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法では、パスワードを適切なbcryptハッシュでハッシュしながらユーザーを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension requires at least one datasource to access to your database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`security-jpa` エクステンションは、データベースにアクセスするために少なくとも一つのデータソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our context, we are using PostgreSQL as identity store. The database schema is created by Hibernate ORM automatically on startup (change this in production) and we initialize the database with users and roles in the `Startup` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのコンテキストでは、IDストアとしてPostgreSQLを使用しています。データベーススキーマはHibernate ORMによって起動時に自動的に作成され(本番ではこれを変更します)、 `Startup` クラスのユーザーとロールでデータベースを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is probably useless but we kindly remind you that you must not store clear-text passwords in production environments ;-).  As a result, the `security-jpa` defaults to using bcrypt-hashed passwords.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おそらく役に立たないと思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください。)その結果、 `security-jpa` はデフォルトで bcrypt でハッシュ化されたパスワードを使用するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following tests we use the basic authentication mechanism, you can enable it by setting `quarkus.http.auth.basic=true` in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のテストでは、基本的な認証メカニズムを使用していますが、 `application.properties` ファイルに `quarkus.http.auth.basic=true` を設定することで有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is now protected and the identities are provided by our database.  The very first thing to check is to ensure the anonymous access works.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが保護され、アイデンティティがデータベースから提供されるようになりました。非常に最初に確認しなければならないことは、匿名アクセスが機能することを確認することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's try a to hit a protected resource anonymously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、匿名で保護されたリソースを攻撃してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far so good, now let's try with an allowed user.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここまでは順調ですが、今度は許可されたユーザーで試してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By providing the `admin:admin` credentials, the extension authenticated the user and loaded their roles.  The `admin` user is authorized to access to the protected resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`admin:admin` 資格情報を提供することで、エクステンションはユーザーを認証し、そのロールをロードしました。 `admin` ユーザーは、保護されたリソースへのアクセスを許可されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user `admin` should be forbidden to access a resource protected with `@RolesAllowed("user")` because it doesn't have this role.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `admin` は、この役割を持っていないので、 `@RolesAllowed("user")` で保護されたリソースへのアクセスを禁止する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, using the user `user` works and the security context contains the principal details (username for instance).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ユーザー `user` を使用すると動作し、セキュリティーコンテキストには主要な詳細(例えばユーザー名)が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported model types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているモデルの種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@UserDefinition` class must be a JPA entity (with Panache or not).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@UserDefinition` クラスは JPA エンティティーである必要があります(Panache を使用しているかどうかは問いません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Username` and `@Password` field types must be of type `String`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Username` と `@Password` フィールドの型は `String` でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Roles` field must either be of type `String` or `Collection&lt;String&gt;` or alternately a `Collection&lt;X&gt;` where `X` is an entity class with one `String` field annotated with the `@RolesValue` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Roles` フィールドは `String` か `Collection&amp;amp;lt;String&amp;amp;gt;` のいずれかのタイプであるか、または `Collection&amp;amp;lt;X&amp;amp;gt;` である必要があります。 `X` はエンティティークラスで、 `@RolesValue` アノテーションが付与された `String` フィールドが 1 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each `String` role element type will be parsed as a comma-separated list of roles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各 `String` role 要素の型は、カンマで区切られたロールのリストとして解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Storing roles in another entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のエンティティーにロールを格納する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also store roles in another entity:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、別のエンティティーにロールを格納することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Password storage and hashing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスワードの保存とハッシュ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, we consider passwords to be stored hashed with https://en.wikipedia.org/wiki/Bcrypt[bcrypt] under the https://en.wikipedia.org/wiki/Crypt_(C)[Modular Crypt Format] (MCF).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、パスワードは MCF ( link:https://en.wikipedia.org/wiki/Crypt_©[Modular Crypt Format]) の下で link:https://en.wikipedia.org/wiki/Bcrypt[bcrypt]でハッシュ化されて保存されると考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to create such a hashed password we provide the convenient `String BcryptUtil.bcryptHash(String password)` function, which defaults to creating a random salt and hashing in 10 iterations (though you can specify the iterations and salt too).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなハッシュ化されたパスワードを作成する必要がある場合は、便利な `String BcryptUtil.bcryptHash(String password)` 関数を用意しています。デフォルトでは、ランダムなソルトを作成して 10 回の繰り返しでハッシュ化します (繰り返しとソルトも指定できます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with MCF you don't need dedicated columns to store the hashing algorithm, the iterations count or the salt because they're all stored in the hashed value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MCF を使うと、ハッシュアルゴリズムや反復回数、 ソルトを格納するための専用のカラムは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WARN: you can also store passwords in clear text with `@Password(PasswordType.CLEAR)` but we strongly recommend against it in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>警告: `@Password(PasswordType.CLEAR)` を使ってパスワードをクリアテキストで保存することもできますが、本番では絶対にしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM, Docker or Podman installed if you want to run in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行したい場合は、GraalVM、Docker、Podman がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will implement a service, namely `CostConverter` that consumes HTTP messages with costs in multiple currencies and converts each cost to its value in Euro.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、複数の通貨のコストを持つ HTTP メッセージを消費し、各コストをユーロの値に変換するサービス、すなわち `CostConverter` を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To let a user easily try out the service, we will implement an HTTP resource summing up the costs (`CostCollector`), and a simple web page to add new costs and watch the sum.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーが簡単にサービスを試すことができるように、コストを合計したHTTPリソース( `CostCollector` )と、新しいコストを追加して合計を見るためのシンプルなWebページを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `reactive-messaging-http-quickstart` {quickstarts-tree-url}/reactive-messaging-http-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and HTTP connector extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、Reactive MessagingとHTTPコネクタエクステンションをインポートしてMavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Converter</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/reactivehttp/CostConverter.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/java/org/acme/reactivehttp/CostConverter.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume messages from the `incoming-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`incoming-costs` ストリームからメッセージを消費します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dispatch returned values to the `outgoing-costs` stream.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>返された値を `outgoing-costs` ストリームにディスパッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consume an event with payload of type `Cost` and produce a `double`.  In the case of consuming an arbitrary object, the reactive-messaging-http extension will attempt to deserialize the request body assuming it is JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Cost` 型のペイロードを持つイベントを消費して `double` を生成します。任意のオブジェクトを消費する場合、reactive-messaging-http エクステンションは、リクエストボディが JSON であると仮定して、リクエストボディをデシリアライズしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's define the `Cost` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Cost` クラスを定義してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the next step, we will create configurations for both streams in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップでは、 `application.properties` ファイルに両方のストリームの設定を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the HTTP connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP コネクタを設定する必要があります。これは `application.properties` ファイルで行います。キーは以下のように構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CostCollector</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コストコレクター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To illustrate that converting messages and passing them through works, let's add an endpoint that will receive the outgoing costs and sum them up.  This is a usual JAX-RS endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージを変換して受け渡す様子を説明するために、送信コストを受け取って集計するエンドポイントを追加してみましょう。これは通常のJAX-RSエンドポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To conveniently interact with the application, let's create a simple web page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションと便利にやりとりするために、簡単なWebページを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The page will provide a form to add costs, and an info of the current sum of costs.  The page periodically updates the sum by requesting the current sum from `/cost-collector`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このページでは、コストを追加するためのフォームと、現在のコストの合計の情報を提供します。ページは定期的に `/cost-collector` から現在の合計を要求することによって合計を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/resources/META-INF/resources/index.html` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/resources/META-INF/resources/index.html` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8080/index.html` in your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザで `http://localhost:8080/index.html` を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All `quarkus-http` connector options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-http` コネクタの全オプション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except of the `quarkus-http` connector, the `quarkus-reactive-messaging-http` extension also brings in `quarkus-websocket` - a connector for exposing and feeding WebSockets.  At the moment only binary data is supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-http` コネクタ以外に、 `quarkus-reactive-messaging-http` エクステンションには `quarkus-websocket` - WebSocket を公開して供給するためのコネクタ - が組み込まれています。現時点ではバイナリーデータのみサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the sink of the HTTP connector checks if the message is consumed by the remote endpoint, the WebSocket sink does not. It may happen that a failure to receive a message is not reported, e.g. if the remote side closes the WebSocket connection in a crucial moment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP コネクタのシンクは、メッセージがリモートエンドポイントによって消費されるかどうかをチェックしますが、WebSocket シンクはチェックしません。例えば、リモート側が肝心な時に WebSocket 接続を閉じた場合など、メッセージの受信に失敗したことが報告されないことがあるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-websocket` connector is configured with the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-websocket` コネクタは、以下のプロパティーで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension utilizes MicroProfile Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、MicroProfile Reactive Messaging を利用してデータストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you did the Kafka or AMQP quickstart, you have realized that it's the same code.  The only difference is the connector configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>KafkaやAMQPのクイックスタートをした人は、同じコードであることに気づいたはずです。違いはコネクタの設定だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect[Using OpenID Connect to Protect Service Applications] guide for more information about `Bearer Token` authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer Token` 認証メカニズムの詳細については、 link:security-openid-connect[Using OpenID Connect to Protect Service Applications]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  There are two scheduler extensions in Quarkus.  The `quarkus-scheduler` extension brings the API and a lightweight in-memory scheduler implementation.  The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.  You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。Quarkusには2つのスケジューラーエクステンションがあります。 `quarkus-scheduler` エクステンションには、APIと軽量なインメモリースケジューラーの実装が含まれています。 `quarkus-quartz` エクステンションは、 `quarkus-scheduler` エクステンションのAPIを実装し、Quartzライブラリをベースにしたスケジューラーの実装が含まれています。 `quarkus-quartz` が必要になるのは、永続的タスク、クラスターリング、ジョブのプログラマティックスケジューリングなど、より高度なスケジューリングのユースケースのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトに `quarkus-quartz` 依存関係を追加すると、 `quarkus-scheduler` エクステンションからの軽量スケジューラーの実装は自動的に無効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduled Methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.  In fact, such a method must be a non-private non-static method of a CDI bean.  As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドに `@io.quarkus.scheduler.Scheduled` をアノテーションすると、自動的に呼び出されるようにスケジュールされます。実際には、そのようなメソッドはCDI Beanの非プライベート非静的メソッドでなければなりません。CDI Beanのメソッドであることの結果として、スケジュールされたメソッドは、 `@javax.transaction.Transactional` や `@org.eclipse.microprofile.metrics.annotation.Counted` のようなインターセプターバインディングでアノテーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no CDI scope defined on the declaring class then `@Singleton` is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>宣言クラスにCDIスコープが定義されていない場合は、 `@Singleton` が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、アノテーションされたメソッドは `void` を返し、パラメーターを宣言しないか、 `io.quarkus.scheduler.ScheduledExecution` 型のパラメーターを 1 つだけ宣言する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The annotation is repeatable so a single method could be scheduled multiple times.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アノテーションは繰り返し可能なので、1つのメソッドを複数回スケジュールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Triggers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トリガー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.  If both are specified, the cron expression takes precedence.  If none is specified, the build fails with an `IllegalStateException`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トリガーは、 `@Scheduled#cron()` 属性または `@Scheduled#every()` 属性によって定義されます。両方が指定されている場合、cron 式が優先されます。何も指定されていない場合、ビルドは `IllegalStateException` で失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A CRON trigger is defined by a cron-like expression.  For example `"0 15 10 * * ?"` fires at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CRONトリガーは、cronライクな式で定義されています。例えば `"0 15 10 * * ?"` は毎日午前10時15分に起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.  The values can be `cron4j`, `quartz`, `unix` and `spring`.  `quartz` is used by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CRON 式で使用される構文は `quarkus.scheduler.cron-type` プロパティーによって制御されます。 値は `cron4j` , `quartz` , `unix` および `spring` のいづれかです。`quartz` がデフォルトで使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a CRON expression starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CRON式が `{` で始まり `}` で終わる場合、スケジューラーは対応するコンフィグプロパティーを検索し、設定された値を代わりに使用しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Intervals</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターバル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interval trigger defines a period between invocations.  The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`.  However, if an expression starts with a digit then the `PT` prefix is added automatically.  So for example, `15m` can be used instead of `PT15M` and is parsed as "15 minutes".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターバルトリガーは、呼び出しの間の期間を定義します。期間式は ISO-8601 の期間フォーマット `PnDTnHnMn.nS` に基づいており、 `@Scheduled#every()` の値は `java.time.Duration#parse(CharSequence)` で解析されます。ただし、式が数字で始まる場合は、 `PT` の接頭辞が自動的に追加されます。例えば、 `PT15M` の代わりに `15m` を使用することができ、「15 分」と解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interval Trigger Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターバルトリガーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値が `{` で始まり `}` で終わる場合、スケジューラーは対応するコンフィグプロパティーを探して、設定された値を代わりに使用しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interval Config Property Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターバル設定プロパティーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイデンティティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a unique id is generated for each scheduled method.  This id is used in log messages and during debugging.  Sometimes a possibility to specify an explicit id may come in handy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、スケジュールされた各メソッドに対して一意の ID が生成されます。このIDはログメッセージやデバッグ中に使用されます。時には、明示的な id を指定することが便利な場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイデンティティの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delayed Execution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅延実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Scheduled` provides two ways to delay the time a trigger should start firing at.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` では、トリガーが発報を開始時刻を遅らせるための2つの方法を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled#delay()` と `@Scheduled#delayUnit()` は初期遅延を一緒に形成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The trigger fires for the first time two hours after the application start.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション開始から2時間後に初めてトリガーが発射されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final value is always rounded to full second.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最終的な値は常に1秒単位で丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Scheduled#delayed()` is a text alternative to the properties above.  The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`.  However, if an expression starts with a digit, the `PT` prefix is added automatically.  So for example, `15s` can be used instead of `PT15S` and is parsed as "15 seconds".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled#delayed()` は、上記のプロパティーのテキスト形式での代替です。ピリオド式は ISO-8601 duration format `PnDTnHnMn.nS` に基づいており、値は `java.time.Duration#parse(CharSequence)` で解析されます。ただし、式が数字で始まる場合は、 `PT` の接頭辞が自動的に追加されます。そのため、例えば `PT15S` の代わりに `15s` を使用することができ、「15 秒」と解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled#delay()` がゼロよりも大きい値に設定されている場合、 `@Scheduled#delayed()` の値は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main advantage over `@Scheduled#delay()` is that the value is configurable.  If the value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled#delay()` と比較した場合の主な利点は、値が設定可能であることです。値が `{` で始まり `}` で終わる場合、スケジューラーは対応するコンフィグプロパティーを見つけようとし、代わりに設定された値を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The config property `myMethod.delay.expr` is used to set the delay.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅延の設定には、configプロパティー `myMethod.delay.expr` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Concurrent Execution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同時実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, a scheduled method can be executed concurrently.  Nevertheless, it is possible to specify the strategy to handle concurrent executions via `@Scheduled#concurrentExecution()`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、スケジュールされたメソッドは同時に実行することができます。それにもかかわらず、 `@Scheduled#concurrentExecution()` を通じて同時実行を処理するための戦略を指定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Concurrent executions are skipped.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同時実行はスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a built-in bean of type `io.quarkus.scheduler.Scheduler` that can be injected and used to pause/resume the scheduler.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、 `io.quarkus.scheduler.Scheduler` 型のビルトインBeanを提供しており、これを注入してスケジューラーを一時停止/再開するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Injection Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラーインジェクションの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pause all triggers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのトリガーを一時停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resume the scheduler.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラーを再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatic Scheduling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プログラムスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to schedule a job programmatically you'll need to add the link:quartz[Quartz extension] and use the Quartz API directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プログラムでジョブをスケジュールする必要がある場合は、 link:quartz[Quartzエクステンション] を追加してQuartz APIを直接使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the scheduler is not started unless a `@Scheduled` business method is found. You may need to force the start of the scheduler for "pure" programmatic scheduling. See also &lt;&lt;quartz.adoc#quartz-configuration-reference,Quartz Configuration Reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `@Scheduled` ビジネスメソッドが見つからない限り、スケジューラーは起動されません。「純粋な」プログラマティックスケジューリングのために、スケジューラーを強制的に起動する必要があるかもしれません。 link:quartz.html#quartz-configuration-reference[Quartz Configuration Reference] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduled Methods and Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたメソッドとテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is often desirable to disable the scheduler when running the tests.  The scheduler can be disabled through the runtime config property `quarkus.scheduler.enabled`.  If set to `false` the scheduler is not started even though the application contains scheduled methods.  You can even disable the scheduler for particular &lt;&lt;getting-started-testing#testing_different_profiles,Test Profiles&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを実行する際には、スケジューラーを無効にすることが望ましいことがよくあります。スケジューラーは、ランタイム設定プロパティー `quarkus.scheduler.enabled` を通じて無効にすることができます。 `false` に設定すると、アプリケーションにスケジュールされたメソッドが含まれていても、 スケジューラーは起動しません。特定の link:getting-started-testing.html#testing_different_profiles[テストプロファイル] に対してスケジューラーを無効にすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jdbc-quickstart` {quickstarts-tree-url}/security-jdbc-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `security-jdbc-quickstart` {quickstarts-tree-url}/security-jdbc-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `elytron-security-jdbc` extension which is an https://docs.wildfly.org/17/WildFly_Elytron_Security.html#jdbc-security-realm[`wildfly-elytron-realm-jdbc`] adapter for Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドはMavenプロジェクトを生成し、 `elytron-security-jdbc` エクステンションをインポートします。 link:https://docs.wildfly.org/17/WildFly_Elytron_Security.html#jdbc-security-realm[`wildfly-elytron-realm-jdbc`] Quarkusアプリケーション用のアダプターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `elytron-security-jdbc` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `elytron-security-jdbc` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `elytron-security-jdbc` extension requires at least one datasource to access to your database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`elytron-security-jdbc` エクステンションは、データベースにアクセスするために少なくとも一つのデータソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our context, we are using PostgreSQL as identity store and we initialize the database with users and roles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのコンテキストでは、PostgreSQLをアイデンティティストアとして使用しており、ユーザーとロールでデータベースを初期化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is probably useless but we kindly remind you that you must not store clear-text passwords in production environment ;-).  The `elytron-security-jdbc` offers a built-in bcrypt password mapper.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おそらく無用と思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください ;-)。 `elytron-security-jdbc` は組み込みの bcrypt パスワードマッパーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now configure the Elytron JDBC Realm.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、Elytron JDBC Realmを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `elytron-security-jdbc` extension requires at least one principal query to authenticate the user and its identity.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`elytron-security-jdbc` エクステンションは、ユーザーとそのアイデンティティを認証するために、少なくとも一つのプリンシパルのクエリを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We define a parameterized SQL statement (with exactly 1 parameter) which should return the user's password plus any additional information you want to load.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーのパスワードと、ロードしたい追加情報を返却するパラメーター化されたSQL文(単一のパラメーター付)を定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We configure the password mapper with the position of the password field in the `SELECT` fields and other information like salt, hash encoding, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SELECT` フィールドのパスワードフィールドの位置や、ソルト、ハッシュエンコードなどの情報を使って、パスワードマッパーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `attribute-mappings` to bind the `SELECT` projection fields (ie. `u.role` here) to the target Principal representation attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`attribute-mappings` を使用して、 `SELECT` の投影フィールド(例:ここでは `u.role` )をターゲットの Principal 表現属性にバインドしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `principal-query` configuration all the `index` properties start at 1 (rather than 0).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`principal-query` の設定では、 `index` のプロパティーはすべて 1 から始まります (0 ではなく)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>高度な設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide only covered an easy use case, the extension offers multiple datasources, multiple principal queries configuration as well as a bcrypt password mapper.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、簡単な使用例のみを取り上げていますが、このエクステンションは複数のデータソース、複数のプリンシパルクエリの設定、および bcrypt パスワードマッパーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-azure-functions-http` extension allows you to write microservices with RESTEasy (JAX-RS), Undertow (servlet), Vert.x Web, or link:funqy-http[Funqy HTTP] and make these microservices deployable to the Azure Functions runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-azure-functions-http` エクステンションを使うと、RESTEasy (JAX-RS)、Undertow (サーブレット)、Vert.x Web、または link:funqy-http[Funqy HTTP] を使ってマイクロサービスを書き、これらのマイクロサービスをAzure Functionsランタイムにデプロイできるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One azure function deployment can represent any number of JAX-RS, servlet, Vert.x Web, or link:funqy-http[Funqy HTTP] endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1 つの Azure Functions デプロイメントでは、JAX-RS、サーブレット、Vert.x Web、または link:funqy-http[Funqy HTTP] エンドポイントを任意の数だけ代表できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://azure.microsoft.com[An Azure Account].  Free accounts work.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://azure.microsoft.com[Azureのアカウント]  。無料アカウントでも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through running a Maven Archetype to generate a sample project that contains three http endpoints written with JAX-RS APIs, Servlet APIs, Vert.x Web, or link:funqy-http[Funqy HTTP] APIs.  After building, you will then be able to deploy to Azure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、JAX-RS API、Servlet API、Vert.x Web、または link:funqy-http[Funqy HTTP] APIで記述された3つのHTTPエンドポイントを含むサンプルプロジェクトを生成するために、Maven Archetype のウォークスルーを行います。ビルド後、Azureにデプロイできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the azure maven project for your Quarkus application using our Maven Archetype.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven Archetypeを使用して、Quarkusアプリケーション用の Azure mavenプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running this command will run maven in interactive mode and it will ask you to fill in some build properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドを実行すると、インタラクティブモードでmavenが実行され、いくつかのビルドプロパティーの入力を求められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`groupId` - The maven groupId of this generated project.  Type in `org.acme`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`groupId` - この生成されたプロジェクトの maven グループ ID。 `org.acme` と入力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`artifactId` - The maven artifactId of this generated project. Type in `quarkus-demo`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`artifactId` - この生成されたプロジェクトの maven artifactId。を入力します。 `quarkus-demo` と入力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`version` - Version of this generated project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`version` - この生成されたプロジェクトのバージョン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appName` - Use the default value.  This is the application name in Azure.  It must be a unique subdomain name under `*.azurewebsites.net`. Otherwise deploying to Azure will fail.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`appName` - 既定値を使用します。これは、Azure でのアプリケーション名です。 `*.azurewebsites.net` 以下の一意のサブドメイン名である必要があります。そうしないと、Azure へのデプロイに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`appRegion` - Defaults to `westus`.  Dependent on your azure region.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`appRegion` - デフォルトは `westus` です。お使いの azure リージョンに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`function` - Use the default which is `quarkus`.  Name of your azure function. Can be anything you want.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`function` - デフォルトの `quarkus` を使用してください。あなたの azure 関数の名前。何でも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`resourceGroup` - Use the default value.  Any value is fine though.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`resourceGroup` - デフォルト値を使用してください。どんな値でも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values above are defined as properties in the generated `pom.xml` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の値は、生成された `pom.xml` ファイルのプロパティーとして定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't login to Azure you won't be able to deploy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azureにログインしないとデプロイできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy to Azure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドと Azure へのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `pom.xml` you generated in the previous step pulls in the `azure-functions-maven-plugin`.  Running maven install generates config files and a staging directory required by the `azure-functions-maven-plugin`.  Here's how to execute it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のステップで生成した `pom.xml` は、 `azure-functions-maven-plugin` .maven install を実行すると、設定ファイルと `azure-functions-maven-plugin` によって必要とされるステージングディレクトリーが生成されます。実行方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you haven't already created your function up at azure, the will build an uber-jar, package it, create the function at Azure, and deploy it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あなたがまだ Azure で Function を作成していない場合は、uber-jar をビルドしてパッケージ化し、Azure で Function を作成してデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If deployment is a success, the azure plugin will tell you the base URL to access your function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイが成功した場合、azure プラグインは Function にアクセスするためのベース URL を教えてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>i.e.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL to access the service would be</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスにアクセスするためのURLは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://{appName}.azurewebsites.net/api/ https://{appName}.azurewebsites.net/api/hello https://{appName}.azurewebsites.net/api/servlet/hello hello https://{appName}.azurewebsites.net/api/ https://{appName}.azurewebsites.net/api/vertx/hello https://{appName}.azurewebsites.net/api/funqyHello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension maven dependencies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのmaven依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The sample project includes the RESTEasy, Undertow, Vert.x Web, link:funqy-http[Funqy HTTP] extensions.  If you are only using one of those APIs (i.e. jax-rs only), respectively remove the maven dependency `quarkus-resteasy`, `quarkus-undertow`, `quarkus-funqy-http`, and/or `quarkus-vertx-web`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サンプルプロジェクトには、RESTEasy、Undertow、Vert.x Web、 link:funqy-http[Funqy HTTP] エクステンションが含まれています。これらのAPIの1つだけを使用している場合(つまりjax-rsのみ)は、`quarkus-resteasy` , `quarkus-undertow` , `quarkus-funqy-http` , , および/または `quarkus-vertx-web` などのそれぞれmavenの依存関係を削除してください </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must include the `quarkus-azure-functions-http` extension as this is a generic bridge between the Azure Functions runtime and the HTTP framework you are writing your microservices in.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-azure-functions-http` エクステンションを含める必要があります。これは、Azure Functions ランタイムとマイクロサービスを書いている HTTP フレームワークの間の一般的なブリッジです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates for Azure Functions deployment descriptors (`host.json`, `function.json`) are within the `azure-config` directory.  Edit them as you need to.  Rerun the build when you are ready.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure Functions デプロイメントディスクリプタのテンプレート ( `host.json` , `function.json` ) は、 `azure-config` ディレクトリー内にあります。必要に応じて編集してください。準備ができたらビルドを再実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*NOTE*: If you change the `function.json` `path` attribute or if you add a `routePrefix`,
your jax-rs endpoints won't route correctly.  See &lt;&lt;config-azure-paths&gt;&gt; for more information.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*注* : `function.json` `path` 属性を変更したり、 `routePrefix` を追加したりすると、jax-rs エンドポイントは正しくルーティングされません。詳細は link:#config-azure-paths[[config-azure-paths] ] を参照してください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Root Paths</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートパスの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default route prefix for an Azure Function is `/api`.  All of your JAX-RS, Servlet, Vert.x Web, and link:funqy-http[Funqy HTTP] endpoints must explicitly take this into account.  In the generated project this is handled by the `quarkus.http.root-path` switch in `application.properties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure Function のデフォルトのルートプレフィックスは `/api` です。すべてのJAX-RS、サーブレット、Vert.x Web、および link:funqy-http[Funqy HTTP] エンドポイントは、これを明示的に考慮しなければなりません。生成されたプロジェクトでは、これは `application.properties` の `quarkus.http.root-path` スイッチで制御できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you modify the `path` or add a `routePrefix` within the `azure-config/function.json` deployment descriptor, your code or configuration must also reflect any prefixes you specify for your path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`path` を変更したり、 `azure-config/function.json` デプロイメントディスクリプタ内に `routePrefix` を追加したりする場合、コードや設定にはパスに指定した接頭辞も反映させる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Code</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a scheduled job</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたジョブの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `get()` method allows retrieving the current value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`get()` メソッドでは、現在の値を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression `cron.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` で設定可能な`cron.expr` で cron のような式でジョブを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the application configuration file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション設定ファイルの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the resource and the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースとテストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `CountResource` class, and update the content to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountResource` クラスを編集して、内容を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CounterBean`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CounterBean` の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send back the current counter value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のカウンターの値の返却</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `CountResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストも更新する必要があります。`CountResourceTest` クラスを一致するように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that the response contains `count`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスに `count` が含まれていることを確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  In another terminal, run `curl localhost:8080/count` to check the counter value.  After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` でアプリケーションを実行してください。別のターミナルで `curl localhost:8080/count` を実行して、カウンターの値を確認します。数秒後に `curl localhost:8080/count` を再実行して、カウンターがインクリメントされていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Property Expressions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティー式の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Software Transactional Memory (STM) has been around in research environments since the late 1990's and has relatively recently started to appear in products and various programming languages. We won't go into all of the details behind STM but the interested reader could look at https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].  However, suffice it to say that STM offers an approach to developing transactional applications in a highly concurrent environment with some of the same characteristics of ACID transactions, which you've probably already used through JTA. Importantly though, the Durability property is relaxed (removed) within STM implementations, or at least made optional. This is not the situation with JTA, where state changes are made durable to a relational database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[the X/Open XA standard].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソフトウェア・トランザクション・メモリー(STM)は、1990 年代後半から研究環境に存在し、比較的最近になって製品や様々なプログラミング言語に登場し始めました。STM の背後にあるすべての詳細については触れませんが,興味のある方は link:https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[この論文] を参照してください.しかし、STM は、JTA を通じて既に使用されている ACID トランザクションと同じ特性を持つ、高度な同時実行環境でトランザクショ ン・アプリケーションを開発するためのアプローチを提供していることは言うまでもありません。しかし、重要なことは、STM の実装では Durability プロパティーが緩和(削除)されているか、少なくともオプションになっていることです。これは、 link:https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[X/Open XA 標準] をサポートするリレーショナル・データベースに対して状態の変更を耐久性のあるものにするという JTA の状況とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, the STM implementation provided by Quarkus is based on the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. This document isn't meant to be a replacement for that project's documentation so you may want to look at that for more detail. However, we will try to focus more on how you can combine some of the key capabilities into Quarkus when developing Kubernetes native applications and microservices.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusが提供するSTMの実装は、 link:https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] の実装に基づいています。このドキュメントは、そのプロジェクトのドキュメントに代わるものではありませんので、詳細についてはそちらを参照してください。しかし、Kubernetesネイティブアプリケーションやマイクロサービスを開発する際に、主要な機能のいくつかをQuarkusにどのように組み合わせることができるかについて、より焦点を当ててみたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why use STM with Quarkus?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜQuarkusでSTMを使うのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you may still be asking yourself "Why STM instead of JTA?" or "What are the benefits to STM that I don't get from JTA?" Let's try to answer those or similar questions, with a particular focus on why we think they're great for Quarkus, microservices and Kubernetes native applications. So in no specific order ...</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今、あなたはまだ「なぜJTAではなくSTMなのか?」や「JTAでは得られないSTMのメリットは何か?」と自問自答しているかもしれません。ここでは、Quarkus、マイクロサービス、Kubernetesネイティブアプリケーションに最適だと思う理由を中心に、これらの質問や似たような質問に答えてみましょう。ということで、順不同で ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the extension include it as a dependency in your application pom:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションを使用するには、アプリケーションの依存関係として以下を pom にインクルードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining transaction boundaries</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの境界の定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once an object is placed within an STM container the application developer can manage the scope of transactions within which it is used. There are some annotations which can be applied to the STM-aware class to have the container automatically create a transaction whenever a specific method is invoked.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一度オブジェクトをSTMコンテナー内に配置すると、アプリケーション開発者はそれが使用されるトランザクションの範囲を管理することができます。特定のメソッドが呼び出されたときにコンテナーが自動的にトランザクションを作成するように、STM-aware クラスに適用できるアノテーションがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Distributed transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分散型トランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing a transaction between multiple services is possible but is currently an advanced use case only and the Narayana documentation should be consulted if this behaviour is required. In particular, STM does not yet support the features described in the link:context-propagation[Context Propagation guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のサービス間でトランザクションを共有することは可能ですが、現在のところ高度なユースケースのみであり、この動作が必要な場合はNarayanaのドキュメントを参照してください。特に、STMは link:context-propagation[コンテキスト伝搬ガイド] で説明されている機能をまだサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops.  This guide explains how to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、以下の方法を説明します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a Quarkus application with a main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メインメソッドでQuarkusアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write command mode applications that run a task and then terminate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タスクを実行して終了するコマンドモードのアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application starts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの開始時に通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application stops</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが停止したときに通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `lifecycle-quickstart` {quickstarts-tree-url}/lifecycle-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `lifecycle-quickstart`  {quickstarts-tree-url}/lifecycle-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下が生成されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Maven structure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenの構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page accessible on `http://localhost:8080`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランディングページは次のURLでアクセス可能です: `http://localhost:8080`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`native`  と `jvm`  の両方のモードに対応した `Dockerfile`  ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.lifecycle.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.lifecycle.GreetingResource`  リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メインメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus will automatically generate a main method, that will bootstrap Quarkus and then just wait for shutdown to be initiated. Let's provide our own main method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusは自動的にメインメソッドを生成し、Quarkusを起動し、シャットダウンが開始されるのを待つだけです。独自のメインメソッドを追加してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation tells Quarkus to use this as the main method, unless it is overridden in the config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、設定でオーバーライドされない限り、これをメインのメソッドとして使用するようQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This launches Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これによりQuarkusが起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This main class will bootstrap Quarkus and run it until it stops. This is no different to the automatically generated main class, but has the advantage that you can just launch it directly from the IDE without needing to run a Maven or Gradle command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメインクラスはQuarkusを起動し、停止するまで実行します。これは自動生成されたメインクラスと変わりませんが、MavenやGradleのコマンドを実行する必要がなく、IDEから直接起動するだけで済むという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not recommenced to do any business logic in this main method, as Quarkus has not been set up yet, and Quarkus may run in a different ClassLoader. If you want to perform logic on startup use an `io.quarkus.runtime.QuarkusApplication` as described below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだQuarkusが設定されておらず、Quarkusは別のClassLoaderで動作する可能性があるため、このメインメソッドでビジネスロジックを行うことは推奨されていません。起動時にロジックを実行したい場合は、以下のように `io.quarkus.runtime.QuarkusApplication`  を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we want to actually perform business logic on startup (or write applications that complete a task and then exit)  we need to supply a `io.quarkus.runtime.QuarkusApplication` class to the run method. After Quarkus has been started the `run` method of the application will be invoked. When this method returns the Quarkus application will exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動時に実際にビジネスロジックを実行したい場合(またはタスクを完了してから終了するアプリケーションを書きたい場合)、runメソッドに `io.quarkus.runtime.QuarkusApplication`  クラスを指定する必要があります。Quarkusが起動すると、アプリケーションの `run`  メソッドが呼び出されます。このメソッドが返されると、Quarkusアプリケーションは終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to perform logic on startup you should call `Quarkus.waitForExit()`, this method will wait until a shutdown is requested (either from an external signal like when you press `Ctrl+C` or because a thread has called `Quarkus.asyncExit()`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動時にロジックを実行したい場合は、 `Quarkus.waitForExit()`  を呼び出す必要があります。このメソッドは、シャットダウンが要求されるまで待機します( `Ctrl+C`  を押したときのような外部シグナルや、スレッドが `Quarkus.asyncExit()`  を呼び出したときのような外部シグナルのいずれか)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of what this looks like is below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その一例が以下のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting the command line arguments</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドライン引数の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to inject the arguments that were passed in on the command line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインで渡された引数を注入することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening for startup and shutdown events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタートアップとシャットダウンのイベントをリッスンする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new class named `AppLifecycleBean` (or pick another name) in the `org.acme.lifecycle` package, and copy the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.lifecycle`  パッケージ内に `AppLifecycleBean`  という名前の新しいクラスを作成し(または別の名前を選び)、以下の内容をコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is starting</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is terminating</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの終了時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The events are also called in _dev mode_ between each redeployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、各再配置の間に _devモード_ でイベントが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The methods can access injected beans. Check the {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] class for details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドは注入されたBeanにアクセスすることができます。詳細は {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] クラスを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the difference from `@Initialized(ApplicationScoped.class)` and `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Initialized(ApplicationScoped.class)`  との違いは? `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JVM mode, there is no real difference, except that `StartupEvent` is always fired *after* `@Initialized(ApplicationScoped.class)` and `ShutdownEvent` is fired *before* `@Destroyed(ApplicationScoped.class)`.  For a native executable build, however, `@Initialized(ApplicationScoped.class)` is fired as *part of the native build process*, whereas `StartupEvent` is fired when the native image is executed.  See link:writing-extensions#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMモードでは、 `StartupEvent`  は常に `@Initialized(ApplicationScoped.class)`  の *後に* 実行され、 `ShutdownEvent`  は `@Destroyed(ApplicationScoped.class)`  の *前に* 実行されることを除けば、実質的な違いはありません。しかし、ネイティブの実行可能なビルドでは、 `@Initialized(ApplicationScoped.class)`  はネイティブの *ビルドプロセスの一部* として実行され、 `StartupEvent`  はネイティブイメージが実行されたときに実行されます。詳細については、 link:writing-extensions#bootstrap-three-phases[Bootstrapの3つのフェーズとQuarkusの哲学]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI applications, an event with qualifier `@Initialized(ApplicationScoped.class)` is fired when the application context is initialized. See https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[the spec, window="_blank"] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI アプリケーションでは、アプリケーションコンテキストが初期化されると、修飾子 `@Initialized(ApplicationScoped.class)`  を持つイベントが発生します。詳細は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[仕様, window=_blank]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@Startup` to initialize a CDI bean at application startup</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  を使用して、アプリケーション起動時に CDI Bean を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean represented by a class, producer method or field annotated with `@Startup` is initialized at application startup:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  でアノテーションされたクラス、プロデューサメソッド、フィールドで表現されたBeanは、アプリケーションの起動時に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   private final String name;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>   private final String name;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>   EagerAppBean(NameGenerator generator) { // &lt;2&gt;
     this.name = generator.createName();
   }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>   EagerAppBean(NameGenerator generator) { // &lt;2&gt;
     this.name = generator.createName();
   }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  でアノテーションされた各Beanに対して、 `StartupEvent`  の合成オブザーバが生成されます。デフォルトの優先度が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanのコンストラクタは、アプリケーションの起動時に呼び出され、結果として得られるコンテキストインスタンスがアプリケーションのコンテキストに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Dependent` beans are destroyed immediately afterwards to follow the behavior of observers declared on `@Dependent` beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Dependent` Beanは、 `@Dependent`  Beanに宣言されたオブザーバーの行動に従うために、その後すぐに破壊されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class is annotated with `@Startup` but with no scope annotation then `@ApplicationScoped` is added automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスが `@Startup`  でアノテーションされていて、スコープのアノテーションがない場合は、 `@ApplicationScoped`  が自動的に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`, the logged message is printed.  When the application is stopped, the second log message is printed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev`  でアプリケーションを実行すると、ログメッセージが表示されます。アプリケーションを停止すると、2 番目のログメッセージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch Modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has 3 different launch modes, `NORMAL` (i.e. production), `DEVELOPMENT` and `TEST`. If you are running `quarkus:dev` then the mode will be `DEVELOPMENT`, if you are running a JUnit test it will be `TEST`, otherwise it will be `NORMAL`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには3種類の起動モードがあります。 `NORMAL`  (つまりプロダクション)、 `DEVELOPMENT`  、 `TEST`  です。 `quarkus:dev`  を実行している場合は `DEVELOPMENT`  、JUnit テストを実行している場合は `TEST`  、それ以外の場合は `NORMAL`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application can get the launch mode by injecting the `io.quarkus.runtime.LaunchMode` enum into a CDI bean, or by invoking the static method `io.quarkus.runtime.LaunchMode.current()`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは、 `io.quarkus.runtime.LaunchMode`  enum を CDI Beanに注入するか、静的メソッド `io.quarkus.runtime.LaunchMode.current()`  を呼び出すことで起動モードを取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Graceful Shutdown</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グレースフルシャットダウン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes support for graceful shutdown, this allows Quarkus to wait for running requests to finish, up till a set timeout. By default this is disabled, however you can configure this by setting the `quarkus.shutdown.timeout` config property. When this is set shutdown will not happen until all running requests have completed, or until this timeout has elapsed. This config property is a duration, and can be set using the standard `java.time.Duration` format, if only a number is specified it is interpreted as seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、Quarkusは、実行中のリクエストが終了するまで、設定されたタイムアウトまで待機することができます。デフォルトでは無効になっていますが、 `quarkus.shutdown.timeout`  configプロパティーを設定することで設定することができます。これが設定されている場合、すべての実行中のリクエストが完了するまで、またはこのタイムアウトが経過するまでシャットダウンは行われません。この設定プロパティーは持続時間であり、標準の `java.time.Duration`  形式で設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions that accept requests need to add support for this on an individual basis. At the moment only the HTTP extension supports this, so shutdown may still happen when messaging requests are active.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストを受け付けるエクステンションは、個別にサポートを追加する必要があります。現時点では HTTP エクステンションだけがこれをサポートしているので、メッセージングリクエストがアクティブなときにシャットダウンが発生する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document explains the Quarkus class loading architecture. It is intended for extension authors and advanced users who want to understand exactly how Quarkus works.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus のクラスロードアーキテクチャについて説明します。このドキュメントは、Quarkus がどのように動作するかを正確に理解したいエクステンションの作者や上級ユーザーを対象としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus class loading architecture is slightly different depending on the mode that the application is run in. When running a production application everything is loaded in the system ClassLoader, so it is a completely flat class path. This also applies to native image mode which does not really support multiple ClassLoaders, and is based on a normal production Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus のクラスロードアーキテクチャは、アプリケーションを実行するモードによって若干異なります。本番環境のアプリケーションを実行しているときは、すべてがシステム ClassLoader でロードされるため、完全にフラットなクラスパスとなります。これは、複数の ClassLoader をサポートしていないネイティブイメージモードにも当てはまり、通常のプロダクション Quarkus アプリケーションをベースにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For all other use cases (e.g. tests, dev mode, and building the application) Quarkus uses the class loading architecture outlined here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のすべてのユースケース(テスト、開発モード、アプリケーションのビルドなど)では、Quarkus はここで説明したクラスロードアーキテクチャを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading Class Bytecode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスバイトコードの読み取り</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to use the correct `ClassLoader`. The recommended approach is to get it by calling the `Thread.currentThread().getContextClassLoader()` method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>正しい `ClassLoader` を使用することが重要です。推奨される方法は、 `Thread.currentThread().getContextClassLoader()` メソッドを呼び出して取得することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus application. The end result of this process is a `CuratedApplication`, which contains all the class loading information for the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての Quarkus アプリケーションは、 `independent-projects/bootstrap` モジュールの QuarkusBootstrap クラスによって作成されます。このクラスは、Quarkus アプリケーションに必要なすべての関連する依存関係(デプロイメントとランタイムの両方)を解決するために使用されます。このプロセスの最終結果は、 `CuratedApplication` であり、これにはアプリケーションのすべてのクラスロード情報が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `CuratedApplication` を使用して `AugmentAction` インスタンスを作成し、本番アプリケーションを作成したり、ランタイムのものを起動/再起動したりすることができます。このアプリケーションインスタンスは、分離された ClassLoader 内に存在しています。収集処理によって解決されるため、クラスパスに Quarkus デプロイメントクラスを配置する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このブートストラッププロセスは、Quarkus がどのように起動されても、異なるパラメーターが渡されているだけで、同じであるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Current Run Modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の実行モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment we have the following use cases for bootstrapping Quarkus:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、Quarkus のブートストラップには以下のようなユースケースがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファクタの目的の一つは、これらの異なる実行モードのすべてが基本的に同じ方法で Quarkus を起動できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A ClassLoader is said to be 'transformer safe' if it is safe to load classes in the class loader before the transformers are ready. Once a class has been loaded it cannot be changed, so if a class is loaded before the transformers have been prepared this will prevent the transformation from working. Loading classes in a transformer safe ClassLoader will not prevent the transformation, as the loaded class is not used at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ClassLoader は、Transformer が準備される前にクラスをロードしても安全であれば、「Transformerセーフ」と言われます。一度ロードされたクラスは変更することができないので、もし Transformer の準備が整う前にロードされた場合、変換が機能しなくなります。Transformer セーフな ClassLoader でクラスをロードした場合は、ロードされたクラスは実行時には使用されないので、変換を妨げることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ClassLoader Implementations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスローダーの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベース ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは通常、通常の JVM System ClassLoader です。Maven のような環境では異なる場合があります。この ClassLoader はブートストラップクラスをロードするために使用され、他の ClassLoader インスタンスは JDK クラスのロードをこれに委譲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Augment ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>拡張 ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader, and it is transformer safe.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、すべての `-deployment` アーティファクトとその依存関係、および他のユーザー依存関係をロードします。アプリケーションのルートやホットデプロイされたコードはロードしません。この ClassLoader は永続的に動作し、アプリケーションが再起動してもそれは残ります (ホットデプロイされている可能性のあるアプリケーションクラスをロードできないのはそのためです)。親はベースの ClassLoader であり、Transformerセーフです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、これはベース ClassLoader に委譲するように設定することができますが、計画ではこのオプションは廃止され、常に分離された ClassLoader として使用することになっています。これを分離型 ClassLoader にすることは、すべてのビルダクラスが分離されていることを意味するので複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイメント ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can load all application classes, its parent is the Augment ClassLoader so it can also load all deployment classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはすべてのアプリケーションクラスをロードすることができ、その親は 拡張 ClassLoader なので、すべてのデプロイメントクラスをロードすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader is the context ClassLoader that is used when running the build steps. It is also transformer safe.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この ClassLoader は永続的ではなく、アプリケーションの起動時に再作成され、分離されています。この ClassLoader は、ビルドステップを実行する際に使用されるコンテキスト ClassLoader です。また、Transformerセーフでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Base Runtime ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベースランタイム ClassLoader</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads all the runtime extension dependencies, as well as other user dependencies (note that this may include duplicate copies of classes also loaded by the Augment ClassLoader). It does not load the application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、他のユーザー依存関係と同様に、すべてのランタイムエクステンション依存関係をロードします(これには 拡張 ClassLoader によってロードされたクラスの重複コピーも含まれる可能性があることに注意してください)。アプリケーションのルートやホットデプロイされたコードはロードされません。この ClassLoader は永続的なもので、アプリケーションが再起動しても残ります (ホットデプロイされている可能性のあるアプリケーションクラスをロードできないのはそのためです)。親はベース ClassLoader です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this transformation is no longer possible). This means that only transformers registered in the first application start will take effect, however as these transformers are expected to be idempotent this should not cause problems. An example of the sort of transformation that might be required here is a Panache entity packaged in an external jar. This class needs to be transformed to have its static methods implemented, however this transformation only happens once, so restarts use the copy of the class that was created on the first start.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはホットリロードできないコードをロードしますが、変換をサポートしています (ただし、クラスがロードされるとこの変換はできなくなります)。これは、最初のアプリケーション起動時に登録された Transformer のみが有効になることを意味しますが、これらの Transformer は冪等であることが期待されているため、これは問題を引き起こすことはないはずです。ここで必要となる可能性のある変換の例として、外部 jar にパッケージ化された Panache エンティティーがあります。このクラスは静的メソッドを実装するために変換する必要がありますが、この変換は一度しか行われないため、再起動時には最初の起動時に作成されたクラスのコピーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications to behave more like a production application (production applications are isolated in that they run in a whole new JVM).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この ClassLoader は、拡張 ClassLoader とデプロイメント ClassLoader から分離されています。つまり、デプロイメント側の静的フィールドに値を設定して、実行時に読み込まれることを期待することはできません。これにより、開発アプリケーションやテストアプリケーションが本番アプリケーションのように振る舞うことができます(本番アプリケーションは全く新しい JVM で実行されるという点で分離されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、実行時のバージョンは別の依存関係のセットに対してリンクされる可能性があることを意味します。例えば、デプロイ時に使用する Hibernate バージョンには ByteBuddy が含まれていても、実行時に使用するバージョンには含まれていない場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runtime Class Loader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムクラス ローダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ClassLoader is used to load the application classes and other hot deployable resources. Its parent is the base runtime ClassLoader, and it is recreated when the application is restarted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この ClassLoader は、アプリケーションクラスやその他のホットデプロイ可能なリソースをロードするために使用されます。親はベースランタイム ClassLoader で、アプリケーションの再起動時に再作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Isolated ClassLoaders</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離型クラスローダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime ClassLoader is always isolated. This means that it will have its own copies of almost every class from the resolved dependency list. The exception to this are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムの ClassLoader は常に分離されています。これは、解決された依存関係リストのほとんどすべてのクラスの独自のコピーを持つことを意味します。これには例外があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classes from artifacts that extensions have marked as parent first (more on this later).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションが親優先とマークしたアーティファクトからのクラス (これについては後述します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parent First Dependencies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>親優先の依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some classes that should not be loaded in an isolated manner, but that should always be loaded by the system ClassLoader (or whatever ClassLoader is responsible for bootstrapping Quarkus). Most extensions do not need to worry about this, however there are a few cases where this is necessary:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された方法でロードされるべきではないクラスがいくつかありますが、それは常にシステムの ClassLoader(または Quarkus のブートストラップを担当している ClassLoader )によってロードされなければなりません。ほとんどのエクステンションはこのことを気にする必要はありませんが、必要な場合もあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some logging related classes, as logging must be loaded by the system ClassLoader</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングはシステム ClassLoader によってロードされなければならないので、いくつかのロギング関連のクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If this is required it can be configured in the `quarkus-bootstrap-maven-plugin`. Note that if you mark a dependency as parent first then all of its dependencies must also be parent first, or a `LinkageError` can occur.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが必要な場合は、 `quarkus-bootstrap-maven-plugin` で設定することができます。 依存関係を親優先とマークした場合は、その依存関係もすべて親優先にしなければならないことに注意してください。そうでないと、 `LinkageError` が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Banned Dependencies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>禁止された依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are some dependencies that we can be sure we do not want. This generally happens when a dependency has had a name change (e.g. smallrye-config changing groups from `org.smallrye` to `org.smallrye.config`, the `javax` -&gt; `jakarta` rename).  This can cause problems, as if these artifacts end up in the dependency tree out of date classes can be loaded that are not compatible with Quarkus. To deal with this extensions can specify artifacts that should never be loaded. This is done by modifying the `quarkus-bootstrap-maven-plugin` config in the pom (which generates the `quarkus-extension.properties` file). Simply add an `excludedArtifacts` section as shown below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係の中には、必要ないと確信できるものもあります。これは一般的に、依存関係の名前が変更された場合に起こります(例:smallrye-configがグループを `org.smallrye` から `org.smallrye.config` に変更した、 `javax` → `jakarta` のリネームなど)。これは問題を引き起こす可能性があります。これらのアーティファクトが依存関係ツリーで終わると、Quarkusと互換性のない古いクラスがロードされる可能性があるからです。この問題に対処するために、エクステンションでは、決してロードしてはいけないアーティファクトを指定することができます。これは、 `quarkus-extension.properties` ファイルを生成する pom の `quarkus-bootstrap-maven-plugin` 設定を変更することで行います。以下のように `excludedArtifacts` セクションを追加するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This should only be done if the extension depends on a newer version of these artifacts. If the extension does not bring in a replacement artifact as a dependency then classes the application needs might end up missing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、エクステンションがこれらのアーティファクトの新しいバージョンに依存している場合にのみ行うべきです。もしエクステンションが代替アーティファクトを依存関係として持ち込まなかった場合、 アプリケーションが必要とするクラスが見つからなくなってしまうかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security provides the architecture, multiple authentication and authorization mechanisms, and other tools for the developers to build a production-quality security for their Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityでは、開発者がQuarkusアプリケーションの商用品質のセキュリティーを構築するためのアーキテクチャ、複数の認証および認可メカニズム、その他のツールを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document provides a brief overview of Quarkus Security and links to the individual guides.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus Securityの簡単な概要と、各ガイドへのリンクについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`HttpAuthenticationMechanism` is the main entry into Quarkus HTTP Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`HttpAuthenticationMechanism`  は、Quarkus HTTP Securityのメインエントリーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security Manager uses `HttpAuthenticationMechanism` to extract the authentication credentials from the HTTP request and delegates to `IdentityProvider` to complete the conversion of these credentials to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Security Managerは、 `HttpAuthenticationMechanism`  を使用してHTTPリクエストから認証資格情報を抽出し、 `IdentityProvider`  に委任して、これらの資格情報の `SecurityIdentity`  への変換を完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the credentials may be coming with the HTTP `Authorization` header, client HTTPS certificates or cookies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、資格情報は、HTTP `Authorization`  ヘッダー、クライアントの HTTPS 証明書、またはクッキーを使用している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` verifies the authentication credentials and maps them to `SecurityIdentity` which contains the username, roles, the original authentication credentials, and other attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`IdentityProvider`  は認証資格情報を検証し、ユーザー名、ロール、元の認証資格情報、およびその他の属性を含む `SecurityIdentity`  にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For every authenticated resource, you can inject a `SecurityIdentity` instance to get the authenticated identity information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証済みリソースごとに、 `SecurityIdentity`  インスタンスを注入して、認証済みの ID 情報を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some other contexts you may have other parallel representations of the same information (or parts of it) such as `SecurityContext` for JAX-RS or `JsonWebToken` for JWT.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他の文脈では、JAX-RSであれば `SecurityContext`  、JWTであれば `JsonWebToken`  のように、同じ情報(またはその一部)を他の別の表現で表現している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports several sources to load authentication information from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、認証情報をロードするためのいくつかのソースをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基本認証とフォーム認証の仕組み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form HTTP-based authentication mechanisms are the core authentication mechanisms supported in Quarkus.  Please see link:security-built-in-authentication#basic-auth[Basic HTTP Authentication] and link:security-built-in-authentication#form-auth[Form HTTP Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Basic HTTPベースの認証メカニズムとForm HTTPベースの認証メカニズムは、Quarkusでサポートされている主要な認証メカニズムです。詳細については、 link:security-built-in-authentication#basic-auth[基本HTTP認証]と link:security-built-in-authentication#form-auth[フォームHTTP認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutual TLS Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>相互TLS認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides Mutual TLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは相互TLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security-built-in-authentication#mutual-tls[Mutual TLS Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳しくは link:security-built-in-authentication#mutual-tls[相互TLS認証] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenId Connect</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenId Connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` extension provides a reactive, interoperable, multi-tenant enabled OpenId Connect adapter which supports `Bearer Token` and `Authorization Code Flow` authentication mechanisms.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-oidc`  エクステンションは、 `Bearer Token`  および `Authorization Code Flow`  認証メカニズムをサポートする、リアクティブで相互運用可能なマルチテナント対応の OpenId Connect アダプターを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bearer Token` mechanism extracts the token from HTTP `Authorization` header.  `Authorization Code Flow` mechanism uses OpenId Connect Authorization Code flow. It redirects the user to IDP to authenticate and completes the authentication process after the user has been redirected back to Quarkus by exchanging the provided code grant for ID, access and refresh tokens.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer Token`  メカニズムは、HTTP `Authorization`  ヘッダーからトークンを抽出します。 `Authorization Code Flow`  メカニズムは、OpenId Connect Authorization Code Flowを使用します。ユーザーをIDPにリダイレクトして認証を行い、提供されたCode GrantをID、アクセストークン、リフレッシュトークンと交換することで、ユーザーがQuarkusにリダイレクトされた後に認証プロセスを完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ID and access `JWT` tokens are verified with the refreshable `JWK` key set but both JWT and opaque (binary) tokens can be introspected remotely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ID とアクセス `JWT` トークンは、リフレッシュ可能な `JWK` キーセットで検証されますが、JWT と不透明な (バイナリーの) トークンの両方をリモートで検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application] guide for more information about `Authorization Code Flow` authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Authorization Code Flow`  認証メカニズムの詳細については、 link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `quarkus-oidc` `Bearer` and `Authorization Code Flow` Authentication mechanisms use &lt;&lt;smallrye-jwt, SmallRye JWT&gt;&gt; to represent JWT tokens as Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-oidc` の`Bearer` と `Authorization Code Flow`  認証メカニズムはいずれも link:#smallrye-jwt[SmallRye JWT ]を使用して、JWT トークンを Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken` として表現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-openid-connect-multitenancy[Using OpenID Connect Multi-Tenancy] for more information about multiple tenants which can support `Bearer` or `Authorization Code Flow` authentication mechanism and configured statically or dynamically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer`  または `Authorization Code Flow`  認証メカニズムをサポートし、静的または動的に設定できる複数のテナントの詳細については、 link:security-openid-connect-multitenancy[OpenID Connect マルチテナントの使用]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would like to have Quarkus OIDC extension enabled at runtime then set `quarkus.oidc.tenant-enabled=false` at build time and re-enable it at runtime using a system property.  See also link:security-openid-connect-multitenancy#disable-tenant[Disabling Tenant Configurations] for more information about managing the individual tenant configurations in the multi-tenant OIDC deployments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時にQuarkus OIDCエクステンションを有効にしたい場合は、ビルド時に `quarkus.oidc.tenant-enabled=false` を設定し、システムプロパティーを使用して実行時に再度有効にします。マルチテナントOIDCデプロイメントでの個々のテナント設定の管理の詳細については、テナント link:security-openid-connect-multitenancy#disable-tenant[設定の無効化]も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to configure Keycloak programmatically then consider using https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API] with the help of the `quarkus-keycloak-admin-client` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Keycloakをプログラムで設定する必要がある場合は、 `quarkus-keycloak-admin-client` エクステンションの助けを借りて、 link:https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API]の使用を検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye JWT</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` provides Microprofile JWT 1.1.1 implementation and many more options to verify signed and encrypted `JWT` tokens and represent them as `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-jwt` はMicroprofile JWT 1.1.1.1 の実装と、署名・暗号化された `JWT` トークンを検証し、 `org.eclipse.microprofile.jwt.JsonWebToken` として表現するための多くのオプションを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It can currently verify only `JWT` tokens using the PEM keys or refreshable `JWK` key set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは `quarkus-oidc` ベアラートークン認証メカニズムに代わるものを提供します。現在、PEM 鍵または更新可能な `JWK` 鍵セットを使用して `JWT` トークンのみを検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally it provides `JWT Generation API` for creating `signed`, `inner-signed` and/or `encrypted` `JWT` tokens with ease.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、 `JWT Generation API` を提供して、 `signed` , `inner-signed` , および/または `encrypted` `JWT`トークンを簡単に作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-jwt[Using SmallRye JWT] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-jwt[Using SmallRye JWT]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OAuth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-elytron-security-oauth2` provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It is based on `Elytron` and is primarily meant for introspecting the opaque tokens remotely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-elytron-security-oauth2`  は `quarkus-oidc`  Bearer Token 認証メカニズムの代替手段を提供します。これは `Elytron` をベースにしており、主に不透明なトークンをリモートでイントロスペクトするためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-oauth2[Using OAuth2] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-oauth2[OAuth2 の使用]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see the link:security-ldap[Authenticate with LDAP] guide for more information about LDAP authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>LDAP認証メカニズムの詳細については、 link:security-ldap[Authenticate with LDAP]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity Providers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイデンティティ・プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`IdentityProvider`  は、 `HttpAuthenticationMechanism`  が提供する認証資格情報を `SecurityIdentity`  に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions such as `OIDC`, `OAuth2`, `SmallRye JWT`, `LDAP` have the inlined `IdentityProvider` implementations which are specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`OIDC` , `OAuth2` , `SmallRye JWT` , `LDAP`  などのエクステンションには、サポートされている認証フローに固有の `IdentityProvider` のインライン実装があります。例えば、 `quarkus-oidc` は独自の `IdentityProvider` を使用してトークンを `SecurityIdentity` に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use `Basic` or `Form` HTTP-based authentication then you have to add an `IdentityProvider` which can convert a user name and password to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Basic` または `Form` HTTP ベースの認証を使用している場合は、ユーザー名とパスワードを `SecurityIdentity` に変換できる `IdentityProvider` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-jpa[JPA IdentityProvider] and link:security-jdbc[JDBC IdentityProvider] for more information.  You can also use link:security-testing#configuring-user-information[User Properties IdentityProvider] for testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、 link:security-jpa[JPA IdentityProvider]および link:security-jdbc[JDBC IdentityProvider]を参照してください。また、テストに link:security-testing#configuring-user-information[User Properties IdentityProvider を]使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証メカニズムの組み合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One can combine multiple authentication mechanisms if they get the authentication credentials from the different sources.  For example, combining built-in `Basic` and `quarkus-oidc` `Bearer` authentication mechanisms is allowed, but combining `quarkus-oidc` `Bearer` and `smallrye-jwt` authentication mechanisms is not allowed because both will attempt to verify the token extracted from the HTTP `Authorization Bearer` scheme.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるソースから認証証明書を取得する場合、複数の認証メカニズムを組み合わせることができます。例えば、組み込みの `Basic`  と `Bearer`   `quarkus-oidc`  認証機構を組み合わせることはできますが、 `quarkus-oidc`   `Bearer`  と `smallrye-jwt`  認証機構を組み合わせることはできません。なぜなら、両方とも HTTP `Authorization Bearer`  スキームから抽出されたトークンを検証しようとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proactive Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロアクティブ認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます(ターゲットページが認証を必要としない場合でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-built-in-authentication#proactive-authentication[Proactive Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-built-in-authentication#proactive-authentication[プロアクティブ認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-authorization[Security Authorization] for more information about Role Based Access Control and other authorization options.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>役割ベースのアクセス制御およびその他の認可オプションの詳細については、 link:security-authorization[セキュリティー認可]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customization and other useful tips</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタマイズやその他の便利なヒント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security is highly customizable. One can register custom ``HttpAuthenticationMechanism``s, ``IdentityProvider``s and ``SecurityidentityAugmentor``s.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityは、高度なカスタマイズが可能です。カスタム `HttpAuthenticationMechanism` 、 `IdentityProvider` 、 `SecurityidentityAugmentor` を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-customization[Security Customization] for more information about customizing Quarkus Security and other useful tips about the reactive security, registering the security providers, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityのカスタマイズの詳細や、リアクティブセキュリティー、セキュリティープロバイダーの登録などの便利なヒントについては、セキュリティーの link:security-customization[カスタマイズ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:http-reference#ssl[Supporting secure connections with SSL] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:http-reference#ssl[SSL による安全な接続のサポート]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross-Origin Resource Sharing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クロスオリジンリソース共有</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to make your Quarkus application accessible to another application running on a different domain, you will need to configure CORS (Cross-Origin Resource Sharing). Please read the link:http-reference#cors-filter[HTTP CORS documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを別のドメインで実行している別のアプリケーションにアクセスできるようにする場合は、CORS(Cross-Origin Resource Sharing)を設定する必要があります。詳細については、 link:http-reference#cors-filter[HTTP CORSのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-testing[Security Testing] for more information about testing Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityのテストの詳細については、 link:security-testing[セキュリティーのテスト]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret Engines</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットエンジン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a very comprehensive HashiCorp Vault support, please see the link:vault[Quarkus and HashiCorp Vault] documentation for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは非常に包括的な HashiCorp Vault のサポートを提供しています。詳しくは link:vault[Quarkus and HashiCorp Vault] のドキュメントを参照下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is developed by a third party and is part of the Quarkus Platform.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションはサードパーティによって開発されたもので、Quarkus Platformの一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kotlinlang.org/[Kotlin] is a very popular programming language that targets the JVM (amongst other environments). Kotlin has experienced a surge in popularity the last few years making it the most popular JVM language, except for Java of course.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://kotlinlang.org/[Kotlin] は、JVMをターゲットにした(他の環境を含めても)非常に人気のあるプログラミング言語です。Kotlinはここ数年で人気が急上昇し、Javaを除いて最も人気のあるJVM言語となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Identity and Access Management (IAM) enables users to manage access to AWS services and resources securely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon Identity and Access Management(IAM)は、ユーザーがAWSのサービスやリソースへのアクセスを安全に管理できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about IAM at https://aws.amazon.com/iam/[the Amazon IAM website].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://aws.amazon.com/iam/[アマゾンのIAMのサイト]を見てみると、IAMについての詳しい情報が掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The IAM extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IAMエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x]をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供する1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hello World Quarkus アプリの作成方法を説明します。 このガイドでは、以下の内容を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping an application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functional tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>機能テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging of the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の JDK をインストール済みで、Maven が意図した Java を使用するかわからない場合は、予期しない結果になることがあります。Maven が使用する JDK は、`mvn --version` コマンドで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、`hello` エンドポイントを提供する簡単なアプリケーションを作成します。依存性の注入を示すために、このエンドポイントでは `greeting` Bean を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started-architecture.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>getting-started-architecture.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide also covers the testing of the endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、エンドポイントのテストについても解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions from &lt;&lt;bootstrapping-the-project,Bootstrapping project&gt;&gt; and onwards to create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;bootstrapping-the-project,プロジェクトのブートストラップ&gt;&gt;とそれ以降の解説に従って、ステップバイステップでアプリを作成していくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかしながら、完成した例をすぐ確認することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive] or clone the git repository:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-archive-url}[アーカイブ] をダウンロードするか、gitレポジトリをクローンします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` {quickstarts-tree-url}/getting-started[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started` {quickstarts-tree-url}/getting-started[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to create a new Quarkus project is to open a terminal and run the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいQuarkusプロジェクトを作成する最も簡単な方法は、ターミナルを開いて以下のコマンドを実行することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd , (don't use backward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cmd を使っている場合 (バックスラッシュは使わないでください)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Powershell を使用する場合は、`-D` パラメーターを二重引用符で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `./getting-started` に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.getting.started.GreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.getting.start.GreetingResource` リソースは、`/hello` で公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/docker` にある `native` と `jvm` の両方のモード用の `Dockerfile` ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたら、`pom.xml` を確認してください。 Quarkus の BOM のインポートが存在することが分かります。これにより、異なる Quarkus の依存関係のバージョンを省略できます。さらに、アプリケーションのパッケージングと開発モードを処理する `quarkus-maven-plugin` が存在することが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係の部分に注目すると、REST アプリケーションの開発を可能にするエクステンションを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/GreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト作成時には、 `src/main/java/org/acme/getting/started/GreetingResource.java` ファイルが以下の内容で作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "hello" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは非常にシンプルな REST エンドポイントで、"/hello" 上のリクエストに "hello" を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences with vanilla JAX-RS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バニラ JAX-RS との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、`Application` クラスを作成する必要がありません。作成は可能ですが、必須ではありません。加えて、リソースは 1 つのみが作成され、リクエスト毎に 1 つではありません。これは、異なる `*Scoped` アノテーション (`ApplicationScoped`、`RequestScoped` など) を使用することで設定可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application.  Use: `./mvnw compile quarkus:dev`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを実行する準備が整いました。 `./mvnw compile quarkus:dev` を実行してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once started, you can request the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動したら、提供されたエンドポイントにリクエストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CTRL+C` を押してアプリケーションを停止したり、アプリケーションを起動したままにでき、快適な操作を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically add newline with `curl -w "\n"`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`curl -w "\n"` で自動的に改行を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using `curl -w "\n"` in this example to avoid your terminal printing a '%' or put both result and next command prompt on the same line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例では、 `curl -w "\n"` を使用して、結果と次のコマンドプロンプトが同じ行に表示されるのを防止しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the link:cdi[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の依存性注入は、Quarkus のアーキテクチャに合わせて調整された CDI ベースの依存性注入ソリューションである ArC をベースにしています。 CDI が初めての方は、 link:cdi[CDI入門] ガイドをお読みになることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus only implements a subset of the CDI features and comes with non-standard features and specific APIS, you can learn more about it in the link:cdi-reference[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は CDI 機能のサブセットのみを実装しており、非標準の機能や特定の API が付属しています。詳細は、 link:cdi-reference[Contexts and Dependency Injection ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC comes as a dependency of `quarkus-resteasy` so you already have it handy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ArCは `quarkus-resteasy` の依存関係として提供されているので、すでに追加済です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/getting/started/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを変更してコンパニオン Bean を追加してみましょう。 以下の内容で `src/main/java/org/acme/getting/started/GreetingService.java` ファイルを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `GreetingResource` class to inject the `GreetingService` and create a new endpoint using it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingResource` クラスを編集して `GreetingService` を注入し、それを使って新しいエンドポイントを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application, restart the application with `./mvnw compile quarkus:dev`.  Then check that the endpoint returns `hello quarkus` as expected:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを停止した場合は、`./mvnw compile quarkus:dev` でアプリケーションを再起動します。 そして、エンドポイントが `hello quarkus` を期待通りに返すことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus:dev` は、開発モードで Quarkus を実行します。これにより、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に反映されます。 これは、設定プロパティーファイルなどのリソースファイルに対しても機能します。 ブラウザをリフレッシュすると、ワークスペースのスキャンがトリガーされ、変更が検出された場合、Java ファイルが再コンパイルされ、アプリケーションが再デプロイされます。リクエストは、再デプロイされたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページで通知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはポート `5005` のデバッガーもリッスンします。デバッガーがアタッチされるのを待ってから実行する場合は、コマンドラインで `-Dsuspend` を渡してください。デバッガーを全く必要としない場合は `-Ddebug=false` を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All right, so far so good, but wouldn't it be better with a few tests, just in case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、ここまでは問題ありませんが、念のためにテストをした方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the generated `pom.xml` file, you can see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` ファイルでは、2 つのテスト依存関係を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[Junit 5] tests.  Because of this, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は https://junit.org/junit5/[Junit 5] テストをサポートしています。 デフォルトのバージョンでは Junit 5 をサポートしていないため、 https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] のバージョンを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `java.util.logging` システムプロパティーを設定して、テストが正しいログマネージャーを使用することを確認し、 `maven.home` からカスタム設定が適用されることを確認します (該当する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/getting/started/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたプロジェクトには簡単なテストが含まれています。 `src/test/java/org/acme/getting/started/GreetingResourceTest.java` を以下の内容に合わせて編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusTest` ランナーを使うことで、テストの前にアプリケーションを起動するように JUnit に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP response status code and content</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP レスポンスのステータスコードと内容を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These tests use http://rest-assured.io/[RestAssured], but feel free to use your favorite library.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのテストでは http://rest-assured.io/[RestAssured] を使用していますが、お好きなライブラリーをご自由にお使いください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run these using Maven:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは Maven を使って実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run the test from your IDE directly (be sure you stopped the application first).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、IDE から直接テストを実行することもできます (最初にアプリケーションを停止したことを確認してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource` annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type `String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、実行中のアプリケーションと競合しないように、テストはポート `8081` で実行されます。 RestAssured は、この 8081 ポートを使用するように自動的にを設定されます。別のクライアントを使用したい場合は、`@TestHTTPResource` アノテーションを使用して、テストされたアプリケーションの URL をテストクラスのフィールドに直接注入する必要があります。このフィールドは `String`、 `URL`、`URI` のいずれかの型になります。このアノテーションにはテストパスの値を指定することもできます。例えば、`/myservlet` にマップされたサーブレットをテストしたい場合、次のようにテストに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートは、`quarkus.http.test-port` 設定プロパティーで制御できます。Quarkus はまた、インジェクションを使用できない場合のためにベースとなるテストURLに設定される `test.url` というシステムプロパティーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module project or external modules</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトや外部モジュールとの連携</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus はビルド時に https://github.com/wildfly/jandex[Jandex] を多用して、さまざまなクラスやアノテーションを発見しています。これをすぐに認識できるアプリケーションの1つは、CDI Beanのディスカバリーです。 その結果、このビルド時のディスカバリーが適切に設定されていないと、Quarkusのエクステンションのほとんどが正しく動作しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index is created by default on the project on which Quarkus is configured for, thanks to our Maven and Gradle plugins.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このインデックスは、Maven と Gradle プラグインのおかげで、Quarkus が設定されているプロジェクト上にデフォルトで作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the link:maven-tooling#multi-module-maven[Maven] or link:gradle-tooling#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、マルチモジュールプロジェクトで作業する場合は、 link:maven-toolsing#multi-module-maven[Maven] または link:gradle-toolsing#multi-module-maven[Gradle] ガイドの 「マルチモジュールプロジェクトでの作業」のセクションを必ず読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>外部モジュール (例えば、すべてのドメインオブジェクトのための外部ライブラリ) を使用する予定がある場合は、Jandex プラグインを追加するか (変更できる場合)、 `application.properties` 内の `quarkus.index-dependency` プロパティーを使って (モジュールを変更できない場合に便利です)、これらのモジュールをインデックス作成プロセスに知らせておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to read the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、CDI ガイドの link:cdi-reference#bean_discovery[Bean Discovery] セクションを必ずお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージングとアプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行する前に、ホットリロードモードを停止する (CTRL+C) ことを忘れないでください 。停止しないと、ポートが衝突します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the banner</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バナーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus アプリケーションが起動すると (通常モードまたは開発モードで) 、ASCII アートバナーが表示されます。バナーを無効にするには、 `application.properties` で `quarkus.banner.enabled=false` を設定するか、 `Dquarkus.banner.enabled=false` の Java システムプロパティーを設定するか、 `QUARKUS_BANNER_ENABLED` 環境変数を `false` に設定します。 さらに、 `src/main/resources` にバナーファイルを配置し、 `application.properties` に `quarkus.banner.path=nam-of-file` を設定することで、ユーザーはカスタムのバナーを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the link:building-native-image[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the link:getting-started-reactive[Getting started with reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus を使用したアプリケーションの作成について説明しました。 しかし、まだまだ多くのことがあります。 link:built-native-image[ネイティブ実行可能ファイルのビルド] では、ネイティブ実行ファイルの作成とコンテナーへのパッケージングを説明します。 リアクティブに興味がある場合は、link:get-started-reactive[リアクティブ入門ガイド] をお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the link:tooling[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、link:tooling[ツールガイド] のドキュメントでは、以下の方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>enable the _development mode_ (hot reload)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_development mode_ (ホットリロード) を有効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-google-cloud-functions` extension allows you to use Quarkus to build your Google Cloud Functions.  Your functions can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-google-cloud-functions` エクステンションを使用すると、Quarkusを使用してGoogle Cloud Functionsを構築することができます。関数では、CDIやSpringからのインジェクションアノテーションや、必要に応じて他のQuarkusの機能を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the Google Cloud Function Java engine is a new Beta feature of Google Cloud, this extension is flagged as experimental.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud FunctionsのJavaへの対応は現在ベータ版であるため、このエクステンションは実験的なものとなります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloud.google.com/[A Google Cloud Account].  Free accounts work.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://cloud.google.com/[Googleクラウドのアカウント] 。無料アカウントでも大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating a sample project followed by creating multiple functions showing how to implement `HttpFunction`, `BackgroundFunction` and `RawBackgroundFunction` in Quarkus.  Once built, you will be able to deploy the project to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、サンプルプロジェクトを生成し、Quarkusで `HttpFunction` 、 `BackgroundFunction` 、 `RawBackgroundFunction` を実装する方法を説明します。ビルド後は、プロジェクトをGoogle Cloudにデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to follow all these steps, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの手順を順にすべて実行しない場合、完成したサンプルを以下で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `google-cloud-functions-quickstart` {quickstarts-tree-url}/google-cloud-functions-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでのソリューションは `google-cloud-functions-quickstart` {quickstarts-tree-url}/google-cloud-functions-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an application with the `quarkus-google-cloud-functions` extension.  You can use the following Maven command to create it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-google-cloud-functions` のエクステンションを持つアプリケーションを作成します。以下のMavenコマンドを使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's remove what's not needed inside the generated application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、生成されたアプリケーションから不要なものを削除します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the dependency `io.quarkus:quarkus-resteasy` from your `pom.xml` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus:quarkus-resteasy` を、`pom.xml` の依存関係から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the generated `org.acme.quickstart.GreetingResource` class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `org.acme.quickstart.GreetingResource` クラスを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the `index.html` from `resources/META-INF/resources` or it will be picked up instead of your Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`resources/META-INF/resources` から `index.html` を削除します。このファイルを削除しない場合Cloud Functions の関数として扱われてしまいます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the existing tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のテストを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Login to Google Cloud is necessary for deploying the application and it can be done as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのデプロイにはGoogle Cloudへのログインが必要で、以下のように行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the time of this writing, Cloud Functions are still in beta so make sure to install the `beta` command group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本ガイドの執筆時点では、Cloud Functionsはまだベータ版であるため、 `beta` コマンドグループをインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Cloud Functions の関数を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this example project, we will create three functions, one `HttpFunction`, one `BackgroundFunction` (Storage event) and one `RawBackgroundFunction` (PubSub event).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロジェクトの例では、 `HttpFunction` 、 `BackgroundFunction` (ストレージイベント)、 `RawBackgroundFunction` (PubSubイベント)の3つの関数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-google-cloud-functions` extension scans your project for a class that directly implements the Google Cloud `HttpFunction`, `BackgroundFunction` or `RawBackgroundFunction` interface.  It must find a class in your project that implements one of these interfaces or it will throw a build time failure.  If it finds more than one function classes, a build time exception will also be thrown.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-google-cloud-functions` エクステンションは、プロジェクト内からGoogle Cloud `HttpFunction` 、 `BackgroundFunction` 、または `RawBackgroundFunction` インターフェイスを直接実装しているクラスをプロジェクト内でスキャンします。これらのインターフェイスを実装しているクラスがプロジェクト内で見つからない場合やインターフェイスを実装しているクラスが複数見つかった場合は、ビルド時に例外がスローされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, though, you might have a few related functions that share code and creating multiple maven modules is just an overhead you don't want to do.  The extension allows you to bundle multiple functions in one project and use configuration or an environment variable to pick the function you want to deploy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、同じコードを利用するCloud Functionの関数クラスが複数あるような場合に、個別maven モジュールを作成することは手間となります。このQuarkusエクステンションを使うと、複数のCloud Function関数を一つのプロジェクトにバンドルし、設定や環境変数を使ってデプロイしたい関数を選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the name of the function, you can use the following configuration property:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Cloud Functions の関数に名前を設定するには、以下の設定プロパティーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.google-cloud-functions.function` property tells Quarkus which function to deploy. This can be overridden with an environment variable too.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.google-cloud-functions.function` プロパティーは、デプロイする関数をQuarkusに伝えます。これは環境変数でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CDI name of the function class must match the value specified within the `quarkus.google-cloud-functions.function` property.  This must be done using the `@Named` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Cloud Functions の関数となるクラスの CDI 名は、 `quarkus.google-cloud-functions.function` プロパティー内で指定された値と一致している必要があります。これは `@Named` アノテーションを使用して行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Named` annotation allows to name the CDI bean to be used by the `quarkus.google-cloud-functions.function` property, this is optional.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Named` アノテーションでは、 `quarkus.google-cloud-functions.function` プロパティーで使用する CDI Beanに名前を付けることができますが、これはオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function must be a CDI bean</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>関数はCDI Beanでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a regular Google Cloud Function implementation, so it needs to implement `com.google.cloud.functions.HttpFunction`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud Functionで実行するためには、実行する対象のクラスは`com.google.cloud.functions.HttpFunction`インターフェースをImplementsする必要があります .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection works inside your function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションはCloud Function関数クラスの中で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is standard Google Cloud Function implementation, nothing fancy here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは標準的な Google Cloud Function の実装であり、ここでは何も派手なことはしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `BackgroundFunction` is triggered by a Storage event, you can use any events supported by Google Cloud instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この `BackgroundFunction` はストレージイベントによってトリガーされる以外にも、Google Cloud でサポートされているトリガーイベントを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a regular Google Cloud Function implementation, so it needs to implement `com.google.cloud.functions.BackgroundFunction`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud Functionで実行するためには、実行する対象のクラスは `com.google.cloud.functions.BackgroundFunction` インターフェースをImplementsする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the class the event will be deserialized to.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはトリガーのイベントデータがデシリアライズされるクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `RawBackgroundFunction` is triggered by a PubSub event, you can use any events supported by Google Cloud instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この `RawBackgroundFunction` は PubSub イベントでトリガーされる以外にも、Google Cloud でサポートされているトリガーイベントを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a regular Google Cloud Function implementation, so it needs to implement `com.google.cloud.functions.RawBackgroundFunction`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud Functionで実行するためには、実行する対象のクラスは  `com.google.cloud.functions.RawBackgroundFunction` インターフェースをImplementsする必要があります。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy to Google Cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのビルドとGoogle Cloudへのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build your application, you can package it using the standard `mvn clean package` command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをビルドするには、標準の `mvn clean package` コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The result of the previous command is a single JAR file inside the `target/deployment` repository that contains classes and dependencies of the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のコマンドの結果、 `target/deployment` リポジトリ内に単一の JAR ファイルが生成されます。このJARファイルにはプロジェクト内のクラスと、依存関係のクラスが含まれています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you will be able to use `gcloud beta functions deploy` command to deploy your function to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのビルド後、 `gcloud beta functions deploy` コマンドを使って Google Cloud に関数をデプロイすることができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first time you launch this command, you can have the following error message:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドを初めて起動したときには、以下のようなエラーメッセージが表示されることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that Cloud Build is not activated yet. To overcome this error, open the URL shown in the error, follow the instructions and then wait a few minutes before retrying the command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Cloud Buildがまだ有効化されていないことを意味します。このエラーを解決するには、エラーに表示されているURLを開き指示に従った後、数分待ってからコマンドを再試行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example command to deploy your `HttpFunction` to Google Cloud:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `HttpFunction` を Google Cloud にデプロイするためのコマンドの例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entry point must always be set to `io.quarkus.gcp.functions.QuarkusHttpFunction` as this is the class that integrates Cloud Functions with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エントリーポイントは常に `io.quarkus.gcp.functions.QuarkusHttpFunction` に設定する必要があります。このクラスはQuarkusとCloud Functionsを統合するクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will give you as output a `httpsTrigger.url` that points to your function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、作成したCloud Functions 関数をトリガーするための `httpsTrigger.url` を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before deploying your function, you need to create a bucket.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>関数をデプロイする前に、バケットを作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example command to deploy your `BackgroundFunction` to Google Cloud, as the function is triggered by a Storage event, it needs to use `--trigger-event google.storage.object.finalize` and the `--trigger-resource` parameter with the name of a previously created bucket:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `BackgroundFunction` を Google Cloud にデプロイするためのコマンドの例です。この関数は Storage イベントによってトリガーされるため、 `--trigger-event google.storage.object.finalize` と `--trigger-resource` パラメーターに先の手順で作成したバケットの名前を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entry point must always be set to `io.quarkus.gcp.functions.QuarkusBackgroundFunction` as this is the class that integrates Cloud Functions with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エントリーポイントは常に `io.quarkus.gcp.functions.QuarkusBackgroundFunction` に設定する必要があります。このクラスはQuarkusとCloud Functionsを統合するクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger the event, you can send a file to the GCS `quarkus-hello` bucket or you can use gcloud to simulate one:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントをトリガーするには、GCS `quarkus-hello` バケットにファイルを送るか、gcloudコマンドを使ってシミュレーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`--data` contains the GCS event, it is a JSON document with the name of the file added to the bucket.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`--data` には GCS イベントを指定します。これは、バケットに追加されたファイル名を含む JSON形式のフォーマットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example command to deploy your `RawBackgroundFunction` to Google Cloud, as the function is triggered by a PubSub event, it needs to use `--trigger-event google.pubsub.topic.publish` and the `--trigger-resource` parameter with the name of a previously created topic:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `RawBackgroundFunction` を Google Cloud にデプロイするコマンドの例です。この関数は PubSub イベントによってトリガーされるので、 `--trigger-event google.pubsub.topic.publish` と `--trigger-resource` パラメーターに、先の手順で作成したトピックの名前を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger the event, you can send a file to the `hello_topic` topic or you can use gcloud to simulate one:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントをトリガーするには、 `hello_topic` トピックにファイルを送信するか、gcloudコマンドを使用してシミュレーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing locally</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ローカルでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to locally test your function is using the Cloud Function invoker JAR.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>関数をローカルでテストする最も簡単な方法は、Cloud Function invoker JAR を使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can download it via Maven using the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコマンドでMaven経由でダウンロードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before using the invoker, you first need to build your function via `mvn package`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>invokerを使用する前に、`mvn package` で関数をビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test an `HttpFunction`, you can use this command to launch your function locally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`HttpFunction` をテストするために、以下のコマンドを使用しローカルで関数を起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `--classpath` parameter needs to be set to the previously packaged JAR that contains your function class and all Quarkus related classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`--classpath` パラメーターには、関数クラスとQuarkus関連のすべてのクラスを含む、先の手順でパッケージ化されたJARを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your endpoints will be available on http://localhost:8080.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントは http://localhost:8080 で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For background functions, you launch the invoker with a target class of `io.quarkus.gcp.functions.BackgroundFunction`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>BackgroundFunction関数の場合は、 `io.quarkus.gcp.functions.BackgroundFunction` のターゲットクラスでinvokerを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can call your background function via an HTTP call with a payload containing the event:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動後、HTTP 呼び出しにイベントを含むペイロードを付与することでバックグラウンド関数を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will call your Storage background function with an event `{"name":"hello.txt"}`, so an event on the `hello.txt` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドにより、イベント `{"name":"hello.txt"}` でBackgroundFunctionを呼び出します。これは、`hello.txt`をCloud Storageに保存した際のイベントをテストするのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will call your PubSub background function with a PubSubMessage `{"greeting":"world"}`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、PubSubのBackgroundFunctionを次のPubSubMessageで呼び出します `{"greeting":"world"}` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward chat application using web sockets to receive and send messages to the other connected users.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、WebSocketを使用して、接続されている他のユーザーとメッセージを送受信するための簡単なチャットアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can skip right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、すぐに完成した例に飛んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send and receive messages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージの送受信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto standard JPA implementation and offers you the full breadth of an Object Relational Mapper.  It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMは、デファクトスタンダートなJPA実装であり、オブジェクトリレーショナルマッパーの全幅を提供します。これはQuarkusで美しく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/fruits")
public class FruitResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/fruits")
public class FruitResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we are ready to run our application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、アプリケーションを実行する準備が整いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once your application is started, you can make a request to the default `/q/openapi` endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを起動すると、デフォルトの `/q/openapi` エンドポイントにリクエストを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contact Information</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>連絡先情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`META-INF/openapi.yaml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`META-INF/openapi.yaml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`META-INF/openapi.yml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`META-INF/openapi.yml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`META-INF/openapi.json`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`META-INF/openapi.json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WEB-INF/classes/META-INF/openapi.yml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`WEB-INF/classes/META-INF/openapi.yml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WEB-INF/classes/META-INF/openapi.yaml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`WEB-INF/classes/META-INF/openapi.yaml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WEB-INF/classes/META-INF/openapi.json`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`WEB-INF/classes/META-INF/openapi.json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the method name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッド名を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the class name (without the package) plus the method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(パッケージを含まない)クラス名とメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the class name plus the method name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラス名とメソッド名を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenAPI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Swagger UI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Swagger UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events] builds off of the link:funqy-http[Funqy HTTP] extension to allow you to route and process Knative Events within a Funqy function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events]は 、link:funqy-http[Funqy HTTP] エクステンションをベースに構築されており、Funqy関数内でKnative Eventsをルーティングして処理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions with Knative Events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、クイックスタートコードを使って、Knative Events を使って Funqy 関数をデプロイして呼び出す方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read about link:funqy[Funqy Basics].  This is a short read!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:funqy[Funqy の基礎] を読む。短時間で読めます!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have gone through the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial], specifically link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knativeチュートリアル] 、特に link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[ブローカーとトリガー] を一読していること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  It is advised to follow https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[this] Knative Tutorial put together by Red Hat.  It walks through how to set up Knative on Minikube or OpenShift in a local environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Minikube 環境で Knative をローカルに設定することは、このガイドの範囲を超えています。link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Red HatがまとめたKnativeチュートリアル] に従うことをお勧めします。このチュートリアルでは、ローカル環境でMinikubeやOpenShift上でKnativeをセットアップする方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specifically you should run the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers] tutorial as this guide requires that you can invoke on a Broker to trigger the quickstart code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、クイックスタートコードをトリガーするためにブローカーを呼び出す必要があるため、特に link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[ブローカーとトリガー] のチュートリアルを実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event link:https://cloudevents.io/[specification] is a good read to give you an even greater understanding of Knative Events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative Events をより深く理解するために、Cloud Events の link:https://cloudevents.io/[仕様] を読んでおくと良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quickstart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-knative-events-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `funqy-knative-events-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quickstart Flow</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタートの流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The quickstart works by manually sending an HTTP request containing a Cloud Event to the Knative Broker using `curl`.  The Knative Broker receives the request and triggers the startup of the Funqy container built by the quickstart.  The event triggers the invocation of a chain of Funqy functions.  The output of one function triggers the invocation of another Funqy function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタートは、Cloud Eventを含む HTTP リクエストを `curl` を使用して Knative Broker に手動で送信することで動作します。Knative Broker はリクエストを受信し、クイックスタートによって構築された Funqy コンテナの起動をトリガーします。イベントは、一連の Funqy 関数の呼び出しをトリガーします。1 つの関数の出力は、別の Funqy 関数の呼び出しをトリガーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When living within a Knative Events environment, Funqy functions are triggered by a specific Cloud Event type.  You can have multiple Funqy functions within a single application/deployment, but they must be triggered by a specific Cloud Event Type.  The exception to this rule is if there is only one Funqy function in the application.  In that case, the event is pushed to that function irregardless of the Cloud Event type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative Events環境内で稼働する場合、Funqy関数は特定のタイプの Cloud Event によってトリガーされます。1つのアプリケーション/デプロイメント内に複数のFunqy関数を持つことができますが、それらは特定のタイプの Cloud Event によってトリガーされなければなりません。このルールの例外は、アプリケーション内にFunqy関数が1つしかない場合です。この場合、イベントは Cloud Event タイプに関係なく、その関数にプッシュされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Currently, Funqy can only consume JSON-based data.  It supports both Binary and Structured mode of execution, but the data component of the Cloud Event message must be JSON.  This JSON must also be marshallable to and from the Java parameters and return types of your functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在、FunqyはJSONベースのデータしか消費できません。それ自体はバイナリモードと構造化モードの両方をサポートしていますが、Cloud EventメッセージのデータコンポーネントはJSONでなければなりません。このJSONは、関数のJavaパラメータやリターンタイプとの間でマーシャル可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start looking at our quickstart code so that you can understand how Knative Events map to Funqy.  Open up {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative イベントがどのように Funqy にマップされるかを理解するために、クイックスタートのコードを見てみましょう。クイックスタートコードは、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java] を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first function we'll look at is `defaultChain`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初に見る関数は `defaultChain` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As is, a Funqy function has a default Cloud Event mapping.  By default, the Cloud Event type must match the function name for the function to trigger.  If the function returns output, the response is converted into a Cloud Event and returned to the Broker to be routed to other triggers.  The default Cloud Event type for this response is the function name + `.output`.  The default Cloud Event source is the function name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この状態で、Funqy関数はデフォルトの Cloud Event マッピングを持っています。デフォルトでは、 Cloud Event のタイプは、トリガする関数の関数名と一致していなければなりません。関数が出力を返す場合、レスポンスは Cloud Event に変換され、ブローカに返されて他のトリガーにルーティングされます。このレスポンスのデフォルトの Cloud Event  タイプは、関数名 + `.output` です。デフォルトの Cloud Event のソースは、関数名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, for the `defaultChain` function, the Cloud Event type that triggers the function is `defaultChain`.  It generates a response that triggers a new Cloud Event whose type is `defaultChain.output` and the event source is `defaultChain`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>したがって、 `defaultChain` 関数の場合、この関数をトリガーする Cloud Event のタイプは `defaultChain` です。これは、タイプが `defaultChain.output` でイベントソースが `defaultChain` である新しい Cloud Event をトリガーするレスポンスを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the default mapping is simple, it might not always be feasible.  You can change this default mapping through configuration.  Let's look at the next function:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのマッピングはシンプルですが、必ずしもうまくいくとは限りません。このデフォルトのマッピングは設定で変更することができます。次の関数を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `configChain` function has its Cloud Event mapping changed by configuration within {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties[application.properties].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`configChain` 関数は、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties[application.properties] 内の設定により、 Cloud Event のマッピングが変更されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the configuration maps the incoming Cloud Event type `defaultChain.output` to the `configChain` function.  The `configChain` function maps its response to the `annotated` Cloud Event type, and the Cloud Event source `configChain`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、この構成では、受信するCloud Eventのタイプ `defaultChain.output` を `configChain` 関数にマッピングします。 `configChain` 関数は、そのレスポンスを `annotated` Cloud Event タイプに、Cloud Event ソース `configChain` にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.trigger` sets the Cloud Event type that triggers a specific function</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.trigger` は、特定の機能をトリガーする Cloud Event タイプを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.response-type` sets the Cloud Event type of the response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.response-type` は、レスポンスの Cloud Event タイプを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.resource-source` sets the Cloud Event source of the response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.funqy.knative-events.mapping.{function name}.resource-source` は、レスポンスの Cloud Event のソースを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy Knative Events extension also has annotations to do this Cloud Event mapping to your functions.  Take a look at the `annotatedChain` method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy Knative Events エクステンションには、この Cloud Event の関数へのマッピングを行うためのアノテーションも用意されています。 `annotatedChain` メソッドを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the `@CloudEventMapping` annotation on your function you can map the Cloud Event type trigger and the Cloud Event response.  In this example the `annotatedChain` function will be triggered by the `annotated` Cloud Event type and the response will be mapped to a `lastChainLink` type and `annotated` Cloud Event source.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>関数に `@CloudEventMapping` アノテーションを使用すると、Cloud Event タイプのトリガーとCloud Event レスポンスをマッピングできます。この例では、 `annotatedChain` 関数は `annotated` Cloud Event タイプによってトリガされ、レスポンスは `lastChainLink` タイプと `annotated` Cloud Eventソースにマッピングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if look at all the functions defined within `SimpleFunctionChain` you'll notice that one function triggers the next.  The last function that is triggered is `lastChainLink`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、 `SimpleFunctionChain` 内で定義されているすべての関数を見てみると、ある関数が次の関数を引き金にしていることに気づくでしょう。最後にトリガーされる関数は `lastChainLink` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two things to notice about this function.  One, it has no output.  Your functions are not required to return output.  Second, there is an additional `event` parameter to the function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能には2つの注意点があります。一つは、この関数には出力がありません。あなたの関数は出力を返す必要はありません。第二に、この関数には追加の `event` パラメータがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to know additional information about the incoming Cloud Event, you can inject the `CloudEvent` interface using the Funqy `@Context` annotation.  The `CloudEvent` interface exposes information about the triggering event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信したCloud Eventに関する追加情報を知りたい場合は、Funqy `@Context` アノテーションを使用して `CloudEvent` インターフェイスを注入することができます。 `CloudEvent` インターフェイスは、トリガーとなるイベントに関する情報を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Maven</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml[pom], you'll see that it is a typical Quarkus pom that pulls in one funqy dependency</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml[pom] を見ると、典型的なQuarkusのpomで、以下のような1つのfunqy依存関係を持っていることがわかるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode and Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードとテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy Knative Events support dev mode and unit testing using RestAssured.  You can invoke on Funqy Knative Events functions using the same invocation model as link:funqy-http[Funqy HTTP] using normal HTTP requests, or Cloud Event Binary mode, or Structured Mode.  All invocation modes are supported at the same time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy Knative Eventsは、RestAssuredを使用したdevモードとユニットテストをサポートしています。通常のHTTPリクエストを使用した link:funqy-http[Funqy HTTP] と同じ呼び出しモデルを使用してFunqy Knative Events関数上で呼び出すか、Cloud Event Binaryモード、またはStructured Modeを使用して呼び出すことができます。すべての呼び出しモードが同時にサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, if you open up the unit test code in {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java] you'll see that its simply using RestAssured to make HTTP invocations to test the functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、 {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java] のユニットテストコードを開くと、関数をテストするためのHTTP呼び出しを行うために、単にRestAssuredを使用していることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the Project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First build the Java artifacts:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、Javaアーティファクトをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, a docker image is required by Knative, so you'll need to build that next:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、Knativeではdockerイメージが必要なので、続いてそれをビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to replace `yourAccountName` with your docker or quay account name when you run `docker build`.  The Dockerfile is a standard Quarkus dockerfile.  No special Knative magic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`docker build` を実行する際には、必ず `yourAccountName` を docker または quay のアカウント名に置き換えてください。Dockerfileは標準のQuarkusのdockerfileです。特別なKnativeマジックはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Push your image to docker hub or quay</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イメージをDocker HubやQuayにプッシュする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Again, make sure to replace `yourAccountName` with your docker or quay account name when you run `docker push`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>繰り返しになりますが、 `docker push` を実行する際には、 `yourAccountName` を docker または quay のアカウント名に置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to define a Kubernetes/OpenShift service to points to your the docker image you created and pushed during build.  Take a look at {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/funqy-service.yaml[funqy-service.yaml]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のステップは、ビルド時に作成してプッシュしたdockerイメージを指すKubernetes/OpenShiftサービスを定義することです。クイックスタート/src/main/k8s/funqy-service.yaml[funqy-service.yaml]を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a standard Kubernetes service definition yaml file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはKubernetesの標準的なサービス定義のyamlファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you change the image url to point to the image you built and pushed earlier!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あなたが以前に構築してプッシュしたイメージを指すように、イメージのURLを変更することを確認してください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For our quickstart, one Kubernetes service will contain all functions.  There's no reason you couldn't break up this quickstart into multiple different projects and deploy a service for each function.  For simplicity, and to show that you don't have to have a deployment per function, the quickstart combines everything into one project, image, and service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のクイックスタートでは、1つのKubernetesサービスにすべての機能が含まれます。このクイックスタートを複数の異なるプロジェクトに分割して、機能ごとにサービスをデプロイできない理由はありません。シンプルにするために、また、機能ごとにデプロイする必要がないことを示すために、このクイックスタートでは、すべての機能を1つのプロジェクト、イメージ、サービスにまとめています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploy the service yaml.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスyamlをデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next step is to deploy Knative Event triggers for each of the event types.  As noted in the code section, each Funqy function is mapped to a specific Cloud Event type.  You must create Knative Event triggers that map a Cloud Event and route it to a specific Kubernetes service.  We have 4 different triggers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップは、イベントタイプごとにKnative Eventのトリガーを展開することです。コードのセクションで述べたように、各Funqy関数は特定のCloud Eventタイプにマッピングされています。Cloud Eventをマッピングし、特定のKubernetesサービスにルーティングするKnative Eventトリガーを作成する必要があります。ここでは4つの異なるトリガーを用意しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml[defaultChain-trigger.yaml]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `spec:filter:attributes:type` maps a Cloud Event type to the Kubernetes service defined in `spec:subscriber:ref`.  When a Cloud Event is pushed to the Broker, it will trigger the spin up of the service mapped to that event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`spec:filter:attributes:type` は、 `spec:subscriber:ref` で定義されている Kubernetes サービスにCloud Eventのタイプをマッピングします。Cloud EventがBrokerにプッシュされると、そのイベントにマッピングされたサービスのスピンアップがトリガーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's a trigger yaml file for each of our 4 Funqy functions.  Deploy them all:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>4つのFunqy関数それぞれのトリガーyamlファイルがあります。それらをすべてデプロイしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the demo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デモの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You'll need two different terminal windows.  One to do a curl request to the Broker, the other to watch the pod log files so you can see the messages flowing through the Funqy function event chain.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つの異なるターミナルウィンドウが必要です。一つは Broker への curl リクエストを行うためのもので、もう一つはポッドのログファイルを見るためのもので、Funqy 関数のイベントチェーンを流れるメッセージを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have the `stern` tool installed.  See the Knative Tutorial setup for information on that.  Run stern to look for logs outputted by our Funqy deployment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`stern` ツールがインストールされていることを確認してください。それについての情報は Knative チュートリアルのセットアップを参照してください。Funqy デプロイメントが出力したログを探すために stern を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a separate terminal.  You'll first need to learn the URL of the broker.  Execute this command to find it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の端末を開きます。まずブローカーのURLを知る必要があります。このコマンドを実行して探します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will provide you a url like this (exactly like this if you followed the knative tutorial): `http://default-broker.knativetutorial.svc.cluster.local` Remember this URL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなURLが表示されます(knativeのチュートリアルに従った場合はこのようになります)。 `http://default-broker.knativetutorial.svc.cluster.local` このURLを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next thing we need to do is ssh into our Kubernetes cluster so that we can send a curl request to our broker.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に行う必要があるのは、Kubernetes クラスタに ssh して、ブローカーに curl リクエストを送信できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will now be in a shell within the Kubernetes cluster.  Within the shell, execute this curl command</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでKubernetesクラスタ内のシェルになります。シェル内で、次のような curl コマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This posts a Knative Event to the broker, which will trigger the `defaultChain` function.  As discussed earlier, the output of `defaultChain` triggers an event that is posted to `configChain` which triggers an event posted to `annotatedChain` then finally to the `lastChainLink` function.  You can see this flow in your `stern` window.  Something like this should be outputted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ブローカーに Knative イベントをポストし、 `defaultChain` 関数をトリガーします。前述したように、 `defaultChain` の出力は、 `configChain` に投稿されたイベントをトリガーにして、 `annotatedChain` に投稿されたイベントをトリガーにして、最後に `lastChainLink` 関数をトリガーにします。この流れは `stern` ウィンドウで見ることができます。以下のようなものが出力されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, you will learn how to enable application data caching in any CDI managed bean of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションのCDI管理されたBeanでアプリケーションデータのキャッシングを有効にする方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scenario</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シナリオ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you want to expose in your Quarkus application a REST API that allows users to retrieve the weather forecast for the next three days.  The problem is that you have to rely on an external meteorological service which only accepts requests for one day at a time and takes forever to answer.  Since the weather forecast is updated once every twelve hours, caching the service responses would definitely improve your API performances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションで、ユーザーが今後3日間の天気予報を取得できるREST APIを公開したいとします。問題は、一度に1日分のリクエストしか受け付けず、応答に時間がかかる外部の気象サービスに依存しなければならないことです。天気予報は12時間に一度更新されるので、サービスのレスポンスをキャッシュすればAPIのパフォーマンスは間違いなく向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll do that using a single Quarkus annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これをQuarkusの単一のアノテーションを使用して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create a new Quarkus project using Maven with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、以下のコマンドでMavenを使って新しいQuarkusプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `cache` and `resteasy-jackson` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `cache` と `resteasy-jackson` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service that will simulate an extremely slow call to the external meteorological service.  Create `src/main/java/org/acme/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは、外部気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class that will contain the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、ユーザーが次の3日間の天気予報を求めたときに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/cache/WeatherForecast.java` をこのように作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションが動いたので、外部の気象サービスのレスポンスをキャッシュすることで、レスポンスタイムを大幅に改善してみましょう。 `WeatherForecastService` クラスを次のように修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do you want to learn more about the Quarkus application data caching abilities? The following sections will show you everything there is to know about it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションのデータキャッシング機能について詳しく知りたいですか?以下のセクションでは、この機能について知っておくべきことをすべて紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュのアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers a set of annotations that can be used in a CDI managed bean to enable caching abilities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、CDI管理されたBeanで使用できる、キャッシング機能を有効にするアノテーションのセットを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Caching annotations are not allowed on private methods.  They will work fine with any other access modifier including package-private (no explicit modifier).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プライベートメソッドではアノテーションのキャッシュは許可されていません。package-private (明示的な修飾子を持たない) を含む他のアクセス修飾子では問題なく動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CacheResult</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@CacheResult</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation cannot be used on a method returning `void`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、 `void` を返すメソッドでは使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CacheInvalidate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@CacheInvalidate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removes an entry from the cache.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュからエントリーを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@CacheKey</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@CacheKey</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Composite cache key building logic</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複合キャッシュキー構築ロジック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a cache key is built from several method arguments, whether they are explicitly identified with `@CacheKey` or not, the building logic depends on the order of these arguments in the method signature. On the other hand, the arguments names are not used at all and do not have any effect on the cache key.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュキーが複数のメソッド引数から構築される場合、それらが明示的に `@CacheKey` で識別されているかどうかに関わらず、構築ロジックはメソッドシグネチャ内のこれらの引数の順序に依存します。一方、引数名は全く使用されず、キャッシュキーには何の影響も与えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explicit composite cache key</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>明示的な合成キャッシュキー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the _lingua franca_ between microservices.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON は今やマイクロサービス間の _共通言語_ となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、REST サービスが JSON ペイロードを消費および生成する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>there is another guide if you need a link:rest-client[REST client] (including support for JSON).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:rest-client[REST クライアント] が必要な場合は、別のガイドがあります (JSON のサポートを含む)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドで開発するアプリケーションは非常にシンプルです: ユーザーはフォームを使用してリストに要素を追加することができ、リストが更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server are formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザとサーバー間の情報はすべて JSON 形式になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `rest-json-quickstart` {quickstarts-tree-url}/rest-json-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and https://github.com/FasterXML/jackson[Jackson] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RSと link:https://github.com/FasterXML/jackson[Jackson] エクステンションをインポートするMaven構造を生成し、特に以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To improve user experience, Quarkus registers the three Jackson https://github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need to do it manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーエクスペリエンスを向上させるために、Quarkusは3つのJackson link:https://github.com/FasterXML/jackson-modules-java8[Java 8モジュール] を登録しているので、手動で登録する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports http://json-b.net/[JSON-B] so, if you prefer JSON-B over Jackson, you can create a project relying on the RESTEasy JSON-B extension instead:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは link:http://json-b.net/[JSON-B] もサポートしているので、JacksonよりもJSON-Bが好きな場合は、代わりにRESTEasy JSON-B エクステンションに依存したプロジェクトを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and http://json-b.net/[JSON-B] extensions, and in particular adds the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RSと link:http://json-b.net/[JSON-B] 拡張をインポートするMaven構造を生成し、特に以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating your first JSON REST service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのJSON RESTサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of fruits.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、果物のリストを管理するアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's create the `Fruit` bean as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、以下のように `Fruit` Bean を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことはJSONシリアライズレイヤーで必須であるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.rest.json.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `org.acme.rest.json.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実装は非常に簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Fruit` objects will be automatically serialized/deserialized by http://json-b.net/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], depending on the extension you chose when initializing the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Fruit` オブジェクトは、プロジェクトの初期化時に選択したエクステンションに応じて、 link:http://json-b.net/[JSON-B] または link:https://github.com/FasterXML/jackson[Jackson] によって自動的にシリアライズ/デシリアライズされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a JSON extension is installed such as `quarkus-resteasy-jackson` or `quarkus-resteasy-jsonb`, Quarkus will use the `application/json` media type by default for most return values, unless the media type is explicitly set via `@Produces` or `@Consumes` annotations (there are some exceptions for well known types, such as `String` and `File`, which default to `text/plain` and `application/octet-stream` respectively).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-resteasy-jackson` や `quarkus-resteasy-jsonb` などの JSON エクステンションがインストールされている場合、メディアタイプが `@Produces` や `@Consumes` アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` メディアタイプをデフォルトで使用します( `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` と `application/octet-stream` がデフォルトとなっています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the default Jackson `ObjectMapper` obtained via CDI (and consumed by the Quarkus extensions) is configured to ignore unknown properties (by disabling the `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` feature).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、CDI経由で取得した(そしてQuarkusのエクステンションによって消費される)デフォルトのJackson `ObjectMapper` は、未知のプロパティーを無視するように設定されています( `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 機能を無効にすることで)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can restore the default behavior of Jackson by setting `quarkus.jackson.fail-on-unknown-properties=true` in your `application.properties` or on a per class basis via `@JsonIgnoreProperties(ignoreUnknown = false)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` で `quarkus.jackson.fail-on-unknown-properties=true` を設定するか、 `@JsonIgnoreProperties(ignoreUnknown = false)` を経由してクラスごとに設定することで、Jackson のデフォルトの動作を復元することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, Quarkus makes it very easy to configure various Jackson settings via CDI beans.  The simplest (and suggested) approach is to define a CDI bean of type `io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson configuration can be applied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkusは、CDI Bean を介して、様々なJackson設定を非常に簡単に設定することができます。最も単純な(そして推奨される)アプローチは、 `io.quarkus.jackson.ObjectMapperCustomizer` 型の CDI Bean を定義し、その中で、Jackson の設定を適用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example where a custom module needs to be registered would look like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムモジュールを登録する必要がある場合の例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can even provide their own `ObjectMapper` bean if they so choose.  If this is done, it is very important to manually inject and apply all `io.quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that produces `ObjectMapper`.  Failure to do so will prevent Jackson specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーは、選択すれば自分の `ObjectMapper` Beanを提供することもできます。この場合、 `ObjectMapper` を生成する CDI プロデューサの中で、すべての `io.quarkus.jackson.ObjectMapperCustomizer` Bean を手動で注入して適用することが非常に重要です。これを怠ると、様々なエクステンションによって提供される Jackson 固有のカスタマイズが適用されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As stated above, Quarkus provides the option of using JSON-B instead of Jackson via the use of the `quarkus-resteasy-jsonb` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のように、Quarkusでは、 `quarkus-resteasy-jsonb` エクステンションを使用することで、Jacksonの代わりにJSON-Bを使用するオプションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the same approach as described in the previous section, JSON-B can be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前項と同様のアプローチで、 `io.quarkus.jsonb.JsonbConfigCustomizer` beanを使用してJSON-Bを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for example a custom serializer named `FooSerializer` for type `com.example.Foo` needs to be registered with JSON-B, the addition of a bean like the following would suffice:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `FooSerializer` という名前のカスタムシリアライザを `com.example.Foo` タイプで JSON-B で登録する必要がある場合、以下のような Bean を追加すれば十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A more advanced option would be to directly provide a bean of `javax.json.bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).  If the latter approach is leveraged it is very important to manually inject and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI producer that produces `javax.json.bind.Jsonb`.  Failure to do so will prevent JSON-B specific customizations provided by various extensions from being applied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より高度なオプションとしては、 `javax.json.bind.JsonbConfig` ( `Dependent` スコープ付き)の Bean を直接提供するか、極端な場合には `javax.json.bind.Jsonb` ( `Singleton` スコープ付き)のタイプの Bean を提供することが考えられます。後者のアプローチを利用する場合は、 `javax.json.bind.Jsonb` を生成する CDI プロデューサに `io.quarkus.jsonb.JsonbConfigCustomizer` Bean をすべて手動で注入して適用することが非常に重要です。これを怠ると、様々なエクステンションによって提供される JSON-B 固有のカスタマイズが適用されなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a frontend</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フロントエンドの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `FruitResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] ファイルの内容を含む `fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can now interact with your REST service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、REST サービスと対話できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>start Quarkus with `./mvnw compile quarkus:dev`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` で Quarkus を起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>open a browser to `http://localhost:8080/fruits.html`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザで `http://localhost:8080/fruits.html` を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルは、通常のコマンド `./mvnw package -Pnative` でビルドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running it is as simple as executing `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行は簡単で、 `./target/rest-json-quickstart-1.0-SNAPSHOT-runner` を実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then point your browser to `http://localhost:8080/fruits.html` and use your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、ブラウザで `http://localhost:8080/fruits.html` を開いてアプリケーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>About serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シリアライゼーションについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON serialization libraries use Java reflection to get the properties of an object and serialize them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSONシリアライズライブラリは、Javaのリフレクションを使用してオブジェクトのプロパティーを取得してシリアライズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using native executables with GraalVM, all classes that will be used with reflection need to be registered.  The good news is that Quarkus does that work for you most of the time.  So far, we haven't registered any class, not even `Fruit`, for reflection usage and everything is working fine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMでネイティブ実行ファイルを使用する場合、リフレクションで使用されるすべてのクラスを登録する必要があります。良いニュースは、Quarkusがほとんどの場合、その作業を代行してくれるということです。これまでのところ、 `Fruit` でさえ、リフレクトを使用するためのクラスを登録しておらず、すべてが正常に動作しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus performs some magic when it is capable of inferring the serialized types from the REST methods.  When you have the following REST method, Quarkus determines that `Fruit` will be serialized:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、RESTメソッドからシリアライズされた型を推論することができる場合に、何らかのマジックを実行します。以下のようなRESTメソッドがある場合、Quarkusは、 `Fruit` がシリアライズされると判断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does that for you automatically by analyzing the REST methods at build time and that's why we didn't need any reflection registration in the first part of this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、ビルド時にRESTメソッドを分析することで、自動的にそのような処理を行ってくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another common pattern in the JAX-RS world is to use the `Response` object.  `Response` comes with some nice perks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSの世界では、 `Response` オブジェクトを使用するのがもう一つの一般的なパターンです。 `Response` にはいくつかの素晴らしい特典があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can return different entity types depending on what happens in your method (a `Legume` or an `Error` for instance);</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドで何が起こるかによって異なるエンティティータイプを返すことができます (例えば `Legume` や `Error` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can set the attributes of the `Response` (the status comes to mind in the case of an error).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `Response` の属性を設定することができます (エラーが発生した時にステータスを知ることができます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your REST method then looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTメソッドは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible for Quarkus to determine at build time the type included in the `Response` as the information is not available.  In this case, Quarkus won't be able to automatically register for reflection the required classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Response` に含まれるタイプは情報がないため、Quarkusがビルド時に判断することはできません。この場合、Quarkusは必要なクラスを自動的に反映登録することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This leads us to our next section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが次のセクションにつながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create the `Legume` class which will be serialized as JSON, following the same model as for our `Fruit` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Fruit` クラスと同じモデルに従って、JSON としてシリアライズされる `Legume` クラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's create a `LegumeResource` REST service with only one method which returns the list of legumes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、マメ科植物のリストを返すメソッドを一つだけ持つ `LegumeResource` REST サービスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method returns a `Response` and not a list of `Legume`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは `Response` を返し、 `Legume` のリストではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to display our list of legumes.  In the `src/main/resources/META-INF/resources` directory, add a `legumes.html` file with the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、マメ科植物のリストを表示するための簡単なウェブページを追加してみましょう。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/legumes.html[legumes.html] ファイルの内容を含む `legumes.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open a browser to http://localhost:8080/legumes.html and you will see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザを開いて http://localhost:8080/legumes.html にアクセスすると、マメ科植物のリストが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part starts when running the application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>興味深い部分は、アプリケーションをネイティブ実行ファイルとして実行するときに始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>create the native executable with `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative` でネイティブ実行ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>execute it with `./target/rest-json-quickstart-1.0.0-SNAPSHOT-runner`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./target/rest-json-quickstart-1.0-SNAPSHOT-runner` で実行します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No legumes there.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこには豆類はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the issue is that Quarkus was not able to determine the `Legume` class will require some reflection by analyzing the REST endpoints.  The JSON serialization library tries to get the list of fields of `Legume` and gets an empty list so it does not serialize the fields' data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のように、Quarkusが `Legume` クラスを判断できなかったことが問題となっており、REST エンドポイントを解析して何らかの反映が必要となります。JSONシリアライズライブラリは、 `Legume` のフィールドのリストを取得しようとすると空のリストを取得するので、フィールドのデータをシリアライズしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment, when JSON-B or Jackson tries to get the list of fields of a class, if the class is not registered for reflection, no exception will be thrown.  GraalVM will simply return an empty list of fields.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現時点では、JSON-BやJacksonがクラスのフィールドのリストを取得しようとしたときに、そのクラスがリフレクションに登録されていない場合、例外はスローされません。GraalVMは単に空のフィールドのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hopefully, this will change in the future and make the error more obvious.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>うまくいけば、将来的にはこれが変化して、エラーがより明白になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can register `Legume` for reflection manually by adding the `@RegisterForReflection` annotation on our `Legume` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Legume` クラスに `@RegisterForReflection` アノテーションを追加することで、手動で `Legume` を リフレクション用に登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's do that and follow the same steps as before:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それを実行して、今までと同じ手順を踏んでみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hit `Ctrl+C` to stop the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Ctrl+C` を叩いてアプリケーションを停止させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This time, you can see our list of legumes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回はマメ科の一覧が表示されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return _reactive types_ to handle asynchronous processing.  Quarkus recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write reactive and asynchronous code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期処理を処理するために _リアクティブ型_ を返すことができます。Quarkusでは、リアクティブで非同期なコードを書くために link:https://smallrye.io/smallrye-mutiny[Mutiny] の使用を推奨しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To integrate Mutiny and RESTEasy, you need to add the `quarkus-resteasy-mutiny` dependency to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny と RESTEasy を統合するには、 `quarkus-resteasy-mutiny` 依存関係をプロジェクトに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, your endpoint can return `Uni` or `Multi` instances:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、エンドポイントは `Uni` や `Multi` のインスタンスを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `Uni` when you have a single result.  Use `Multi` when you have multiple items that may be emitted asynchronously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>単一の結果がある場合は `Uni` を使用します。 `Multi` は、非同期的に放出される可能性のある複数の項目がある場合に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Uni` and `Response` to return asynchronous HTTP responses: `Uni&lt;Response&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` と `Response` を使用して、非同期 HTTP レスポンスを返すことができます: `Uni&lt;Response&gt;` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about Mutiny can be found in the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyについての詳細は、 link:getting-started-reactive#mutiny[Reactiveの入門ガイド] に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both HTTP request and response can be intercepted by providing `ContainerRequestFilter` or `ContainerResponseFilter` implementations respectively. These filters are suitable for processing the metadata associated with a message: HTTP headers, query parameters, media type, and other metadata. They also have the capability to abort the request processing, for instance when the user does not have the permissions to access the endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP リクエストとレスポンスの両方とも、それぞれ `ContainerRequestFilter` または `ContainerResponseFilter` の実装を提供することで、 インターセプトすることができます。これらのフィルタは、メッセージに関連付けられたメタデータを処理するのに適しています。HTTP ヘッダ、クエリパラメーター、メディアタイプ、その他のメタデータです。また、ユーザーがエンドポイントにアクセスする権限を持っていない場合など、リクエスト処理を中止する機能も持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's use `ContainerRequestFilter` to add logging capability to our service. We can do that by implementing `ContainerRequestFilter` and annotating it with the `@Provider` annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ContainerRequestFilter` を使用して、サービスにロギング機能を追加してみましょう。 `ContainerRequestFilter` を実装して、 `@Provider` アノテーションをつけることで実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, whenever a REST method is invoked, the request will be logged into the console:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、RESTメソッドが呼び出されるたびに、リクエストがコンソールにログとして記録されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] (CORS) is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[クロスオリジンリソース共有] (CORS)は、ウェブページ上の制限されたリソースを、最初のリソースが提供されたドメイン以外の別のドメインから要求できるようにするメカニズムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a CORS filter. Read the link:http-reference#cors-filter[HTTP Reference Documentation] to learn how to use it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはCORSフィルターが付属しています。使用方法については、 link:http-reference#cors-filter[HTTPリファレンスドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with GZip support (even though it is not enabled by default). The following configuration knobs allow to configure GZip support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはGZipサポートが搭載されています(デフォルトでは有効になっていませんが)。以下の設定ノブを使用して、GZipサポートを設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable Gzip support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gzipサポートを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the upper limit on deflated request body. This is useful to mitigate potential attacks by limiting their reach. The default value is `10M`.  This configuration option would recognize strings in this format (shown as a regular expression): `[0-9]+[KkMmGgTtPpEeZzYy]?`. If no suffix is given, assume bytes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフレーションされたリクエストボディの上限を設定します。これは、リーチを制限することで潜在的な攻撃を緩和するのに便利です。既定値は `10M` です。この設定オプションは、以下の形式の文字列を認識します(正規表現で表示されます): `[0-9]+[KkMmGgTtPpEeZzYy]?` .サフィックスが指定されていない場合は、バイトとみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once GZip support has been enabled you can use it on an endpoint by adding the `@org.jboss.resteasy.annotations.GZIP` annotation to your endpoint method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GZip サポートが有効になったら、エンドポイントメソッドに `@org.jboss.resteasy.annotations.GZIP` アノテーションを追加することで、エンドポイントで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to compress everything then we recommended that you use the `quarkus.http.enable-compression=true` setting instead to globally enable compression support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてを圧縮したい場合は、代わりに `quarkus.http.enable-compression=true` の設定を使用してグローバルに圧縮サポートを有効にすることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multipart Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチパートサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy supports multipart via the https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyは link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider] を介してマルチパートをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides an extension called `quarkus-resteasy-multipart` to make things easier for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、 `quarkus-resteasy-multipart` というエクステンションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension slightly differs from the RESTEasy default behavior as the default charset (if none is specified in your request) is UTF-8 rather than US-ASCII.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、デフォルトの文字セットが US-ASCII ではなく UTF-8 であるため、RESTEasy のデフォルトの動作とは若干異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure this behavior with the following configuration properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、以下の構成プロパティーで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Servlet compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーブレットとの互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, RESTEasy can either run directly on top of the Vert.x HTTP server, or on top of Undertow if you have any servlet dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、RESTEasyはVert.x HTTPサーバーの上で直接実行するか、サーブレットに依存している場合はUndertowの上で実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a result, certain classes, such as `HttpServletRequest` are not always available for injection. Most use-cases for this particular class are covered by JAX-RS equivalents, except for getting the remote client's IP. RESTEasy comes with a replacement API which you can inject: https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html[`HttpRequest`], which has the methods https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`] and https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`] to solve this problem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その結果、 `HttpServletRequest` のような特定のクラスが常にインジェクションに利用できるわけではありません。この特定のクラスのほとんどのユースケースは、リモートクライアントの IP を取得することを除いて、JAX-RS と同等のものでカバーされています。RESTEasy には、インジェクション可能な代替 API が付属しています。 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html[`HttpRequest`] これは以下のメソッドを持っています。 link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`] そして link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest.html#getRemoteHost--[`getRemoteHost()`] を解決するために、この問題を解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, the RESTEasy extension and link:rest-client[the REST Client extension] share the same infrastructure.  One important consequence of this consideration is that they share the same list of providers (in the JAX-RS meaning of the word).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、RESTEasyエクステンションと link:rest-client[RESTクライアントエクステンションは] 同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、(JAX-RSの意味での)プロバイダーのリストを共有しているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *server* calls by adding the `@ConstrainedTo(RuntimeType.SERVER)` annotation to your provider;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 *サーバー* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>only consider *client* calls by adding the `@ConstrainedTo(RuntimeType.CLIENT)` annotation to your provider.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 *クライアント* コールのみを考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No Need for `Application` Class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Application` クラスは不要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration via an application-supplied subclass of `Application` is supported, but not required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Application` のアプリケーションが提供するサブクラスによる設定もサポートされていますが、必須ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only a single JAX-RS application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>単一のJAX-RSアプリケーションのみ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In contrast to JAX-RS (and RESTeasy) running in a standard servlet-container, Quarkus only supports the deployment of a single JAX-RS application.  If multiple JAX-RS `Application` classes are defined, the build will fail with the message `Multiple classes have been annotated with @ApplicationPath which is currently not supported`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS(およびRESTeasy)が標準のサーブレットコンテナーで実行されているのとは対照的に、Quarkusは単一のJAX-RSアプリケーションのデプロイのみをサポートしています。複数のJAX-RS `Application` クラスが定義されている場合、ビルドは `Multiple classes have been annotated with @ApplicationPath which is currently not supported` というメッセージとともに失敗するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If multiple JAX-RS applications are defined, the property `quarkus.resteasy.ignoreApplicationClasses=true` can be used to ignore all explicit `Application` classes. This makes all resource-classes available via the application-path as defined by `quarkus.resteasy.path` (default: `/`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の JAX-RS アプリケーションが定義されている場合、プロパティー `quarkus.resteasy.ignoreApplicationClasses=true` を使用して、すべての明示的な `Application` クラスを無視することができます。これにより、すべてのリソースクラスが `quarkus.resteasy.path` で定義されたアプリケーションパスを介して利用できるようになります(デフォルトは `/` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle of Resources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus all JAX-RS resources are treated as CDI beans.  It's possible to inject other beans via `@Inject`, bind interceptors using bindings such as `@Transactional`, define `@PostConstruct` callbacks, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、すべてのJAX-RSリソースはCDI Bean として扱われます。 `@Inject` を介して他の Bean を注入したり、 `@Transactional` のようなバインディングを使用してインターセプターをバインドしたり、 `@PostConstruct` コールバックを定義したりすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no scope annotation declared on the resource class then the scope is defaulted.  The default scope can be controlled through the `quarkus.resteasy.singleton-resources` property.  If set to `true` (default) then a *single instance* of a resource class is created to service all requests (as defined by `@javax.inject.Singleton`).  If set to `false` then a *new instance* of the resource class is created per each request.  An explicit CDI scope annotation (`@RequestScoped`, `@ApplicationScoped`, etc.) always overrides the default behavior and specifies the lifecycle of resource instances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースクラスでスコープ注釈が宣言されていない場合は、スコープはデフォルトになります。デフォルトのスコープは `quarkus.resteasy.singleton-resources` プロパティーで制御できます。 `true` (デフォルト) に設定すると、( `@javax.inject.Singleton` で定義されているように) すべてのリクエストにサービスを提供するためのリソースクラスの *単一のインスタンス* が作成されます。 `false` に設定すると、各リクエストごとにリソースクラスの *新しい インスタンス* が作成されます。明示的な CDI スコープ注釈 ( `@RequestScoped` , `@ApplicationScoped` , など) は常にデフォルトの動作を上書きし、リソースインスタンスのライフサイクルを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conclusion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating JSON REST services with Quarkus is easy as it relies on proven and well known technologies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用したJSON RESTサービスの作成は、実績のあるよく知られたテクノロジーに依存しているため、簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, Quarkus further simplifies things under the hood when running your application as a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、Quarkusは、アプリケーションをネイティブ実行ファイルとして実行する際に、水面下の作業をさらに簡略化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is only one thing to remember: if you use `Response` and Quarkus can't determine the beans that are serialized, you need to annotate them with `@RegisterForReflection`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>覚えておくべきことは一つだけあります。 `Response` を使用していて、Quarkus がシリアライズされているBeanを特定できない場合は、 `@RegisterForReflection` を使って注釈を付ける必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The format for durations uses the standard `java.time.Duration` format.  You can learn more about it in the link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>期間のフォーマットは標準の `java.time.Duration` フォーマットを使用します。詳細は link:https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() javadoc] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide duration values starting with a number.  In this case, if the value consists only of a number, the converter treats the value as seconds.  Otherwise, `PT` is implicitly prepended to the value to obtain a standard `java.time.Duration` format.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数値で始まる期間の値を指定することもできます。この場合、値が数値のみで構成されている場合、コンバーターは値を秒として扱います。そうでない場合は、 `PT` が暗黙的に値の前に付加され、標準の `java.time.Duration` 形式が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended, that you have read the {quickstarts-tree-url}/kafka-quickstart[Kafka quickstart] before.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>事前に {quickstarts-tree-url}/kafka-quickstart[Kafka quickstart] を読んでおくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension for Kafka Streams allows for very fast turnaround times during development by supporting the Quarkus Dev Mode (e.g. via `./mvnw compile quarkus:dev`).  After changing the code of your Kafka Streams topology, the application will automatically be reloaded when the next input message arrives.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams用のQuarkusエクステンションを使用すると、Quarkus Dev Modeをサポートすることで、開発期間を非常に短縮することができます(例: `./mvnw compile quarkus:dev` を参照)。Kafka Streamsトポロジーのコードを変更した後、次の入力メッセージが到着すると、アプリケーションが自動的にリロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A recommended development set-up is to have some producer which creates test messages on the processed topic(s) in fixed intervals, e.g. every second and observe the streaming application's output topic(s) using a tool such as `kafkacat`.  Using the dev mode, you'll instantly see messages on the output topic(s) as produced by the latest version of your streaming application when saving.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>推奨される開発セットアップは、処理されたトピックに対して一定の間隔 (たとえば毎秒) でテストメッセージを作成するプロデューサを用意し、 `kafkacat` のようなツールを使用してストリーミング アプリケーションの出力トピックを観察することです。開発モードを使用すると、保存時にストリーミングアプリケーションの最新バージョンによって生成された出力トピッ ク上のメッセージを即座に見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the best development experience, we recommend applying the following configuration settings to your Kafka broker:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最高の開発環境を実現するために、以下の設定を Kafka ブローカーに適用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also specify the following settings in your Quarkus `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下の設定をQuarkusの `application.properties`で指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Together, these settings will ensure that the application can very quickly reconnect to the broker after being restarted in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの設定を併用することで、アプリケーションを開発モードで再起動した後に、非常に迅速にブローカに再接続できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to generate (random) temperature values in one component (named `generator`).  These values are associated to given weather stations and are written in a Kafka topic (`temperature-values`).  Another topic (`weather-stations`) contains just the master data about the weather stations themselves (id and name).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、(ランダムな)温度値を 1 つのコンポーネント ( `generator` ) で生成します。これらの値は、与えられた気象観測所に関連付けられ、Kafka トピック ( `temperature-values` ) に書き込まれます。別のトピック ( `weather-stations` ) には、気象観測所自体に関するマスターデータ (id と名前) だけが格納されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A second component (`aggregator`) reads from the two Kafka topics and processes them in a streaming pipeline:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2 つ目のコンポーネント ( `aggregator` ) は、2 つの Kafka トピックから読み込み、ストリーミングパイプラインで処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the two topics are joined on weather station id</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ウェザーステーション ID では、この2つのトピックが結合されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>per weather station the min, max and average temperature is determined</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各気象台ごとに最低、最高、平均気温が決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this aggregated data is written out to a third topic (`temperatures-aggregated`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この集約されたデータは、第三のトピック ( `temperatures-aggregated` ) に書き出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The data can be examined by inspecting the output topic.  By exposing a Kafka Streams https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html[interactive query], the latest result for each weather station can alternatively be obtained via a simple REST query.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>出力トピックを検査することで、データを調べることができます。Kafka Streams の link:https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html[対話型クエリ] を公開することで、各気象観測所の最新の結果を単純な REST クエリで取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The overall architecture looks like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>全体的なアーキテクチャはこんな感じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project with the temperature value producer.  Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、温度値プロデューサを持つ新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Reactive Messaging and Kafka connector extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドにより、Maven プロジェクトが作成され、Reactive Messaging と Kafka コネクターエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-reactive-messaging-kafka` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行して、プロジェクトに `smallrye-reactive-messaging-kafka` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Temperature Value Producer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>温度値プロデューサー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `producer/src/main/java/org/acme/kafka/streams/producer/generator/ValuesGenerator.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `producer/src/main/java/org/acme/kafka/streams/producer/generator/ValuesGenerator.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Reactive Messaging to dispatch the items from the returned `Multi` to `temperature-values`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>返却された `Multi` から `temperature-values` にアイテムを発送するように Reactive Messaging に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a Mutiny _stream_ (`Multi`) emitting a random temperature value every 0.5 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、0.5 秒ごとにランダムな温度値を放出する Mutiny _ストリーム_ ( `Multi` ) を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instruct Reactive Messaging to dispatch the items from the returned `Multi` (static list of weather stations) to `weather-stations`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>返された `Multi` (気象観測所の静的リスト) から `weather-stations` にアイテムをディスパッチするように、Reactive Messaging に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The two methods each return a _reactive stream_ whose items are sent to the streams named `temperature-values` and `weather-stations`, respectively.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この 2 つのメソッドは、それぞれ `temperature-values` と `weather-stations` という名前のストリームにアイテムが送信される _リアクティブストリーム_ を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Topic Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トピック構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The two channels are mapped to Kafka topics using the Quarkus configuration file `application.properties`.  For that, add the following to the file `producer/src/main/resources/application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つのチャンネルは、Quarkus設定ファイル `application.properties` を使用してKafkaトピックにマッピングされます。そのためには、ファイル `producer/src/main/resources/application.properties` に次のように追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configures the Kafka bootstrap server, the two topics and the corresponding (de-)serializers.  More details about the different configuration options are available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Kafka ブートストラップサーバー、2 つのトピック、および対応する (デ)シリアライザを設定します。さまざまな設定オプションの詳細については、Kafka ドキュメントの link:https://kafka.apache.org/documentation/#producerconfigs[Producer 設定] と link:https://kafka.apache.org/documentation/#consumerconfigs[Consumer 設定] のセクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Aggregator Maven Project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アグリゲータMavenプロジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the producer application in place, it's time to implement the actual aggregator application, which will run the Kafka Streams pipeline.  Create another project like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサアプリケーションを用意したら、Kafka Streams パイプラインを実行するアグリゲータアプリケーションを実装しましょう。このように別のプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This creates the `aggregator` project with the Quarkus extension for Kafka Streams and with RESTEasy support for Jackson.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、Kafka Streams用のQuarkusエクステンションとJackson用のRESTEasyサポートを備えた `aggregator` プロジェクトが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `kafka-streams` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `kafka-streams` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Pipeline Implementation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パイプラインの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's begin the implementation of the stream processing application by creating a few value objects for representing temperature measurements, weather stations and for keeping track of aggregated values.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ストリーム処理アプリケーションの実装を開始しましょう。温度測定、気象観測所を表現し、集約された値を追跡するためのいくつかの値オブジェクトを作成することから始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStation.java`, representing a weather station, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、次の内容でファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStation.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding the `@RegisterForReflection` annotation, it is ensured that this type can be instantiated reflectively when running the application in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@RegisterForReflection` アノテーションを追加することで、ネイティブモードでアプリケーションを実行しているときに、この型がリフレクションによってインスタンス化されることが保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/TemperatureMeasurement.java`, representing temperature measurements for a given station:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、指定されたステーションの温度測定値を表すファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/TemperatureMeasurement.java` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/Aggregation.java`, which will be used to keep track of the aggregated values while the events are processed in the streaming pipeline:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして最後に `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/Aggregation.java` 、イベントがストリーミング・パイプラインで処理されている間、集約された値を追跡するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, let's create the actual streaming query implementation itself in the `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/TopologyProducer.java` file.  All we need to do for that is to declare a CDI producer method which returns the Kafka Streams `Topology`; the Quarkus extension will take care of configuring, starting and stopping the actual Kafka Streams engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、実際のストリーミングクエリの実装自体を `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/TopologyProducer.java` ファイルで作成してみましょう。そのために必要なのは、Kafka Streams `Topology` を返す CDI プロデューサメソッドを宣言することだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `weather-stations` table is read into a `GlobalKTable`, representing the current state of each weather station</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`weather-stations` テーブルは、各気象台の現在の状態を表す `GlobalKTable` に読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `temperature-values` topic is read into a `KStream`; whenever a new message arrives to this topic, the pipeline will be processed for this measurement</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`temperature-values` トピックは `KStream` に読み込まれます。このトピックに新しいメッセージが到着するたびに、パイプラインはこの測定のために処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The message from the `temperature-values` topic is joined with the corresponding weather station, using the topic's key (weather station id); the join result contains the data from the measurement and associated weather station message</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`temperature-values` トピックからのメッセージは、トピックのキー (ウェザーステーション ID) を使用して、対応するウェザーステーションと結合されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The values are grouped by message key (the weather station id)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値はメッセージキー(ウェザーステーションID)によってグループ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Within each group, all the measurements of that station are aggregated, by keeping track of minimum and maximum values and calculating the average value of all measurements of that station (see the `Aggregation` type)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各グループ内では、最小値と最大値を追跡し、そのステーションのすべての測定値の平均値を計算することで、そのステーションのすべての測定値が集約されます( `Aggregation` タイプを参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The results of the pipeline are written out to the `temperatures-aggregated` topic</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パイプラインの結果は `temperatures-aggregated` トピックに書き出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka Streams extension is configured via the Quarkus configuration file `application.properties`.  Create the file `aggregator/src/main/resources/application.properties` with the following contents:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams エクステンションは、Quarkusの設定ファイル `application.properties` で設定します。ファイル `aggregator/src/main/resources/application.properties` を以下の内容で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The options with the `quarkus.kafka-streams` prefix can be changed dynamically at application startup, e.g. via environment variables or system properties.  `bootstrap-servers` and `application-server` are mapped to the Kafka Streams properties `bootstrap.servers` and `application.server`, respectively.  `topics` is specific to Quarkus: the application will wait for all the given topics to exist before launching the Kafka Streams engine.  This is to done to gracefully await the creation of topics that don't yet exist at application startup time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kafka-streams` `bootstrap-servers` と は、それぞれ Kafka Streams プロパティー と にマップされます。 `application-server` `bootstrap.servers` `application.server` `topics` は Quarkus に固有のもので、アプリケーションは Kafka Streams エンジンを起動する前に、指定したすべてのトピックが存在するのを待ちます。これは、アプリケーションの起動時にまだ存在しないトピックの作成をグレースフルに待つために行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can use `kafka.bootstrap.servers` instead of `quarkus.kafka-streams.bootstrap-servers` as you did in the _generator_ project above.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、上記の _ジェネレーター_ プロジェクトで行ったように、 `quarkus.kafka-streams.bootstrap-servers` の代わりに `kafka.bootstrap.servers` を使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the properties within the `kafka-streams` namespace are passed through as-is to the Kafka Streams engine.  Changing their values requires a rebuild of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`kafka-streams` ネームスペース内のすべてのプロパティーは、そのまま Kafka Streams エンジンに渡されます。プロパティーの値を変更するには、アプリケーションの再構築が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building and Running the Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのビルドと実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now can build the `producer` and `aggregator` applications:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`producer` と `aggregator` のアプリケーションをビルドできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of running them directly on the host machine using the Quarkus dev mode, we're going to package them into container images and launch them via Docker Compose.  This is done in order to demonstrate scaling the `aggregator` aggregation to multiple nodes later on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのdevモードを使ってホストマシン上で直接実行するのではなく、コンテナーイメージにパッケージ化してDocker Compose経由で起動します。これは、後で `aggregator` のアグリゲーションを複数のノードにスケーリングすることを実証するために行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Dockerfile` created by Quarkus by default needs one adjustment for the `aggregator` application in order to run the Kafka Streams pipeline.  To do so, edit the file `aggregator/src/main/docker/Dockerfile.jvm` and replace the line `FROM fabric8/java-alpine-openjdk8-jre` with `FROM fabric8/java-centos-openjdk8-jdk`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusがデフォルトで作成した `Dockerfile` は、Kafka Streamsパイプラインを実行するために、 `aggregator` アプリケーションに1つの調整が必要です。そのためには、 `aggregator/src/main/docker/Dockerfile.jvm` ファイルを編集して、 `FROM fabric8/java-alpine-openjdk8-jre` の行を `FROM fabric8/java-centos-openjdk8-jdk` に置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next create a Docker Compose file (`docker-compose.yaml`) for spinning up the two applications as well as Apache Kafka and ZooKeeper like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、2 つのアプリケーションを起動するための Docker Compose ファイル ( `docker-compose.yaml` ) を作成し、Apache Kafka と ZooKeeper と同様に以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To launch all the containers, building the `producer` and `aggregator` container images, run `docker-compose up --build`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`producer` と `aggregator` のコンテナーイメージをビルドして、すべてのコンテナーを起動するには、 `docker-compose up --build` を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of `QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS`, you can use `KAFKA_BOOTSTRAP_SERVERS`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS` の代わりに、 `KAFKA_BOOTSTRAP_SERVERS` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see log statements from the `producer` application about messages being sent to the "temperature-values" topic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`producer` アプリケーションから、"temperature-values" トピックに送信されたメッセージに関するログステートメントが表示されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now run an instance of the _debezium/tooling_ image, attaching to the same network all the other containers run in.  This image provides several useful tools such as _kafkacat_ and _httpie_:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで _debezium/tooling_ イメージのインスタンスを実行し、他のすべてのコンテナーが実行しているのと同じネットワークにアタッチします。このイメージは、 _kafkacat_ や _httpie_ などの便利なツールを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Within the tooling container, run _kafkacat_ to examine the results of the streaming pipeline:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツールコンテナー内で、 _kafkacatを_ 実行して、ストリーミングパイプラインの結果を調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should see new values arrive as the producer continues to emit temperature measurements, each value on the outbound topic showing the minimum, maximum and average temperature values of the represented weather station.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサが温度測定値を出力し続けると、新しい値が表示され、送信トピックの各値は、表現された気象観測所の最小、最大、および平均温度値を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interactive Queries</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インタラクティブクエリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Subscribing to the `temperatures-aggregated` topic is a great way to react to any new temperature values.  It's a bit wasteful though if you're just interested in the latest aggregated value for a given weather station.  This is where Kafka Streams interactive queries shine: they let you directly query the underlying state store of the pipeline for the value associated to a given key.  By exposing a simple REST endpoint which queries the state store, the latest aggregation result can be retrieved without having to subscribe to any Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`temperatures-aggregated` のトピックを購読することは、新しい気温の値に反応するための素晴らしい方法です。しかし、特定の気象観測所の最新の集計値だけに興味があるのであれば、少しもったいないです。そこで、Kafka Streams の対話型クエリが威力を発揮します。ステートストアをクエリするシンプルな REST エンドポイントを公開することで、Kafka トピックを購読しなくても最新の集計結果を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's begin by creating a new class `InteractiveQueries` in the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/InteractiveQueries.java`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、ファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/InteractiveQueries.java` 内に `InteractiveQueries` を作成することから始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>one more method to the `KafkaStreamsPipeline` class which obtains the current state for a given key:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`KafkaStreamsPipeline` クラスに、与えられたキーの現在の状態を取得するメソッドをもう一つ追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A value for the given station id was found, so that value will be returned</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定されたステーションIDの値が見つかったので、その値が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No value was found, either because a non-existing station was queried or no measurement exists yet for the given station</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>存在しないステーションがクエリされたか、指定されたステーションに測定がまだ存在しないため、値が見つかりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also create the method's return type in the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、メソッドの戻り値の型もファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java` に作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also create `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStationData.java`, which represents the actual aggregation result for a weather station:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、気象台の実際の集計結果を表す `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/WeatherStationData.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now can add a simple REST endpoint (`aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/WeatherStationEndpoint.java`), which invokes `getWeatherStationData()` and returns the data to the client:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、 `getWeatherStationData()` を呼び出してクライアントにデータを返すシンプルな REST エンドポイント ( `aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/WeatherStationEndpoint.java` ) を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on whether a value was obtained, either return that value or a 404 response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値が取得されたかどうかに応じて、その値を返すか、404 レスポンスを返すかのどちらかを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this code in place, it's time to rebuild the application and the `aggregator` service in Docker Compose:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコードを用意して、Docker Composeでアプリケーションと `aggregator` サービスをリビルドしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will rebuild the `aggregator` container and restart its service.  Once that's done, you can invoke the service's REST API to obtain the temperature data for one of the existing stations.  To do so, you can use `httpie` in the tooling container launched before:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `aggregator` コンテナーが再構築され、サービスが再起動されます。これが完了したら、サービスの REST API を呼び出して、既存のステーションの 1 つの温度データを取得することができます。そのためには、前に起動したツーリングコンテナで `httpie` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scaling Out</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケールアウト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very interesting trait of Kafka Streams applications is that they can be scaled out, i.e. the load and state can be distributed amongst multiple application instances running the same pipeline.  Each node will then contain a subset of the aggregation results, but Kafka Streams provides you with https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html#querying-remote-state-stores-for-the-entire-app[an API] to obtain the information which node is hosting a given key.  The application can then either fetch the data directly from the other instance, or simply point the client to the location of that other node.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams の非常に興味深い特性は、それらがスケールアウト可能であるということです。つまり、同じパイプラインを実行している複数のアプリケーションインスタンス間で負荷や状態を分散させることができます。各ノードには集約結果のサブセットが含まれますが、Kafka Streams は与えられたキーをホストしているノードの情報を取得するための link:https://kafka.apache.org/22/documentation/streams/developer-guide/interactive-queries.html#querying-remote-state-stores-for-the-entire-app[API] を提供しています。アプリケーションは、他のインスタンスから直接データを取得するか、クライアントにその他のノードの場所を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launching multiple instances of the `aggregator` application will make look the overall architecture like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`aggregator` アプリケーションの複数のインスタンスを起動すると、全体のアーキテクチャがこのようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `InteractiveQueries` class must be adjusted slightly for this distributed architecture:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`InteractiveQueries` クラスは、この分散型アーキテクチャ用に少し調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The streams metadata for the given weather station id is obtained</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>与えられたウェザーステーションIDのストリームメタデータが取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The given key (weather station id) is maintained by the local application node, i.e. it can answer the query itself</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>与えられたキー(ウェザーステーションID)はローカルのアプリケーションノードによって管理されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The given key is maintained by another application node; in this case the information about that node (host and port) will be returned</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>与えられたキーは別のアプリケーションノードによって管理されています; この場合、そのノードに関する情報(ホストとポート)が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `getMetaData()` method is added to provide callers with a list of all the nodes in the application cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getMetaData()` メソッドが追加され、アプリケーション・クラスター内の全ノードのリストを呼び出し元に提供するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GetWeatherStationDataResult` type must be adjusted accordingly:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GetWeatherStationDataResult` のタイプは、それに合わせて調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also the return type for `getMetaData()` must be defined (`aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java`):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `getMetaData()` のリターンタイプも定義しなければなりません ( `aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lastly, the REST endpoint class must be updated:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、RESTエンドポイントクラスを更新する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The data was found locally, so return it</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データはローカルで見つかったので、それを返す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The data is maintained by another node, so reply with a redirect (HTTP status code 303) if the data for the given key is stored on one of the other nodes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データは他のノードで管理されているので、指定されたキーのデータが他のノードに保存されている場合は、リダイレクト(HTTPステータスコード303)で返信する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No data was found for the given weather station id</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定されたウェザーステーションIDに対するデータが見つからなかった。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exposes information about all the hosts forming the application cluster</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションクラスターを形成しているすべてのホストの情報を表示する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now stop the `aggregator` service again and rebuild it.  Then let's spin up three instances of it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで再び `aggregator` サービスを停止してリビルドします。そして、3つのインスタンスを起動してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When invoking the REST API on any of the three instances, it might either be that the aggregation for the requested weather station id is stored locally on the node receiving the query, or it could be stored on one of the other two nodes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>3つのインスタンスのいずれかでREST APIを呼び出す場合、要求されたウェザーステーションIDの集約は、クエリを受信したノードにローカルに格納されるか、他の2つのノードのいずれかに格納されるかのどちらかであるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the load balancer of Docker Compose will distribute requests to the `aggregator` service in a round-robin fashion, we'll invoke the actual nodes directly.  The application exposes information about all the host names via REST:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Docker Composeのロードバランサーがラウンドロビン方式で `aggregator` サービスにリクエストを配信するので、実際のノードを直接呼び出すことにします。アプリケーションはREST経由ですべてのホスト名の情報を公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the data from one of the three hosts shown in the response (your actual host names will differ):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスに表示されている 3 つのホストのうちの 1 つからデータを取得します (実際のホスト名は異なります)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If that node holds the data for key "1", you'll get a response like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのノードがキー「1」のデータを保持している場合は、このようなレスポンスが得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Otherwise, the service will send a redirect:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そうでない場合、サービスはリダイレクトを送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also have _httpie_ automatically follow the redirect by passing the `--follow option`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `--follow option` を渡すことで _httpie_ が自動的にリダイレクトに従うようにすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running Natively</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension for Kafka Streams enables the execution of stream processing applications natively via GraalVM without further configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams用のQuarkusエクステンションを使用すると、GraalVMを介してストリーム処理アプリケーションをネイティブ実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run both the `producer` and `aggregator` applications in native mode, the Maven builds can be executed using the `native` profile:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`producer` と `aggregator` アプリケーションをネイティブモードで実行するには、 `native` プロファイルを使用して Maven ビルドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create an environment variable named `QUARKUS_MODE` and with value set to "native":</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `QUARKUS_MODE` という名前の環境変数を作成し、値を"native"に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is used by the Docker Compose file to use the correct `Dockerfile` when building the `producer` and `aggregator` images.  The Kafka Streams application can work with less than 50 MB RSS in native mode.  To do so, add the `Xmx` option to the program invocation in `aggregator/src/main/docker/Dockerfile.native`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、 `producer` と `aggregator` のイメージをビルドする際に正しい `Dockerfile` を使用するために Docker Compose ファイルで使用されます。Kafka Streams アプリケーションは、ネイティブモードでは 50 MB 未満の RSS で動作します。そのためには、 `aggregator/src/main/docker/Dockerfile.native` のプログラム呼び出しに `Xmx` オプションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now start Docker Compose as described above (don't forget to rebuild the container images).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、上記のようにDocker Composeを起動します(コンテナーイメージのリビルドを忘れずに)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka-streams` will automatically add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-health` のエクステンションを使用している場合は、 `quarkus-kafka-streams` が自動的に以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a readiness health check to validate that all topics declared in the `quarkus.kafka-streams.topics` property are created,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.kafka-streams.topics` プロパティーで宣言されたすべてのトピックが作成されているかどうかを検証するための Readiness ヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a liveness health check based on the Kafka Streams state.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams の状態に基づく Liveness ヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/health` endpoint of your application you will have information about the state of the Kafka Streams and the available and/or missing topics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、アプリケーションの `/q/health` エンドポイントにアクセスすると、Kafka Streams の状態や、利用可能なトピックや不足しているトピックについての情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an example of when the status is `DOWN`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ステータスが `DOWN` になった場合の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liveness health check. Also available at `/q/health/live` endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liveness ヘルスチェック。 `/q/health/live` エンドポイントでも利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Readiness health check. Also available at `/q/health/ready` endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Rediness ヘルスチェック。 `/q/health/ready` エンドポイントでも利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So as you can see, the status is `DOWN` as soon as one of the `quarkus.kafka-streams.topics` is missing or the Kafka Streams `state` is not `RUNNING`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、ご覧のように `quarkus.kafka-streams.topics` のいずれかが欠けているか、Kafka Streams の `state` が `RUNNING` でないとすぐにステータスが `DOWN` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no topics are available, the `available_topics` key will not be present in the `data` field of the `Kafka Streams topics health check`.  As well as if no topics are missing, the `missing_topics` key will not be present in the `data` field of the `Kafka Streams topics health check`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トピックがない場合、 `Kafka Streams topics health check` .の `data` フィールドに `available_topics` キーは表示されません。また、トピックがない場合は、 `Kafka Streams topics health check` の `data` フィールドに `missing_topics` キーは表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can of course disable the health check of the `quarkus-kafka-streams` extension by setting the `quarkus.kafka-streams.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もちろん、 `quarkus-kafka-streams` エクステンションのヘルスチェックを無効にすることもできます。`application.properties` の中で `quarkus.kafka-streams.health.enabled` を `false` にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously you can create your liveness and readiness probes based on the respective endpoints `/q/health/live` and `/q/health/ready`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>言うまでもなく、それぞれのエンドポイント `/q/health/live` と `/q/health/ready` に対して自前の Liveness および Rediness プローブを作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of the liveness check:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Liveness チェックの一例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `state` is coming from the `KafkaStreams.State` enum.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`state` は `KafkaStreams.State` Enum から来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of the readiness check:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、Rediness チェックの一例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going Further</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can build stream processing applications using Quarkus and the Kafka Streams APIs, both in JVM and native modes.  For running your KStreams application in production, you could also add health checks and metrics for the data pipeline.  Refer to the Quarkus guides on link:micrometer[Micrometer], link:microprofile-metrics[MicroProfile Metrics], and link:microprofile-health[health checks] to learn more.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusとKafka Streams APIを使用して、JVMとネイティブモードの両方でストリーム処理アプリケーションを構築する方法を紹介しました。KStreamsアプリケーションを本番環境で実行するために、データパイプラインのヘルスチェックやメトリクスを追加することもできます。詳細については、 link:micrometer[Micrometer] 、 link:microprofile-metrics[MicroProfile Metrics] 、 link:microprofile-health[ヘルスチェック] に関するQuarkusのガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If enabled, when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを有効にすると、アプリケーションの `/q/health/ready` エンドポイントにアクセスしたときに、接続検証ステータスに関する情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative Events (Cloud Events).  It is also usable as a standalone service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqyは、Quarkusのサーバーレス戦略の一環で、AWS Lambda、Azure Functions、Knative、Knative Events（クラウドイベント）など、様々なFaaS環境にデプロイ可能な関数を書くためのポータブルなJava APIを提供することを目的としています。スタンドアロンサービスとしても利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Funqy is an abstraction that spans multiple different cloud/function providers and protocols it has to be a very simple API and thus, might not have all the features you are used to in other remoting abstractions.  A nice side effect though is that Funqy is as optimized and as small as possible.  This means that because Funqy sacrifices a little bit on flexibility, you'll get a framework that has little to no overhead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy は複数の異なるクラウド/ファンクションプロバイダやプロトコルにまたがる抽象化なので、非常にシンプルな API でなければならず、あなたが使い慣れている他のリモーティング抽象化で提供される機能をすべて備えているわけではないかもしれません。しかし、良い副作用として、Funqyは可能な限り最適化されていて小さいということがあります。つまり、Funqy は柔軟性を少し犠牲にしているので、オーバーヘッドがほとんどないフレームワークを手に入れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy API is simple.  Annotate a method with `@Funq`.  This method may only have one optional input parameter and may or may not return a response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy API はシンプルです。メソッドに `@Funq` をアノテーションします。このメソッドはオプションの入力パラメータを1つだけ持つことができ、レスポンスを返すこともあれば返さないこともあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java classes can also be used as input and output and must follow the Java bean convention and have a default constructor.  The Java type that is declared as the parameter or return type is the type that will be expected by the Funqy runtime.  Funqy does type introspection at build time to speed up boot time, so any derived types will not be noticed by the Funqy marshalling layer at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javaクラスは入力と出力としても使用でき、Java Bean の規約に従う必要があり、デフォルトのコンストラクタを持たなければなりません。パラメータや戻り値の型として宣言されたJavaの型は、Funqyのランタイムが期待する型です。Funqyは起動時間を短縮するためにビルド時に型のイントロスペクションを行いますので、派生型は実行時にFunqyのマーシャリング層に意識されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's an example of using a POJO as input and output types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>POJO を入出力タイプとして使用した例をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Async Reactive Types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期リアクティブ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy supports the https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` reactive type as a return type.  The only requirement is that the `Uni` must fill out the generic type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqyは戻り値の型として link:https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` リアクティブ型をサポートしています。唯一の要件は、 `Uni` がジェネリック型を保持しなければならないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The function name defaults to the method name and is case sensitive.  If you want your function referenced by a different name, parameterize the `@Funq` annotation as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>関数名の既定値はメソッド名で、大文字と小文字を区別します。関数を別の名前で参照したい場合は、 `@Funq` アノテーションを次のようにパラメータ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Funqy DI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy DI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Funqy Java class is a Quarkus Arc component and supports dependency injection through CDI or Spring DI.  Spring DI requires including the `quarkus-spring-di` dependency in your build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各Funqy JavaクラスはQuarkus Arcコンポーネントであり、CDIまたはSpring DIによる依存性注入をサポートしています。Spring DIでは、ビルドに `quarkus-spring-di` 依存関係を含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default object lifecycle for a Funqy class is `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy クラスのデフォルトのオブジェクトライフサイクルは `@Dependent` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキスト注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy API will usually not allow you to inject or use abstractions that are specific to a protocol (i.e. HTTP) or function API (i.e. AWS Lambda).  There are exceptions to the rule though and you may be able to inject contextual information that is specific to the environment you are deploying in.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy APIは通常、プロトコル(例:HTTP)や関数API(例:AWS Lambda)に固有の抽象化を注入したり使用したりすることはできません。しかし、ルールには例外があり、デプロイしている環境に固有のコンテキスト情報を注入できるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムに固有のコンテキスト情報を注入することはお勧めしません。 Function を移植性の高いものにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contextual information is injected via the `@Context` annotation which can be used on a function parameter or a class field.  A good example is the `CloudEvent` interface that comes with our Funqy Knative Cloud Events integration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキスト情報は `@Context` アノテーションを介して注入され、関数パラメータやクラスフィールドで使用することができます。良い例としては、Funqy Knative Cloud Events 統合に付属する `CloudEvent` インターフェイスがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Should I Use Funqy?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy を使うべきか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of Funqy is to allow you to write cross-provider functions so that you can move off of your current function provider if, for instance, they start charging you a lot more for their service.  Another reason you might not want to use Funqy is if you need access specific APIs of the target function environment.  For example, developers often want access to the AWS Context on Lambda.  In this case, we tell them they may be better off using the link:amazon-lambda[Quarkus Amazon Lambda] integration instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqyの目的は、クロスプロバイダの関数を書けるようにすることで、例えば、現在の Function プロバイダがサービスの料金を高くし始めた場合に、現在の Function プロバイダから離れることができるようにすることです。Funqyを使わないもう一つの理由は、ターゲットの Function 環境の特定のAPIにアクセスする必要がある場合です。例えば、開発者はLambda上のAWSコンテキストにアクセスしたいことがよくあります。この場合、代わりに link:amazon-lambda[Quarkus Amazon Lambda] インテグレーションを使った方が良いかもしれないと伝えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes the Quarkus built-in authentication mechanisms for HTTP based FORM, BASIC and Mutual TLS authentication as well as the proactive authentication.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、HTTPベースのFORM認証、BASIC認証、相互TLS認証、およびプロアクティブ認証のためのQuarkusの組み込み認証メカニズムについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベーシック認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable basic authentication set `quarkus.http.auth.basic=true`. You must also have at least one extension installed that provides a username/password based `IdentityProvider`, such as link:security-jdbc[Elytron JDBC].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベーシック認証を有効にするには、 `quarkus.http.auth.basic=true` を設定します。また、ユーザー名/パスワードベースの `IdentityProvider` を提供するエクステンションを少なくとも 1 つインストールしておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security#identity-providers[Security Identity Providers] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security#identity-providers[セキュリティー ID プロバイダ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also see link:security-testing#configuring-user-information[Configuring User Information in application.properties] section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:security-testing#configuring-user-information[application.propertiesでユーザー情報の設定]セクションも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Form Based Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フォームベース認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides form based authentication that works in a similar manner to traditional Servlet form based auth. Unlike traditional form authentication, the authenticated user is not stored in an HTTP session, as Quarkus does not provide clustered HTTP session support. Instead the authentication information is stored in an encrypted cookie, which can be read by all members of the cluster (provided they all share the same encryption key).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、従来のサーブレットのフォームベースの認証と同様の方法で動作するフォームベースの認証を提供します。従来のフォーム認証とは異なり、Quarkusはクラスター化されたHTTPセッションをサポートしていないため、認証されたユーザーはHTTPセッションに保存されません。代わりに、認証情報は暗号化されたCookieに保存され、クラスターのすべてのメンバーが読み取ることができます(すべてのメンバーが同じ暗号化キーを共有している場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encryption key can be set using the `quarkus.http.auth.session.encryption-key` property, and it must be at least 16 characters long. This key is hashed using SHA-256 and the resulting digest is used as a key for AES-256 encryption of the cookie value. This cookie contains an expiry time as part of the encrypted value, so all nodes in the cluster must have their clocks synchronized. At one minute intervals a new cookie will be generated with an updated expiry time if the session is in use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>暗号化キーは `quarkus.http.auth.session.encryption-key` プロパティーを使って設定でき、少なくとも 16 文字の長さでなければなりません。このキーは SHA-256 を使ってハッシュ化され、その結果のダイジェストがクッキー値の AES-256 暗号化のキーとして使用されます。このクッキーは暗号化された値の一部として有効期限を含んでいますので、クラスター内のすべての ノードはクロックを同期させなければなりません。1 分間隔で、セッションが使用中であれば、更新された有効期限時間を持つ新しいクッキーが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to configure form based auth:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のプロパティーを使用して、フォームベース認証を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides mTLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはmTLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this authentication method, you should first enable SSL for your application. For more details, check the link:http-reference#ssl[Supporting secure connections with SSL] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この認証方法を利用するには、まずアプリケーションでSSLを有効にする必要があります。詳細については、 link:http-reference#ssl[SSLによるセキュアな接続のサポート]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once your application is accepting secure connections, the next step is to configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the certificates that your application should trust as well as how your application should ask for certificates when a client (e.g.: browser or another service) tries to access one of its protected resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが安全な接続を受け入れたら、次のステップは、アプリケーションが信頼すべきすべての証明書を保持する `quarkus.http.ssl.certificate.trust-store-file` を設定し、クライアント(例: ブラウザや他のサービス)が保護されたリソースにアクセスしようとしたときに、アプリケーションがどのように証明書を要求するかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a key store where the server's private key is located.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバーの秘密鍵が置かれている鍵ストアを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a trust store from where the trusted certificates are going to be loaded from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>信頼された証明書がロードされるトラストストアを構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines that the server should *always* ask certificates from clients. You can relax this behavior by using `REQUEST` so that the server should still accept requests without a certificate. Useful when you are also supporting authentication methods other than mTLS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバーが *常に*クライアントからの証明書を要求することを定義します。 `REQUEST` を使用することで、この動作を緩和することができます。mTLS 以外の認証方法もサポートしている場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines a policy where only authenticated users should have access to resources from your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証されたユーザーのみがアプリケーションからリソースにアクセスできるようにするポリシーを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the incoming request matches a valid certificate in the truststore, your application should be able to obtain the subject by just injecting a `SecurityIdentity` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信したリクエストがトラストストアの有効な証明書と一致したら、アプリケーションは以下のように `SecurityIdentity` を注入するだけでサブジェクトを取得できるようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the subject</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>subjectの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should also be able to get the certificate as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下のように証明書を取得できるようにしておきましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the certificate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>証明書の取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The information from the client certificate can be used to enhance Quarkus `SecurityIdentity`. For example, one can add new roles after checking a client certificate subject name, etc.  Please see the link:security-customization#security-identity-customization[SecurityIdentity Customization] section for more information about customizing Quarkus `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアント証明書からの情報は、Quarkus `SecurityIdentity` を強化するために使用することができます 。たとえば、クライアント証明書のサブジェクト名などを確認した後に、新しいロールを追加することができます。Quarkus `SecurityIdentity` のカスタマイズの詳細については、 link:security-customization#security-identity-customization[SecurityIdentity]のカスタマイズのセクションを参照してください 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます(ターゲットページが認証を必要としない場合でも)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that requests with an invalid credential will always be rejected, even for public pages. You can change this behavior and only authenticate when required by setting `quarkus.http.auth.proactive=false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、公開ページであっても、無効なクレデンシャルを持つリクエストは常に拒否されることを意味します。この動作を変更して、 `quarkus.http.auth.proactive=false` を設定することで必要な場合のみ認証を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you disable proactive authentication then the authentication process will only be run when an identity is requested, either because there are security rules that requires the user to be authenticated, or due to programatic access to the current identity.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロアクティブ認証を無効にすると、認証プロセスは ID が要求されたときにのみ実行されます。これは、ユーザーの認証を必要とするセキュリティー ルールがある場合、または現在の ID へのプログラム的なアクセスがある場合のいずれかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that if proactive authentication is in use accessing the `SecurityIdentity` is a blocking operation. This is because authentication may not have happened yet, and accessing it may require calls to external systems such as databases that may block. For blocking applications this is no problem, however if you are have disabled authentication in a reactive application this will fail (as you cannot do blocking operations on the IO thread). To work around this you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation`, and call the `Uni&lt;SecurityIdentity&gt; getDeferredIdentity();` method. You can then subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロアクティブ認証を使用している場合、 `SecurityIdentity` へのアクセスはブロック操作になることに注意してください。これは、認証がまだ行われていない可能性があるためで、アクセスする際にデータベースなどの外部システムへの呼び出しが必要となり、ブロックされる可能性があるからです。ブロッキングアプリケーションの場合は問題ありませんが、リアクティブアプリケーションで認証を無効にしている場合は失敗します (IO スレッドでブロッキング操作を行うことができないため)。これを回避するには、 `io.quarkus.security.identity.CurrentIdentityAssociation` のインスタンスを `@Inject` し、 `Uni&lt;SecurityIdentity&gt; getDeferredIdentity();` メソッドを呼び出す必要があります。そして、結果として得られる `Uni` を購読し、認証が完了して ID が利用可能になったときに通知を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the authentication security constraints are enforced before the JAX-RS chain starts.  Disabling the proactive authentication effectively shifts this process to the moment when the JAX-RS chain starts running thus making it possible to use JAX-RS `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException` if required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、認証セキュリティー制約は、JAX-RSチェーンが開始される前に適用されます。プロアクティブ認証を無効にすると、このプロセスがJAX-RSチェーンの実行開始時に効果的に移行するため、必要に応じてJAX-RS `ExceptionMapper` を使用して、 `io.quarkus.security.AuthenticationFailedException` などのQuarkus Security認証例外をキャプチャすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用してリアクティブアプリケーションを作成する方法と、Quarkusが提供するさまざまなリアクティブ機能について説明します。このガイドでは、以下の内容を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A quick glance at the Quarkus engine and how it enables reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエンジンの概要と、それがどのようにリアクティブを可能にしているかを簡単に説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A brief introduction to Mutiny - the reactive programming library used by Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>概説Mutiny - Quarkusによって使用されているリアクティブプログラミングライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな JAX-RS エンドポイントの作成（非同期、ストリーム...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータベースアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のリアクティブAPIの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solutions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started-reactive` と `getting-started-reactive-crud` のディレクトリにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x (https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはリアクティブです。ボンネットの下を見ると、Quarkusアプリケーションの動力源となっているリアクティブエンジンを見つけることができます。このエンジンはEclipse Vert.x（ https://vertx.io ）です。すべてのネットワークI/Oは、ノンブロッキングでリアクティブなVert.xエンジンを通過します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:quarkus-reactive-stack.png[alt="Quarkusはリアクティブなエンジンをベースとしている", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つの例を挙げて、その仕組みを説明してみましょう。入ってくるHTTPリクエストを想像してみてください。Quarkusに組み込まれたHTTPサーバー（Vert.x）がリクエストを受信し、アプリケーションにルーティングします。リクエストが _命令的な_ メソッド（従来のJAX-RS、 `@Blocking` ...で注釈されたコード）をターゲットにしている場合、ルーティング層は _ワーカースレッド_ でリソースメソッドを呼び出し、データが利用可能になるとレスポンスを書き込みます。今のところ、目新しいものも目立ったものもありません。次の図は、この動作を示しています。この場合、アプリケーションコードはワーカースレッドで呼び出され、ビジネスロジックはそのスレッドをブロックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:http-blocking-sequence.png[alt="命令的な route を使ったときの挙動", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with `@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、HTTPリクエストがリアクティブなメソッド（RESTEasy Reactiveを使用したJAX-RS、リアクティブなルート、 `@Incoming` メソッドは `@Blocking` ...でアノテーションされていない）をターゲットにしている場合、ルーティング層はI/Oスレッド上でルートを呼び出し、より高い同時実行性とパフォーマンスなどの多くの利点を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:http-reactive-sequence.png[alt="リアクティブな route を使ったときの挙動", width="70%"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはI/Oスレッドを使用してコードを呼び出すため、コンテキストスイッチを節約し、大規模なスレッドプール管理を回避し、リソースの利用率を向上させます。ただし、コードはそのスレッドをブロックしてはいけ *ませ* ん。なぜでしょうか？なぜなら、I/O スレッドは複数の同時リクエストを処理するために使用されます。リクエストの処理がいくつかのI/Oを実行する必要があるために進行できなくなるとすぐに、これらのI/Oをスケジュールし、継続(continuation)を渡します。別のリクエストを処理できるスレッドを解放します。スケジュールされたI/Oが完了すると、I/Oスレッドに戻って継続(continuation)が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>結果として、多くのQuarkusコンポーネントは、データベースアクセス（PostgreSQL、MySQL、Mongoなど）、アプリケーションサービス（メール、テンプレートエンジンなど）、メッセージング（Kafka、AMQPなど）など、リアクティブを念頭に置いて設計されています。しかし、このモデルの恩恵を十分に受けるためには、アプリケーションコードはノンブロッキングで書かれなければなりません。そこで、リアクティブ API を持つことが究極の武器となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers two types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/smallrye/smallrye-mutiny[Mutiny] は、非同期アクションを表現したり構成したりすることができるリアクティブプログラミングライブラリです。2つのタイプがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.mutiny.Multi` - マルチアイテム（バックプレッシャー付き）ストリーム用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらのタイプも lazy で、サブスクリプションパターンに従います。計算は、実際に必要とされる場合にのみ開始されます (すなわち、サブスクライバがエンリストした場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable API, and the result does not require too much knowledge around reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` も `Multi` もイベント駆動型の API を公開しています: 与えられたイベント (成功、失敗など) に対して何をしたいかを表現します。これらのAPIはグループ(操作の種類)に分けられており、より表現力を高め、1つのクラスに100個ものメソッドをアタッチすることを避けています。主な操作の種類は、失敗に反応するもの、完了するもの、アイテムを操作するもの、抽出するもの、収集するものなどです。ナビゲーション可能なAPIでスムーズなコーディングを実現し、結果的にリアクティブ周りの知識をあまり必要としないようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more complex.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://www.reactive-streams.org/ `Multi` は Reactive Streams `Publisher` を実装しているので、Reactive Streams のバックプレッシャーメカニズムを実装しています。 `Uni` へのサブスクリプションは結果に興味があることを示すのに十分なので、 `Uni` は `Publisher` を実装していません。これは、Reactive Streams のサブスクリプション/リクエスト式がより複雑であるため、よりシンプルでスムーズな API のアイデアを念頭に置いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのリアクティブな面と命令的な面の統合を受け入れた `Uni` と `Multi` は、両方とも命令的構造への橋渡しをしてくれます。たとえば、 `Multi` を `Iterable` に変換したり、 `Uni` .NET で生成されたアイテムを _待っ_ たりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny allows converting `Unis` and `Multis` from and to RX Java and Reactor types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この時点で、あなたがRxJavaやReactorのユーザーであれば、お馴染みの `Flowable` , `Single` , `Flux` , , `Mono` ... Mutinyでは、 `Unis` と `Multis` をRX JavaやReactorの型に変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、Vert.xはどうでしょうか？Vert.xのAPIはMutiny型を使っても利用できます。以下のスニペットは、Vert.x Web Clientの使い方を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so on in your reactive pipeline.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後になりますが、MutinyにはMicroProfile Context Propagationとの統合が組み込まれているので、リアクティブパイプラインでトランザクションやトレーサビリティデータなどを伝搬することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But enough talking, let's get our hands dirty!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>話はもういい、手を汚すんだ！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでリアクティブアプリケーションを実装するには、いくつかの方法があります。このガイドでは、Quarkusのリアクティブエンジンの恩恵を受けるRESTEasyの実装であるRESTEasy Reactiveを使用します。デフォルトでは、I/Oスレッド上のHTTPエンドポイントを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_従来の_ RESTEasy を使用することは可能ですが、 `quarkus-resteasy-mutiny` エクステンションを追加する必要があり、メソッドは _ワーカースレッド_ 上で呼び出されます。つまり、リアクティブプログラミングを使用するとはいえ、ワーカースレッドを必要とし、その目的は達成されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use forward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cmd を使用する場合は、(前方スラッシュを使用しないでください `\` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Powershell を使用する場合は、 `-D` のパラメータを二重引用符で囲みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started-reactive`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./getting-started-reactive` 内に以下が生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/hello` で公開されている `org.acme.quickstart.ReactiveGreetingResource` リソース </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive JAX-RS resources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな JAX-RS リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト作成時に、 `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` ファイルは以下の内容で作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "Hello RESTEasy Reactive" to requests on "/hello".  As it uses RESTEAsy Reactive, this method is called on the I/O thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは非常にシンプルなRESTエンドポイントで、"/hello"上のリクエストに対して"Hello RESTEasy Reactive"を返します。RESTEAsy Reactiveを使用しているので、このメソッドはI/Oスレッド上で呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use `@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_ワーカースレッド_ でこのメソッドを呼び出すようにQuarkusに指示するには、 `io.smallrye.common.annotation.Blocking` アノテーションを付けます。メソッドやクラスで `@Blocking` を使用したり、 `Application` クラスをアノテーションすることで、アプリケーション全体で を使用できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create a `ReactiveGreetingService` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、以下の内容の `ReactiveGreetingService` クラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, edit the `ReactiveGreetingResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `ReactiveGreetingResource` クラスを以下の内容に合わせて編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReactiveGreetingService` クラスには、 `Uni` を生成する簡単なメソッドが含まれています。この例では、結果として得られるアイテムがすぐに出力されますが、非同期 API で `Uni` を生成することは想像できます。これについては、このガイドで後ほど説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, start the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、以下でアプリケーションを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行したら、 http://localhost:8080/hello/greeting/neo を開いて、期待通りのグリーティングメッセージが表示されているか確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、非同期の結果を返すだけでした。このセクションでは、複数のアイテムを伝えるストリームを使ってアプリケーションを拡張します。これらのストリームは Kafka や他のデータソースからのものでも構いませんが、物事をシンプルに保つために、定期的にグリーティングメッセージを生成するだけにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingService`, add the following method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReactiveGreetingService` で、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`import io.smallrye.mutiny.Multi;` と `import java.time.Duration;` のステートメントを追加する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates a greeting message every second and stops after `count` messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1秒ごとに greeting メッセージを生成し、 `count` メッセージの後に停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `ReactiveGreetingResource` add the following method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReactiveGreetingResource` で、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエンドポイントは、アイテムをJSON配列としてクライアントにストリームします。メッセージの名前と数は、パスパラメータを使用してパラメータ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So calling the endpoint produces something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、エンドポイントを呼び出すと、次のようなものが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can also generate Server-Sent Event responses by returning a `Multi`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `Multi` を返すことで Server-Sent Event レスポンスを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the `@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどのスニペットとの違いは、生成される型と、各イベントの型を示す `@RestSseElementType` アノテーションだけです。 `@Produces` アノテーションは `SERVER_SENT_EVENTS` を定義しているので、JAX-RS は各（入れ子になった）イベントのコンテンツタイプを知るために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`import org.jboss.resteasy.reactive.RestSseElementType;` の文を追加する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can see the result using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下で結果を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ API の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to interact with your database in a non-blocking and reactive way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはMutinyモデルを使用した多くのリアクティブAPIを提供しています。このセクションでは、リアクティブPostgreSQLドライバを使用して、ノンブロッキングでリアクティブな方法でデータベースと対話する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new project using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下で新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application is interacting with a PostgreSQL database, so you need one:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションはPostgreSQLデータベースと対話しているので、DBが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>続いて、データソースを設定してみましょう。 `src/main/resources/application.properties` を開き、以下の内容を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the application gets initialized.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の3行はデータソースを定義しています。最後の行は、アプリケーションが初期化されたときにいくつかの項目を挿入するかどうかを示すためにアプリケーションで使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、 _エンティティを_ 作成しましょう。以下の内容で `org.acme.reactive.crud.Fruit` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この _エンティティに_ は、データベースから行を検索、更新、削除するためのいくつかのフィールドとメソッドが含まれています。これらのメソッドは、結果が取得されると非同期的に生成されるので、 `Unis` または `Multis` のいずれかを返します。反応型PostgreSQLクライアントは既に `Uni` と `Multi` のインスタンスを提供していることに注意してください。つまり、データベースからの結果を _ビジネスに適した_ オブジェクトに変換するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にデータベースを初期化する目的で、以下の内容の `DBInit` という名前のクラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、この `Fruit` クラスを `FruitResource` . `FruitResource` クラスを以下の内容に合わせて編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリソースは、 `Fruit` クラスが生成した結果に基づいて `Uni` と `Multi` のインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどの例では、Quarkusが提供する _サービス_ を使用しています。また、Vert.xクライアントを直接使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、 `quarkus-vertx` の エクステンションが存在することを確認してください。存在しない場合は、以下のコマンドを実行して エクステンションを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or add `quarkus-vertx` into your dependencies manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、手動で `quarkus-vertx` を依存関係に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x APIのMutinyバージョンがあります。このAPIは独立してインポートできるいくつかのアーティファクトに分かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 http://smallrye.io/smallrye-reactive-utils/apidocs/ で利用可能な API を確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example.  Add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を挙げてみましょう。以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x Web ClientのMutiny APIを提供します。すると、以下のようにWebクライアントを利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 important points:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>重要なポイントは2つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションされた Vert.x インスタンスは、Vert.x の Mutiny バリアントである `io.vertx.mutiny.core.Vertx` タイプを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Web クライアントは `io.vertx.mutiny.ext.web.client.WebClient` から作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny version of the Vert.x APIs also offers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x APIのMutinyバージョンも提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block the event loop / IO thread that way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sendAndAwait` . `andAwait` のような `andAwait` メソッドは、結果が得られるまで呼び出し元のスレッドがブロックされていることを示しています。そのような方法でイベントループ/IOスレッドをブロックしないように注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be triggered.  `andForget` manages this for you and manage the subscription.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`andForget` `writeAndForget` のような `Uni` を返すメソッドが利用可能です。`andForget` は操作の成否を示す結果の `Uni` を必要としないことを示しています。しかし、サブスクライブしないと操作が発動しないことを覚えておいてください。`andForget` はこれを管理してくれるうえに、サブスクリプションも管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`toBlockingIterable` / `toBlockingStream` メソッドは、Vert.x `ReadStream` をブロッキング可能な iterable またはブロッキング可能な `java.util.Stream` に変換することができます。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny は RxJava 2 と Project Reactor の型を `Uni` と `Multi` に変換するユーティリティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RxJava 2 converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RxJava 2のコンバータは以下の依存関係にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、RxJava 2 の型を返す API ( `Completable` , `Single` , `Maybe` , `Observable` , `Flowable` ) を持っている場合は、以下のように `Unis` と `Multis` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into RxJava types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Unis` と `Multis` を RxJava 型に変換することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Project Reactor converters are available in the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Project Reactorコンバータは、以下の依存関係で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、Reactorの型を返すAPI( `Mono` , `Flux` )を持っている場合は、以下のように `Unis` と `Multis` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also transform `Unis` and `Multis` into Reactor types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `Unis` と `Multis` を Reactor タイプに変換することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` can be created from a `CompletionStage` or from a `Supplier&lt;CompletionStage&gt;`. For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CompletionStage` , `CompletableFuture` , `Publisher` を使った API に対面している場合、双方向に変換することができます。まず、 `Uni` も `Multi` も `CompletionStage` から作成することも、 `Supplier&lt;CompletionStage&gt;` から作成することもできます。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or failure emitted by the `Uni`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni` 上で、あなたはまた、 `subscribeAsCompletionStage()` を使用して `CompletionStage` を生成することができます。 `Uni` によって放出されたアイテムまたは障害を取得するだろう `CompletionStage` を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a `Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`createFrom().publisher(Publisher)` を使って `Unis` と `Multis` を `Publisher` のインスタンスから作成することもできます。 `Uni` を `toMulti` を使って `Publisher` に変換することもできます。実際、 `Multi` は `Publisher` を実装しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a few examples:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusでのリアクティブについて紹介します。Quarkusの機能の中には、すでにリアクティブになっているものがたくさんあります。以下のリストでは、いくつかの例を紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mailer[Sending email]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:mailer[メール送信]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:mongodb#reactive[MongoDB] と link:mongodb-panache#reactive[MongoDBをPanacheで] link:mongodb#reactive[使う]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:reactive-routes[Using reactive routes]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:reactive-routes[リアクティブルートの使用]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DynamoDB is a scalable AWS managed *NoSQL* database.  It supports both key-value and document data models, that enables to have a flexible schema for your data.  This extension provides functionality that allows the client to communicate with the service when running in Quarkus.  You can find more information about DynamoDB at https://aws.amazon.com/dynamodb/[the Amazon DynamoDB website].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DynamoDBは、AWSで管理されているスケーラブルな *NoSQL* データベースです。DynamoDBはキーバリューとドキュメントの両方のデータモデルをサポートしており、データに対して柔軟なスキーマを持つことができます。このエクステンションは、Quarkusで実行しているときにクライアントがサービスと通信できるようにする機能を提供します。DynamoDBの詳細については、 link:https://aws.amazon.com/dynamodb/[Amazon DynamoDBのウェブサイト] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The DynamoDB extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).  Keep in mind it's actively developed and does not support yet all the features available in SDK 1.x such as https://github.com/aws/aws-sdk-java-v2/issues/36[Document APIs] or https://github.com/aws/aws-sdk-java-v2/issues/35[Object Mappers]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DynamoDBエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x] をベースにしています。1.xのコードベースを大幅に書き換えたもので、2つのプログラミングモデル(ブロッキングと非同期)を提供しています。このエクステンションは積極的に開発されており、 link:https://github.com/aws/aws-sdk-java-v2/issues/36[ドキュメントAPI] や link:https://github.com/aws/aws-sdk-java-v2/issues/35[オブジェクトマッパー] のようなSDK 1.xで利用可能な機能はまだサポートしていないことを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use the DynamoDB locally and on AWS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、RESTサービスでDynamoDBをローカルとAWS上で利用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, Docker for your system to run DynamoDB locally for testing purposes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションで、Dockerを使ってシステムをテスト用にローカルでDynamoDBを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start working with DynamoDB is to run a local instance as a container.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DynamoDBで作業を始める最も簡単な方法は、ローカルインスタンスをコンテナーとして実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a DynamoDB instance that is accessible on port `8000`.  You can check it's running by accessing the web shell on `http://localhost:8000/shell`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ポート `8000` でアクセス可能な DynamoDB インスタンスを起動します。`http://localhost:8000/shell` のWebシェルにアクセスして、実行中であることを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Have a look at the https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html[Setting Up DynamoDB Local guide] for other options to run DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DynamoDBを実行するための他のオプションについては、 link:https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html[Setting Up DynamoDB Local ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `http://localhost:8000/shell` in your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラザで `http://localhost:8000/shell` を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy and paste the following code to the shell and run it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードをシェルにコピー&amp;ペーストして実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you can use the AWS SDKs with DynamoDB, you must get an AWS access key ID and secret access key.  For more information, see https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SettingUp.DynamoWebService.html[Setting Up DynamoDB (Web Service)].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DynamoDBでAWS SDKを利用する前に、AWSのアクセスキーIDとシークレットアクセスキーを取得する必要があります。詳しくは、 link:https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SettingUp.DynamoWebService.html[DynamoDB(Webサービス)] のセットアップを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend to use the AWS CLI to provision the table:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テーブルのプロビジョニングにはAWS CLIを利用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built here allows to manage elements (fruits) stored in Amazon DynamoDB.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで構築したアプリケーションでは、Amazon DynamoDBに格納されている要素(果物)を管理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `amazon-dynamodb-quickstart` {quickstarts-tree-url}/amazon-dynamodb-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `amazon-dynamodb-quickstart` {quickstarts-tree-url}/amazon-dynamodb-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and DynamoDB Client extensions.  After this, the `amazon-dynamodb` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RS、Mutiny、DynamoDBクライアントエクステンションをインポートするMaven構造を生成します。 `pom.xml` この後、RESTEasyのMutinyサポートと同様に、 `amazon-dynamodb` エクステンションが追加されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of fruits. The example application will demonstrate the two programming models supported by the extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このサンプルでは、果物のリストを管理するアプリケーションを作成します。サンプルアプリケーションでは、エクステンションでサポートされている2つのプログラミングモデルをデモします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer. The static `from` method creates a bean based on the `Map` object provided by the DynamoDB client response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことは、JSONシリアライズレイヤーによって要求されるということです。static `from` メソッドは、DynamoDB クライアントのレスポンスで提供された `Map` オブジェクトをベースにBeanを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.dynamodb.AbstractService` that will consist of helper methods that prepare DynamoDB request objects for reading and adding items to the table.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、テーブルにアイテムを読み込んで追加するためのDynamoDBリクエストオブジェクトを準備するヘルパーメソッドで構成される `org.acme.dynamodb.AbstractService` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a `org.acme.dynamodb.FruitSyncService` that will be the business layer of our application and stores/loads the fruits from DynamoDB using the synchronous client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、アプリケーションのビジネスレイヤーとなる `org.acme.dynamodb.FruitSyncService` を作成し、同期クライアントを使用して DynamoDB からフルーツを保存/ロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.dynamodb.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `org.acme.dynamodb.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitSyncService` to list/add new fruits.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実装はとても簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義し、 `FruitSyncService` を使って新しいフルーツをリストアップ/追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both DynamoDB clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.  Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses the `java.net.URLConnection` HTTP client, so you need to add a URL connection client dependency to the `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DynamoDBクライアント(syncとasync)はどちらも、 `src/main/resources` ディレクトリーで提供されている `application.properties` ファイルを介して設定可能です。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、エクステンションは `java.net.URLConnection` HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` ファイルに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use the Apache HTTP client instead, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代わりにApache HTTPクライアントを使いたい場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And add following dependency to the application `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、以下の依存関係をアプリケーションの `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're going to use a local DynamoDB instance, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ローカルのDynamoDBインスタンスを使用する場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.region` - It's required by the client, but since you're using a local DynamoDB instance you can pick any valid AWS region.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.dynamodb.aws.region` - クライアントが必要としますが、ローカルのDynamoDBインスタンスを使用しているので、有効なAWSリージョンを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.dynamodb.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-id` と `secret-access-key` の任意の値で設定します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to work with an AWS account, you'd need to set it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWSアカウントで作業したい場合は、次のようにして設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.region` you should set it to the region where you provisioned the DynamoDB table,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.dynamodb.aws.region` 、DynamoDBテーブルをプロビジョニングしたリージョンに設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.dynamodb.aws.credentials.type` - use the `default` credentials provider chain that looks for credentials in this order:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.dynamodb.aws.credentials.type` - `default` クレデンシャル・プロバイダ・チェーンを使用して、この順番でクレデンシャルを検索します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.dynamodb.FruitAsyncService` that will be similar to our `FruitSyncService` but using an asynchronous programming model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`FruitSyncService` と同様の `org.acme.dynamodb.FruitAsyncService` を作成しますが、非同期プログラミングモデルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous code, we create `Uni` instances from the `CompletionStage` objects returned by the asynchronous DynamoDB client, and then transform the emitted item.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどのコードでは、非同期のDynamoDBクライアントから返された `CompletionStage` オブジェクトから `Uni` インスタンスを作成し、発行されたアイテムを変換しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create an asynchronous REST resource that consumes this async service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、この非同期サービスをコンシュームする非同期RESTリソースを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And add Netty HTTP client dependency to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `pom.xml` に Netty HTTP クライアントの依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>adding the `smallrye-health` Quarkus extension to your project using the `quarkus-maven-plugin`: +</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`smallrye-health` Quarkusエクステンションをプロジェクトに追加するには、 `quarkus-maven-plugin`. +</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or simply adding the following Maven dependency: +</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、単に以下のMaven依存関係を追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This technology is considered {extension-status}.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この技術は、{extension-status}と考えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability nor long term presence in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_experimental_ モードでは、アイデアを成熟させるために早期のフィードバックが求められます。ソリューションが成熟するまでの間、プラットフォームの安定性や長期的な存在を保証するものではありません。フィードバックは link:https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] や link:https://github.com/quarkusio/quarkus/issues[GitHubの課題管理] で受け付けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _preview_, backward compatibility and presence in the ecosystem is not guaranteed.  Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_preview_ では、下位互換性やエコシステムでの存在は保証されていません。具体的な改善には設定や API の変更が必要になるかもしれませんが、 _stable_ 版になるための計画は現在進行中です。フィードバックは link:https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] や link:https://github.com/quarkusio/quarkus/issues[GitHub の課題管理] で受け付けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Being _stable_, backward compatibility and presence in the ecosystem are taken very seriously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_stable_ では、下位互換性があること、エコシステムの中に存在していることが、非常に重要だと考えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a full list of possible extension statuses, check our https://quarkus.io/faq/#extension-status[FAQ entry].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>とりうるエクステンションステータスの完全なリストについては、 link:https://quarkus.io/faq/#extension-status[FAQの項目を] 参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. Use:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、アプリケーションを実行する準備が整いました。以下を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and you should see output similar to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のような出力が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus:dev Output</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus:dev 出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also generate the native executable with `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw clean package -Pnative` でネイティブの実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property Nam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public void setMessage(String message) {
        this.message = message;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public void setMessage(String message) {
        this.message = message;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference covers how to write applications that run and then exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファレンスでは、実行して終了するアプリケーションの書き方について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Command Mode Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different approaches that can be used to implement applications that exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>終了するアプリケーションを実装するためには、2つの異なるアプローチがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and have Quarkus run this method automatically</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` を実装し、Quarkusがこのメソッドを自動的に実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and a Java main method, and use the Java main method to launch Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` とJava mainメソッドを実装し、Java mainメソッドを使用してQuarkusを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this document the `QuarkusApplication` instance is referred to as the application main, and a class with a Java main method is the Java main.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、 `QuarkusApplication` インスタンスをアプリケーション mainと呼び、Java mainメソッドを持つクラスを Java mainと呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;.&gt; The `@QuarkusMain` annotation tells Quarkus that this is the main entry point.  &lt;.&gt; The `run` method is invoked once Quarkus starts, and the application stops when it finishes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;.&gt; `@QuarkusMain` アノテーションは、これがメインのエントリーポイントであることをQuarkusに伝えます。  &lt;.&gt; `run` メソッドは、Quarkusが起動すると呼び出され、終了するとアプリケーションが停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contexts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get access to your application beans and services, be aware that a `@QuarkusMain` instance is an application scoped bean by default. It has access to singletons, application and dependent scoped beans. If you want to interact with beans that requires a request scope put a `@ActivateRequestContext` on your `run()` method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションBeanやサービスにアクセスするために、 `@QuarkusMain` インスタンスはデフォルトでapplicationスコープのBeanであることに注意してください。singleton、application、dependentスコープのBeanへのアクセスを持っています。requestスコープを必要とするBeanと対話したい場合は、 `run()` メソッドに `@ActivateRequestContext` を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This let `run()` have access to methods like `listAll()` and `query*` methods on a Panache Entity. Without it you will eventually get a `ContextNotActiveException` when accessing such classes/beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `run()` は Panache Entity 上の `listAll()` や `query*` のようなメソッドにアクセスできるようになります。これがないと、そのようなクラスやBeanにアクセスするときに、最終的には `ContextNotActiveException` に直面することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Main method</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is effectively the same as running the `HelloWorldMain` application main directly, but has the advantage it can be run from the IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `HelloWorldMain` アプリケーション mainを直接実行するのと実質的には同じですが、IDE から実行できるという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class that implements `QuarkusApplication` and has a Java main then the Java main will be run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` を実装したクラスで Java main がある場合は Java main が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended that a Java main perform very little logic, and just launch the application main. In development mode the Java main will run in a different ClassLoader to the main application, so may not behave as you would expect.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java mainはほとんどロジックを実行せず、アプリケーション mainを起動するだけにすることをお勧めします。開発モードでは、Java mainはアプリケーション mainとは異なるClassLoaderで実行されるので、期待通りの動作をしないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Main Methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のmainメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to have multiple main methods in an application, and select between them at build time.  The `@QuarkusMain` annotation takes an optional 'name' parameter, and this can be used to select the main to run using the `quarkus.package.main-class` build time configuration option. If you don't want to use annotations this can also be used to specify the fully qualified name of a main class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション内に複数のmainメソッドを持ち、ビルド時にそれらの間で選択することが可能です。 `@QuarkusMain` アノテーションはオプションの 'name' パラメーターを取り、 `quarkus.package.main-class` ビルド時設定オプションを使用して実行するmainを選択するために使用できます。アノテーションを使用したくない場合は、メインクラスの完全修飾名を指定するために使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the `@QuarkusMain` with no name (i.e. the empty string) will be used, and if it is not present and `quarkus.package.main-class` is not specified then Quarkus will automatically generate a main class that just runs the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、名前のない `@QuarkusMain` (つまり空文字列)が使用され、それが存在せず `quarkus.package.main-class` が指定されていない場合は、Quarkus はアプリケーションを実行するだけのメインクラスを自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `name` of `@QuarkusMain` must be unique (including the default of the empty string). If you have multiple `@QuarkusMain` annotations in your application the build will fail if the names are not unique.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusMain` の `name` は一意である必要があります(デフォルトの空文字列を含む)。アプリケーション内に複数の `@QuarkusMain` アノテーションがある場合、名前が一意でないとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command mode lifecycle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running a command mode application the basic lifecycle is as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのアプリケーションを実行する場合、基本的なライフサイクルは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the `QuarkusApplication` main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` mainメソッドの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shut down Quarkus and exit the JVM after the main method returns</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mainメソッドがreturnされた後にQuarkusをシャットダウンし、JVMを終了する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shutdown is always initiated by the application main thread returning. If you want to run some logic on startup, and then run like a normal application (i.e. not exit) then you should call `Quarkus.waitForExit` from the main thread (A non-command mode application is essentially just running an application that just calls `waitForExit`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シャットダウンは常にアプリケーションのメインスレッドがreturnされることで開始されます。起動時に何らかのロジックを実行して、通常のアプリケーションのように実行したい場合 (つまり終了しない) は、メインスレッドから `Quarkus.waitForExit` を呼び出す必要があります (非コマンドモードのアプリケーションは、基本的に `waitForExit` を呼び出すだけのアプリケーションを実行しているだけです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to shut down a running application and you are not in the main thread then you should call `Quarkus.asyncExit` in order to unblock the main thread and initiate the shutdown process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行中のアプリケーションをシャットダウンしたい場合、メインスレッドにいない場合は、 `Quarkus.asyncExit` を呼び出してメインスレッドのブロックを解除し、シャットダウン処理を開始する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also for command mode applications the dev mode is supported. When running `mvn compile quarkus:dev`, the command mode application is executed and on press of the Enter key, is restarted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コマンドモードアプリケーションでは、開発モードにも対応しています。 `mvn compile quarkus:dev` を実行しているときは、コマンドモードアプリケーションを実行し、Enter キーを押すと再起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As command mode applications will often require arguments to be passed on the commandline, this is also possible in dev mode via:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのアプリケーションでは、コマンドラインで引数を渡す必要があることが多く、これは開発モードでも可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides integration with https://jbang.dev[jbang] which allows you to write Java scripts/applications requiring no Maven nor Gradle to get running.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは link:https://jbang.dev[jbang] との統合を提供しており、MavenもGradleも必要としないJavaスクリプト/アプリケーションを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will see how you can write a REST application using just a single Java file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、1つのJavaファイルだけを使ってRESTアプリケーションを書く方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM installed if you want to run in native mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行する場合は、GraalVM がインストールされていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally we would link to a Git repository to clone but in this case there is no additional files than the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常はGitリポジトリにリンクしてクローンするのですが、今回は以下のみで追加ファイルはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint with a single source file, no additional build files like `pom.xml` or `build.gradle` needed. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 `hello` エンドポイントを提供する簡単なアプリケーションを、 `pom.xml` や `build.gradle` のような追加のビルドファイルを必要とせず、単一のソースファイルで作成します。依存関係の注入を実証するために、このエンドポイントは `greeting` Beanを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the initial file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初期ファイルの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a Java file. jbang lets you create an initial version using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、Javaファイルが必要です。jbangを使うと初期バージョンを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a .java file that you can directly run on Linux and macOS, i.e. `./quarkusapp.java` - on Windows you need to use `jbang quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jbang quarkusapp.java` このコマンドは.javaファイルを生成し、LinuxやmacOS、つまり `./quarkusapp.java` で直接実行できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This initial version will print `Hello World` when run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この初期バージョンは、実行すると `Hello World` が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたら、 `quarkusapp.java` を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will find at the top a line looking like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一番上にこんな感じの行があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This line is what on Linux and macOS allows you to run it as a script. On Windows this line is ignored.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この行は、LinuxやmacOSでスクリプトとして実行できるようにするためのものです。Windowsではこの行は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The next line</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Is illustrating how you add dependencies to this script. This is a feature of `jbang`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このスクリプトに依存関係を追加する方法を説明しています。これは `jbang` の機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go ahead and update this line to include the `quarkus-resteasy` dependency like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この行を更新して、 `quarkus-resteasy` 依存関係を含むようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, run `jbang quarkusapp.java` and you will see `jbang` resolving this dependency and building the jar with help from Quarkus' jbang integration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、 `jbang quarkusapp.java` を実行すると、 `jbang` がこの依存関係を解決し、Quarkus の jbang 統合の助けを借りて jar をビルドしていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now the application does nothing new.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ、アプリケーションは何も新しいことをしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I edit this file and get content assist?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルを編集してコンテンツアシストを受けるにはどうすればいいですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As there is nothing but a `.java` file, most IDE's don't handle content assist well.  To work around that you can run `jbang edit quarkusapp.java`, this will print out a directory that will have a temporary project setup you can use in your IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`.java` ファイルしかないので、ほとんどの IDE はコンテンツアシストをうまく処理できません。これを回避するには、 `jbang edit quarkusapp.java` を実行すると、IDE で使用できる一時的なプロジェクトの設定があるディレクトリーが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux/macOS you can run `&lt;idecommand&gt; `jbang edit quarkusapp.java``.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Linux/macOSでは、 `&lt;idecommand&gt; `jbang edit quarkusapp.java`` で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you add dependencies while editing you can get jbang to automatically refresh the IDE project using `jbang edit --live=&lt;idecommand&gt; quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>編集中に依存関係を追加した場合は、 `jbang edit --live=&lt;idecommand&gt; quarkusapp.java` を使用して、IDE プロジェクトを自動的に更新するように jbang を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let us replace the class with one that uses Quarkus features:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、Quarkusの機能を使用するクラスに置き換えてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple class with a main method that starts Quarkus with a REST endpoint, returning "hello" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントでQuarkusを起動し、「/hello」上のリクエストに「hello」を返すメインメソッドを持つ非常にシンプルなクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why is the `main` method there?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜそこに `main` メソッドがあるのか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `main` method is currently needed for the `jbang` integration to work - we might remove this requirement in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jbang` の統合が機能するためには、現在 `main` メソッドが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run the application you will see Quarkus start up.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを実行すると、Quarkusが起動するのがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use: `jbang quarkusapp.java`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用方法: `jbang quarkusapp.java`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After that, hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、 `CTRL+C` を叩いてアプリケーションを停止させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why is `quarkus-resteasy` not resolved?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-resteasy` が解決されないのはなぜですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this second run you should not see a line saying it is resolving `quarkus-resteasy` as jbang caches the dependency resolution between runs.  If you want to clear the caches to force resolution use `jbang cache clear`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この2回目の実行では、jbangが実行間の依存関係の解決をキャッシュしているため、 `quarkus-resteasy` を解決しているという行は表示されないはずです。キャッシュをクリアして強制的に解決したい場合は `jbang cache clear` を利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  You can learn more about it in the link:cdi-reference[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの依存性インジェクションは、Quarkusのアーキテクチャに合わせて調整されたCDIベースの依存性インジェクションソリューションであるArCをベースにしています。ArCの詳細については、 link:cdi-reference[コンテキストと依存性注入ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを修正してコンパニオンBeanを追加してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Normally you would add a separate class, but as we are aiming to have it all in one file you will add a nested class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常は別のクラスを追加しますが、一つのファイルにまとめようとしているので、入れ子クラスを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following *inside* the `quarkusapp` class body.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkusapp` クラスのボディ *内に* 以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use of nested static public classes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネストされた静的パブリッククラスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using a nested static public class instead of a top level class for two reasons:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トップレベルのクラスではなく、ネストされた静的パブリッククラスを使用しているのには、2つの理由があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang currently does not support multiple source files.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangは現在、複数のソースファイルをサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Java frameworks relying on introspection have challenges using top level classes as they are not as visible as public classes; and in Java there can only be one top level public class in a file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イントロスペクションに依存するすべてのJavaフレームワークは、トップレベルのクラスを使用することに課題があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `quarksapp` class to inject the `GreetingService` and create a new endpoint using it, you should end up with something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarksapp` クラスを編集して `GreetingService` を注入し、それを使って新しいエンドポイントを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run `jbang quarkusapp.java` you can check what the new end point returns:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、 `jbang quarkusapp.java` を実行すると、新しいエンドポイントが何を返すかを確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that is unexpected, why is it returning `hello null` and not `hello quarkus`?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、予想に反して、なぜそれは `hello quarkus` ではなく `hello null` を返しているのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reason is that JAX-RS `@PathParam` relies on the `-parameters` compiler flag to be set to be able to map `{name}` to the `name` parameter.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、JAX-RS `@PathParam` は `{name}` を `name` パラメーターにマッピングできるように `-parameters` コンパイラフラグを設定することに依存しているためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We fix that by adding the following comment instruction to the file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ファイルに以下のコメント命令を追加することで修正しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now when you run with `jbang quarkusapp.java` the end point should return what you expect:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、 `jbang quarkusapp.java` で実行すると、エンドポイントは期待通りの値を返すようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To debug the application you use `jbang --debug quarkusapp.java` and you can use your IDE to connect on port 4004; if you want to use the more traditional Quarkus debug port you can use `jbang --debug=5005 quarkusapp.java`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jbang --debug=5005 quarkusapp.java` アプリケーションのデバッグには `jbang --debug quarkusapp.java` を使用し、IDEを使用してポート4004で接続することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: `jbang` debugging always suspends thus you need to connect the debugger to have the application run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注意: `jbang` デバッグは常にサスペンドしているので、アプリケーションを実行させるにはデバッガーを接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use logging in Quarkus scripting with jbang you do as usual, with configuring a logger, i.e.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangを使ってQuarkusスクリプトでロギングを使用するには、通常通りロガーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get it to work you need to add a Java option to ensure the logging is initialized properly, i.e.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを動作させるには、ロギングが適切に初期化されるように Java オプションを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With that in place running `jbang quarkusapp.java` will log and render as expected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで `jbang quarkusapp.java` を実行すると、期待通りにログが記録され、レンダリングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `//Q:CONFIG &lt;property&gt;=&lt;value&gt;` to set up static configuration for your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`//Q:CONFIG &lt;property&gt;=&lt;value&gt;` を使用して、アプリケーションの静的設定を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I.e. if you wanted to add the `smallrye-openapi` and `swagger-ui` extensions and have the Swagger UI always show up you would add the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `smallrye-openapi` と `swagger-ui` のエクステンションを追加して Swagger UI を常に表示させたい場合は、以下のように追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now during build the `quarkus.swagger-ui.always-include` will be generated into the resulting jar and `http://0.0.0.0:8080/q/swagger-ui` will be available when run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでビルド中に `quarkus.swagger-ui.always-include` が生成され、結果の jar と実行時に `http://0.0.0.0:8080/q/swagger-ui` が利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running as a native application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブアプリケーションとしての実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have the `native-image` binary installed and `GRAALVM_HOME` set, you can get the native executable built and run using `jbang --native quarkusapp.java`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`native-image` バイナリーがインストールされていて `GRAALVM_HOME` が設定されている場合は、 `jbang --native quarkusapp.java` を使用してネイティブの実行ファイルをビルドして実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This native build will take some time on first run but any subsequent runs (without changing `quarkusapp.java`) will be close to instant thanks to jbang cache:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このネイティブビルドは最初の実行時には時間がかかりますが、その後の実行では ( `quarkusapp.java` を変更せずに) jbang キャッシュのおかげですぐに実行できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to get started with Quarkus or write something quickly, Quarkus Scripting with jbang lets you do that. No Maven, no Gradle - just a Java file. In this guide we outlined the very basics on using Quarkus with jbang; if you want to learn more about what jbang can do, go see https://jbang.dev.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使い始めたい場合や、何かを素早く書きたい場合は、Quarkus Scripting with jbangを使用すると、それが可能になります。MavenもGradleも必要ありません。このガイドでは、jbangを使ったQuarkusの使い方の基本を説明しました。jbangで何ができるのかをもっと知りたい方は、 https://jbang.dev をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Runtime configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One can customize `HttpAuthenticationMechanism` by registering a CDI implementation bean.  In the example below the custom authenticator delegates to `JWTAuthMechanism` provided by `quarkus-smallrye-jwt`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI実装Beanを登録することで、 `HttpAuthenticationMechanism` をカスタマイズすることができます。以下の例では、カスタム認証機能は `quarkus-smallrye-jwt` によって提供される `JWTAuthMechanism` にデリゲートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Identity Customization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー・アイデンティティのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Internally, the identity providers create and update an instance of the `io.quarkus.security.identity.SecurityIdentity` class which holds the principal, roles, credentials which were used to authenticate the client (user) and other security attributes. An easy option to customize `SecurityIdentity` is to register a custom `SecurityIdentityAugmentor`. For example, the augmentor below adds an addition role:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>内部的には、アイデンティティ・プロバイダは、プリンシパル、役割、クライアント(ユーザー)の認証に使用されたクレデンシャル、 およびその他のセキュリティー属性を保持する `io.quarkus.security.identity.SecurityIdentity` クラスのインスタンスを作成して更新します。 `SecurityIdentity` をカスタマイズする簡単なオプションは、カスタム `SecurityIdentityAugmentor` を登録することです。例えば、以下のエクステンションは、追加のロールを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is another example showing how to use the client certificate available in the current link:security-built-in-authentication#mutual-tls[Mutual TLS] request to add more roles:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、現在の link:security-built-in-authentication#mutual-tls[相互TLS] リクエストで利用可能なクライアント証明書を使用して、より多くのロールを追加する方法を示すもう一つの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If more than one custom `SecurityIdentityAugmentor` is registered then they will be considered equal candidates and invoked in random order.
You can enforce the order by implementing a default `SecurityIdentityAugmentor#priority` method. Augmentors with higher priorities will be invoked first.
===
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のカスタム `SecurityIdentityAugmentor` が登録されている場合、それらは同等の候補とみなされ、ランダムな順序で呼び出されます。
デフォルトの `SecurityIdentityAugmentor#priority` メソッドを実装することで順番を強制することができます。優先度の高いエクステンションが最初に起動されます。
===
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom JAX-RS SecurityContext</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム JAX-RS SecurityContext</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use JAX-RS `ContainerRequestFilter` to set a custom JAX-RS `SecurityContext` then make sure `ContainerRequestFilter` runs in the JAX-RS pre-match phase by adding a `@PreMatching` annotation to it for this custom security context to be linked with Quarkus `SecurityIdentity`, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS `ContainerRequestFilter` を使用してカスタム JAX-RS `SecurityContext` を設定する場合は、 `ContainerRequestFilter` が JAX-RS のプレマッチフェーズで実行されていることを確認し、このカスタムセキュリティーコンテキストが Quarkus `SecurityIdentity` とリンクされるように `@PreMatching` アノテーションを追加します。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disabling Authorization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可の無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a good reason to disable the authorization (for example, when testing) then you can register a custom `AuthorizationController`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可を無効にする正当な理由がある場合(テスト時など)は、カスタムの `AuthorizationController` を登録してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering Security Providers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー プロバイダの登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default providers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのプロバイダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in native mode, the default behavior for GraalVM native executable generation is to only include the main "SUN" provider unless you have enabled SSL, in which case all security providers are registered. If you are not using SSL, then you can selectively register security providers by name using the `quarkus.security.security-providers` property. The following example illustrates configuration to register the "SunRsaSign" and "SunJCE" security providers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行している場合、GraalVMネイティブ実行ファイル生成のデフォルトの動作は、SSLを有効にしていない限り、メインの「SUN」プロバイダのみを含めるようになっています。SSLを有効にしている場合は、すべてのセキュリティープロバイダが登録されます。SSLを使用していない場合は、 `quarkus.security.security-providers` プロパティーを使用して、セキュリティープロバイダを名前で選択的に登録することができます。以下の例では、「SunRsaSign」と「SunJCE」のセキュリティープロバイダを登録するための設定を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティー プロバイダの設定例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>BouncyCastle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jce.provider.BouncyCastleProvider` JCE provider then please set a `BC` provider name:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.bouncycastle.jce.provider.BouncyCastleProvider` JCE プロバイダを登録する必要がある場合は、 `BC` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティープロバイダの例 BouncyCastleの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and add the BouncyCastle provider dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、BouncyCastleプロバイダ依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle JSSE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>BouncyCastle JSSE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSE provider and use it instead of the default SunJSSE provider then please set a `BCJSSE` provider name:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSE プロバイダを登録して、デフォルトの SunJSSE プロバイダの代わりに使用する必要がある場合は、 `BCJSSE` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle JSSE Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティープロバイダの例 BouncyCastle JSSE設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and add the BouncyCastle TLS dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、BouncyCastleのTLS依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle FIPS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>BouncyCastle FIPS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` JCE provider then please set a `BCFIPS` provider name:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` JCE プロバイダを登録する必要がある場合は、 `BCFIPS` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle FIPS Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティープロバイダの例 BouncyCastleのFIPS設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and add the BouncyCastle FIPS provider dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、BouncyCastle FIPSプロバイダの依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>BouncyCastle JSSE FIPS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>BouncyCastle JSSE FIPS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to register an `org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSE provider and use it in combination with `org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` instead of the default SunJSSE provider then please set a `BCFIPSJSSE` provider name:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのSunJSSEプロバイダではなく、 `org.bouncycastle.jsse.provider.BouncyCastleJsseProvider` JSSEプロバイダを登録して、 `org.bouncycastle.jcajce.provider.BouncyCastleFipsProvider` と組み合わせて使用する必要がある場合は、 `BCFIPSJSSE` プロバイダ名を設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Security Providers BouncyCastle FIPS JSSE Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティープロバイダの例 BouncyCastle FIPS JSSE設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the keystore and truststore type and provider are set to `BCFKS` and `BCFIPS`.  One can generate a keystore with this type and provider like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>keystore と truststore のタイプとプロバイダが `BCFKS` と `BCFIPS` に設定されていることに注意してください。このタイプとプロバイダでは、以下のようにキーストアを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are going to use security in a reactive environment, you will likely need SmallRye Context Propagation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな環境でセキュリティーを使用する場合は、SmallRye Context Propagationが必要になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will allow you to propagate the identity throughout the reactive callbacks. You also need to make sure you are using an executor that is capable of propagating the identity (e.g. no `CompletableFuture.supplyAsync`), to make sure that Quarkus can propagate it. For more information see the link:context-propagation[Context Propagation Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、リアクティブコールバック全体にIDを伝播させることができます。また、QuarkusがIDを伝播できるようにするために、IDを伝播できる実行者を使用していることを確認する必要があります(例: `CompletableFuture.supplyAsync` がない)。詳細については、 link:context-propagation[コンテキスト伝搬ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3 is an object storage service. It can be employed to store any type of object which allows for uses like storage for Internet applications, backup and recovery, disaster recovery, data archives, data lakes for analytics, any hybrid cloud storage.  This extension provides functionality that allows the client to communicate with the service when running in Quarkus.  You can find more information about S3 at https://aws.amazon.com/s3/[the Amazon S3 website].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon S3はオブジェクトストレージサービスです。インターネットアプリケーションのストレージ、バックアップとリカバリ、災害復旧、データアーカイブ、分析用のデータレイク、あらゆるハイブリッドクラウドストレージなどの用途に使用できるように、あらゆるタイプのオブジェクトを保存するために採用することができます。このエクステンションは、Quarkusで実行しているときにクライアントがサービスと通信できるようにする機能を提供します。S3についての詳細は、 link:https://aws.amazon.com/s3/[Amazon S3のウェブサイト] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The S3 extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S3 エクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x] をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供する1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use S3 locally and on AWS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ローカルでAWS上でS3を使用するためのRESTサービスを取得する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven 3.5.3+</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Maven 3.5.3+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An AWS Account to access the S3 service. Before you can use the AWS SDKs with Amazon S3, you must get an AWS access key ID and secret access key.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S3サービスにアクセスするためのAWSアカウント。Amazon S3でAWS SDKを利用する前に、AWSのアクセスキーIDとシークレットアクセスキーを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, Docker for your system to run S3 locally for testing purposes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションで、テスト目的でローカルでS3を実行するためのシステムのためのDocker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Provision S3 locally</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ローカルでの S3 の準備</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to start working with S3 is to run a local instance as a container.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S3を使い始める最も簡単な方法は、ローカルインスタンスをコンテナーとして実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts a S3 instance that is accessible on port `8008`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ポート `8008` でアクセス可能な S3 インスタンスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Note**: Versions of localstack newer than v0.11.5 require port `4566` instead of port `4572`. See this https://github.com/localstack/localstack/issues/2983[GitHub issue] for details on this change
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Note** : v0.11.5 より新しいバージョンの localstack では、ポート `4572` の代わりに `4566` を必要とします。この変更の詳細は link:https://github.com/localstack/localstack/issues/2983[GitHub issue] を参照してください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built here allows to manage files stored in Amazon S3.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで構築したアプリケーションでは、Amazon S3に保存されているファイルを管理することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `amazon-s3-quickstart` {quickstarts-tree-url}/amazon-s3-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `amazon-s3-quickstart` {quickstarts-tree-url}/amazon-s3-quickstart[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS and S3 Client extensions.  After this, the `amazon-s3` extension has been added to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RSとS3クライアントエクステンションをインポートするMaven構造を生成します。この後、 `amazon-s3` エクステンションが `pom.xml` に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we'll add the following dependency to support `multipart/form-data` requests:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `multipart/form-data` リクエストをサポートするために、以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we will create an application to manage a list of files. The example application will demonstrate the two programming models supported by the extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、ファイルのリストを管理するアプリケーションを作成します。この例のアプリケーションでは、エクステンションでサポートされている2つのプログラミングモデルをデモします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because the primary goal of our application is to upload a file into the S3 bucket, we need to setup the model we will be using to define the `multipart/form-data` payload, in the form of a `MultipartBody` POJO.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのアプリケーションの主な目的はファイルをS3バケットにアップロードすることなので、 `multipart/form-data` ペイロードを定義するために使用するモデルを `MultipartBody` POJO の形で設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.s3.FormData` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `org.acme.s3.FormData` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class defines three fields:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスは3つのフィールドを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the second step let's create a bean that will represent a file in a Amazon S3 bucket as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>第2ステップでは、以下のようにAmazon S3バケット内のファイルを表すBeanを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer. The static `from` method creates a bean based on the `S3Object` object provided by the S3 client response when listing all the objects in a bucket.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことは、JSONシリアライゼーションレイヤーによって要求されるということです。static `from` メソッドは、バケット内のすべてのオブジェクトをリストアップする際に、S3 クライアントのレスポンスで提供される `S3Object` オブジェクトに基づいてBeanを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.s3.CommonResource` that will consist of methods to prepare S3 request to get object from a S3 bucket, or to put file into a S3 bucket.  Note a configuration property `bucket.name` is defined here as the request method required name of the S3 bucket.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、S3バケットからオブジェクトを取得したり、S3バケットにファイルを入れたりするためのS3リクエストを準備するためのメソッドからなる `org.acme.s3.CommonResource` を作成します。ここでは、S3バケットのリクエストメソッドの必要な名前として、設定プロパティー `bucket.name` が定義されていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a `org.acme.s3.S3SyncClientResource` that will provides an API to upload/download files as well as to list all the files in a bucket.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、ファイルをアップロード/ダウンロードするためのAPIを提供する `org.acme.s3.S3SyncClientResource` を作成し、バケットのすべてのファイルを一覧表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both S3 clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S3クライアント(同期と非同期)は、 `src/main/resources` ディレクトリーで提供される `application.properties` ファイルを介して設定可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to add to the classpath a proper implementation of the sync client. By default the extension uses the URL connection HTTP client, so add a URL connection client dependency to the `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、エクステンションは URL Connection 接続 HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` ファイルに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For asynchronous client refer to &lt;&lt;Going asynchronous&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期クライアントについては、 link:#Going asynchronous[非同期にする] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're going to use a local S3 instance, configure it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ローカルのS3インスタンスを使う場合は、以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.s3.aws.region` - It's required by the client, but since you're using a local S3 instance you can pick any valid AWS region.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.s3.aws.region` - クライアントが必要としていますが、ローカルのS3インスタンスを使用しているので、有効なAWSリージョンを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.s3.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.s3.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-id` と `secret-access-key` の任意の値で設定します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`bucket.name` - name of the S3 bucket on your AWS account.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`bucket.name` - AWSアカウント上のS3バケット名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.s3.aws.credentials.type` - use the `default` credentials provider chain that looks for credentials in this order:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.s3.aws.credentials.type` - `default` クレデンシャル・プロバイダ・チェーンを使用して、この順番でクレデンシャルを検索します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `S3SyncClientResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `s3.html` file with the content from this {quickstarts-blob-url}/amazon-s3-quickstart/src/main/resources/META-INF/resources/s3.html[s3.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `S3SyncClientResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/amazon-s3-quickstart/src/main/resources/META-INF/resources/s3.html[s3.html] ファイルの内容を含む `s3.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a `org.acme.s3.S3AsyncClientResource` that will be similar to our `S3SyncClientResource` but using an asynchronous programming model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`S3SyncClientResource` と同様の `org.acme.s3.S3AsyncClientResource` を作成しますが、非同期プログラミングモデルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need the RESTEasy Mutiny support for asynchronous programming. Add the dependency to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期プログラミングにはRESTEasy Mutinyのサポートが必要です。依存関係を `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or you can alternatively run this command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、プロジェクトのベースディレクトリーでこのコマンドを実行することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And add the Netty HTTP client dependency to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `pom.xml` に Netty HTTPクライアントの依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Maven, you can scaffold a new project with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenを使えば、新しいプロジェクトをスキャフォールド(足場の作成)できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`platformGroupId`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`platformGroupId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The group id of the target platform. Given that all the existing platforms are coming from `io.quarkus` this one won't practically be used explicitly. But it's still an option.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>対象となるプラットフォームのグループID。既存のすべてのプラットフォームが `io.quarkus` から来ていることを考えると、実際にはこれは明示的には使われないでしょう。しかし、これはまだオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`platformArtifactId`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`platformArtifactId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-universe-bom`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-universe-bom`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The artifact id of the target platform BOM. It should be `quarkus-bom` in order to use the locally built Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ターゲットプラットフォームBOMのアーティファクトID。ローカルでビルドされたQuarkusを使用するためには、 `quarkus-bom` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`platformVersion`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`platformVersion`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's not specified, the latest one will be resolved.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定されていない場合は、最新のものに解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The version of the platform you want the project to use. It can also accept a version range, in which case the latest from the specified range will be used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトで使用したいプラットフォームのバージョンを指定します。バージョンの範囲を指定することもでき、その場合は指定した範囲の最新のものが使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the command will target the latest version of `quarkus-universe-bom` (unless specific coordinates have been specified). If you run offline however, it will look for the latest locally available and if `quarkus-universe-bom` (satisfying the default version range which is currently up to 2.0) is not available locally, it will fallback to the bundled platform based on `quarkus-bom` (the version will match the version of the plugin).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、このコマンドは `quarkus-universe-bom`  の最新バージョンをターゲットにします (特定の coordinates が指定されていない限り)。しかし、オフラインで実行した場合、ローカルで利用可能な最新のものを探し、 `quarkus-universe-bom`  (現在 2.0 までのデフォルトのバージョン範囲を満たしている) がローカルで利用できない場合は、 `quarkus-bom`  をベースにしたバンドルされたプラットフォームにフォールバックします (バージョンはプラグインのバージョンと一致します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is generated in a directory named after the passed artifactId.  If the directory already exists, the generation fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトは、渡された artifactId にちなんだ名前のディレクトリーに生成されます。ディレクトリーが既に存在する場合は、生成に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern :</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グロブパターンに一致するすべてのエクステンションをインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus:dev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティーファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, `quarkus:dev` sets the debug host to `localhost` (for security reasons). If you need to change this, for example to enable debugging on all hosts, you can use the `-DdebugHost` option like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quarkus:dev` はデバッグホストを `localhost` に設定します (セキュリティー上の理由から)。これを変更する必要がある場合、例えばすべてのホストでデバッグを有効にしたい場合は、 `-DdebugHost` オプションを次のように使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production application in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must build a mutable application, using the `mutable-jar` format. Set the following properties in `application.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを行うには、 `mutable-jar`  形式を使用して、ミュータブルアプリケーションを構築する必要があります。 `application.xml`  で以下のプロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Quarkus to use the mutable-jar format. Mutable applications also include the deployment time parts of Quarkus, so they take up a bit more disk space. If run normally they start just as fast and use the same memory as an immutable application, however they can also be started in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、QuarkusにMutable-jar形式を使用するように指示します。ミュータブルアプリケーションには、Quarkusのデプロイメント時間の部分も含まれているため、より多くのディスクスペースを占有します。普通に実行した場合は、イミュータブルアプリケーションと同じ速度で起動し、同じメモリーを使用しますが、devモードで起動することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The password that is used to secure communication between the remote side and the local side.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート側とローカル側の通信を安全に保つためのパスワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL that your app is going to be running in dev mode at. This is only needed on the local side, so you may want to leave it out of the properties file and specify it as a system property on the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリがdevモードで実行されるURL。これはローカル側でのみ必要なので、プロパティー ファイルから除外して、コマンド ラインでシステム プロパティーとして指定するとよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you start Quarkus on the remote host set the environment variable `QUARKUS_LAUNCH_DEVMODE=true`. If you are on bare metal you can just set this via the `export QUARKUS_LAUNCH_DEVMODE=true` command, if you are running using docker start the image with `-e QUARKUS_LAUNCH_DEVMODE=true`. When the application starts you should now see the following line in the logs: `Profile dev activated. Live Coding activated`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモートホストでQuarkusを起動する前に、環境変数 `QUARKUS_LAUNCH_DEVMODE=true`  を設定します。ベアメタルを使用している場合は、 `export QUARKUS_LAUNCH_DEVMODE=true`  コマンドで設定します。dockerを使用している場合は、 `-e QUARKUS_LAUNCH_DEVMODE=true`  でイメージを起動します。アプリケーションが起動すると、ログに次のような行が表示されるはずです: `Profile dev activated. Live Coding activated` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The remote side does not need to include Maven or any other development tools. The normal `fast-jar` Dockerfile that is generated with a new Quarkus application is all you need. If you are using bare metal launch the Quarkus runner jar, do not attempt to run normal devmode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート側にはMavenなどの開発ツールを入れる必要はありません。新しいQuarkusアプリケーションで生成される通常の `fast-jar`  Dockerfileがあれば大丈夫です。ベアメタルでQuarkus runner jarを起動している場合は、通常のdevmodeを実行しようとしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to connect your local agent to the remote host, using the `remote-dev` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `remote-dev`  コマンドを使用して、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app. This is done via a HTTP based long polling transport, that will synchronize your local workspace and the remote application via HTTP calls.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、ブラウザを更新するたびに、ローカルで行った変更がリモート アプリに即座に表示されるようになりました。これは、HTTPベースのロングポーリングトランスポートを介して行われ、HTTPコールを介してローカルのワークスペースとリモートアプリケーションを同期させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not want to use the HTTP feature then you can simply run the `remote-dev` command without specifying the URL.  In this mode the command will continuously rebuild the local application, so you can use an external tool such as odo or rsync to sync to the remote application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP 機能を使用したくない場合は、URL を指定せずに `remote-dev`  コマンドを実行するだけです。このモードでは、コマンドはローカルアプリケーションを継続的に再構築するので、 odo や rsync のような外部ツールを使ってリモートアプリケーションに同期することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended you use SSL when using remote dev mode, however even if you are using an unencrypted connection your password is never sent directly over the wire. For the initial connection request the password is hashed with the initial state data, and subsequent requests hash it with a random session id generated by the server and any body contents for POST requests, and the path for DELETE requests, as well as an incrementing counter to prevent replay attacks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート開発モードを使用する際には SSL を使用することを推奨しますが、たとえ暗号化されていない接続を使用していても、パスワードが直接ネットワーク上で送信されることはありません。最初の接続リクエストでは、パスワードは初期状態のデータでハッシュ化され、それ以降のリクエストでは、サーバーによって生成されたランダムなセッションIDと、POSTリクエストのためのボディコンテンツ、DELETEリクエストのためのパス、そしてリプレイ攻撃を防ぐためのインクリメントカウンタでハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Maven plugin picks up compiler flags to pass to `javac` from `maven-compiler-plugin`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Maven プラグインは `maven-compiler-plugin`  から `javac`  に渡すコンパイラフラグをピックアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to customize the compiler flags used in development mode, add a `configuration` section to the `plugin` block and set the `compilerArgs` property just as you would when configuring `maven-compiler-plugin`.  You can also set `source`, `target`, and `jvmArgs`.  For example, to pass `--enable-preview` to both the JVM and `javac`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードで使用するコンパイラ・フラグをカスタマイズする必要がある場合は、 `plugin`  ブロックに `configuration`  セクションを追加し、 `maven-compiler-plugin`  を設定するときと同じように `compilerArgs`  プロパティーを設定します。また、 `source`  、 `target`  、および `jvmArgs`  を設定することもできます。例えば、 `--enable-preview`  を JVM と `javac`  の両方に渡すには、 を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run a Quarkus application in debug mode with a suspended JVM using `./mvnw compile quarkus:dev -Dsuspend` which is a shorthand for `./mvnw compile quarkus:dev -Dsuspend=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev -Dsuspend` を使用して、サスペンドされたJVMでQuarkusアプリケーションをデバッグモードで実行することもできます( `./mvnw compile quarkus:dev -Dsuspend=true` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Maven project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;project-creation, プロジェクトを生成したら&gt;&gt;、お気に入りのIDEでインポートすることができます。唯一の要件は、Mavenプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Maven -&gt; Existing Maven Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Maven → Existing Maven Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish` をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./mvnw compile quarkus:dev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末で `./mvnw compile quarkus:dev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Maven`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Import project from external model`  を選択して `Maven`を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のターミナルまたは組み込みのターミナルで、 `./mvnw compile quarkus:dev`  を実行してください。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./mvnw compile quarkus:dev`  を実行します。お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Maven project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VS Codeでプロジェクトディレクトリーを開きます。Java Extension Pack(Java拡張のセットをグループ化したもの)をインストールしている場合、プロジェクトはMavenプロジェクトとしてロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually, dependencies of an application (which is a Maven project) could be displayed using `mvn dependency:tree` command. In case of a Quarkus application, however, this command will list only the runtime dependencies of the application.  Given that the Quarkus build process adds deployment dependencies of the extensions used in the application to the original application classpath, it could be useful to know which dependencies and which versions end up on the build classpath.  Luckily, the `quarkus-bootstrap` Maven plugin includes the `build-tree` goal which displays the build dependency tree for the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常、アプリケーション(Mavenプロジェクト)の依存関係は、 `mvn dependency:tree`  コマンドを使用して表示することができます。しかし、Quarkusアプリケーションの場合、このコマンドはアプリケーションの実行時の依存関係のみを表示します。Quarkusのビルドプロセスは、アプリケーションで使用されているエクステンションのデプロイメント依存関係を元のアプリケーションのクラスパスに追加するので、どの依存関係とどのバージョンがビルドクラスパスで終わるかを知ることは便利です。幸いにも、 `quarkus-bootstrap`  Mavenプラグインには、アプリケーションのビルド依存関係ツリーを表示する `build-tree`  ゴールが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to use it, the following plugin configuration has to be added to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使えるようにするためには、以下のプラグイン設定を `pom.xml` に追加する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you should be able to execute `./mvnw quarkus-bootstrap:build-tree` on your project and see something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、プロジェクト上で `./mvnw quarkus-bootstrap:build-tree`  を実行して、以下のようなものが表示されるようになるはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).  Verify that your `pom.xml` has the proper `native` profile (see &lt;&lt;build-tool-maven&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(GraalVMのJava 11バージョンを使用していることを確認してください)。あなたの `pom.xml`  が適切な `native`  プロファイルを持っていることを確認してください( link:#build-tool-maven[[build-tool-maven]を]参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.  A native executable will be present in `target/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative` を使用してネイティブ実行ファイルを作成します。ネイティブ実行ファイルは `target/` に出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run Integration Tests on the native executable, make sure to have the proper Maven plugin configured (see &lt;&lt;build-tool-maven&gt;&gt;) and launch the `verify` goal.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルで統合テストを実行するには、適切なMavenプラグインが設定されていることを確認し( link:#build-tool-maven[[build-tools-maven]を]参照)、 `verify`  ゴールを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can follow the link:building-native-image[Build a native executable guide] as well as link:deploying-to-kubernetes[Deploying Application to Kubernetes and OpenShift] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:building-native-image[ネイティブ実行ファイルのビルドガイド]と同様に、 link:deploying-to-kubernetes[アプリケーションをKubernetesとOpenShiftにデプロイ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have not used &lt;&lt;project-creation,project scaffolding&gt;&gt;, add the following elements in your `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;project-creation,プロジェクトのスキャフォールド&gt;&gt;を使用していない場合は、以下の要素を `pom.xml` に追加してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally use a BOM file to omit the version of the different Quarkus dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションで、BOMファイルを使用して、異なるQuarkus依存関係のバージョンを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Quarkus Maven plugin that will hook into the build process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドプロセスにフックするQuarkus Mavenプラグインを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add system properties to `maven-surefire-plugin`. + `maven.home` is only required if you have custom configuration in `${maven.home}/conf/settings.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムのプロパティーを `maven-surefire-plugin`  に追加します。+ `maven.home`  は、 `${maven.home}/conf/settings.xml`  にカスタム設定がある場合にのみ必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a specific `native` profile for native executable building.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルのビルドには、特定の `native`  プロファイルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the `native` package type. The build will therefore produce a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`native`  パッケージタイプを有効にします。そのため、ビルドはネイティブ実行可能ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to test your native executable with Integration Tests, add the following plugin configuration. Test names `*IT` and annotated `@NativeImageTest` will be run against the native executable. See the link:building-native-image[Native executable guide] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Integration Testsでネイティブ実行可能ファイルをテストしたい場合は、以下のプラグイン設定を追加してください。テスト名 `*IT`  と注釈付き `@NativeImageTest`  は、ネイティブ実行ファイルに対して実行されます。詳細は link:building-native-image[ネイティブ実行ファイルガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Maven plugin supports the generation of Uber-Jars by specifying a `quarkus.package.type=uber-jar` configuration option in your `application.properties` (or `&lt;quarkus.package.type&gt;uber-jar&lt;/quarkus.package.type&gt;` in your `pom.xml`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Mavenプラグインは、 `application.properties` .Quarkus Mavenプラグインで `quarkus.package.type=uber-jar`  設定オプションを指定することで、UberJar の生成をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The original jar will still be present in the `target` directory but it will be renamed to contain the `.original` suffix.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>元の jar は `target`  ディレクトリーに残っていますが、 `.original`  の接尾辞を含むように名前が変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `quarkus.package.ignored-entries` configuration option, this takes a comma separated list of entries to ignore.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Uber-jar をビルドする際に、 `quarkus.package.ignored-entries`  設定オプションを使用して生成された jar から除外したいエントリーを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar creation by default excludes link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[signature files] that might be present in the dependencies of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Uber-Jar の作成は、アプリケーションの依存関係に存在する可能性のある link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[署名ファイル]を除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar's final name is configurable via a Maven's build settings `finalName` option.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Uber-Jarの最終的な名前は、Mavenのビルド設定 `finalName`  オプションで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include the `jandex-maven-plugin`, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクト内のモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されていない限り、`jandex-maven-plugin`  をインクルードすることです。モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されている場合は自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt;
      &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.0.7&lt;/version&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;make-index&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;jandex&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt;
      &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.0.7&lt;/version&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;make-index&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;jandex&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Project Output</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト出力の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a several configuration options that will define what the output of your project build will be.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのビルドの出力を定義するための設定オプションがいくつかあります。これらは他の設定プロパティーと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties are shown below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Maven Surefire and Maven Failsafe configurations shown below. This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ただし、以下に示すMaven SurefireおよびMaven Failsafe構成で、テストにカスタム構成プロファイルを使用することは可能です。これは、例えば、デフォルトのテストデータベースではない特定のデータベースを使用してテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Amazon Lambda with RESTEasy, Undertow, or Vert.x Web </seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - RESTEasy、Undertow、またはVert.x Webを使用した Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Lambda を純粋な Java jar としてデプロイすることもできますし、プロジェクトをネイティブイメージにコンパイルしてデプロイすることで、より少ないメモリーフットプリントと起動時間を実現することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through generating an example Java project via a maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、mavenのアーキタイプを介してJavaプロジェクトのサンプルを生成する方法を説明します。その後、既存のプロジェクトを Amazon Lambda で利用できるようにするために、プロジェクトの構造を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWSのすべてのツールをインストールすることは、おそらくこのガイドでは最も難しいことです。AWS CLIをインストールするためのすべての手順に従っていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev-mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでコードがコンパイルされ、生成されたプロジェクト内に含まれるユニットテストが実行されます。ユニットテストは他のJavaプロジェクトと同じで、Amazonで実行する必要はありません。Quarkus dev-modeもこのエクステンションで利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to build for native too, make sure you have GraalVM installed correctly and just add a `native` property to the build</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ用にもビルドしたい場合は、GraalVMが正しくインストールされていることを確認し、 `native` プロパティーをビルドに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.jvm.yaml` - sam cli deployment script</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sam.jvm.yaml` - SAM CLI デプロイメントスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sam.native.yaml` - sam cli deployment script for native</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sam.native.yaml` - ネイティブ用の SAM CLI デプロイメントスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires docker to be installed (see their install docs).  After you have built your maven project, execute this command</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWS SAM CLIを使うと、ラップトップ上でLambdaをシミュレートした環境でローカルに実行することができます。このためにはdockerをインストールする必要があります(インストールドキュメントを参照してください)。mavenプロジェクトをビルドした後、以下のコマンドを実行してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start a docker container that mimics Amazon's Lambda's deployment environment.  Once the environment is started you can invoke the example lambda in your browser by going to</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでAmazonのLambdaのデプロイ環境を模したdockerコンテナーが起動します。環境が起動したら、ブラウザで以下を開くとサンプルの Lambda を実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールには、ラムダからの起動メッセージが表示されます。この特定のデプロイメントでは、JVM を起動し、純粋な Java として Lambda をロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バイナリー型のレスポンスは自動的にbase64でエンコードされます。これは、生のバイトを返す `quarkus:dev` を使用した動作とは異なります。Amazon の API には、base64 エンコーディングを必要とする追加の制限があります。一般的に、クライアントコードは自動的にこのエンコーディングを処理しますが、特定のカスタムな状況では、手動でエンコーディングを管理する必要があるかもしれないことを認識しておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension as a dependencies.  The extension automatically generates everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>POM には `quarkus-amazon-lambda-http` エクステンションが依存関係として含まれている以外に特別なことは何もありません。このエクステンションは Lambda のデプロイに必要なものをすべて自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated maven archetype `pom.xml`, the `quarkus-resteasy`, `quarkus-vertx-web`, and `quarkus-undertow` dependencies are all optional.  Pick which http framework(s) you want to use (JAX-RS, Vertx Web, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、少なくとも生成された maven のアーキタイプ `pom.xml` , `quarkus-resteasy` , `quarkus-vertx-web` , `quarkus-undertow` の依存関係はすべてオプションです。使用したい http フレームワーク (JAX-RS、Vertx Web、および/または Servlet) を選択し、他の依存関係を削除してデプロイを縮小します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine sam.yaml</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>sam.yaml を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things to note though that are particular to the `quarkus-amazon-lambda-http` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sam.yaml` の構文はこのドキュメントの範囲を超えています。しかし、 `quarkus-amazon-lambda-http` エクステンションに特有の注意点がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon's API Gateway assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AmazonのAPI Gatewayでは、設定でどのメディアタイプがバイナリーであるかを明示的に指定しない限り、HTTPレスポンスボディはテキストであることを前提としています。より簡単にするために、QuarkusエクステンションはすべてのHTTP応答メッセージのバイナリー(ベース64)エンコーディングを強制します。 `sam.yaml` ファイルでは、すべてのメディアタイプがバイナリーであると仮定するようにAPI Gatewayを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another thing to note is that for pure Java lambda deployments, do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つ注意すべきことは、純粋な Java Lambda ラムダデプロイメントの場合、 Lambda ハンドラーの名前を変更しないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This particular handler handles all the intricacies of integrating with the Quarkus runtime.  So you must use that handler.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この特定のハンドラーは、Quarkusランタイムとの統合のすべての複雑さを処理します。そのため、そのハンドラーを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ネイティブなGraalVMデプロイメントのために設定しなければならない環境変数があります。 `sam.native.yaml` を見ると、以下のようになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This environment variable resolves some incompatibilities between Quarkus and the Amazon Lambda Custom Runtime environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この環境変数は、QuarkusとAmazon Lambdaカスタムランタイム環境との間のいくつかの非互換性を解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many projects that use data require connections to a relational database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データを使用する多くのプロジェクトでは、リレーショナルデータベースへの接続が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The usual way of obtaining connections to a database is to use a datasource and configure a JDBC driver.  But you might also prefer using a reactive driver to connect to your database in a reactive way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースへの接続を取得する一般的な方法は、データソースを使用して JDBC ドライバーを設定することです。しかし、リアクティブな方法でデータベースに接続するために、リアクティブなドライバーを使用することが好まれる場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has you covered either way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、どちらにも対応できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For JDBC, the preferred datasource and connection pooling implementation is https://agroal.github.io/[Agroal].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC の場合、データソースと接続プーリングの実装は https://agroal.github.io/[Agroal] が好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For reactive, we use the https://vertx.io/[Vert.x] reactive drivers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブには、https://vertx.io/[Vert.x] リアクティブドライバーを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both are configured via unified and flexible configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらも統一された柔軟な構成で構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Agroal is a modern, light weight connection pool implementation designed for very high performance and scalability, and features first class integration with the other components in Quarkus, such as security, transaction management components, health, and metrics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Agroal は、非常に高いパフォーマンスとスケーラビリティ－を実現するように設計されたモダンで軽量な接続プールの実装です。また、セキュリティー、トランザクション管理コンポーネント、ヘルス、メトリクスなど、Quarkus における他のコンポーネントとのファーストクラスの統合を特徴としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will explain how to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is mainly about datasource configuration.  If you want more details about how to consume and make use of a reactive datasource, please refer to the link:reactive-sql-clients[Reactive SQL clients guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、主にデータソースの設定について説明します。反応性のあるデータソースを消費して利用する方法の詳細については、リアクティブデータソースの利用方法についての詳細は、link:reactive-sql-clients[リアクティブ SQL クライアントガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TL;DR</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細な説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a quick introduction to datasource configuration.  If you want a better understanding of how all this works, this guide has a lot more information in the subsequent paragraphs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはデータソースの設定についての簡単な紹介です。すべての動作について理解を深める場合は、このガイドの後の段落でさらに多くの情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the `agroal` extension plus one of `jdbc-db2`, `jdbc-derby`, `jdbc-h2`, `jdbc-mariadb`, `jdbc-mssql`, `jdbc-mysql`, or `jdbc-postgresql`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`agroal` エクステンションに加えて、`jdbc-db2`、`jdbc-derby`、`jdbc-h2`、`jdbc-mariadb`、`jdbc-mssql`、`jdbc-mysql`、`jdbc-postgresql` のいずれかを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then configure your datasource:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、データソースを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.jdbc.max-size=16
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.jdbc.max-size=16
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the correct reactive extension for the database you are using: `reactive-pg-client`, `reactive-mysql-client`, or `reactive-db2-client`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用しているデータベースに適切なリアクティブ拡張を追加します。`reactive-pg-client` , `reactive-mysql-client`、または `reactive-db2-client`。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then configure your reactive datasource:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、リアクティブデータソースを構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.reactive.url=postgresql:///your_database
quarkus.datasource.reactive.max-size=20
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.reactive.url=postgresql:///your_database
quarkus.datasource.reactive.max-size=20
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A datasource can be either a JDBC datasource, a reactive one or both.  It all depends on how you configure it and which extensions you added to your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースは、JDBC データソースまたはリアクティブデータソースのいずれか 1 つでも、その両方でも構いません。データソースの設定方法と、プロジェクトに追加したエクステンションによって異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To define a datasource, start with the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースを定義するには、以下から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=h2
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.db-kind=h2
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The database kind defines which type of database you will connect to.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースの種類は、接続するデータベースの種類を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We currently include these built-in database kinds:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、これらの組み込みデータベースの種類が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2: `db2`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DB2: `db2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby: `derby`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Derby: `derby`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>H2: `h2`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>H2: `h2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MariaDB: `mariadb`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MariaDB: `mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server: `mssql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Microsoft SQL Server: `mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL: `mysql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MySQL: `mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL: `postgresql`, `pgsql` or `pg`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PostgreSQL: `postgresql`、`pgsql`、または `pg`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Giving Quarkus the database kind you are targeting will facilitate configuration.  By using a JDBC driver extension and setting the kind in the configuration, Quarkus resolves the JDBC driver automatically, so you don't need to configure it yourself.  If you want to use a database kind that is not part of the built-in ones, use `other` and define the JDBC driver explicitly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>対象とするデータベースの種類を Quarkus に指定することで、設定が容易になります。JDBC ドライバーの拡張を使用して、設定でタイプを指定することで、Quarkus は自動的に JDBC ドライバーを解決します。そのため、自分で設定する必要はありません。組み込みのものに含まれていないデータベースの種類を使用したい場合は、`other` を使用して、JDBCドライバーを明示的に定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use any JDBC driver in a Quarkus app in JVM mode (see &lt;&lt;other-databases,Using other databases&gt;&gt;).  It is unlikely that it will work when compiling your application to a native executable though.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVM モードの Quarkus アプリでは、任意のJDBCドライバーを使用することができます (&lt;&lt;other-databases,Using other databases&gt;&gt; を参照)。しかし、アプリケーションをネイティブの実行ファイルにコンパイルした場合には動作しない可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to make a native executable, we recommend you use the existing JDBC Quarkus extensions (or contribute one for your driver).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルを作成する場合は、既存の JDBC Quarkus エクステンションを使用するこが推奨されます (または、ドライバーに貢献することをお勧めします)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a good chance you will need to define some credentials to access your database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースにアクセスするために、いくつかの認証情報を定義する必要がある可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is done by configuring the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、以下のプロパティーを設定することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.username=&lt;your username&gt;
quarkus.datasource.password=&lt;your password&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also retrieve the password from Vault by link:vault-datasource[using a credential provider] for your datasource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、データソースの link:vault-datasource[認証情報プロバイダを使用] 、Vault からパスワードを取得することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have defined the database kind and the credentials, you are ready to configure either a JDBC datasource, a reactive one, or both.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースの種類と認証情報を定義したら、JDBC データソースまたはリアクティブデータソースのいずれか 1 つ、あるいはその両方を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDBC is the most common database connection pattern.  You typically need a JDBC datasource when using Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC は最も一般的なデータベース接続パターンです。通常、Hibernate ORM を使用する場合は JDBC データソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Maven dependencies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven の依存関係をインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you will need to add the `quarkus-agroal` dependency to your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、`quarkus-agroal` 依存関係をプロジェクトに追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can add it using a simple Maven command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルな Maven コマンドを使って追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="agroal"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="agroal"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Agroal comes as a transitive dependency of the Hibernate ORM extension so if you are using Hibernate ORM, you don't need to add the Agroal extension dependency explicitly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Agroal は Hibernate ORM 拡張の遷移依存関係として提供されるので、Hibernate ORM を使用している場合は、Agroal エクステンションの依存関係を明示的に追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will also need to choose, and add, the Quarkus extension for your relational database driver.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、リレーショナルデータベースドライバー用の Quarkus エクステンションを選択して追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides driver extensions for:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、以下のためのドライバーエクステンションを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2 - `jdbc-db2`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DB2 - `jdbc-db2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby - `jdbc-derby`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Derby - `jdbc-derby`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>H2 - `jdbc-h2`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>H2 - `jdbc-h2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MariaDB - `jdbc-mariadb`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MariaDB - `jdbc-mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server - `jdbc-mssql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Microsoft SQL Server - `jdbc-mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL - `jdbc-mysql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MySQL - `jdbc-mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL - `jdbc-postgresql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PostgreSQL - `jdbc-postgresql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See &lt;&lt;other-databases&gt;&gt; if you want to use a JDBC driver for another database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のデータベースに JDBC ドライバーを使用する場合は、&lt;&lt;other-databases&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The H2 and Derby databases can normally be configured to run in "embedded mode"; the extension does not support compiling the embedded database engine into native executables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>H2 データベースと Derby データベースは通常、「埋め込みモード」で実行するように設定することができます。また、この拡張は、組み込みデータベースエンジンのネイティブ実行ファイルへのコンパイルに対応していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Read &lt;&lt;in-memory-databases,Testing with in-memory databases&gt;&gt; (below) for suggestions regarding integration testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合テストに関する提案については、&lt;&lt;in-memory-databases,Testing with in-memory databases&gt;&gt; (下) をお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, you can install the extension using `add-extension`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常通り、`add-extension` を使ってエクステンションをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To install the PostgreSQL driver dependency for instance, run the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PostgreSQL ドライバーの依存関係をインスタンスにインストールするには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="jdbc-postgresql"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="jdbc-postgresql"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your JDBC connection is easy, the only mandatory property is the JDBC URL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC 接続の設定は簡単で、必須のプロパティーは JDBC URL のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note the `jdbc` prefix in the property name.  All the configuration properties specific to JDBC have this prefix.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティー名の接頭辞 `jdbc` に注意してください。JDBC に固有のすべての構成プロパティーには、この接頭辞があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about the JDBC URL format, please refer to the &lt;&lt;jdbc-url,JDBC url reference section&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC URL 形式の詳細については、&lt;&lt;jdbc-url,JDBC url reference section&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using one of the built-in datasource kinds, the JDBC driver is resolved automatically to the following values:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルトインデータソースのいずれかの種類を使用している場合、JDBC ドライバーは以下の値に自動的に解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Database kind</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースの種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`db2`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`db2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.ibm.db2.jcc.DBDriver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`com.ibm.db2.jcc.DBDriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.ibm.db2.jcc.DB2XADataSource`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`com.ibm.db2.jcc.DB2XADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`derby`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`derby`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.derby.jdbc.ClientDriver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.apache.derby.jdbc.ClientDriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.apache.derby.jdbc.ClientXADataSource`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.apache.derby.jdbc.ClientXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`h2`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`h2`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.h2.Driver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.h2.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.h2.jdbcx.JdbcDataSource`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.h2.jdbcx.JdbcDataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mariadb`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mariadb`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.mariadb.jdbc.Driver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.mariadb.jdbc.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.mariadb.jdbc.MySQLDataSource`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.mariadb.jdbc.MySQLDataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mssql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mssql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerDriver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerDriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerXADataSource`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`com.microsoft.sqlserver.jdbc.SQLServerXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`mysql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mysql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.mysql.cj.jdbc.Driver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`com.mysql.cj.jdbc.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`com.mysql.cj.jdbc.MysqlXADataSource`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`com.mysql.cj.jdbc.MysqlXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`postgresql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`postgresql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.postgresql.Driver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.postgresql.Driver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.postgresql.xa.PGXADataSource`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.postgresql.xa.PGXADataSource`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As previously stated, most of the time, this automatic resolution will suit you and you won't need to configure the driver.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前述したように、多くの場合、この自動解像度が適切で、ドライバーを設定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a database with no built-in extension or with a different driver</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルトインエクステンションのないデータベースを使用するか、別のドライバーのあるデータベースを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use a specific driver if you need to (for instance for using the OpenTracing driver)  or if you want to use a database for which Quarkus does not have a built-in JDBC driver extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要に応じて (例えば OpenTracing ドライバーを使用する場合)、あるいはビルトイン JDBC ドライバー拡張のない Quarkus のデータベースを使用する必要がある場合は、特定のドライバーを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without an extension, the driver will work fine in any Quarkus app running in JVM mode.  It is unlikely that it will work when compiling your application to a native executable though.  If you plan to make a native executable, we recommend you use the existing JDBC Quarkus extensions (or contribute one for your driver).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>拡張がない場合でも、JVM モードで実行されている Quarkus アプリであれば、ドライバーは問題なく動作します。しかし、アプリケーションをネイティブ実行ファイルにコンパイルした場合には動作しません。ネイティブ実行ファイルを作成する予定がある場合は、既存の JDBC Quarkus エクステンションを使用することをお勧めします (または、ドライバー用のエクステンションを提供することをお勧めします)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is how you would use the OpenTracing driver:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、OpenTracing ドライバーをどのように使用するかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.driver=io.opentracing.contrib.jdbc.TracingDriver
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.jdbc.driver=io.opentracing.contrib.jdbc.TracingDriver
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is how you would define access to a database with no built-in support (in JVM mode):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、組み込みサポートのないデータベースへのアクセスを定義する方法を説明します (JVMモードで)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=other
quarkus.datasource.jdbc.driver=oracle.jdbc.driver.OracleDriver
quarkus.datasource.jdbc.url=jdbc:oracle:thin:@192.168.1.12:1521/ORCL_SVC
quarkus.datasource.username=scott
quarkus.datasource.password=tiger
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.db-kind=other
quarkus.datasource.jdbc.driver=oracle.jdbc.driver.OracleDriver
quarkus.datasource.jdbc.url=jdbc:oracle:thin:@192.168.1.12:1521/ORCL_SVC
quarkus.datasource.username=scott
quarkus.datasource.password=tiger
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure a lot more things, for instance the size of the connection pool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>接続プールのサイズなど、より多くのことを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please refer to the &lt;&lt;jdbc-configuration,JDBC configuration reference&gt;&gt; for all the details about the JDBC configuration knobs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC 構成ノブの詳細については、&lt;&lt;jdbc-configuration,JDBC configuration reference&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming the datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースの消費</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Hibernate ORM, the datasource will be consumed automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM を使用している場合、データソースは自動的に消費されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If for whatever reason, access to the datasource is needed in code, it can be obtained as any other bean in the following manner:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何らかの理由でコード内でデータソースへのアクセスが必要な場合は、以下の方法で他の Bean と同じようにデータソースを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject
AgroalDataSource defaultDataSource;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Inject
AgroalDataSource defaultDataSource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above example, the type is `AgroalDataSource` which is a subtype of `javax.sql.DataSource`.  Because of this, you can also use `javax.sql.DataSource` as the injected type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の例では、型は `AgroalDataSource` であり、 `javax.sql.DataSource` のサブタイプです。このため、`javax.sql.DataSource` を注入された型として使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer using a reactive datasource, Quarkus offers DB2, MySQL/MariaDB, and PostgreSQL reactive clients.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータソースを使用したい場合は、Quarkus では、DB2、MySQL/MariaDB、PostgreSQL リアクティブクライアントを利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Depending on which database you want to use, add the corresponding extension:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用したいデータベースに応じて、対応するエクステンションを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>DB2: `quarkus-reactive-db2-client`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DB2: `quarkus-reactive-db2-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL/MariaDB: `quarkus-reactive-mysql-client`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MySQL/MariaDB: `quarkus-reactive-mysql-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL: `quarkus-reactive-pg-client`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PostgreSQL: `quarkus-reactive-pg-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The installed extension must be consistent with the `quarkus.datasource.db-kind` you define in your datasource configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インストールされているエクステンションは、データソースの設定で定義する `quarkus.datasource.db-kind` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the reactive datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータソースの構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the driver is there, you just need to configure the connection URL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドライバーあれば、あとは接続 URL を設定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally, but highly recommended, you should define a proper size for your connection pool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>任意ですが、接続プールの適切なサイズを定義することを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDBC and reactive datasources simultaneously</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC とリアクティブデータソースの同時利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, if you include both a JDBC extension (+ Agroal) and a reactive datasource extension handling the given database kind, both will be created.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、JDBC 拡張 (+ Agroal) と、指定したデータベースの種類を扱うリアクティブデータソース拡張の両方を含めると、これらのファイル両方が作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to disable the JDBC datasource explicitly, use:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC データソースを明示的に無効にしたい場合は、以下を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc=false
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.jdbc=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to disable the reactive datasource explicitly, use:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータソースを明示的に無効にしたい場合は、以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.reactive=false
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.reactive=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time, the configuration above won't be necessary as either a JDBC driver or a reactive datasource extension will be present and not both.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの場合、存在するのはJDBC ドライバーまたはリアクティブデータソース拡張のどちらかで、両方存在するわけではありません。そのため、上記の設定は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Multiple Datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のデータソースの構成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, multiple datasources are only supported for JDBC and the Agroal extension.  So it is not currently possible to create multiple reactive datasources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、複数のデータソースは JDBC と Agroal 拡張でのみサポートされています。そのため、現在、複数の反応性データソースを作成することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Hibernate ORM extension link:hibernate-orm#multiple-persistence-units[supports defining several persistence units using configuration properties].  For each persistence unit, you can point to the datasource of your choice.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM エクステンションは、link:hibernate-orm#multiple-persistence-units[設定プロパティーを使用して複数の永続ユニットの定義に対応]しています。それぞれの永続化ユニットでは、任意のデータソースを参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining multiple datasources works exactly the same way as defining a single datasource, with one important change: you define a name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のデータソースの定義は、単一のデータソースの定義と全く同じです。ただし、1 つだけ重要な変更点があります。それは、名前を定義することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following example, you have 3 different datasources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の例では、3 つの異なるデータソースがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default one,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A datasource named `users`,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`users` という名前のデータソース。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A datasource named `inventory`,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`inventory` という名前のデータソース。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>each with its own configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それぞれが独自の設定を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there is an extra bit in the key.  The syntax is as follows: `quarkus.datasource.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キーに余分なビットがあることに注意してください。構文は以下の通りです。`quarkus.datasource.[optional name.][datasource property]` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Datasource Injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前付きデータソースインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple datasources, each `DataSource` also has the `io.quarkus.agroal.DataSource` qualifier with the name of the datasource as the value.  Using the above properties to configure three different datasources, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のデータソースを使用する場合、それぞれの `DataSource` にも、値としてデータソース名のある `io.quarkus.agroal.DataSource` の修飾子が付けられています。上記のプロパティーを使って 3 つの異なるデータソースを設定すると、以下のようにそれぞれのデータソースを注入することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject
@DataSource("users")
AgroalDataSource usersDataSource;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Inject
@DataSource("users")
AgroalDataSource usersDataSource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject
@DataSource("inventory")
AgroalDataSource inventoryDataSource;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Inject
@DataSource("inventory")
AgroalDataSource inventoryDataSource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datasource Health Check</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, the `quarkus-agroal` and reactive client extensions will automatically add a readiness health check to validate the datasource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-health` 拡張を使用している場合、`quarkus-agroal` とリアクティブクライアント拡張は、データソースを検証するための準備の健全性チェックを自動的に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you access the `/q/health/ready` endpoint of your application you will have information about the datasource validation status.  If you have multiple datasources, all datasources will be checked and the status will be `DOWN` as soon as there is one datasource validation failure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの `/q/health/ready` エンドポイントにアクセスすると、データソースの検証ステータスに関する情報が表示されます。複数のデータソースがある場合は、すべてのデータソースがチェックされ、1 つのデータソースの検証に失敗するとすぐにステータスが `DOWN` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled via the property `quarkus.datasource.health.enabled`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、プロパティー `quarkus.datasource.health.enabled` で無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datasource Metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースメトリクス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-micrometer` or `quarkus-smallrye-metrics` extension, `quarkus-agroal` can expose some data source metrics on the `/q/metrics` endpoint. This can be turned on by setting the property `quarkus.datasource.metrics.enabled` to true.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-micrometer` または `quarkus-smallrye-metrics` エクステンションを使用している場合、`quarkus-agroal` は `/q/metrics` エンドポイントでいくつかのデータソースメトリクスを公開できます。これは、プロパティー `quarkus.datasource.metrics.enabled` を true に設定することで有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the exposed metrics to contain any actual values, it is necessary that metric collection is enabled internally by Agroal mechanisms. By default, this metric collection mechanism gets turned on for all data sources if a metrics extension is present and metrics for the Agroal extension are enabled. If you want to disable metrics for a particular data source, this can be done by setting `quarkus.datasource.jdbc.enable-metrics` to `false` (or `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics` for a named datasource).  This disables collecting the metrics as well as exposing them in the `/q/metrics` endpoint, because it does not make sense to expose metrics if the mechanism to collect them is disabled.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>公開されたメトリクスに実際の値が含まれるようにするには、メトリクス収集が Agroal メカニズムによって内部的に有効化されている必要があります。デフォルトでは、メトリクス拡張が存在し、Agroal 拡張のメトリクスが有効になっている場合に、このメトリック収集メカニズムはすべてのデータソースに対してオンになります。特定のデータソースのメトリクスを無効にしたい場合は、`quarkus.datasource.jdbc.enable-metrics` を `false` (名前付きデータソースの場合は `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics`) に設定することで行うことができます。これは、メトリクスを収集するメカニズムが無効化されている場合は、メトリクスの公開は意味がありません。そのため、`/q/metrics` エンドポイントでの公開と同様に、メトリクスの収集を無効化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conversely, setting `quarkus.datasource.jdbc.enable-metrics` to `true` (or `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics` for a named datasource) explicitly can be used to enable collection of metrics even if a metrics extension is not in use.  This can be useful if you need to access the collected metrics programmatically.  They are available after calling `dataSource.getMetrics()` on an injected `AgroalDataSource` instance. If collection of metrics is disabled for this data source, all values will be zero.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>逆に、明示的に `quarkus.datasource.jdbc.enable-metrics` を `true` (名前付きデータソースの場合は `quarkus.datasource.&lt;datasource name&gt;.jdbc.enable-metrics`) に設定することで、メトリクス拡張が使用されていなくても、メトリクスの収集を有効にすることができます。これは、収集したメトリクスにプログラムでアクセスする必要がある場合に便利です。インジェクト下 `AgroalDataSource` インスタンスで `dataSource.getMetrics()` を呼び出した後に利用できます。このデータソースでメトリクスの収集が無効になっている場合、すべての値はゼロになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the Narayana JTA extension is also available, integration is automatic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Narayana JTA のエクステンションも利用できる場合、統合は自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override this by setting the `transactions` configuration property - see the &lt;&lt;configuration-reference, Configuration Reference&gt;&gt; below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを上書きするには、`transactions` 構成プロパティーを設定します。以下の &lt;&lt;configuration-reference, Configuration Reference&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing with in-memory databases</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インメモリーデータベースを使用したテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some databases like H2 and Derby are commonly used in "embedded mode" as a facility to run quick integration tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>H2 や Derby のようなデータベースの中には、迅速な統合テストを実行するためのファシリティして "embedded mode" で一般的に使用されているものもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our suggestion is to use the real database you intend to use in production; container technologies made this simple enough so you no longer have an excuse. Still, there are sometimes good reasons to also want the ability to run quick integration tests using the JVM powered databases, so this is possible as well.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番で使用する予定の実際のデータベースを使用することを提案します。コンテナーテクノロジーによりこれが容易になりました。依然として、JVM を搭載したデータベースを使用して迅速な統合テストを実行する機能が必要な場合もあります。そのような場合でも、これが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to remember that when configuring H2 (or Derby) to use the embedded engine, this will work as usual in JVM mode but such an application will not compile into a native executable, as the Quarkus extensions only cover for making the JDBC client code compatible with the native compilation step: embedding the whole database engine into a native executable is currently not implemented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>埋め込みエンジンを使用するように H2 (または Derby) を設定する場合、JVM モードでは通常通り動作しますが、そのようなアプリケーションはネイティブの実行ファイルにはコンパイルされません。これは、Quarkus 拡張が、JDBC クライアントコードをネイティブコンパイルステップに対応させることのみを対象としているためです。データベースエンジン全体のネイティブ実行可能ファイルへの組み込みは現在実装されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to run such integration tests in the JVM exclusively, it will of course work as usual.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このような統合テストを JVM で排他的に実行する予定であれば、もちろん通常通りに動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These additional helpers are provided by the artifacts having Maven coordinates `io.quarkus:quarkus-test-h2` and `io.quarkus:quarkus-test-derby`, respectively for H2 and Derby.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの追加のヘルパーは、H2 と Derby 用にそれぞれ Maven 座標 `io.quarkus:quarkus-test-h2` と `io.quarkus:quarkus-test-derby` を持アーティファクトによって提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Follows an example for H2:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、H2 の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package my.app.integrationtests.db;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package my.app.integrationtests.db;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.h2.H2DatabaseTestResource;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.h2.H2DatabaseTestResource;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@QuarkusTestResource(H2DatabaseTestResource.class)
public class TestResources {
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@QuarkusTestResource(H2DatabaseTestResource.class)
public class TestResources {
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will allow you to test your application even when it's compiled into a native executable, while the database will run in the JVM as usual.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、ネイティブ実行ファイルにコンパイルされている場合でもアプリケーションをテストすることができ、データベースは通常通り JVM で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connect to it using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下を使用して接続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:test
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:test
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Common Datasource Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>共通データソース構成リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each of the supported databases contains different JDBC URL configuration options.  Going into each of those options is beyond the scope of this document, but the following section gives an overview of each database URL and a link to the official documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているデータベースにはそれぞれ異なる JDBC URL 設定オプションがあります。それぞれのオプションについては、本ドキュメントの説明範囲を超えていますが、以下のセクションでは各データベースの URL の概要と公式ドキュメントへのリンクを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:h2:{ {.|mem:}[name] | [file:]fileName | {tcp|ssl}:[//]server[:port][,server2[:port]]/name }[;key=value...]`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:h2:{ {.|mem:}[name] | [file:]fileName | {tcp|ssl}:[//]server[:port][,server2[:port]]/name }[;key=value...]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:h2:tcp://localhost/~/test`, `jdbc:h2:mem:myDB`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:h2:tcp://localhost/~/test`, `jdbc:h2:mem:myDB`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>H2 is an embedded database.  It can run as a server, based on a file, or live completely in memory.  All of these options are available as listed above.  You can find more information at the https://h2database.com/html/features.html?highlight=url&amp;search=url#database_url[official documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>H2 は組み込みデータベースです。サーバーとして、ファイルに基づいて、あるいは、メモリー内で完全にライブで実行できます。これらすべてのオプションは上記のように利用可能です。詳細は、link:https://h2database.com/html/features.html?highlight=url&amp;search=url#database_url[公式ドキュメント] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PostgreSQL only runs as a server, as do the rest of the databases below.  As such, you must specify connection details, or use the defaults.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PostgreSQL は、以下の他のデータベースと同様に、サーバーとしてのみ動作します。そのため、接続の詳細を指定するか、デフォルトを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:postgresql:[//][host][:port][/database][?key=value...]`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:postgresql:[//][host][:port][/database][?key=value...]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:postgresql://localhost/test`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:postgresql://localhost/test`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defaults for the different parts are as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各部のデフォルトは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`host`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`host`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>localhost</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>localhost</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`port`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`port`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`database`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`database`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://jdbc.postgresql.org/documentation/head/connect.html[official documentation] go into more detail and list optional parameters as well.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://jdbc.postgresql.org/documentation/head/connect.html[公式ドキュメント] では、より詳細な情報を紹介しており、同様にオプションのパラメーターをリストアップしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:db2://&lt;serverName&gt;[:&lt;portNumber&gt;]/&lt;databaseName&gt;[:&lt;key1&gt;=&lt;value&gt;;[&lt;key2&gt;=&lt;value2&gt;;]]`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:db2://&lt;serverName&gt;[:&lt;portNumber&gt;]/&lt;databaseName&gt;[:&lt;key1&gt;=&lt;value&gt;;[&lt;key2&gt;=&lt;value2&gt;;]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:db2://localhost:50000/MYDB:user=dbadm;password=dbadm;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:db2://localhost:50000/MYDB:user=dbadm;password=dbadm;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.apdv.java.doc/src/tpc/imjcc_r0052342.html[official documentation] for more detail on URL syntax and additional supported options.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>URL の構文やサポートされているオプションの詳細は、 link:https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.apdv.java.doc/src/tpc/imjcc_r0052342.html[公式ドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MariaDB</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MariaDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mariadb:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:mariadb:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>hostDescription</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>hostDescription</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mariadb://localhost:3306/test`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:mariadb://localhost:3306/test`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this feature and others detailed in the https://mariadb.com/kb/en/library/about-mariadb-connector-j/[official documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能の詳細は、link:https://mariadb.com/kb/en/library/about-mariadb-connector-j/[公式ドキュメント] に掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MySQL</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MySQL</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mysql:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:mysql:[replication:|failover:|sequential:|aurora:]//&lt;hostDescription&gt;[,&lt;hostDescription&gt;...]/[database][?&lt;key1&gt;=&lt;value1&gt;[&amp;&lt;key2&gt;=&lt;value2&gt;]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:mysql://localhost:3306/test`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:mysql://localhost:3306/test`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about this feature and others detailed in the https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference.html[official documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能は、link:https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference.html[公式ドキュメント] に詳しい情報が掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Microsoft SQL Server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Microsoft SQL Server takes a connection URL in the following form:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Microsoft SQL Server は、以下の形式で接続 URL を処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:sqlserver://localhost:1433;databaseName=AdventureWorks`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:sqlserver://localhost:1433;databaseName=AdventureWorks`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft SQL Server JDBC driver works essentially the same as the others.  More details can be found in the https://docs.microsoft.com/en-us/sql/connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver?view=sql-server-2017[official documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Microsoft SQL Server JDBC ドライバーは基本的に他のものと同じように動作します。詳細は link:https://docs.microsoft.com/en-us/sql/connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver?view=sql-server-2017[公式ドキュメント] に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Derby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:derby:[//serverName[:portNumber]/][memory:]databaseName[;property=value[;property=value]]`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:derby:[//serverName[:portNumber]/][memory:]databaseName[;property=value[;property=value]]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`jdbc:derby://localhost:1527/myDB`, `jdbc:derby:memory:myDB;create=true`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`jdbc:derby://localhost:1527/myDB`, `jdbc:derby:memory:myDB;create=true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Derby is an embedded database.  It can run as a server, based on a file, or live completely in memory.  All of these options are available as listed above.  You can find more information at the https://db.apache.org/derby/docs/10.8/devguide/cdevdvlp17453.html#cdevdvlp17453[official documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Derby は組み込みデータベースです。サーバーとして、ファイルを元にして、あるいは完全にメモリー内でライブで実行するこもできます。これらすべてのオプションは上記のように利用可能です。詳細は link:https://db.apache.org/derby/docs/10.8/devguide/cdevdvlp17453.html#cdevdvlp17453[公式ドキュメント] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive Datasource Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータソース構成リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive DB2 Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな DB2 の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive MariaDB/MySQL Specific Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな MariaDB/MySQL 固有の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive PostgreSQL Specific Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな PostgreSQL 固有の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The guide walks through quickstart code to show you how you can deploy Funqy as a standalone service and invoke on Funqy functions using HTTP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Funqyをスタンドアロンサービスとしてデプロイし、HTTPを使ってFunqy関数を呼び出す方法をクイックスタートコードで説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable across a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's JAX-RS, Spring MVC, or Vert.x Web Reactive Routes support instead, although Funqy will have less overhead than these alternatives (except Vert.x which is still super fast).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのHTTPバインディングはHTTP上のRESTの代わりではありません。Funqyは多くの異なるプロトコルや Function プロバイダに対してポータブルである必要があるので、HTTPバインディングは非常にミニマムで、リンクのようなREST機能やキャッシュコントロールや条件付きGETのようなHTTPを利用する機能を失うことになります。代わりにQuarkusのJAX-RS、Spring MVC、またはVert.x Web Reactive Routesのサポートを使用することを検討すると良いでしょう。しかしながら、Funqy はこれらの選択肢と比べてオーバーヘッドが小さいでしょう(例外として Vert.x はそれでもすごく早いですが)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at the Java code, you'll see that there is no HTTP specific API.  Its just simple Java methods annotated with `@Funq`.  Simple, easy, straightforward.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javaコードを見ると、HTTP固有のAPIがないことがわかります。単純な Java メソッドに `@Funq` と注釈が付けられているだけです。シンプルで、簡単で、わかりやすいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write Funqy HTTP functions, simply include the `quarkus-funqy-http` dependency into your Quarkus `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Funqy HTTP Function を書くには、 `quarkus-funqy-http` 依存関係をQuarkus `pom.xml` ファイルにインクルードするだけでよいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This starts your functions in Quarkus dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、Quarkus devモードで Function が起動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL path to execute a function is the function name.  For example if your function name is `foo` then the URL path to execute the function would be `/foo`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Function を実行するための URL パスは、Function 名です。例えば、Function 名が `foo` の場合、Function を実行する URL パスは `/foo` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The HTTP POST or GET methods can be used to invoke on a function.  The return value of the function is marshalled to JSON using the Jackson JSON library.  Jackson annotations can be used.  If your function has an input parameter, a POST invocation must use JSON as the input type.  Jackson is also used here for unmarshalling.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP POST または GET メソッドを使用して Function を呼び出すことができます。Function の戻り値は、Jackson JSON ライブラリを使用して JSON にマーシャルされます。Jackson アノテーションを使用することができます。Function に入力パラメーターがある場合、POST 呼び出しは入力タイプとして JSON を使用しなければなりません。ここでもJackson はアンマーシャリングに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can invoke the `hello` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] by pointing your browser to http://localhost:8080/hello</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザを http://localhost:8080/hello に向けると、 {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `hello` Function を呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoking the other functions in the quickstart requires an HTTP POST.  To execute the `greet` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/GreetingFunction.java[GreetingFunction.java] invoke this curl script.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クイックスタートの他の Function を呼び出すには、HTTP POST が必要です。 {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/GreetingFunction.java[GreetingFunction.java] で定義されている `greet` 関数を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Primitive types can also be passed as input using the standard JSON mapping for them.  To execute the `toLowerCase` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl script:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プリミティブ型は、標準の JSON マッピングを使用して入力として渡すこともできます。`toLowerCase` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `toLowerCase` 関数を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To execute the `double` function defined in {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl script:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] で定義されている `double` Function を実行するには、この curl スクリプトを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For GET requests, the Funqy HTTP Binding also has a query parameter mapping for function input parameters.  Only bean style classes and `java.util.Map` can be used for your input parameter.  For bean style classes, query parameter names are mapped to properties on the bean class.  Here's an example of a simple `Map`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GETリクエストのために、Funqy HTTPバインディングは、Function の入力パラメーターのためのクエリパラメーターマッピングも提供しています。Bean スタイル・クラスと `java.util.Map` だけが入力パラメーターに使用できます。Bean スタイル・クラスでは、クエリ・パラメーター名は Bean クラスのプロパティーにマッピングされます。以下は、単純な `Map` の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Key values must be a primitive type (except char) or `String`.  Values can be primitives (except char), `String`, `OffsetDateTime` or a complex bean style class.  For the above example, here's the corresponding curl request:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キー値は、プリミティブ型(char を除く)か `String` でなければなりません。値は、プリミティブ型 (char を除く)、 `String` 、 `OffsetDateTime` 、または複雑な Bean スタイルのクラスを使用できます。上記の例に対して、対応する curl リクエストを以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `map` input parameter of the `hello` function would have the key value pairs: `a`-&gt;1, `b`-&gt;2.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`hello` Function の `map` 入力パラメーターは、 `a` →1, `b` →2 というキーバリューペアを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean style classes can also be use as the input parameter type.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean スタイルクラスを入力パラメーター型として使用することもできます。以下に例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property values can be any primitive type except `char`. It can also be `String`, and `OffsetDateTime`.  `OffsetDateTime` query param values must be in ISO-8601 format.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーの値は、 `char` 以外の任意のプリミティブ型にすることができます。また、 `String` や `OffsetDateTime` も可能です。 `OffsetDateTime` クエリのパラメーター値は ISO-8601 形式でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can invoke on this using an HTTP GET and query parameters:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP GET とクエリパラメーターを使用して呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above request, the query parameter names are mapped to corresponding properties in the input class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のリクエストでは、クエリパラメーター名が入力クラスの対応するプロパティーにマッピングされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The input class can also have nested bean classes.  Expanding on the previous example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>入力クラスは、入れ子になった Bean クラスを持つこともできます。前の例を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, query parameters for nested values use the `.` notation.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、入れ子になった値のクエリパラメーターは `.` 表記法を使用します。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.List` and `Set` are also supported as property values.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java.util.List` と `Set` もプロパティー値としてサポートされています。例えば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To invoke a GET request, just list the `pets` query parameter multiple times.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GETリクエストを実行するためには、 `pets` クエリパラメーターを複数回リストアップするだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more complex types, `List` and `Set` members must have an identifier in the query parameter.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より複雑な型の場合、 `List` および `Set` のメンバーは、クエリパラメーターに識別子を持つ必要があります。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each `kids` query parameter must identify the kid they are referencing so that the runtime can figure out which property values go to which members in the list.  Here's the curl request:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それぞれの `kids` クエリーパラメーターは、参照している kid を識別する必要があります。これにより、ランタイムはどのプロパティー値がリストのどのメンバーに属するかを把握することができます。これが curl リクエストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above URL uses the value `1` and `2` to identity the target member of the list, but any unique string can be used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のURLでは、リストの対象メンバーを識別するために `1` と `2` という値を使用していますが、任意の一意の文字列を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A property can also be a `java.util.Map`.  The key of the map can be any primitive type and `String`.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーは `java.util.Map` でもよいです。 マップのキーは、任意のプリミティブ型と `String` が利用できます。例えば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding call would look like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>対応する呼び出しは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your `Map` value is a complex type, then just continue the notation by adding the property to set at the end.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Map` の値が複雑な型であれば、最後に set するプロパティーを追加して表記を続けるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers generating and deploying OpenShift resources based on sane default and user supplied configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、妥当なデフォルト設定とユーザーが提供する設定に基づいたOpenShiftリソースの生成とデプロイについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>roughly 5 minutes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ざっと五分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>access to an OpenShift cluster (Minishift is a viable option)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShift クラスターへのアクセス(Minishift も選択可能なオプションです)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift CLI (Optional. Only required for manually deploying)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShift CLI (オプション。手動でデプロイする場合のみ必要)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project that contains the OpenShift extension. This can be done using the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、OpenShift エクステンションを含む新しいプロジェクトが必要です。これは以下のコマンドを使用して行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers the ability to automatically generate OpenShift resources based on sane default and user supplied configuration.  The OpenShift extension is actually a wrapper extension that brings together the link:deploying-to-kubernetes[kubernetes] and link:container-image#s2i[container-image-s2i] extensions with sensible defaults so that it's easier for the user to get started with Quarkus on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、妥当なデフォルトとユーザーが提供する設定に基づいてOpenShiftリソースを自動的に生成する機能を提供します。OpenShift エクステンションは、実際には link:deploying-to-kubernetes[kubernetes] エクステンションと link:container-image#s2i[container-image-s2i] エクステンションをよく考えられたデフォルトでまとめたラッパーエクステンションであり、ユーザーがOpenShift上でQuarkusを使い始めるのを容易にするためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When we added the OpenShift extension to the command line invocation above, the following dependency was added to the `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のコマンドライン呼び出しにOpenShift エクステンションを追加すると、以下のような依存関係が `pom.xml` に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By adding this dependency, we now have the ability to configure the OpenShift resource generation and application using the usual `application.properties` approach that Quarkus provides.  The configuration items that are available can be found in: `io.quarkus.kubernetes.deployment.OpenShiftConfig` class.  Furthermore, the items provided by `io.quarkus.deployment.ApplicationConfig` affect the OpenShift resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この依存関係を追加することで、Quarkusが提供している通常の `application.properties` のアプローチでOpenShiftリソースの生成とアプリケーションの設定ができるようになりました。利用できる設定項目は、 `io.quarkus.kubernetes.deployment.OpenShiftConfig` クラスにあります。さらに、 `io.quarkus.deployment.ApplicationConfig` で提供されている項目は OpenShift リソースに影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy (in separate steps)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドとデプロイ(別々のステップで)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the OpenShift extension was not included during the bootstraping of the project nor was it added subsequently (check pom.xml file for it), then it can be added like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのブートストラップ時にOpenShiftエクステンションが含まれていなかったり、その後に追加されなかったりした場合(pom.xmlファイルを確認してください)、以下のように追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building is handled by the link:container-image#s2i[container-image-s2i] extension. To trigger a build:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドは link:container-image#s2i[container-image-s2i] エクステンションによって処理されます。ビルドをトリガーするには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The build that will be performed is an s2i binary build. The input of the build is the jar that has been built locally and the output of the build is an ImageStream that is configured to automatically trigger a deployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行されるビルドは s2i バイナリービルドです。ビルドの入力はローカルでビルドされた jar で、ビルドの出力はデプロイを自動的に起動するように設定された ImageStream です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy the container image created in the above step to OpenShift, follow these commands:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の手順で作成したコンテナーイメージをOpenShiftにデプロイするには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the above, `oc get is` will list the image stream created.  It should be tagged as &lt;project&gt;/openshift-quickstart:1.0.0-SNAPSHOT.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記では、 `oc get is` で、作成されたイメージストリームが一覧表示されます。&lt;project&gt;/openshift-quickstart:1.0.0-snapshotとタグ付けされているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly, `oc get route` will list the route URL for the exposed service "greeting" so that you can use it to test the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同様に、 `oc get route` で、公開されているサービス「greeting」のルートURLをリストアップしてくれるので、アプリケーションのテストに利用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non S2i Builds</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非S2iビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Out of the box the openshift extension is configured to use link:container-image#s2i[container-image-s2i]. However, it's still possible to use other container image extensions like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>openshift エクステンションは link:container-image#s2i[container-image-s2i] を使用するように設定されています。しかし、次のようにして他のコンテナーイメージエクステンションを使用することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#s2i[container-image-jib]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#s2i[container-image-jib]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When a non-s2i container image extension is used, an ImageStream is created that is pointing to an external `dockerImageRepository`. The image is built and pushed to the registry and the ImageStream populates the tags that are available in the `dockerImageRepository`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非 s2i コンテナーイメージエクステンションが使用されている場合、外部の `dockerImageRepository` を指す ImageStream が作成されます。イメージはビルドされてレジストリーにプッシュされ、ImageStream は `dockerImageRepository` において有効なタグを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To select which extension will be used for building the image:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イメージのビルドに使用するエクステンションを選択するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and Deploy (in a single step)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドとデプロイ(1つのステップで)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger a build and deployment in a single step:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドとデプロイを1つのステップでトリガーするためには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The aforementioned command will build a jar file locally, trigger a container image build and then apply the generated OpenShift resources.  The generated resources are using OpenShift's `DeploymentConfig` that is configured to automatically trigger a redeployment when a change in the `ImageStream` is noticed.  In other words, any container image build after the initial deployment will automatically trigger redeployment, without the need to delete, update or re-apply the generated resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前述のコマンドは、ローカルで jar ファイルをビルドし、コンテナーイメージのビルドをトリガーして、生成された OpenShift リソースを適用します。生成されたリソースは、 `ImageStream` の変更に気づいたときに自動的に再デプロイをトリガーするように設定されている OpenShift の `DeploymentConfig` を使用しています。つまり、最初のデプロイ後のコンテナーイメージビルドであれば、生成されたリソースを削除、更新、再適用する必要がなく、自動的に再デプロイがトリガーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To confirm the above command has created an image stream, a service resource and has deployed the application (has a pod running), apply these commands:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記コマンドでイメージストリーム、サービスリソースが作成され、アプリケーションがデプロイされている(ポッドが実行されている)ことを確認するために、これらのコマンドを適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To expose the created service to a route and test it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成したサービスを route に公開してテストするには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All available customization options are available in the link:deploying-to-kubernetes#openshift[OpenShift configuration options].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なカスタマイズオプションはすべて link:deploying-to-kubernetes#openshift[OpenShiftの設定オプション] で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some examples are provided in the sections below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの例は、以下のセクションで提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To expose a `Route` for the Quarkus application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションの `Route` を公開するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tip: You don't necessarily need to add this property in the `application.properties`. You can pass it as a command line argument:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヒント: このプロパティーを `application.properties` で追加する必要はありません。コマンドラインの引数として渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same applies to all properties listed below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下にリストされているすべてのプロパティも同様です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a label in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースにラベルを追加するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add an annotation in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースにアノテーションを追加するには次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift provides multiple ways of defining environment variables:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShiftでは環境変数の定義方法が複数用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Previous versions of the OpenShift extension supported a different syntax to add environment variables. The older syntax is still supported but is deprecated, and it's advised that you migrate to the new syntax.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShift エクステンションの以前のバージョンでは、環境変数を追加するための異なる構文がサポートされていました。古い構文はまだサポートされていますが、非推奨となっており、新しい構文に移行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env-vars.my-env-var.value=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.vars.my-env-var=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env.vars.my-env-var=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env-vars.my-env-var.field=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.fields.my-env-var=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env.fields.my-env-var=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env-vars.xxx.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.configmaps=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env.configmaps=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.xxx.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env-vars.xxx.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.secrets=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env.secrets=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.foo.secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env-vars.foo.secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env.mapping.foo.from-secret=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.foo.value=field`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env-vars.foo.value=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.mapping.foo.with-key=field`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env.mapping.foo.with-key=field`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env-vars.foo.configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env-vars.foo.configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.openshift.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.openshift.env.mapping.foo.from-configmap=foobar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you redefine the same variable using the new syntax while keeping the old syntax, **ONLY** the new version will be kept, and a warning will be issued to alert you of the problem. For example, if you define both `quarkus.openshift.env-vars.my-env-var.value=foobar` and `quarkus.openshift.env.vars.my-env-var=newValue`, the extension will only generate an environment variable `MY_ENV_VAR=newValue` and issue a warning.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>古い構文を維持したまま新しい構文を使用して同じ変数を再定義した場合、新しいバージョン *のみ* が保持され、警告が表示されて問題を警告します。例えば、 `quarkus.openshift.env-vars.my-env-var.value=foobar` と `quarkus.openshift.env.vars.my-env-var=newValue` の両方を定義した場合、エクステンションは環境変数 `MY_ENV_VAR=newValue` のみを生成し、警告を発行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenShift extension allows the user to configure both volumes and mounts for the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShiftエクステンションを使用すると、アプリケーションのボリュームとマウントの両方を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Any volume can be mounted with a simple configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どんなボリュームでも、簡単な構成でマウントすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add a mount to my pod for volume `my-volume` to path `/where/to/mount`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 Podのパス  `/where/to/mount` にボリューム `my-volume` のマウントを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The volumes themselves can be configured as shown in the sections below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ボリューム自体は、以下のセクションに示すように設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift also provides the ability to use Knative via the link:https://www.openshift.com/learn/topics/serverless[OpenShift Serverless] functionality.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、OpenShiftでは、OpenShift link:https://www.openshift.com/learn/topics/serverless[Serverless] 機能を介してKnativeを利用する機能も提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first order of business is to instruct Quarkus to generate Knative resources by setting:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず最初にQuarkusの設定でKnativeのリソースを生成するように指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to leverage OpenShift S2I to build the container image on the cluster and use the resulting container image for the Knative application, we need to set a couple of configuration properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShift S2I を利用してクラスタ上にコンテナイメージを構築し、その結果のコンテナイメージをKnativeアプリケーションで使用するためには、いくつかの設定プロパティを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can then be deployed to OpenShift Serverless by enabling the standard `quarkus.kubernetes.deploy=true` property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、標準の `quarkus.kubernetes.deploy=true` プロパティを有効にすることで、アプリケーションを OpenShift Serverless にデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the information between the browser and the server is formatted as JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブラウザとサーバー間の情報はすべてJSON形式になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided solution contains a few additional elements such as tests and testing infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>提供されるソリューションには、テストやテストのインフラストラクチャなど、いくつかの追加要素が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For this guide you need:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドには以下が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roughly 1 hour for all modalities</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての手順を試すのに約1時間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will take as input an application developed in the link:getting-started[Getting Started guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:getting-started[入門ガイド] で開発されたアプリケーションを入力として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have the getting-started application at hand, or clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]. The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>手元に get-started アプリケーションがあることを確認するか、Git リポジトリをクローンします: `git clone {quickstarts-clone-url}` 、もしくは {quickstarts-archive-url}[archive] をダウンロードしてください。ソリューションは `getting-started` ディレクトリーにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports deploying your application to Google Cloud Functions via the following extensions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、次のエクステンションを使用して、アプリケーションをGoogle Cloud Functionsにデプロイすることをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gcp-functions[Google Cloud Functions]: Build functions using the Google Cloud Functions API.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:gcp-functions[Google Cloud Functions] : Google Cloud Functions API を使用して Function をビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gcp-functions-http[Google Cloud Functions HTTP binding]: Build functions using Quarkus HTTP APIs: RESTEasy (JAX-RS), Undertow (Servlet), Vert.x Web, or link:funqy-http[Funqy HTTP].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:gcp-functions-http[Google Cloud Functions HTTPバインディング] : Quarkus HTTP APIを使用して Function をビルドします: RESTEasy(JAX-RS)、Undertow(サーブレット)、Vert.x Web、または link:funqy-http[Funqy HTTP] </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:funqy-gcp-functions[Funky Google Cloud Functions]: Build functions using Funqy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:funqy-gcp-functions[Funqy Google Cloud Functions] : Funqyを使って Function をビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each extension supports a specific kind of application development, follow the specific guides for more information on how to develop, package and deploy your applications using them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各エクステンションは特定の種類のアプリケーション開発をサポートしており、それらを使用してアプリケーションを開発、パッケージ化、デプロイする方法の詳細については、特定のガイドに従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will only cover the Java 11 runtime as the Java 8 runtime uses its own Servlet engine which is not compatible with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 8 ランタイムはQuarkusと互換性のない独自のサーブレットエンジンを使用しているため、Java 11 ランタイムのみをカバーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First of all, make sure to have an App Engine environment initialized for your Google Cloud project, if not, initialize one via `gcloud app create --project=[YOUR_PROJECT_ID]`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gcloud app create --project=[YOUR_PROJECT_ID]` まず最初に、Google Cloud プロジェクト用に App Engine 環境が初期化されていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you will need to create a `src/main/appengine/app.yaml` file, let's keep it minimalistic with only the selected engine:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `src/main/appengine/app.yaml` ファイルを作成する必要がありますが、選択したエンジンだけで最低限のものにしておきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a default service for your App Engine application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、App Engineアプリケーションのデフォルトサービスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, you can choose to build the application by yourself or letting `gcloud` or the Google Cloud Maven plugin build it for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、自分でアプリケーションを構築するか、 `gcloud` または Google Cloud Maven プラグインに構築を任せるかを選択できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building the application manually</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを手動でビルドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set up your application to be packaged as an uber-jar via your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` ファイルを介して、アプリケーションをuber-jarとしてパッケージ化するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Maven to build the application using `mvn clean package`, it will generate a single JAR that contains all the classes of your application including its dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mvn clean package` を使用してアプリケーションをビルドするために Maven を使用します。依存関係を含むアプリケーションのすべてのクラスを含む単一の JAR を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, use `gcloud` to deploy your application as an App Engine service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、 `gcloud` を使用して、アプリケーションを App Engine サービスとしてデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command will upload your application jar and launch it on App Engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、アプリケーション jar をアップロードし、App Engine で起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When done, the output will display the URL of your application (target url), you can use it with curl or directly open it in your browser using `gcloud app browse`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完了すると、出力にはアプリケーションの URL (ターゲット URL) が表示されます。curlを使うか、 `gcloud app browse` を使ってブラウザで直接開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building the application via gcloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gcloud 経由でアプリケーションをビルドする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can choose to let `gcloud` build your application for you, this is the simplest way to deploy to App Engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gcloud` にアプリケーションをビルドさせることができます。これは App Engine にデプロイする最もシンプルな方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just launch `gcloud app deploy` in the root of your project, it will upload all your project files (the list can be reduced via the `.gcloudignore` file), package your JAR via Maven (or Gradle) and launch it on App Engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのルートで `gcloud app deploy` を実行するだけで、すべてのプロジェクトファイルをアップロードし( `.gcloudignore` ファイルを介してリストを減らすことができます)、Maven(または Gradle)を介して JAR をパッケージ化し、App Engine で起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also let Maven control the deployment of your application using the App Engine Maven plugin.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、App Engine Mavenプラグインを使用して、Mavenでアプリケーションのデプロイを制御することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add the plugin to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、プラグインを `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the default `gcloud` configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトの `gcloud` 設定を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Override the default JAR name to the one generated by the Quarkus Maven plugin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのJAR名を、Quarkus Mavenプラグインによって生成されたものにオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you would be able to use Maven to build and deploy your application to App Engine via `mvn clean package appengine:deploy`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、Mavenを使用してアプリケーションをビルドし、 `mvn clean package appengine:deploy` を経由してApp Engineにデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When it’s done, the output will display the URL of your application (target URL), you can use it with curl or directly open it in your browser using `gcloud app browse`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それが完了すると、出力にはアプリケーションの URL (ターゲット URL) が表示されます。curlを使うか、 `gcloud app browse` を使ってブラウザで直接開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before all, make sure to have an App Engine environment initialized for your Google Cloud project, if not, initialize one via `gcloud app create --project=[YOUR_PROJECT_ID]`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずはじめに、Google Cloud プロジェクト用に App Engine 環境が初期化されていることを確認してください。もしまだであれば、 `gcloud app create --project=[YOUR_PROJECT_ID]` によって初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>App Engine Flexible Custom Runtimes uses a Docker image to run your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>App Engine Flexible Custom RuntimesはDockerイメージを使用してアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create an `app.yaml` file at the root of your project with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、プロジェクトのルートに以下の内容の `app.yaml` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>App Engine Flexible Custom Runtimes deploys your application as a Docker container, you can choose to deploy one of the Dockerfile provided inside your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>App Engine Flexible Custom Runtimesは、アプリケーションをDockerコンテナーとしてデプロイしますが、アプリケーション内で提供されるDockerfileのいずれかを選択してデプロイすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both JVM and native executable versions will work.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVM版とネイティブ実行ファイル版の両方が動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy a JVM application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMアプリケーションをデプロイするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the JVM Dockerfile to the root directory of your project: `cp src/main/docker/Dockerfile.jvm Dockerfile`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMのDockerfileをプロジェクトのルートディレクトリーにコピーします: `cp src/main/docker/Dockerfile.jvm Dockerfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build your application using `mvn clean package`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mvn clean package` を使用してアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy a native application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブアプリケーションをデプロイするには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the native Dockerfile to the root directory of your project: `cp src/main/docker/Dockerfile.native Dockerfile`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブのDockerfileをプロジェクトのルートディレクトリーにコピーします: `cp src/main/docker/Dockerfile.native Dockerfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build your application as a native executable using `mvn clean package -Dnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mvn clean package -Dnative` を使用して、アプリケーションをネイティブ実行ファイルとしてビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, launch `gcloud app deploy` in the root of your project, it will upload all your project files (the list can be reduced via the `.gcloudignore` file), build your Dockerfile and launch it on App Engine Flexible custom runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、プロジェクトのルートで `gcloud app deploy` を起動すると、すべてのプロジェクトファイルをアップロードし( `.gcloudignore` ファイルを介してリストを縮小することができます)、Dockerfile をビルドし、App Engine Flexible カスタムランタイム上で起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It uses Cloud Build to build your Docker image and deploy it to Google Container Registry (GCR).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Cloud Buildを使用してDockerイメージをビルドし、Google Container Registry(GCR)にデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>App Engine Flexible custom runtimes support link:https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml#updated_health_checks[health checks], it is strongly advised to provide them thanks to Quarkus link:microprofile-health[Microprofile Health] support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>App Engine Flexibleカスタムランタイムは link:https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml#updated_health_checks[ヘルスチェック] をサポートしていますが、Quarkus link:microprofile-health[Microprofile Health] のサポートにより、 link:https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml#updated_health_checks[ヘルスチェック] を提供することを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Run allows you to run your Docker containers inside Google Cloud Platform in a managed way.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud Runでは、Google Cloud Platform内でDockerコンテナーをマネージドな方法で実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus listens on port 8080, and it's also the Cloud Run default port.  No need to use the `PORT` environment variable defined in Cloud Run to customize the Quarkus HTTP port.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusは8080番ポートをリッスンし、これはCloud Runのデフォルトポートでもあります。Cloud Runで定義された環境変数 `PORT` を使用して、QuarkusのHTTPポートをカスタマイズする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Run will use Cloud Build to build your Docker image and deploy it to Google Container Registry (GCR).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Cloud RunはCloud Buildを使用してDockerイメージを構築し、Google Container Registry(GCR)にデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a `.gcloudignore` file to tell gcloud which files should be not be uploaded for Cloud Build, without it, it defaults to `.gitignore` that usually exclude the target directory where you packaged application has been created.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、Cloud Buildのためにアップロードすべきでないファイルをgcloudに伝えるための `.gcloudignore` ファイルを作成します。これがない場合、デフォルトは `.gitignore` で、通常はパッケージ化されたアプリケーションが作成されたターゲットディレクトリーを除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, I only exclude the `src` directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、 `src` ディレクトリーだけを除外しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, use Cloud Build to build your image, it will upload to a Google Cloud Storage bucket all the files of your application (except the ones ignored by the `.gcloudignore`file), build your Docker image and push it to Google Container Registry (GCR).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、Cloud Buildを使ってイメージをビルドすると、アプリケーションのすべてのファイル(`.gcloudignore`fileで無視されたファイルを除く)をGoogle Cloud Storageバケットにアップロードし、DockerイメージをビルドしてGoogle Container Registry (GCR)にプッシュします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also build your image locally and push it to a publicly accessible Docker registry, then use this image in the next step.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、イメージをローカルにビルドして、公開されているDockerレジストリーにプッシュし、次のステップでこのイメージを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, use Cloud Run to launch your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、Cloud Runを使ってアプリケーションを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud run will ask you questions on the service name, the region and whether or not unauthenticated calls are allowed.  After you answer to these questions, it will deploy your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Cloud run は、サービス名、リージョン、認証されていない呼び出しが許可されているかどうかについて質問をします。これらの質問に答えると、アプリケーションがデプロイされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the deployment is done, the output will display the URL to access your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイが完了すると、出力にはアプリケーションにアクセスするためのURLが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find a set of extensions to access various Google Cloud Services in the Quarkiverse (a GitHub organization for Quarkus extensions maintained by the community), including PubSub, BigQuery, Storage, Spanner, Firestore (visit the repository for an accurate list of supported services).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PubSub、BigQuery、Storage、Spanner、Firestore(サポートされているサービスの正確なリストはリポジトリを参照してください)など、さまざまなGoogle Cloud ServicesにアクセスするためのエクステンションのセットをQuarkiverse(コミュニティによってメンテナンスされているQuarkusエクステンションのためのGitHub組織)で見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find some documentation about them in the link:https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse Google Cloud Services repository].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらについてのドキュメントは、 link:https://github.com/quarkiverse/quarkiverse-google-cloud-services[QuarkiverseのGoogle Cloud Servicesリポジトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクのスケジュール方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need a clustered scheduler use the link:quartz[Quartz extension].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスター化されたスケジューラーが必要な場合は、 link:quartz[Quartzエクステンション] を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application accessible using HTTP to get the current value of a counter.  This counter is periodically (every 10 seconds) incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、カウンタの現在値を取得するために HTTP を使用してアクセスできる簡単なアプリケーションを作成します。このカウンタは定期的に (10 秒ごとに) インクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.scheduler.CountResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.scheduler.CountResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Maven project also imports the Quarkus scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven プロジェクトは、Quarkus scheduler エクステンションもインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `scheduler` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `scheduler` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.scheduler` package, create the `CounterBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.scheduler` パッケージで、以下の内容の `CounterBean` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the bean in the _application_ scope</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_application_ スコープでの Bean の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to run this method every 10 seconds provided a worker thread is available (Quarkus is using 10 worker threads for the scheduler). If it is not available the method invocation should be re-scheduled by default i.e it should be invoked as soon as possible. The invocation of the scheduled method does not depend on the status or result of the previous invocation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` アノテーションを使用して、ワーカースレッドが利用可能であれば 10 秒ごとにこのメソッドを実行するように Quarkus に指示します (Quarkus はスケジューラーに10個のワーカースレッドを使用しています)。ワーカースレッドが利用できない場合は、メソッドの呼び出しをデフォルトで再スケジューリングする必要があります。スケジュールされたメソッドの呼び出しは、前回の呼び出しのステータスや結果には依存しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is pretty straightforward. Every 10 seconds, the counter is incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードはとても簡単です。10 秒ごとにカウンターがインクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression. The annotated method is executed at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cron のような式でジョブを定義します。アノテーションされたメソッドは毎日午前 10 時 15 分に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the `cron.expr` configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` ファイルを編集し、 `cron.expr` の設定を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observe the console to verify that the message `Cron expression configured in application.properties` has been displayed indicating that the cron job using an expression configured in `application.properties` has been triggered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールを見て、 `application.properties` で構成された式を使用する cron ジョブがトリガーされたことを示すメッセージ `Cron expression configured in application.properties` が表示されたことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラー設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Valu</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have an already created project, the `vertx` extension can be added to an existing Quarkus project with the `add-extension` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに作成済みのプロジェクトがある場合は、 `vertx` エクステンションを既存のQuarkusプロジェクトに `add-extension` コマンドで追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI is provided as a native binary for Linux and macOS or as a jar-file for all operating systems.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI は、Linux と macOS 用のネイティブバイナリーとして、またはすべてのオペレーティングシステム用の jar ファイルとして提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native CLI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the binaries here:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バイナリーはこちらからダウンロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://coming-soon[macOS Binary] (coming soon)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://coming-soon[macOSバイナリー](近日公開予定)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you create a specific Quarkus folder, eg '~/quarkus' and move the binary there.  Then in your shell profile (for Bash shell edit '~/.bash_profile'), export the 'QUARKUS_HOME' folder and add that to your 'PATH':</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定の Quarkus フォルダー、例えば '~/quarkus' を作成し、そこにバイナリーを移動することをお勧めします。次に、シェルプロファイル (Bash シェルの場合は'~/.bash_profile' を編集) で、'QUARKUS_HOME' フォルダーをエクスポートして 'PATH' に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>export QUARKUS_HOME=/path/to/quarkus-cli
export PATH="$PATH:$QUARKUS_HOME"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>export QUARKUS_HOME=/path/to/quarkus-cli
export PATH="$PATH:$QUARKUS_HOME"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reload your terminal or do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>端末をリロードするか、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>source ~/.bash_profile
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>source ~/.bash_profile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can run the Quarkus CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで Quarkus CLI を実行できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus --help
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will display the help information with all the available commands.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、利用可能なすべてのコマンドのヘルプ情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus -i
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus -i
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start the Quarkus CLI in interactive mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、対話型モードで Quarkus CLI が起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jar CLI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jar CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the jar-file here:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jar ァイルはこちらからダウンロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://coming-soon[jar-file] (coming soon)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://coming-soon[jar-file](近日公開)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the native CLI we recommend that you copy the binary to a specific folder, eg '~/quarkus'.  The jar file requires Java 8 or newer to run. To start the CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ CLI と同様に、バイナリーを特定のフォルダー (例: '~/quarkus') にコピーすることをお勧めします。jar ファイルを実行するには Java 8 以降が必要です。CLI を起動するには以下を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ java -jar quarkus-cli.jar
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ java -jar quarkus-cli.jar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The jar file CLI accepts all the same options and commands as the native binary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jar ファイルの CLI は、ネイティブのバイナリーと同じオプションとコマンドをすべて受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: In the examples below switch out 'quarkus' with 'java -jar quarkus-cli.jar'.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注意: 以下の例では、'quarkus' を 'java -jar quarkus-cli.jar' で置き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a new project we use the create-project command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいプロジェクトを作成するには、create-project コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project hello-world
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project hello-world
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a folder called 'hello-world' in your current working directory using default groupId, artifactId and version values (groupId='org.acme', artifactId='quarkus' and version='1.0.0-SNAPSHOT').</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、デフォルトの groupId、artifactId、および version の値 (groupId='org.acme', artifactId='quarkus', version='1.0.0-SNAPSHOT') を使用して、現在の作業ディレクトリーに 'hello-world' という名前のフォルダーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify the groupId, artifactId and version values, use the '--groupid', '--artifactid' and '--version' options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>groupId、artifactId、および version の値を指定するには、'--groupid'、'--artifactid'、および '--version' オプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the help option to display all the possible options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なすべてのオプションを表示するには、ヘルプオプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can obtain a list of the available extensions with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI では、利用可能なエクステンションのリストを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus list-extensions
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus list-extensions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To more easily get an overview and only display the extension names:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より簡単に概要を取得し、エクステンション名のみを表示する場合は、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus list-extensions -n
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus list-extensions -n
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding extension(s)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can add Quarkus extensions to your project with the 'add-extension' command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI では、'add-extension' コマンドを使用して、Quarkus のエクステンションをプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus add-extension --extension=hibernate-validator /path/to/my/project
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus add-extension --extension=hibernate-validator /path/to/my/project
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The argument path either needs to be the base folder for the project or a direct path to the build file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>引数のパスは、プロジェクトのベースフォルダーかビルドファイルへの直接パスである必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start dev mode from the Quarkus CLI do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI から dev モードを起動するには、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus dev /path/to/my/project
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus dev /path/to/my/project
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with 'add-extension' the argument path needs to be the base folder for the project or a direct path to the build file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>add-extension' と同様、引数のパスは、プロジェクトのベースフォルダーまたはビルドファイルへの直接パスである必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://flywaydb.org/[Flyway] is a popular database migration tool that is commonly used in JVM environments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://flywaydb.org/[Flyway] は、JVM環境でよく使われているデータベースマイグレーションツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Flyway as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、このガイドで説明するように、Flywayを使用するためのファーストクラスのサポートを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start using Flyway with your project, you just need to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトで Flyway を使い始めるには、以下のことを行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your migrations to the `{migrations-path}` folder as you usually do with Flyway</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway で通常行うように、マイグレーションを `{migrations-path}` フォルダーに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Flyway` object and run your migration as you normally do</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`migrate-at-start` オプションを有効にしてスキーマを自動的に移行するか、 `Flyway` オブジェクトを注入して通常のように移行を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Flyway extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway エクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway support relies on the Quarkus datasource config.  It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.  First, you need to add the datasource config to the `{config-file}` file in order to allow Flyway to manage the schema.  Also, you can customize the Flyway behaviour by using the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway のサポートは、Quarkus のデータソース設定に依存しています。この設定は、デフォルトのデータソースだけでなく、 すべての link:#multiple-datasources[名前の付いたデータソース] に対してカスタマイズすることができます。まず、Flyway によるスキーマ管理を可能にするために、データソース設定を `{config-file}` ファイルに追加する必要があります。また、以下のプロパティーを使用して、Flyway の動作をカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a SQL migration to the default folder following the Flyway naming conventions: `{migrations-path}/V1.0.0__Quarkus.sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{migrations-path}/V1.0.0__Quarkus.sql` のように Flyway の命名規則に従って、デフォルトフォルダーに SQL マイグレーションを追加します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Flyway's migrate method according to your config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを起動でき、Quarkus は設定に従って Flyway のマイグレーションメソッドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Flyway object if you want to use it directly</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway オブジェクトを直接使用する場合はインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway can be configured for multiple datasources.  The Flyway properties are prefixed exactly the same way as the named datasources, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway は、複数のデータソースに対して設定可能です。Flyway のプロパティーには、例えば、名前の付いたデータソースと全く同じように接頭辞が付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.  The syntax is as follows: `quarkus.flyway.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キーに余分なビットがあることに注意してください。構文は次の通りです。`quarkus.flyway.[optional name.][datasource property]` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without configuration, Flyway is set up for every datasource using the default settings.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定なしの場合、Flyway はデフォルト設定を使用して各データソースに対して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are interested in using the `Flyway` object directly, you can inject it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Flyway` オブジェクトを直接使いたい場合は、以下のように注入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enabled the `quarkus.flyway.migrate-at-start` property, by the time you use the Flyway instance, Quarkus will already have run the migrate operation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.flyway.migrate-at-start` プロパティーを有効にした場合、Flyway インスタンスを使用する時点で、Quarkus はすでにマイグレーション操作を実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources using the Quarkus `FlywayDataSource` qualifier</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus `FlywayDataSource` 修飾子を使用して、指定されたデータソースに Flyway を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前の付いたデータソースへの Flyway の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: guides-configuration-reference
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: guides-configuration-reference
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can find a list of Build Items and the extension that provides them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、ビルドアイテムとそれを提供するエクステンションの一覧を見ることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are quickly moving to an SSL-everywhere world so being able to use SSL is crucial.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>常時SSL接続の時代へと急速に移行しているので、SSLを利用できることは非常に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native executables to support SSL, as native executables don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブの実行ファイルは標準ではSSLをサポートしていないので、このガイドではネイティブの実行ファイルでSSLをサポートする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't plan on using native executables, you can pass your way as in JDK mode, SSL is supported without further manipulations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK モードでは特に変更しなくても SSL がサポートされているので、ネイティブの実行ファイルを使用する予定がない場合はパスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM (Java 11) installed with `JAVA_HOME` and `GRAALVM_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM (Java 11) をインストールし、 `JAVA_HOME` と `GRAALVM_HOME` を適切に設定しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is based on the REST client guide so you should get this Maven project first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドはRESTクライアントガイドに基づいているので、最初にこのMavenプロジェクトを取得する必要があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is located in the `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトは `rest-client-quickstart` {quickstarts-tree-url}/rest-client-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looks like it works out of the box?!?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>修正不要にみえる?!?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you open the application's configuration file (`src/main/resources/application.properties`), you can see the following line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定ファイル ( `src/main/resources/application.properties` ) を開くと、以下の行が存在します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which configures our REST client to connect to an SSL REST service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、REST クライアントが SSL REST サービスに接続するように設定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's build the application as a native executable and run the tests:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、アプリケーションをネイティブ実行ファイルとしてビルドし、テストを実行してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we obtain the following result:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、次のような結果が得られます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, yes, it appears it works out of the box and this guide is pretty useless.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、修正不要で動作し、このガイドはかなり役立たずであるように見えますね。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not. The magic happens when building the native executable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実際は、そうではありません。マジックはネイティブ実行ファイルをビルドするときに起こります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The important elements are these 3 options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>重要な要素は次の3つのオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They enable the native SSL support for your native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはネイティブ実行ファイルのネイティブSSLサポートを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Agroal connection pooling extension (`quarkus-agroal`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Agroalコネクションプールエクステンション ( `quarkus-agroal` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Amazon DynamoDB extension (`quarkus-amazon-dynamodb`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon DynamoDBエクステンション ( `quarkus-amazon-dynamodb` ),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Hibernate Search Elasticsearch extension (`quarkus-hibernate-search-orm-elasticsearch`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate Search Elasticsearch エクステンション ( `quarkus-hibernate-search-orm-elasticsearch` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Infinispan Client extension (`quarkus-infinispan-client`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan クライアントエクステンション ( `quarkus-infinispan-client` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Jaeger extension (`quarkus-jaeger`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jaeger エクステンション ( `quarkus-jaeger` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the JGit extension (`quarkus-jgit`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JGit エクステンション ( `quarkus-jgit` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Keycloak extension (`quarkus-keycloak`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Keycloak エクステンション ( `quarkus-keycloak` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Kubernetes client extension (`quarkus-kubernetes-client`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes クライアントエクステンション ( `quarkus-kubernetes-client` )、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Mailer extension (`quarkus-mailer`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mailer エクステンション ( `quarkus-mailer` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Redis client extension (`quarkus-redis-client`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Redis クライアントエクステンション ( `quarkus-redis-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the MongoDB extension (`quarkus-mongodb-client`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDB エクステンション ( `quarkus-mongodb-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Neo4j extension (`quarkus-neo4j`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Neo4j エクステンション ( `quarkus-neo4j` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the OAuth2 extension (`quarkus-elytron-security-oauth2`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OAuth2 エクステンション ( `quarkus-elytron-security-oauth2` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the REST client extension (`quarkus-rest-client`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST クライアントエクステンション ( `quarkus-rest-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Reactive client for PostgreSQL extension (`quarkus-reactive-pg-client`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PostgreSQLエクステンションのReactiveクライアント ( `quarkus-reactive-pg-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Reactive client for MySQL extension (`quarkus-reactive-mysql-client`),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MySQL エクステンションの Reactive クライアント ( `quarkus-reactive-mysql-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Reactive client for DB2 extension (`quarkus-reactive-db2-client`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>DB2 エクステンションの Reactive クライアント ( `quarkus-reactive-db2-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Cassandra client extensions (`cassandra-quarkus-client`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Cassandraクライアントエクステンション ( `cassandra-quarkus-client` ) 、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As long as you have one of those extensions in your project, the SSL support will be enabled by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトにこれらのエクステンションのいずれかがある限り、SSLサポートはデフォルトで有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's just check the size of our native executable as it will be useful later:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、あとで役立つので、ネイティブ実行ファイルのサイズを確認してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's disable SSL and see how it goes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、SSLを無効にしてどうなるか見てみましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has an option to disable the SSL support entirely.  Why? Because it comes at a certain cost.  So if you are sure you don't need it, you can disable it entirely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、SSLのサポートを完全に無効にするオプションがあります。なぜでしょうか?それは、一定のコストがかかるからです。ですから、必要ないと確信している場合は、完全に無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's disable it without changing the REST service URL and see how it goes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは、RESTサービスのURLを変えずに無効化して様子を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open `src/main/resources/application.properties` and add the following line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/resources/application.properties` を開いて、以下の行を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And let's try to build again:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、またビルドしてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable tests will fail with the following error:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのテストは、以下のエラーで失敗します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This error is the one you obtain when trying to use SSL while it was not explicitly enabled in your native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエラーは、ネイティブ実行ファイルで明示的に有効にしない状態でSSLを使用しようとしたときに発生するエラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's change the REST service URL to **not** use SSL in `src/main/resources/application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、 `src/main/resources/application.properties` でRESTサービスのURLを変更して、SSLを使用し *ない* ように変更してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And build again:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、再びビルドしましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you check carefully the native executable build options, you can see that the SSL related options are gone:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのビルドオプションをよく確認してみると、SSL関連のオプションがなくなっているのがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we end up with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You remember we checked the size of the native executable with SSL enabled? Let's check again with SSL support entirely disabled:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SSLを有効にしたネイティブ実行ファイルのサイズを確認したのを覚えていますか?SSLサポートを完全に無効にした状態でもう一度確認してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, it is now **35 MB** whereas it used to be **46 MB**. SSL comes with a 11 MB overhead in native executable size.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、以前は *46MB* だったのが *35MB* になりました。SSLはネイティブの実行可能サイズで11MBのオーバーヘッドを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And there's more to it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、それだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start again with a clean slate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クリーンな状態でもう一回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revert the changes we made to the configuration file and go back to SSL with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定ファイルに変更した内容を元に戻し、以下のコマンドでSSLを有効に戻してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And let's build the native executable again:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、もう一度ネイティブの実行ファイルをビルドしてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior is new to GraalVM 19.3+.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作はGraalVM 19.3+のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When creating a native binary, GraalVM embraces the principle of "immutable security" for the root certificates.  This essentially means that the root certificates are fixed at image build time, based on the certificate configuration used at that build time (which for Quarkus means when you perform a build having `quarkus.package.type=native` set).  This avoids shipping a `cacerts` file or requiring a system property be set in order to set up root certificates that are provided by the OS where the binary runs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブバイナリーを作成する際、GraalVMはルート証明書の「不変のセキュリティー」の原則を採用しています。これは本質的に、ルート証明書がイメージのビルド時に、そのビルド時に使用される証明書の設定に基づいて固定されることを意味します(Quarkusでは、 `quarkus.package.type=native` を設定してビルドを実行することを意味します)。これにより、 `cacerts` ファイルを出荷したり、バイナリーが実行されるOSによって提供されるルート証明書を設定するためにシステムプロパティーを設定する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a consequence, system properties such as `javax.net.ssl.trustStore` do not have an effect at run time, so when the defaults need to be changed, these system properties must be provided at image build time.  The easiest way to do so is by setting `quarkus.native.additional-build-args`. For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その結果、 `javax.net.ssl.trustStore` のようなシステムプロパティーは実行時には影響を及ぼさないため、デフォルトを変更する必要がある場合は、イメージのビルド時にこれらのシステムプロパティーを提供する必要があります。最も簡単な方法は `quarkus.native.additional-build-args` を設定することです。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will ensure that the certificates of `/tmp/mycerts` are baked into the native binary and used *in addition* to the default cacerts.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記は `/tmp/mycerts` の証明書がネイティブバイナリーに焼き込まれ、デフォルトの cacerts に *加えて* 使用されることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file containing the custom TrustStore does *not* have to be present at runtime as its content has been baked into the native binary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムTrustStoreを含むファイルは、その内容がネイティブバイナリーに焼き込まれているため、実行時に存在する必要は *ありません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with containers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーへの対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No special action needs to be taken when running the native binary in a container. If the native binary was properly built with the custom TrustStore as described in the previous section, it will work properly in container as well.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナー内でネイティブバイナリーを実行する際に特別な対応を取る必要はありません。前のセクションで説明したように、ネイティブバイナリーがカスタムTrustStoreを使って適切にビルドされていれば、コンテナー内でも正常に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We make building native executable easy and, even if the SSL support in GraalVM is still requiring some serious thinking, it should be mostly transparent when using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのビルドを簡単にしています。GraalVMでのSSLサポートはまだ真剣に考える必要があるとしても、Quarkusを使用する場合はほとんど透過的になるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We track GraalVM progress on a regular basis so we will promptly integrate in Quarkus any improvement with respect to SSL support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの進捗状況を定期的に追跡していますので、SSLサポートに関する改善点があれば、速やかにQuarkusに統合していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this reference guide we're going to describe various aspects of Quarkus configuration.  A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.  Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.  All of the standard features are supported.  Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファレンスガイドでは、Quarkus の設定の様々な側面について説明します。Quarkus アプリケーションと Quarkus 自体 (コアとエクステンション) の両方は、link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API を活用した同じメカニズムを介して設定されます。Quarkus の設定は、MicroProfile Config 仕様の実装である link:https://github.com/smallrye/smallrye-config[SmallRye Config] に基づいています。標準機能はすべてサポートされています。さらに、Quarkus だけでなく、SmallRye Config プロジェクトでも利用可能な追加機能がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're looking for information how to make a Quarkus extension configurable then see the &lt;&lt;writing-extensions.adoc#configuration,Writing Your Own Extension&gt;&gt; guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus エクステンションを設定可能にする方法については、link:writing-extensions.html#configuration[独自のエクステンションの作成] ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Sources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定ソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus reads configuration properties from several sources (in decreasing priority):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus は、複数のソースから設定プロパティーを (優先度の高い順に) 読み取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;system_properties,System properties&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#system_properties[システムプロパティー]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;environment_variables,Environment variables&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#environment_variables[環境変数]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;env_file,File named `.env`&gt;&gt; placed in the current working directory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の作業ディレクトリーに置かれた link:#env_file[`.env` という名前のファイル]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#pwd_config_application_file[`application.properties` ファイルを `$PWD/config/` ディレクトリーに配置]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;application_properties_file,An application configuration file&gt;&gt;, i.e. `src/main/resources/application.properties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#application_properties_file[アプリケーション設定ファイル] (すなわち `src/main/resources/application.properties`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>System properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムプロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile Config].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数名は、link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile Config] の変換ルールに従っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File named `.env` placed in the current working directory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の作業ディレクトリーに置かれた `.env` という名前のファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example `.env` file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`.env` ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>QUARKUS_DATASOURCE_PASSWORD=youshallnotpass &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QUARKUS_DATASOURCE_PASSWORD=youshallnotpass &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for &lt;&lt;environment_variables&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QUARKUS_DATASOURCE_PASSWORD` という名前は、link:#environment_variables[environment_variables] と同じルールで変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>dev モードの場合、このファイルはプロジェクトのルートに置くことができますが、バージョン管理を選択 **しない** ことが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`.env` ファイルに設定プロファイルが定義されていない環境変数は、`application.properties` 内のすべての関連プロファイルを上書きします。たとえば、`%test.application.value` は `.env` ファイルの `APPLICATION_VALUE` により上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An `application.properties` file placed in `$PWD/config/`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`$PWD/config/` の `application.properties` ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration.  Furthermore any runtime properties added to this file that were not part of the original `application.properties` file _will also_ be taken into account.  This works in the same way for runner jar and the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが実行するディレクトリーに存在する `config` という名前のディレクトリーに `application.properties` ファイルを置くことで、そのファイルで定義されているランタイムプロパティーは、デフォルトの設定を上書きします。さらに、元の `application.properties` ファイルの一部ではない、このファイルに追加されたランタイムプロパティーも _取り入れられます_。これは、ランナー jar とネイティブ実行ファイルでも同じように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).  Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`config/application.properties` 機能は開発モードでも利用可能です。これを利用するには、ビルドツールの出力ディレクトリー (Maven の場合は `target` 、Gradle の場合は `build/classes/java/main`) の中に `config/application.properties` を置く必要があります。ただし、`mvn clean` や `gradle clean` のようなビルドツールからのクリーンアップ操作は、`config` ディレクトリーも削除してしまうことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An application configuration file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション設定ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the main application configuration file located in `src/main/resources/application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `src/main/resources/application.properties` にあるメインのアプリケーション設定ファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example `application.properties` file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` ファイル例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>greeting.message=hello &lt;1&gt;
quarkus.http.port=9090 &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>greeting.message=hello &lt;1&gt;
quarkus.http.port=9090 &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a user-defined configuration property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ユーザー定義の設定プロパティーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a configuration property consumed by the `quarkus-vertx-http` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `quarkus-vertx-http` エクステンションによって消費される設定プロパティーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of &lt;&lt;using_property_expressions,property expressions&gt;&gt; in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、`application.properties` ファイルの link:#using_property_expressions[プロパティー式] の使用をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting configuration properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティーの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、 link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] アノテーションを使用して、アプリケーションに設定プロパティーを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperty(name = "greeting.message") &lt;1&gt;
String message;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperty(name = "greeting.message") &lt;1&gt;
String message;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.  The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.  This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Inject @ConfigProperty` を使用することも、 `@ConfigProperty` だけを使用することもできます。 `@Inject` アノテーションは、 `@ConfigProperty` でアノテーションされたメンバーには必要ありません。この動作は link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定されていない設定プロパティーをアプリケーションが注入しようとすると、エラーが発生するため、設定が完了した時期をすぐに知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More `@ConfigProperty` Examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の `@ConfigProperty` の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperty(name = "greeting.suffix", defaultValue="!") &lt;2&gt;
String suffix;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperty(name = "greeting.suffix", defaultValue="!") &lt;2&gt;
String suffix;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperty(name = "greeting.name")
Optional&lt;String&gt; name; &lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperty(name = "greeting.name")
Optional&lt;String&gt; name; &lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロパティーに値を指定しないと、アプリケーションの起動は `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message` エラーで失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is injected if the configuration does not provide a value for `greeting.suffix`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト値は、設定が `greeting.suffix` の値を提供していない場合に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロパティーはオプションです - 設定が `greeting.name` の値を提供していない場合は、空の `Optional` が注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically access the configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定にプログラムでアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also access the configuration programmatically.  It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プログラムで設定にアクセスすることもできます。動的なルックアップを実現したり、CDI Bean でも JAX-RS リソースでもないクラスから設定値を取得したりするのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `org.eclipse.microprofile.config.ConfigProvider.getConfig()` を使用してプログラムで設定にアクセスすることも出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>String databaseName = ConfigProvider.getConfig().getValue("database.name", String.class);
Optional&lt;String&gt; maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue("database.name", String.class);
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>String databaseName = ConfigProvider.getConfig().getValue("database.name", String.class);
Optional&lt;String&gt; maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue("database.name", String.class);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using @ConfigProperties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperties の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an alternative to injecting multiple related configuration values in the way that was shown in the previous example, users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の例で示した方法で複数の関連する設定値を注入する代わりに、`@io.quarkus.arc.config.ConfigProperties` アノテーションを使用して、これらのプロパティーをまとめてグループを作成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the greeting properties above, a `GreetingConfiguration` class could be created like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のグリーティングプロパティーについては、以下のように `GreetingConfiguration` クラスを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.config;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.config;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.arc.config.ConfigProperties;
import java.util.Optional;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.arc.config.ConfigProperties;
import java.util.Optional;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperties(prefix = "greeting") &lt;1&gt;
public class GreetingConfiguration {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperties(prefix = "greeting") &lt;1&gt;
public class GreetingConfiguration {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private String message;
    private String suffix = "!"; &lt;2&gt;
    private Optional&lt;String&gt; name;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private String message;
    private String suffix = "!"; &lt;2&gt;
    private Optional&lt;String&gt; name;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public String getSuffix() {
        return suffix;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public String getSuffix() {
        return suffix;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Optional&lt;String&gt; getName() {
        return name;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public Optional&lt;String&gt; getName() {
        return name;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public void setName(Optional&lt;String&gt; name) {
        this.name = name;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public void setName(Optional&lt;String&gt; name) {
        this.name = name;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`prefix` は任意です。設定していない場合は、使用される接頭辞はクラス名によって決まります。この場合も (`Configuration` の接尾辞は削除されているため) `greeting` となります。クラス名が `GreetingExtraConfiguration` の場合は、デフォルトの接頭辞が `greeting-extra` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`!` will be the default value if `greeting.suffix` is not set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`!` は、`greeting.suffix` が設定されていない場合のデフォルト値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは、おなじみの CDI `@Inject` アノテーションを使用して `GreetingResource` に注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Inject
GreetingConfiguration greetingConfiguration;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Inject
GreetingConfiguration greetingConfiguration;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus が提供する別のスタイルは、`GreetingConfiguration` を以下のようなインターフェースとして作成することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.arc.config.ConfigProperties;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import java.util.Optional;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.arc.config.ConfigProperties;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import java.util.Optional;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperties(prefix = "greeting")
public interface GreetingConfiguration {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperties(prefix = "greeting")
public interface GreetingConfiguration {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @ConfigProperty(name = "message") &lt;1&gt;
    String message();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @ConfigProperty(name = "message") &lt;1&gt;
    String message();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @ConfigProperty(defaultValue = "!")
    String getSuffix(); &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @ConfigProperty(defaultValue = "!")
    String getSuffix(); &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Optional&lt;String&gt; getName(); &lt;3&gt;
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    Optional&lt;String&gt; getName(); &lt;3&gt;
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドが対応する構成プロパティーの名前が getter メソッドの命名規則に従っていないため、 `@ConfigProperty` 注釈が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case since `name` was not set, the corresponding property will be `greeting.suffix`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、`name` が設定されていないため、対応するプロパティーは `greeting.suffix` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッド名は getter メソッドの命名規則 (`greeting.name` が対応するプロパティー) に従っており、デフォルト値は不要なため、`@ConfigProperty` アノテーションを指定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.  This does not apply to `Optional` fields and fields with a default value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスまたはインターフェイスで `@ConfigProperties` を使用する場合は、そのフィールドの 1 つの値が提供されていないと、アプリケーションの起動に失敗し、値情報の欠落を示す `javax.enterprise.inject.spi.DeploymentException` が発生します。これは `Optional` フィールドとデフォルト値を持つフィールドには適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional notes on @ConfigProperties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperties に関する追加の注意事項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.  Having simple public non-final fields is valid as well.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConfigProperties` でアノテーションされた通常のクラスを使用する場合、クラスは必ずしも getter および setter を宣言する必要はありません。単純でパブリックな確定的でないフィールドを持つことも有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer of greeting configuration named `content` that would contain a few fields. This could be achieved like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、設定クラスは入れ子になったオブジェクトの設定をサポートしています。たとえば、いくつかのフィールドを含む `content` という名前のグリーティング設定の追加レイヤーが必要であったと仮定します。これは次のように実現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperties(prefix = "greeting")
public class GreetingConfiguration {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperties(prefix = "greeting")
public class GreetingConfiguration {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public String message;
    public String suffix = "!";
    public Optional&lt;String&gt; name;
    public ContentConfig content; &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public String message;
    public String suffix = "!";
    public Optional&lt;String&gt; name;
    public ContentConfig content; &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public static class ContentConfig {
        public Integer prizeAmount;
        public List&lt;String&gt; recipients;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public static class ContentConfig {
        public Integer prizeAmount;
        public List&lt;String&gt; recipients;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name of the field (not the class name) will determine the name of the properties that are bound to the object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フィールドの名前 (クラス名ではありません) は、オブジェクトにバインドされるプロパティーの名前を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting the properties would occur in the normal manner, for example in `application.properties` one could have:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーの設定は通常の方法で行われ、例えば `application.properties` の場合は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>greeting.message = hello
greeting.name = quarkus
greeting.content.prize-amount=10
greeting.content.recipients=Jane,John
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>greeting.message = hello
greeting.name = quarkus
greeting.content.prize-amount=10
greeting.content.recipients=Jane,John
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、`@ConfigProperties` でアノテーションされたクラスは、以下の例に似た Bean Validation アノテーションでアノテートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Size(min = 20)
    public String message;
    public String suffix = "!";
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Size(min = 20)
    public String message;
    public String suffix = "!";
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For validation to work, the `quarkus-hibernate-validator` extension needs to be present.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>検証が機能するようにするには、`quarkus-hibernate-validator` 拡張モジュールが存在する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定された設定で検証に失敗した場合、アプリケーションは起動に失敗し、対応する検証エラーをログに表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from the entire interface hierarchy are used to bind properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConfigProperties` でアノテートされたインターフェースの場合、インターフェースは他のインターフェースを拡張することができ、インターフェース階層全体のメソッドがプロパティーをバインドするために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using same ConfigProperties with different prefixes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同じ ConfigProperties で異なる接頭辞を使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.  Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.  In that case the code would look like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、`io.quarkus.arc.config.@ConfigPrefix` アノテーションを使用して、注入ポイントごとに異なる接頭辞を持つ同じ `@ConfigProperties` オブジェクトの使用もサポートしています。たとえば、上の `GreetingConfiguration` を、`greeting` の接頭辞と `other` の接頭辞の両方に使用する必要があるとします。その場合のコードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`GreetingConfiguration.java`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingConfiguration.java`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`SomeBean.java`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SomeBean.java`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class SomeBean {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped
public class SomeBean {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject &lt;1&gt;
    GreetingConfiguration greetingConfiguration;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject &lt;1&gt;
    GreetingConfiguration greetingConfiguration;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @ConfigPrefix("other") &lt;2&gt;
    GreetingConfiguration otherConfiguration;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @ConfigPrefix("other") &lt;2&gt;
    GreetingConfiguration otherConfiguration;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この注入ポイントでは、`greetingConfiguration` は `@ConfigProperties` で定義されている `greeting` の接頭辞を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この注入ポイントでは、`otherConfiguration` は、`greeting` の接頭辞の代わりに `@ConfigPrefix` から `other` の接頭辞を使用します。この場合、`@Inject` は必須ではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a list of objects</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オブジェクトリストの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain cases it might be necessary to support complex configuration structures that utilize a list of objects as shown in the following example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の例のようにオブジェクトのリストを利用する複雑な構成構造をサポートしないといけない場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ComplexConfiguration.java`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ComplexConfiguration.java`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperties(prefix = "complex")
public class ComplexConfiguration {
    public String name;
    public String user;
    public String password;
    public List&lt;Nested&gt; inputs;
    public List&lt;Nested&gt; outputs;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperties(prefix = "complex")
public class ComplexConfiguration {
    public String name;
    public String user;
    public String password;
    public List&lt;Nested&gt; inputs;
    public List&lt;Nested&gt; outputs;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public static class Nested {
        public String user;
        public String password;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public static class Nested {
        public String user;
        public String password;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Support for such use cases is only available when using YAML configuration with the `quarkus-config-yaml` extension. A corresponding example YAML configuration could be:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなユースケースのサポートは、`quarkus-config-yaml` 拡張モジュールで YAML 設定を使用する場合にのみ利用できます。対応する YAML 設定の例は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`application.yaml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.yaml`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>complex:
  name: defaultName
  user: defaultUser
  password: defaultPassword
  inputs:
    - user: user
      password: secret
    - user: otheruser
      password: secret2
  outputs:
    - user: someuser
      password: asecret
    - user: someotheruser
      password: anothersecret
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>complex:
  name: defaultName
  user: defaultUser
  password: defaultPassword
  inputs:
    - user: user
      password: secret
    - user: otheruser
      password: secret2
  outputs:
    - user: someuser
      password: asecret
    - user: someotheruser
      password: anothersecret
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A limitation of such configuration is that the types used as the generic types of the lists need to be classes and not interfaces.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このような設定の制限は、リストの汎用型として使用される型がインターフェースではなくクラスである必要があることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Profiles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the notion of configuration profiles.  These allow you to have multiple configurations in the same file and select between them via a profile name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、設定プロファイルという概念をサポートしています。これにより、同じファイル内に複数の設定を持つことができ、プロファイル名を使用してそれらの間で選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syntax for this is `%{profile}.config.key=value`. For example if I have the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このための構文は `%{profile}.config.key=value` です。例えば、以下のような場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.port=9090
%dev.quarkus.http.port=8181
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.http.port=9090
%dev.quarkus.http.port=8181
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の HTTP ポートは 9090 になります。この場合は、`dev` プロファイルがアクティブでない限り、8181 になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`.env` ファイルでプロファイルを使用するには、`_{PROFILE}_CONFIG_KEY=value` のパターンに従います。`.env` ファイル内の上記の例と同等のものは、次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus has three profiles, although it is possible to use as many as you like.  The default profiles are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus には 3 つのプロファイルがあります。デフォルトのプロファイルは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*dev* - Activated when in development mode (i.e. `quarkus:dev`)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*dev* - 開発モードのときに有効になる (つまり `quarkus:dev`)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*test* - Activated when running tests
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*test* - テストを実行しているときに有効になる
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*prod* - The default profile when not running in development or test mode
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*prod* - 開発モードまたはテストモード以外で使用されるデフォルトプロファイル
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE` environment variable. If both are set the system property takes precedence. Note that it is not necessary to define the names of these profiles anywhere, all that is necessary is to create a config property with the profile name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムプロファイルを設定するには、`quarkus.profile` システムプロパティーまたは `QUARKUS_PROFILE` 環境変数を介して設定する方法があります。両方が設定されている場合は、システムプロパティーが優先されます。これらのプロファイルの名前をどこかで定義する必要はないことに注意してください。必要なのは、プロファイル名を含む設定プロパティーを作成し、現在のプロファイルをその名前に設定することだけです。たとえば、`staging` プロファイルに異なる HTTP ポートを設定する場合は、`application.properties` に以下を追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.http.port=9090
%staging.quarkus.http.port=9999
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.http.port=9090
%staging.quarkus.http.port=9999
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、`QUARKUS_PROFILE` 環境変数を `staging` に設定して、プロフィールを有効化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アクティブなプロファイルをプログラムで確認する適切な方法は、`io.quarkus.runtime.configuration.ProfileManager` の `getActiveProfile` メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@ConfigProperty("quarkus.profile")` will *not* work properly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConfigProperty("quarkus.profile")` を使用すると正常に**動作しません**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Runtime Profile</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのランタイムプロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default Quarkus application runtime profile is set to the profile used to build the application.  For example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトの Quarkus アプリケーションランタイムプロファイルは、アプリケーションの構築に使用されるプロファイルに設定されています。たとえば、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw package -Pnative -Dquarkus.profile=prod-aws
./target/my-app-1.0-runner // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw package -Pnative -Dquarkus.profile=prod-aws
./target/my-app-1.0-runner // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドは、`prod-aws` プロファイルで実行されます。これは `quarkus.profile` システムプロパティーを使用して上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of property expressions in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、`application.properties` ファイルのプロパティー式の使用をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These expressions are resolved when the property is read.  So if your configuration property is a build time configuration property, the property expression will be resolved at build time.  If your configuration property is overridable at runtime, the property expression will be resolved at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの式は、プロパティーの読み込み時に解決されます。したがって、設定プロパティーがビルド時の設定プロパティーである場合、プロパティー式はビルド時に解決されます。設定プロパティーが実行時にオーバーライド可能になると、プロパティー式は実行時に解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use property expressions both for the Quarkus configuration or for your own configuration properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティー式は、Quarkus の設定にも、独自の設定プロパティーにも使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Property expressions are defined this way: `${my-property-expression}`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティー式は、`${my-property-expression}` と定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, having the following property:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、以下のようなプロパティーがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>remote.host=quarkus.io
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>remote.host=quarkus.io
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and another property defined as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、以下のように定義された別のプロパティーがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>callable.url=https://${remote.host}/
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>callable.url=https://${remote.host}/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>will result in the value of the `callable.url` property being set to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、`callable.url` プロパティーの値が設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>callable.url=https://quarkus.io/
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>callable.url=https://quarkus.io/
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example would be defining different database servers depending on the profile used:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の例としては、使用するプロファイルに応じて異なるデータベースサーバーを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false
quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false
quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>can be simplified by having:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、以下を指定することで簡略化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%dev.application.server=localhost
application.server=remotehost
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%dev.application.server=localhost
application.server=remotehost
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does result in one more line in this example but the value of `application.server` can be reused in other properties, diminishing the possibility of typos and providing more flexibility in property definitions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例ではさらに 1 行増えることになりますが、`application.server` の値は他のプロパティーで再利用でき、タイポの可能性を減らし、プロパティー定義の柔軟性を高めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining Property Expressions and Environment Variables</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティー式と環境変数の組み合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports the combination of both property expressions and environment variables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkus は、プロパティー式と環境変数の両方を組み合わせることもサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's assume you have the following property defined in `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` で以下のようなプロパティーが定義されているとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can combine environment variables and property expressions by having a property defined as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のようにプロパティーを定義しておくことで、環境変数とプロパティー式を組み合わせることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>application.host=${HOST:${remote.host}}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>application.host=${HOST:${remote.host}}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `HOST` 環境変数を展開し、`HOST` が設定されていない場合は、プロパティー `remote.host` の値をデフォルト値として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purpose of this section we used the property `remote.host` we defined previously.  It has to be noted that the value could have been a fixed one such as in:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このセクションでは、先に定義したプロパティー `remote.host` を使用しています。値は、次のような固定値である可能性があることに注意する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>application.host=${HOST:localhost}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>application.host=${HOST:localhost}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>which will result in `localhost` as the default value if `HOST` is not set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`HOST` が設定されていない場合は `localhost` がデフォルト値になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in `application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 自体は、アプリケーションと同じメカニズムで設定されます。Quarkus は、独自の設定とすべてのエクステンションの設定のために、`quarkus.` 名前空間を予約します。たとえば、HTTP サーバーポートを設定するには、`application.properties` で `quarkus.http.port` を設定します。Quarkus の設定プロパティーはすべて link:all-config[文書化されており、検索可能です]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and its extensions.  Therefore `quarkus.` should **never** be used as prefix for application specific properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上述したように、`quarkus.` で始まるプロパティーは、事実上、Quarkus 自体とそのエクステンションを設定するために予約されています。したがって、`quarkus.` は、アプリケーション固有のプロパティーの接頭辞として使用すべきでは**ありません**。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の例では、 `greeting.message` の代わりに `quarkus.message` を使用すると、予期せぬ動作をすることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does much of its configuration and bootstrap at build time and some configuration properties are read and used during the build.  These properties are _fixed at build time_ and it's not possible to change them at runtime.  You always need to repackage your application in order to reflect changes of such properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、その設定とブートストラップの多くをビルド時に行い、いくつかの設定プロパティーはビルド中に読み込まれて使用されます。これらのプロパティーは _ビルド時に固定され_ ており、実行時に変更することはできません。このようなプロパティーの変更を反映させるには、常にアプリケーションをリパッケージする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時に固定されたプロパティーは、 link:all-config[すべての設定オプションのリスト] でロックアイコン([lock])でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, some extensions do define properties that can be _overriden at runtime_.  A canonical example is the database URL, username and password which are only known specifically in your target environment.  This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do.  The list of runtime properties is therefore lean.  You can override these runtime properties with the following mechanisms (in decreasing priority) using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、いくつかのエクステンションは _実行時に上書き_ できるプロパティーを定義します。典型的な例としては、データベースの URL、ユーザー名、およびパスワードがありますが、これらはターゲット環境でのみ認識されます。これは、ランタイムプロパティーが多いほど、Quarkus が実行できるビルド時間の前処理が少なくなるため、トレードオフの関係にあります。そのため、ランタイムプロパティーの一覧は無駄がありません。これらのランタイムプロパティーは、以下のメカニズムを使用して (優先度の高い順に) 上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An environment file named `.env` placed in the current working directory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の作業ディレクトリーに配置された `.env` という名前の環境ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A configuration file placed in `$PWD/config/application.properties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`$PWD/config/application.properties` に配置された設定ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See &lt;&lt;configuration_sources&gt;&gt; for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、link:#configuration_sources[configuration_sources] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating configuration for your application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション設定の生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to generate an example `application.properties` with all known configuration properties, to make it easy to see what Quarkus configuration options are available. To do this, run:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkus 設定オプションがどのようなものかを簡単に確認できるように、すべての既知の設定プロパティーを含むサンプル (`application.properties`) を生成することもできます。これを行うには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/mvnw quarkus:generate-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/mvnw quarkus:generate-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a `src/main/resources/application.properties.example` file that contains all the config options exposed via the extensions you currently have installed. These options are commented out, and have their default value when applicable. For example this HTTP port config entry will appear as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、現在インストールされているエクステンションを介して公開されているすべての設定オプションを含む `src/main/resources/application.properties.example` ファイルが作成されます。これらのオプションはコメントアウトされ、該当する場合はデフォルト値となります。たとえば、この HTTP ポート設定エントリーは次のように表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># # The HTTP port # #quarkus.http.port=8080</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># # The HTTP port # #quarkus.http.port=8080</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile` parameter:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サンプルの設定ファイルを生成するのではなく、`-Dfile` パラメーターを設定して実際の設定ファイルに追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/mvnw quarkus:generate-config -Dfile=application.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/mvnw quarkus:generate-config -Dfile=application.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a config option is already present (commented or not) it will not be added, so it is safe to run this after adding an additional extension to see what additional options have been added.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定オプションが既に存在する場合 (コメントされていてもいなくても) は追加されないため、エクステンションを追加した後にこれを実行して、どのような追加オプションが追加されたかを確認するのが安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clearing properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティーの削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run time properties which are optional, and which have had values set at build time or which have a default value, may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect runtime properties, and will _only_ work with properties whose values are not required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>任意であり、ビルド時に値が設定されていたり、デフォルト値が設定されていたりするランタイムプロパティーは、空の文字列をプロパティーに代入することで明示的に削除することができます。これはランタイムプロパティーに _のみ_ 影響し、値が必須ではないプロパティーで _のみ_ 動作することに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The property may be cleared by setting the corresponding `application.properties` property, setting the corresponding system property, or setting the corresponding environment variable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロパティーは、対応する `application.properties` プロパティーを設定したり、対応するシステムプロパティーを設定したり、対応する環境変数を設定したりすることで削除できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom configuration sources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム設定ソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource` or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the class and it will be detected and installed at application startup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>標準的な MicroProfile Config の方法でカスタム設定ソースを導入することもできます。これを行うには、`org.eclipse.microprofile.config.spi.ConfigSource` または `org.eclipse.microprofile.config.spi.ConfigSourceProvider` を実装したクラスを提供する必要があります。クラスに link:https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[サービスファイル] を作成すると、アプリケーションの起動時に検出されてインストールされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom configuration converters</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム設定コンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use your custom types for configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter&lt;T&gt;` and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定値にカスタムタイプを使用することもできます。これは `org.eclipse.microprofile.config.spi.Converter&lt;T&gt;` を実装し、`META-INF/services/org.eclipse.microprofile.config.spi.Converter` ファイルにその完全修飾クラス名を追加することで行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let us assume you have a custom type like this one:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなカスタムタイプを想定してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class MicroProfileCustomValue {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class MicroProfileCustomValue {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private final int number;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private final int number;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public MicroProfileCustomValue(int number) {
        this.number = number;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public MicroProfileCustomValue(int number) {
        this.number = number;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public int getNumber() {
        return number;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public int getNumber() {
        return number;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have a `public` no-argument constructor. It also must not be `abstract`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>対応するコンバータは以下のようになります。カスタムコンバータクラスは `public` で、`public` の引数がないコンストラクターを持つ必要があることに注意してください。また、`abstract` にはしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.eclipse.microprofile.config.spi.Converter;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import org.eclipse.microprofile.config.spi.Converter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class MicroProfileCustomValueConverter implements Converter&lt;MicroProfileCustomValue&gt; {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class MicroProfileCustomValueConverter implements Converter&lt;MicroProfileCustomValue&gt; {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public MicroProfileCustomValue convert(String value) {
        return new MicroProfileCustomValue(Integer.parseInt(value));
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public MicroProfileCustomValue convert(String value) {
        return new MicroProfileCustomValue(Integer.parseInt(value));
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.  If you have more converters, simply add their class names in this file as well. One fully qualified class name per line, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、コンバーターの完全修飾クラス名をサービスファイル `META-INF/services/org.eclipse.microprofile.config.spi.Converter` に含める必要があります。他にもコンバーターがある場合は、そのクラス名をこのファイルに追加してください。たとえば、1 行に 1 つの完全修飾クラス名を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>org.acme.config.MicroProfileCustomValueConverter
org.acme.config.SomeOtherConverter
org.acme.config.YetAnotherConverter
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>org.acme.config.MicroProfileCustomValueConverter
org.acme.config.SomeOtherConverter
org.acme.config.YetAnotherConverter
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for demonstration purposes. If you include in this file classes which are not available at runtime, the converters loading will fail.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SomeOtherConverter` と `YetAnotherConverter` はデモンストレーションのためだけに追加されたものであることに注意してください。実行時に利用できないクラスをこのファイルに含めると、コンバーターの読み込みに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After this is done, you can use your custom type as a configuration value:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが終わったら、カスタムタイプを設定値として使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ConfigProperty(name = "configuration.value.name")
MicroProfileCustomValue value;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ConfigProperty(name = "configuration.value.name")
MicroProfileCustomValue value;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Converter priority</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンバーターの優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some cases, you may want to use a custom converter to convert a type which is already converted by a different converter. In such cases, you can use the `javax.annotation.Priority` annotation to change converters precedence and make your custom converter of higher priority than the other in the list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>場合によっては、すでに別のコンバーターで変換されている型をカスタムコンバーターで変換したいこともあるでしょう。そのような場合は、`javax.annotation.Priority` アノテーションを使用してコンバーターの優先順位を変更し、カスタムコンバーターをリストの他のコンバーターよりも優先度の高いものにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, if no `@Priority` can be found on a converter, it's registered with a priority of 100 and all Quarkus core converters are registered with a priority of 200, so depending on which converter you would like to replace, you need to set a higher value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、コンバーターに `@Priority` が見つからない場合は優先度 100 で登録され、Quarkus のコアコンバーターはすべて優先度 200 で登録されているため、どのコンバーターを置き換えるかによっては、より高い値を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To demonstrate the idea let us implement a custom converter which will take precedence over `MicroProfileCustomValueConverter` implemented in the previous example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアイデアを実証するために、先ほどの例で実装した `MicroProfileCustomValueConverter` よりも優先されるカスタムコンバーターを実装してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.annotation.Priority;
import org.eclipse.microprofile.config.spi.Converter;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.annotation.Priority;
import org.eclipse.microprofile.config.spi.Converter;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Priority(150)
public class MyCustomConverter implements Converter&lt;MicroProfileCustomValue&gt; {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Priority(150)
public class MyCustomConverter implements Converter&lt;MicroProfileCustomValue&gt; {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public MicroProfileCustomValue convert(String value) {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public MicroProfileCustomValue convert(String value) {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        final int secretNumber;
        if (value.startsFrom("OBF:")) {
            secretNumber = Integer.parseInt(SecretDecoder.decode(value));
        } else {
            secretNumber = Integer.parseInt(value);
        }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        final int secretNumber;
        if (value.startsFrom("OBF:")) {
            secretNumber = Integer.parseInt(SecretDecoder.decode(value));
        } else {
            secretNumber = Integer.parseInt(value);
        }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        return new MicroProfileCustomValue(secretNumber);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        return new MicroProfileCustomValue(secretNumber);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since it converts the same value type (namely `MicroProfileCustomValue`) and has a priority of 150, it will be used instead of a `MicroProfileCustomValueConverter` which has a default priority of 100.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは同じ値タイプ (すなわち `MicroProfileCustomValue`) を変換し、優先度が 150 であるため、デフォルトの優先度が 100 の `MicroProfileCustomValueConverter` の代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This new converter also needs to be listed in a service file, i.e. `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この新しいコンバーターは、サービスファイル、すなわち `META-INF/services/org.eclipse.microprofile.config.spi.Converter` に記載する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>YAML for Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定用 YAML</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might want to use YAML over properties for configuration.  Since link:https://github.com/smallrye/smallrye-config[SmallRye Config] brings support for YAML configuration, Quarkus supports this as well.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定に、プロパティーよりも YAML を使いたい場合があるかもしれません。link:https://github.com/smallrye/smallrye-config[SmallRye Config] は YAML 設定をサポートしているため、Quarkus でもこの設定がサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First you will need to add the Config YAML extension to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初に Config YAML 拡張モジュールを `pom.xml` に追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-config-yaml&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-config-yaml&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or you can alternatively run this command in the directory containing your Quarkus project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、Quarkus プロジェクトが含まれるディレクトリーでこのコマンドを実行することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="config-yaml"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="config-yaml"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now Quarkus can read YAML configuration files.  The config directories and priorities are the same as before.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで Quarkus は YAML 設定ファイルを読み込めるようになりました。設定ディレクトリーと優先順位は以前と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus will choose an `application.yaml` over an `application.properties`.  YAML files are just an alternative way to configure your application.  You should decide and keep one configuration type to avoid errors.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、`application.yaml` が `application.properties` よりも優先されます。YAML ファイルは、アプリケーションを設定するための代替手段にすぎません。エラーを回避するには、設定タイプを 1 つ決めて保持しておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># YAML supports comments
quarkus:
  datasource:
    db-kind: postgresql
    jdbc:
      url: jdbc:postgresql://localhost:5432/some-database
    username: quarkus
    password: quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># YAML supports comments
quarkus:
  datasource:
    db-kind: postgresql
    jdbc:
      url: jdbc:postgresql://localhost:5432/some-database
    username: quarkus
    password: quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># REST Client configuration property
org:
  acme:
    restclient:
      CountriesService/mp-rest/url: https://restcountries.eu/rest
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># REST Client configuration property
org:
  acme:
    restclient:
      CountriesService/mp-rest/url: https://restcountries.eu/rest
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># For configuration property names that use quotes, do not split the string inside the quotes.
quarkus:
  log:
    category:
      "io.quarkus.category":
        level: INFO
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># For configuration property names that use quotes, do not split the string inside the quotes.
quarkus:
  log:
    category:
      "io.quarkus.category":
        level: INFO
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also supports using `application.yml` as the name of the YAML file. The same rules apply for this file as for `application.yaml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は YAML ファイルの名前として `application.yml` を使用することもサポートしています。このファイルには、 `application.yaml` と同じルールが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Profile dependent configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイル依存の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing profile dependent configuration with YAML is done like with properties.  Just add the `%profile` wrapped in quotation marks before defining the key-value pairs:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイル依存の設定を YAML で提供することはプロパティーと同じように行われます。キーと値のペアを定義する前に、引用符で囲んだ `%profile` を追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>"%dev":
  quarkus:
    datasource:
      db-kind: postgresql
      jdbc:
        url: jdbc:postgresql://localhost:5432/some-database
      username: quarkus
      password: quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"%dev":
  quarkus:
    datasource:
      db-kind: postgresql
      jdbc:
        url: jdbc:postgresql://localhost:5432/some-database
      username: quarkus
      password: quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration key conflicts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定キーの競合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MicroProfile Configuration specification defines configuration keys as an arbitrary `.`-delimited string.  However, structured formats like YAML naively only support a subset of the possible configuration namespace.  For example, consider the two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`.  One property is the prefix of another, so it may not be immediately evident how to specify both keys in your YAML configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile の設定仕様は、設定キーを任意の `.` 区切り文字列として定義しています。ただし、YAML のような構造化されたフォーマットは、可能な設定名前空間のサブセットしかサポートしていません。たとえば、`quarkus.http.cors` および `quarkus.http.cors.methods` の 2 つの設定プロパティーについて考えてみましょう。あるプロパティーは別のプロパティーの接頭辞なので、YAML の設定で両方のキーをどのように指定するかはすぐにはわからないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is solved by using a `null` key (normally represented by `~`) for any YAML property which is a prefix of another one.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、別のプロパティーの接頭辞である YAML プロパティーに `null` キー (通常は `~` で示される) を使用することで解決されます。例を以下に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example YAML configuration resolving prefix-related key name conflicts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>接頭辞関連のキー名の競合を解決する YAML 設定の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus:
  http:
    cors:
      ~: true
      methods: GET,PUT,POST
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus:
  http:
    cors:
      ~: true
      methods: GET,PUT,POST
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, `null` YAML keys are not included in assembly of the configuration property name, allowing them to be used to any level for disambiguating configuration keys.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的に、`null` YAML キーは設定プロパティー名のアセンブリーには含まれていないため、設定キーを曖昧にするために任意のレベルで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More info on how to configure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定方法の詳細</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus relies on SmallRye Config and inherits its features.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は SmallRye Config に依存しており、その機能を継承しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Config provides:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Config は以下を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional Config Sources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の設定ソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional Converters</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のコンバーター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors for configuration value resolution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定値解決のためのインターセプタ―</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Relocate Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティーの再配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fallback Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フォールバック設定プロパティー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hide Secrets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>secret の非表示</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, please check the link:https://smallrye.io/docs/smallrye-config/index.html[SmallRye Config documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、link:https://smallrye.io/docs/smallrye-config/index.html[SmallRye Config のドキュメント] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Connection Health Check</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>接続のヘルスチェック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when you access the `/q/health/ready` endpoint of your application you will have information about the connection validation status.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、アプリケーションの `/q/health/ready` エンドポイントにアクセスすると、接続の検証状況に関する情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>having access to an Azure subscription. https://azure.microsoft.com/free/?WT.mc_id=opensource-quarkus-brborges[Get a free one here]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure サブスクリプションにアクセスできること。 link:https://azure.microsoft.com/free/?WT.mc_id=opensource-quarkus-brborges[無料のものを入手するには、ここをクリック] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide will take as input a native application developed in the link:building-native-image[building native image guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:building-native-image[ネイティブイメージのビルド] で開発されたネイティブアプリケーションを入力として受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you correctly followed the link:building-native-image[building native image guide], you should have a local container image named `quarkus-quickstart/getting-started`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:building-native-image[ネイティブイメージのビルド] に正しく従っていれば、 `quarkus-quickstart/getting-started` という名前のローカルコンテナーイメージがあるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus by default runs on port 8080, most Azure services expect web applications to be running on port 80. Before we continue, go back to your quickstart code and open the file `src/main/docker/Dockerfile.native`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはデフォルトではポート 8080 で動作しますが、ほとんどのAzureサービスでは、ウェブアプリケーションがポート 80 で動作することを想定しています。続ける前に、クイックスタートコードに戻り、 `src/main/docker/Dockerfile.native`  を開いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Change the last two commands in the `Dockerfile.native` file and make it read like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Dockerfile.native` ファイルの最後の 2 つのコマンドを変更して、以下のように読み込み可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can rebuild the docker image:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでdockerイメージをリビルドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To test, run it by exposing port 80 into port 8080 in your host:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストのときは、自分のホストでポート80を8080に公開して実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your container image is now ready to run on Azure. Remember, the Quarkus application is mapped to run on port 80.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、コンテナーイメージをAzure上で実行する準備が整いました。Quarkusアプリケーションは、ポート80で実行するようにマッピングされていることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To ease the user experience throughout this guide, it is better to have the Azure CLI installed and authenticated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイド全体を通してユーザー体験を容易にするために、Azure CLI をインストールして認証を受けた方が良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visit the https://docs.microsoft.com/cli/azure/install-azure-cli?view=azure-cli-latest?WT.mc_id=opensource-quarkus-brborges[Azure CLI] installation page for instructions specific to your operating system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お使いのオペレーティングシステムに固有の手順については、 link:https://docs.microsoft.com/cli/azure/install-azure-cli?view=azure-cli-latest?WT.mc_id=opensource-quarkus-brborges[Azure CLI] のインストールページを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once installed, ensure you are authenticated:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インストールしたら、認証されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to deploy images hosted on Docker Hub, but this location by default leaves images accessible to anyone. To better protect your container images, this guide shows how to host your images on a private instance of the Azure Container Registry service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Docker Hub上にホストされたイメージをデプロイすることは可能ですが、この場所はデフォルトでは誰でもイメージにアクセスできる状態になっています。コンテナーイメージをよりよく保護するために、このガイドでは、Azure Container Registry サービスのプライベートインスタンス上でイメージをホストする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, create an Azure Resource Group:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、Azure Resource Groupを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then you can create the ACR:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そうすれば、ACRを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, authenticate your local Docker installation with this container registry by running:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、このコンテナーレジストリーを実行して、ローカルのDockerインストールを認証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you've followed the build native image guide, you should have a local container image named `quarkus-quickstart/getting-started`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドネイティブイメージガイドに従っていれば、 `quarkus-quickstart/getting-started` という名前のローカルコンテナーイメージがあるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To upload this image to your ACR, you must tag and push the image under the ACR login server. To find the login server of the Azure Container Registry, run this command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このイメージをACRにアップロードするには、ACRログインサーバーの下にタグを付けてイメージをプッシュする必要があります。Azure Container Registryのログインサーバーを見つけるには、次のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To upload, now do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アップロードするには、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, you should have your Quarkus container image on your Azure Container Registry. To verify, run the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この時点で、Azure Container Registry上にQuarkusコンテナーイメージがあるはずです。確認するには、次のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest way to start this container in the cloud is with the Azure Container Instances service. It simply creates a container on Azure infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコンテナーをクラウド上で起動する最もシンプルな方法は、Azure Container Instancesサービスです。これは、Azureインフラストラクチャ上にコンテナーを作成するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are different approaches for using ACI. Check the documentation for details. The quickest way to get a container up and running goes as it follows.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ACIを使用するためには、さまざまなアプローチがあります。詳細はドキュメントを確認してください。コンテナーを起動して稼働させるための最も手っ取り早い方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First step is to find the username and password for the admin, so that ACI can authenticate into ACR and pull the Docker image:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のステップは、ACIがACRに認証してDockerイメージをプルできるように、管理者のユーザー名とパスワードを見つけることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create the Docker instance on ACI pointing to your image on ACR:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ACR上のイメージを指すACI上にDockerインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command above, if run successfully, will give you the address of your container in the Cloud. Access your Quarkus application in the address displayed as output.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のコマンドの実行が成功すると、クラウド上のコンテナーのアドレスが表示されます。出力として表示されるアドレスでQuarkusアプリケーションにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information and details on ACR authentication and the use of service principals, follow this guide below and remember the Azure Container Registry `loginServer` and the image name of your Quarkus application now hosted on the ACR.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ACR認証とサービスプリンシパルの使用の詳細と詳細については、以下のガイドに従ってください。Azure Container Registry `loginServer` と、現在ACRでホストされているQuarkusアプリケーションのイメージ名を覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that this service does not provide scalability. A container instance is unique and does not scale.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このサービスはスケーラビリティを提供しないことを覚えておいてください。コンテナーインスタンスは単一であり、スケーラビリティを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also deploy the container image as a microservice in a Kubernetes cluster on Azure. To do that, follow this tutorial:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コンテナーイメージをマイクロサービスとしてAzure上のKubernetesクラスターにデプロイすることもできます。そのためには、このチュートリアルに従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once deployed, the application will be running on whatever port is used to expose the service. By default, Quarkus apps run on port 8080 internally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイされると、アプリケーションは、サービスを公開するために使用されるポートであれば何でも実行されます。デフォルトでは、Quarkusアプリケーションは内部的にポート8080で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This service provides scalability out of the box for web applications. If more instances are required, it will provide a load-balancing automatically, plus monitoring, metrics, logging and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このサービスは、Webアプリケーションのスケーラビリティを提供します。より多くのインスタンスが必要な場合は、自動的に負荷分散を行い、監視、メトリクス、ロギングなどを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy your Quarkus Native container image to this service, follow this tutorial:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Nativeコンテナーイメージをこのサービスにデプロイするには、このチュートリアルに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programming model</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プログラミングモデル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Gradle plugin is published to the https://plugins.gradle.org/plugin/io.quarkus[Gradle Plugin Portal].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Gradle プラグインは、Gradle link:https://plugins.gradle.org/plugin/io.quarkus[プラグインポータル] に公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use it, add the following to your `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用するには、 `build.gradle` ファイルに以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You also need to add the following at the top of your `settings.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、`settings.gradle` ファイルの先頭に以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `plugins{}` method in `settings.gradle` is not supported in Gradle 5.x. In this case make sure to explicitly declare the plugin version in the `build.gradle` file like the example below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`settings.gradle` の `plugins{}` メソッドは Gradle 5.x ではサポートされていません。この場合、以下の例のように `build.gradle` ファイルでプラグインのバージョンを明示的に宣言するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides extensions for building (and pushing) container images. Currently it supports:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、コンテナーイメージを構築 (およびプッシュ) するためのエクステンションを提供しています。現在は以下をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージのエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jib</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-jib` is powered by https://github.com/GoogleContainerTools/jib[Jib] for performing container image builds.  The major benefit of using Jib with Quarkus is that all the dependencies (everything found under `target/lib`) are cached in a different layer than the actual application making rebuilds really fast and small (when it comes to pushing).  Another important benefit of using this extension is that it provides the ability to create a container image without having to have any dedicated client side tooling (like Docker) or running daemon processes (like the Docker daemon)  when all that is needed is the ability to push to a container image registry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-jib` は、コンテナーイメージのビルドを実行するために link:https://github.com/GoogleContainerTools/jib[Jib] を使用しています。Jib を Quarkus で使用する主な利点は、すべての依存関係 (`target/lib` の下にあるすべてのもの) が実際のアプリケーションとは別のレイヤーにキャッシュされるため、リビルドが非常に高速かつ小規模に (プッシュする場合) 行えることです。このエクステンションを使用するもう 1 つの重要な利点は、コンテナーイメージレジストリーにプッシュする機能さえあれば、専用のクライアントサイドツール (Docker など) やデーモンプロセス (Docker デーモンなど) を実行しなくてもコンテナーイーメージを作成できることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In situations where all that is needed to build a container image and no push to a registry is necessary (essentially by having set `quarkus.container-image.build=true` and left `quarkus.container-image.push` unset - it defaults to `false`), then this extension creates a container image and registers it with the Docker daemon. This means that although Docker isn't used to build the image, it is nevertheless necessary. Also note that using this mode, the built container image *will* show up when executing `docker images`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要なことがコンテナーイメージを構築するだけで、レジストリーへのプッシュが不要な場合 (基本的には `quarkus.container-image.build=true` を設定して `quarkus.container-image.push` のままにしておくことで、デフォルトは `false` になります)、このエクステンションはコンテナーイメージを作成し、Docker デーモンに登録します。これは、Docker がイメージのビルドには使われなくても必要であることを意味します。また、このモードを使用すると、`docker images` を実行するとコンテナーイメージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including extra files</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加ファイルの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases when additional files (other than ones produced by the Quarkus build) need to be added to a container image.  To support these cases, Quarkus copies any file under `src/main/jib` into the built container image (which is essentially the same idea that the Jib Maven and Gradle plugins support).  For example, the presence of `src/main/jib/foo/bar` would result in `/foo/bar` being added into the container filesystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージに追加のファイル(Quarkus のビルドで作成されたもの以外)を追加する必要がある場合があります。このような場合に対応するため、Quarkus は、`src/main/jib` 以下のファイルをすべてビルドされたコンテナーイメージにコピーします (これは、Jib Maven や Gradle プラグインがサポートしているのと基本的に同じ考え方です)。例えば、`src/main/jib/foo/bar` が存在すると、`/foo/bar` がコンテナファイルシステムに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-docker` is using the Docker binary and the generated Dockerfiles under `src/main/docker` in order to perform Docker builds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-docker` は、Docker ビルドを実行するために `src/main/docker` 下で Docker バイナリーと生成された Dockerfiles を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-s2i` is using S2I binary builds in order to perform container builds inside the OpenShift cluster.  The idea behind the binary build is that you just upload the artifact and its dependencies to the cluster and during the build they will be merged to a builder image (defaults to `fabric8/s2i-java`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-s2i` は、OpenShift クラスター内でコンテナービルドを実行するために S2I バイナリービルドを使用しています。バイナリービルドの考え方は、アーティファクトとその依存関係をクラスタにアップロードするだけで、ビルド中にそれらがビルダーイメージにマージされます (デフォルトは `fabric8/s2i-java`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The benefit of this approach, is that it can be combined with OpenShift's `DeploymentConfig` that makes it easy to roll out changes to the cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチの利点は、クラスターへの変更を簡単にロールアウトできる OpenShift の `DeploymentConfig` と組み合わせることができることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I builds require creating a `BuildConfig` and two `ImageStream` resources, one for the builder image and one for the output image.  The creation of such objects is being taken care of by the Quarkus Kubernetes extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S2I のビルドでは、`BuildConfig` と 2 つの `ImageStream` リソースを作成する必要があります。このようなオブジェクトの作成は、Quarkus Kubernetes エクステンションによって行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build a container image for your project, `quarkus.container-image.build=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト用のコンテナーイメージを作成するには、Quarkus がサポートしている方法のいずれかで、 `quarkus.container-image.build=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pushing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To push a container image for your project, `quarkus.container-image.push=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトにコンテナーイメージをプッシュするには、Quarkus がサポートしている方法のいずれかで、`quarkus.container-image.push=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no registry is set (using `quarkus.container-image.registry`) then `docker.io` will be used as the default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリーが設定されていない場合 (`quarkus.container-image.registry` を使用) は、 `docker.io` がデフォルトとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selecting among multiple extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のエクステンションから選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does not make sense to use multiple extension as part of the same build. When multiple container image extensions are present, an error will be raised to inform the user. The user can either remove the uneeded extensions or select one using `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のエクステンションを同じビルドの一部として使用するのは意味がありません。複数のコンテナー-イメージエクステンションが存在する場合は、エラーが発生してユーザーに通知されます。ユーザーは不要なエクステンション削除するか、`application.properties` を使って選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if both `container-image-docker` and `container-image-s2i` are present and the user needs to use `container-image-docker`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、`container-image-docker` と `container-image-s2i` の両方が存在し、ユーザーが `container-image-docker` を使用する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to customize the container image build process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のプロパティーを使用して、コンテナーイメージのビルドプロセスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various CI environments provide a ready to use container-image registry which can be combined with the container-image Quarkus extensions in order to effortlessly create and push a Quarkus application to said registry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さまざまな CI 環境では、Quarkus アプリケーションを作成してレジストリーをプッシュするために、コンテナーイメージ Quarkus エクステンションと組み合わせることで、すぐに使えるコンテナーイメージレジストリ-を利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, https://gitlab.com/[GitLab] provides such a registry and in the provided CI environment, makes available the `CI_REGISTRY_IMAGE` environment variable (see GitLab's https://docs.gitlab.com/ee/ci/variables/[documentation]) for more information), which can be used in Quarkus like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 link:https://gitlab.com/[GitLab] はこのようなレジストリーを提供しており、提供されている CI 環境では、環境変数 `CI_REGISTRY_IMAGE` (詳しくは GitLab の link:https://docs.gitlab.com/ee/ci/variables/[ドキュメント] を参照) を利用できるようになっています。なお、Quarkus ではこのように利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:config.adoc#combine-property-env-var[this] for more information on how to combine properties with environment variables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数とプロパティーを組み合わせる方法については link:config.adoc#combine-property-env-var[こちら] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-jib` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-jib` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-docker` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-docker` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I  Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S2I オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-s2i` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-s2i` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension ecosystem consists of the Quarkus extensions developed and maintained by the community, including the Quarkus core development team. While the Quarkus ecosystem (sometimes also referred to as the "Quarkus universe") includes all the Quarkus extensions ever developed, there is also a concept of a Quarkus platform.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションエコシステムは、Quarkusコア開発チームを含むコミュニティによって開発・保守されたQuarkusエクステンションで構成されています。Quarkusエコシステム（"Quarkus universe"と呼ばれることもあります）には、これまでに開発されたすべてのQuarkusエクステンションが含まれていますが、Quarkusプラットフォームという概念もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The fundamental promise of a Quarkus platform is any combination of the Quarkus extensions the platform consists of can be used in the same application without causing any conflict for each other.  Each organization creating their Quarkus platform may establish their own criterions for the extensions to be accepted into the platform and the means to guarantee the compatibility between the accepted extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプラットフォームの基本的な約束事は、プラットフォームで構成されるQuarkusエクステンションを組み合わせて、お互いに競合することなく同じアプリケーションで使用することができるということです。Quarkusプラットフォームを作成する各組織は、プラットフォームに受け入れられるエクステンションについて独自の基準を設定し、受け入れられたエクステンション間の互換性を保証する手段を確立することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Quarkus platform is defined with a few artifacts.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各Quarkusプラットフォームは、いくつかのアーティファクトで定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each Quarkus Platform is expected to provide a Maven BOM artifact that</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各Quarkusプラットフォームは、次のようなMaven BOMアーティファクトを提供することが期待されています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>imports a chosen version of `io.quarkus:quarkus-bom` (the platform BOM may be flattened at the end but it has to be based on some version of `io.quarkus:quarkus-bom`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus:quarkus-bom` の選択されたバージョンをインポートすること (プラットフォームの BOM は最後にフラット化されますが、 `io.quarkus:quarkus-bom` の何らかのバージョンに基づいていなければなりません)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>includes all the Quarkus extension artifacts (the runtime and the deployment ones) the platform consists of</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォームを構成するすべてのQuarkusエクステンションアーティファクト（ランタイムとデプロイメントのもの）を含むこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>includes the &lt;&lt;platform-descriptor,platform JSON descriptor&gt;&gt; artifact</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#platform-descriptor[プラットフォームJSONディスクリプタ]アーティファクトを含むこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>possibly includes the &lt;&lt;platform-properties,platform configuration properties&gt;&gt; artifacts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;platform-properties,プラットフォーム設定プロパティ&gt;&gt; アーティファクトを含む場合があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications that want to include extensions from a Quarkus platform will be importing the Quarkus platform BOM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusプラットフォームからエクステンションをインクルードしたいQuarkusアプリケーションは、QuarkusプラットフォームのBOMをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus platform descriptor is a JSON artifact that provides information about the platform and its extensions to the Quarkus tools. E.g. http://code.quarkus.io and the Quarkus command line tools consult this descriptor to list, add and remove extensions to/from the project on user's request.  This artifact is also used as a Quarkus platform identifier. When Quarkus tools need to identify the Quarkus platform(s) used in the project, they will analyze the dependency version constraints of the project (the effective list of the managed dependencies from the `dependencyManagement` section in Maven terms) looking for the platform descriptor artifact(s) among them. Given that the platform descriptors are included into the Quarkus platform BOMs, every Quarkus application will inherit the platform descriptor artifact from the imported platform BOM(s) as a dependency version constraint (managed dependency in Maven terms).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプラットフォームディスクリプタは、プラットフォームとそのエクステンションに関する情報をQuarkusツールに提供するJSONアーティファクトです。例： http://code.quarkus.io やQuarkusコマンドラインツールは、ユーザーの要求に応じて、このディスクリプタを参照して、プロジェクトへのエクステンションのリスト化、追加、削除を行います。このアーティファクトは、Quarkusプラットフォームディスクリプタとしても使用されます。Quarkusツールがプロジェクトで使用されているQuarkusプラットフォームを識別する必要がある場合、プロジェクトの依存関係バージョン制約（Maven用語では、 `dependencyManagement` セクションから管理されている依存関係の有効なリスト）を分析して、その中からプラットフォームディスクリプタのアーティファクトを探します。プラットフォームディスクリプタがQuarkusプラットフォームBOMに含まれていることを考えると、すべてのQuarkusアプリケーションは、インポートされたプラットフォームBOMからのプラットフォームディスクリプタアーティファクトを依存関係バージョン制約（Maven用語では管理された依存関係）として継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to easily identify Quarkus platform descriptors among the project's dependency constraints, the platform descriptor Maven artifact coordinates should follow the following naming convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトの依存性制約の中でQuarkusプラットフォームディスクリプタを簡単に識別できるように、プラットフォームディスクリプタのMavenアーティファクト座標は、以下の命名規則に従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `groupId` of the descriptor artifact should match the `groupId` of the corresponding Quarkus Platform BOM;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスクリプタアーティファクトの `groupId` は、対応するQuarkus Platform BOMの `groupId` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `artifactId` of the descriptor artifact should be the `artifactId` of the corresponding Quarkus Platform BOM with the `-quarkus-platform-descriptor` suffix;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスクリプタアーティファクトの `artifactId` は、対応するQuarkus Platform BOMの `artifactId` で、サフィックスが `-quarkus-platform-descriptor` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `classifier` of the descriptor artifact should match the `version` of the corresponding Quarkus Platform BOM;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスクリプタアーティファクトの `classifier` は、対応するQuarkus Platform BOMの `version` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `type` of the descriptor artifact should be `json`;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスクリプタアーティファクトの `type` は `json` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `version` of the descriptor artifact should match the `version` of the corresponding Quarkus Platform BOM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスクリプタアーティファクトの `version` は、対応するQuarkus Platform BOMの `version` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a string it will look like `&lt;platform-bom-groupId&gt;:&lt;platform-bom-artifactId&gt;-quarkus-platform-descriptor:&lt;platform-version&gt;:json:&lt;platform-version&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>文字列としては次のようになります： `&lt;platform-bom-groupId&gt;:&lt;platform-bom-artifactId&gt;-quarkus-platform-descriptor:&lt;platform-version&gt;:json:&lt;platform-version&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g. the coordinates of the descriptor for Quarkus BOM `io.quarkus:quarkus-bom::pom:1.2.3` will be `io.quarkus:quarkus-bom-quarkus-platform-descriptor:1.2.3:json:1.2.3`.  And for a custom Quarkus platform defined with BOM `org.acme:acme-bom::pom:555` it will be `org.acme:acme-bom-quarkus-platform-descriptor:555:json:555`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Quarkus BOM `io.quarkus:quarkus-bom::pom:1.2.3` のディスクリプタの座標は `io.quarkus:quarkus-bom-quarkus-platform-descriptor:1.2.3:json:1.2.3` となります。また、BOM `org.acme:acme-bom::pom:555` で定義されたカスタムQuarkusプラットフォームの場合は、 `org.acme:acme-bom-quarkus-platform-descriptor:555:json:555` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The platform descriptor will normally be generated using a Maven plugin, e.g.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォームディスクリプタは通常、Mavenプラグインを使用して生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the version of the `quarkus-platform-descriptor-json-plugin`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-platform-descriptor-json-plugin` のバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`generate-extensions-json` is the goal generating the platform descriptor</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`generate-extensions-json` は、プラットフォームディスクリプタを生成するゴールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this parameter is optional, it allows to override some metadata from the Quarkus extension descriptors found in every runtime extension artifact from which the platform descriptor is generated</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このパラメータはオプションで、プラットフォームディスクリプタが生成されるすべてのランタイムエクステンションアーティファクトに含まれるQuarkusエクステンションディスクリプタのメタデータの一部をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>this parameter is also optional and defaults to false. It has to be set to true in case the platform BOM *is not generated* and *is not flattened*. Which for example is the case for `io.quarkus:quarkus-bom`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このパラメータもオプションで、デフォルトは false です。プラットフォームBOMが *生成されず* 、平坦 *化されていない* 場合はtrueに設定しなければなりません。たとえば、 `io.quarkus:quarkus-bom` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkus platform may provide its own default values for some of the configuration options.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプラットフォームでは、一部の設定オプションに対して独自のデフォルト値を提供している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is using https://github.com/eclipse/microprofile-config[Eclipse MicroProfile Config] for wiring application configuration. A Quarkus platform may be used as another source of configuration in the hierarchy of the configuration sources dominated by the application's `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、アプリケーション設定の接続に link:https://github.com/eclipse/microprofile-config[Eclipse MicroProfile Config]を使用しています。Quarkusプラットフォームは、アプリケーションの `application.properties` によって支配されている構成ソースの階層の別の構成ソースとして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To provide platform-specific defaults, the platform needs to include a dependency version constraint in its BOM for a properties artifact whose coordinates follow the following naming convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プ ラ ッ ト フ ォーム固有のデフ ォル ト を提供す る には、 プ ラ ッ ト フ ォームは、 座標が下記の命名規則に従っ てい る プ ロ パテ ィ アーテ ィ フ ァ ク ト に対 し て、 その BOM 内に依存バージ ョ ン制約を含める必要があ り ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `groupId` of the properties artifact should match the `groupId` of the corresponding Quarkus Platform BOM;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティアーティファクトの `groupId` は、対応するQuarkus Platform BOMの `groupId` と一致している必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `artifactId` of the properties artifact should be the `artifactId` of the corresponding Quarkus Platform BOM with the `-quarkus-platform-properties` suffix;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティアーティファクトの `artifactId` は、対応するQuarkus Platform BOMの `artifactId` で、サフィックスが `-quarkus-platform-properties` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `classifier` of the descriptor artifact should be left empty/null;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスクリプタアーティファクトの `classifier` は空/NULL のままの必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `type` of the descriptor artifact should be `properties`;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスクリプタアーティファクトの `type` は `properties` である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties artifact itself is expected to be a traditional `properties` file that will be loaded into an instance of `java.util.Properties` class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティ・アーティファクト自体は、 `java.util.Properties` クラスのインスタンスにロードされる伝統的な `properties` ファイルであることが期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, platform properties are only allowed to provide the default values for a restricted set of configuration options. The property names in the platform properties file must be prefixed with the `platform.` suffix.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この時点では、プラットフォームプロパティは、制限された設定オプションのセットに対してデフォルト値を提供することのみが許可されています。プラットフォームプロパティファイルのプロパティ名の前には、 `platform.` という接尾辞を付けなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension developers that want to make their configuration options platform-specific should set their default values to properties that start with the `platform.` suffix. Here is an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定オプションをプラットフォーム固有のものにしたいエクステンションの開発者は、デフォルト値を `platform.` で始まるプロパティに設定しなければなりません。以下に例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case the default value for `quarkus.native.builder-image` will be provided by the platform. The user will still be able to set the desired value for `quarkus.native.builder-image` in its `application.properties`, of course. But in case it's not customized by the user, the default value will be coming from the platform properties.  A platform properties file for the example above would contain (the actual value is provided as an example):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、 `quarkus.native.builder-image` のデフォルト値はプラットフォームによって提供されます。もちろん、ユーザーは `application.properties` で `quarkus.native.builder-image` に希望の値を設定することができます。しかし、ユーザーがカスタマイズしていない場合は、デフォルト値はプラットフォームのプロパティから提供されます。上記の例のプラットフォームのプロパティファイルには、以下のようなものが含まれています（実際の値は例として提供されています）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is also a Maven plugin goal that validates the platform properties content and its artifact coordinates and also checks whether the platform properties artifact is present in the platform's BOM. Here is a sample plugin configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、プラットフォームプロパティのコンテンツとそのアーティファクトの座標を検証し、プラットフォームプロパティのアーティファクトがプラットフォームのBOMに存在するかどうかをチェックするMavenプラグインのゴールもあります。ここでは、プラグインの構成例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - JGit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - JGit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `jgit` extension which enables the use of https://www.eclipse.org/jgit/[Eclipse JGit] in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、ネイティブモードでの link:https://www.eclipse.org/jgit/[Eclipse JGit]の使用を可能にする `jgit` エクステンションが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `jgit` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで次のコマンドを実行して、 `jgit` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://wiki.eclipse.org/JGit/User_Guide#API[JGit] dependency is resolved transitively when the extension is added to your project.  Here is an example using it in a JAX-RS endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://wiki.eclipse.org/JGit/User_Guide#API[JGit]依存関係は、エクステンションがプロジェクトに追加されたときに推移的に解決されます。ここでは、JAX-RS エンドポイントでの使用例を示します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in native mode, make sure that the link:native-and-ssl#the-truststore-path[SSL access is configured correctly].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行する場合は、 link:native-and-ssl#the-truststore-path[SSLアクセスが正しく設定されていること]を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running Kafka cluster, or Docker Compose to start a development cluster</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行中の Kafka クラスター、または開発クラスターを開始するための Docker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to generate (random) prices in one component.  These prices are written in a Kafka topic (`prices`).  A second component reads from the `prices` Kafka topic and apply some magic conversion to the price.  The result is sent to an in-memory stream consumed by a JAX-RS resource.  The data is sent to a browser using server-sent events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、1 つのコンポーネントでランダムな価格 (price) を生成します。これらの価格は、Kafka トピック (`prices`) に書かれています。2 番目のコンポーネントは `prices` Kafka トピックから読み込み、この価格に変換を適用します。その結果は、JAX-RS リソースによって消費されるインメモリーストリームに送られます。データは、サーバーから送信されたイベントを使用してブラウザーに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>kafka-guide-architecture.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>kafka-guide-architecture.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このソリューションは `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=kafka-quickstart \
    -DclassName="org.acme.kafka.PriceResource" \
    -Dpath="/prices" \
    -Dextensions="resteasy,smallrye-reactive-messaging-kafka"
cd kafka-quickstart
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=kafka-quickstart \
    -DclassName="org.acme.kafka.PriceResource" \
    -Dpath="/prices" \
    -Dextensions="resteasy,smallrye-reactive-messaging-kafka"
cd kafka-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-reactive-messaging-kafka"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-reactive-messaging-kafka"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we need a Kafka cluster.  You can follow the instructions from the https://kafka.apache.org/quickstart[Apache Kafka web site] or create a `docker-compose.yaml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、Kafka クラスターが必要です。https://kafka.apache.org/quickstart[Apache Kafka の Web サイト] の指示に従うか、以下の内容の `docker-compose.yaml` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>version: '2'
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>version: '2'
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  zookeeper:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/zookeeper-server-start.sh config/zookeeper.properties"
    ]
    ports:
      - "2181:2181"
    environment:
      LOG_DIR: /tmp/logs
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  zookeeper:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/zookeeper-server-start.sh config/zookeeper.properties"
    ]
    ports:
      - "2181:2181"
    environment:
      LOG_DIR: /tmp/logs
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  kafka:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}"
    ]
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      LOG_DIR: "/tmp/logs"
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  kafka:
    image: strimzi/kafka:0.19.0-kafka-2.5.0
    command: [
      "sh", "-c",
      "bin/kafka-server-start.sh config/server.properties --override listeners=$${KAFKA_LISTENERS} --override advertised.listeners=$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect=$${KAFKA_ZOOKEEPER_CONNECT}"
    ]
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      LOG_DIR: "/tmp/logs"
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/java/org/acme/kafka/PriceGenerator.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.kafka;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.kafka;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A bean producing random prices every 5 seconds.
 * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.
 */
@ApplicationScoped
public class PriceGenerator {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
 * A bean producing random prices every 5 seconds.
 * The prices are written to a Kafka topic (prices). The Kafka configuration is specified in the application configuration.
 */
@ApplicationScoped
public class PriceGenerator {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method returns a _Reactive Stream_. The generated items are sent to the stream named `generated-price`.  This stream is mapped to Kafka using the `application.properties` file that we will create soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、_Reactive Stream_ を返します。生成されたアイテムは `generated-price` という名前のストリームに送られます。このストリームは、次に作成する `application.properties` ファイルを使用して Kafka にマッピングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The price converter reads the prices from Kafka, and transforms them.  Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>価格コンバーターは、Kafka から価格を読み込んで変換します。以下の内容の `src/main/java/org/acme/kafka/PriceConverter.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Broadcast;
import org.eclipse.microprofile.reactive.messaging.Acknowledgment;
import org.eclipse.microprofile.reactive.messaging.Incoming;
import org.eclipse.microprofile.reactive.messaging.Outgoing;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A bean consuming data from the "prices" Kafka topic and applying some conversion.
 * The result is pushed to the "my-data-stream" stream which is an in-memory stream.
 */
@ApplicationScoped
public class PriceConverter {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
 * A bean consuming data from the "prices" Kafka topic and applying some conversion.
 * The result is pushed to the "my-data-stream" stream which is an in-memory stream.
 */
@ApplicationScoped
public class PriceConverter {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("prices")                                     // &lt;1&gt;
    @Outgoing("my-data-stream")                             // &lt;2&gt;
    @Broadcast                                              // &lt;3&gt;
    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // &lt;4&gt;
    public double process(int priceInUsd) {
        return priceInUsd * CONVERSION_RATE;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Incoming("prices")                                     // &lt;1&gt;
    @Outgoing("my-data-stream")                             // &lt;2&gt;
    @Broadcast                                              // &lt;3&gt;
    @Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING) // &lt;4&gt;
    public double process(int priceInUsd) {
        return priceInUsd * CONVERSION_RATE;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the method consumes the items from the `prices` topic</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドが `prices` トピックのアイテムを消費することを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the objects returned by the method are sent to the `my-data-stream` stream</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドによって返されたオブジェクトが `my-data-stream` ストリームに送られることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to acknowledge the incoming message</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>着信メッセージの受け取りを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `process` method is called for every Kafka _record_ from the `prices` topic (configured in the application configuration).  Every result is sent to the `my-data-stream` in-memory stream.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`process` メソッドは、`prices` トピック (アプリケーションコンフィグレーションの中で設定) からの Kafka _record_ ごとに呼び出されます。すべての結果は `my-data-stream` インメモリーストリームに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/java/org/acme/kafka/PriceResource.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ストリームを JAX-RSリソース にバインドしてみましょう。以下の内容の `src/main/java/org/acme/kafka/PriceResource.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.jboss.resteasy.annotations.SseElementType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.jboss.resteasy.annotations.SseElementType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
 * A simple resource retrieving the in-memory "my-data-stream" and sending the items as server-sent events.
 */
@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
 * A simple resource retrieving the in-memory "my-data-stream" and sending the items as server-sent events.
 */
@Path("/prices")
public class PriceResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    @Channel("my-data-stream") Publisher&lt;Double&gt; prices; // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    @Channel("my-data-stream") Publisher&lt;Double&gt; prices; // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS) // &lt;2&gt;
    @SseElementType("text/plain") // &lt;3&gt;
    public Publisher&lt;Double&gt; stream() { // &lt;4&gt;
        return prices;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS) // &lt;2&gt;
    @SseElementType("text/plain") // &lt;3&gt;
    public Publisher&lt;Double&gt; stream() { // &lt;4&gt;
        return prices;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicates that the data contained within the server sent events is of type `text/plain`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバーから送信されたイベントに含まれるデータのタイプが `text/plain` であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the Kafka connector. This is done in the `application.properties` file.  The keys are structured as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka コネクターを設定する必要があります。これは `application.properties` ファイルで行います。このキーは以下のような構造になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the SmallRye Kafka connector
kafka.bootstrap.servers=localhost:9092
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the SmallRye Kafka connector
kafka.bootstrap.servers=localhost:9092
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.generated-price.connector=smallrye-kafka
mp.messaging.outgoing.generated-price.topic=prices
mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.generated-price.connector=smallrye-kafka
mp.messaging.outgoing.generated-price.topic=prices
mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka.common.serialization.IntegerSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.prices.connector=smallrye-kafka
mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.prices.connector=smallrye-kafka
mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common.serialization.IntegerDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More details about this configuration is available on the https://kafka.apache.org/documentation/#producerconfigs[Producer configuration] and https://kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] section from the Kafka documentation. These properties are configured with the prefix `kafka`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定の詳細は、Kafka ドキュメントの link:https://kafka.apache.org/documentation/#producerconfigs[Producer 設定] と link:https://kafka.apache.org/documentation/#consumerconfigs[Consumer 設定] のセクションを参照してください。これらのプロパティは、`kafka` という接頭辞で設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have Kafka running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指示に従えば、Kafka が起動しているはずです。あとは、以下でアプリケーションを実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you started the Kafka broker with docker compose, stop it using `CTRL+C` followed by `docker-compose down`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka ブローカーを docker compose で起動した場合は、`CTRL+C` に続いて `docker-compose down` で停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you need to have an imperative way of sending messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、命令的な方法でメッセージを送ることが必要になる場合もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if you need to send a message to a stream, from inside a REST endpoint, when receiving a POST request.  In this case, you cannot use `@Output` because your method has parameters.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、POST リクエストを受信したときに、REST エンドポイントの内部からストリームにメッセージを送信する必要があるとします。この場合、メソッドにはパラメーターがあるため、`@Output` を使用することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use `@OnOverflow` to configure back-pressure strategy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Emitter` の設定は、`@Incoming` と `@Outgoing` が使用する他のストリームの設定と同じ方法で行います。さらに、`@OnOverflow` を使用して、バックプレッシャー戦略を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka` can add a readiness health check to validate the connection to the broker. This is disabled by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-health` エクステンションを使用している場合、`quarkus-kafka` は、ブローカーへの接続を検証するためにレディネスヘルスチェックを追加することができます。これはデフォルトでは無効になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作を有効にするには、`application.properties` の `quarkus.kafka.health.enabled` プロパティを `true` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has built-in capabilities to deal with JSON Kafka messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、JSON Kafka メッセージを扱う機能が組み込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine we have a `Fruit` pojo as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `Fruit` の pojo があると想像してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public String name;
    public int price;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public String name;
    public int price;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Fruit(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    public Fruit(String name, int price) {
        this.name = name;
        this.price = price;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、Kafka からメッセージを受信して、何らかの価格変換を行い、Kafka にメッセージを送り返すために使いたいと考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/**
* A bean consuming data from the "fruit-in" Kafka topic and applying some price conversion.
* The result is pushed to the "fruit-out" stream.
*/
@ApplicationScoped
public class FruitProcessor {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/**
* A bean consuming data from the "fruit-in" Kafka topic and applying some price conversion.
* The result is pushed to the "fruit-out" stream.
*/
@ApplicationScoped
public class FruitProcessor {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("fruit-in")
    @Outgoing("fruit-out")
    @Broadcast
    public Fruit process(Fruit fruit) {
        fruit.price = fruit.price * CONVERSION_RATE;
        return fruit;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Incoming("fruit-in")
    @Outgoing("fruit-out")
    @Broadcast
    public Fruit process(Fruit fruit) {
        fruit.price = fruit.price * CONVERSION_RATE;
        return fruit;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this, we will need to setup JSON serialization with Jackson or JSON-B.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのためには、Jackson や JSON-B で JSON シリアライゼーションを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With JSON serialization correctly configured, you can also use `Publisher&lt;Fruit&gt;` and `Emitter&lt;Fruit&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON シリアライゼーションが正しく設定されていれば、 `Publisher&lt;Fruit&gt;` や `Emitter&lt;Fruit&gt;` も利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-resteasy-jackson` extension, this is not needed).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、`quarkus-jackson` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jackson` のエクステンションを使用している場合は、これは必要ありません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson, but the corresponding deserializer is generic, so it needs to be subclassed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jackson によって全ての POJO をシリアルに変換することができる既存の `ObjectMapperSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、`ObjectMapperDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package com.acme.fruit.jackson;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package com.acme.fruit.jackson;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class FruitDeserializer extends ObjectMapperDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your streams to use the Jackson serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、Jackson シリアライザーとデシリアライザーを使用するようにストリームを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、Kafka メッセージには、Fruit pojo の Jackson によるシリアライズ表現が含まれるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、`quarkus-jsonb` のエクステンションを含める必要があります (すでに `quarkus-resteasy-jsonb` のエクステンションを使用している場合は不要です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B, but the corresponding deserializer is generic, so it needs to be subclassed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON-B によってすべての pojos をシリアライズするために使用できる既存の `JsonbSerializer` があります。ただし、対応するデシリアライザーは汎用的なものなので、サブクラス化する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、一般的な `JsonbDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package com.acme.fruit.jsonb;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package com.acme.fruit.jsonb;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.kafka.client.serialization.JsonbDeserializer;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.kafka.client.serialization.JsonbDeserializer;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class FruitDeserializer extends JsonbDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class FruitDeserializer extends JsonbDeserializer&lt;Fruit&gt; {
    public FruitDeserializer(){
        // pass the class to the parent.
        super(Fruit.class);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pojo に個別にデシリアライザーを作成したくない場合は、`javax.json.JsonObject` にデシリアライズする汎用の `io.vertx.kafka.client.serialization.JsonObjectDeserializer` を使用することができます。対応するシリアライザーも使用できます。`io.vertx.kafka.client.serialization.JsonObjectSerializer`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, configure your streams to use the JSON-B serializer and deserializer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、JSON-B シリアライザーとデシリアライザーを使用するようにストリームを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka source (we read from it)
mp.messaging.incoming.fruit-in.connector=smallrye-kafka
mp.messaging.incoming.fruit-in.topic=fruit-in
mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg># Configure the Kafka sink (we write to it)
mp.messaging.outgoing.fruit-out.connector=smallrye-kafka
mp.messaging.outgoing.fruit-out.topic=fruit-out
mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、Kafka のメッセージには、JSON-B でシリアライズされた Fruit pojo の表現が含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events, as the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy で JSON Server-Sent Events を送信したい場合は、`@SseElementType` アノテーションを使用してイベントのコンテンツタイプを定義する必要があります。これは、このメソッドが `@Produces(MediaType.SERVER_SENT_EVENTS)` のアノテーションが付くためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following example shows how to use SSE from a Kafka topic source.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の例は、Kafka トピックソースから SSE を使用する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    @Channel("fruit-out") Publisher&lt;Fruit&gt; fruits;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    @Channel("fruit-out") Publisher&lt;Fruit&gt; fruits;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @SseElementType(MediaType.APPLICATION_JSON)
    public Publisher&lt;Fruit&gt; stream() {
        return fruits;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @GET
    @Path("/stream")
    @Produces(MediaType.SERVER_SENT_EVENTS)
    @SseElementType(MediaType.APPLICATION_JSON)
    public Publisher&lt;Fruit&gt; stream() {
        return fruits;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blocking processing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブロッキング処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and cannot be run on the caller thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Messaging とデータベースインタラクションなどのブロッキング処理を組み合わせる必要がある状況は少なくありません。そのためには、処理が _ブロックしていて_ 呼び出し元のスレッドで実行できないこと示している `@Blocking` アノテーションを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、以下のコードは、Hibernate with Panacheを 使用してデータベースに受信ペイロードを格納する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.panache;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.panache;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.reactive.messaging.annotations.Blocking;
import org.eclipse.microprofile.reactive.messaging.Incoming;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.smallrye.reactive.messaging.annotations.Blocking;
import org.eclipse.microprofile.reactive.messaging.Incoming;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class PriceStorage {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped
public class PriceStorage {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Incoming("prices")
    @Blocking
    @Transactional
    public void store(int priceInUsd) {
        Price price = new Price();
        price.value = priceInUsd;
        price.persist();
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Incoming("prices")
    @Blocking
    @Transactional
    public void store(int priceInUsd) {
        Price price = new Price();
        price.value = priceInUsd;
        price.persist();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete example is available in the `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な例は `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-quickstart[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are 2 `@Blocking` annotations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Blocking` アノテーションは 2 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.reactive.messaging.annotations.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.common.annotation.Blocking`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They have the same effect.  Thus, you can use both.  The first one provides more fine-grain tuning such as the worker pool to use and whether it preserves the order.  The second one, used in also with other reactive features of Quarkus, uses the default worker pool and preserves the order.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>効果はどちらも同じです。したがって、両方を使うことができます。最初のものは、使用するワーカープールや順序を保持するかどうかなど、より細かい調整が可能です。2 番目のものは、Quarkus の他のリアクティブ機能でも使用され、デフォルトのワーカープールを使用し、順序を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing without a broker</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーなしでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka ブローカーを起動しなくてもアプリケーションをテストできるのは便利です。これを行うには、Kafka コネクターで管理しているチャンネルを _インメモリー_ に _切り替え_ できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-reactive-messaging-in-memory&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;
    &lt;artifactId&gt;smallrye-reactive-messaging-in-memory&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, create a Quarkus Test Resource as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、以下のように Quarkus Test Resource を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; props1 = InMemoryConnector.switchIncomingChannelsToInMemory("orders");  // &lt;1&gt;
        Map&lt;String, String&gt; props2 = InMemoryConnector.switchOutgoingChannelsToInMemory("queue");   // &lt;2&gt;
        env.putAll(props1);
        env.putAll(props2);
        return env;  // &lt;3&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        Map&lt;String, String&gt; env = new HashMap&lt;&gt;();
        Map&lt;String, String&gt; props1 = InMemoryConnector.switchIncomingChannelsToInMemory("orders");  // &lt;1&gt;
        Map&lt;String, String&gt; props2 = InMemoryConnector.switchOutgoingChannelsToInMemory("queue");   // &lt;2&gt;
        env.putAll(props1);
        env.putAll(props2);
        return env;  // &lt;3&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void stop() {
        InMemoryConnector.clear();  // &lt;4&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public void stop() {
        InMemoryConnector.clear();  // &lt;4&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the incoming channel "orders" (expecting messages from Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(Kafka からのメッセージが想定される) 受信チャンネル "order" をインメモリーに切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Switch the outgoing channel "queue" (writing messages to Kafka) to in-memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信チャネル "キュー" (Kafka へのメッセージの書き込み) をインメモリーに切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インメモリーチャネルを使用するためのアプリケーション設定に必要なすべてのプロパティを含む `Map` をビルドして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストが停止したら、`InMemoryConnector` をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a Quarkus Test using the test resource created above:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記で作成したテストリソースを使用して Quarkus テストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@QuarkusTest
@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)
class BaristaTest {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject @Any
    InMemoryConnector connector; // &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject @Any
    InMemoryConnector connector; // &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Test
    void testProcessOrder() {
        InMemorySource&lt;Order&gt; orders = connector.source("orders"); // &lt;2&gt;
        InMemorySink&lt;Beverage&gt; queue = connector.sink("queue");    // &lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Test
    void testProcessOrder() {
        InMemorySource&lt;Order&gt; orders = connector.source("orders"); // &lt;2&gt;
        InMemorySink&lt;Beverage&gt; queue = connector.sink("queue");    // &lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        Order order = new Order();
        order.setProduct("coffee");
        order.setName("Coffee lover");
        order.setOrderId("1234");
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        orders.send(order);  // &lt;4&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        orders.send(order);  // &lt;4&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        await().&lt;List&lt;? extends Message&lt;Beverage&gt;&gt;&gt;until(queue::received, t -&gt; t.size() == 1); // &lt;5&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        await().&lt;List&lt;? extends Message&lt;Beverage&gt;&gt;&gt;until(queue::received, t -&gt; t.size() == 1); // &lt;5&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Beverage queuedBeverage = queue.received().get(0).getPayload();
        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());
        Assertions.assertEquals("coffee", queuedBeverage.getBeverage());
        Assertions.assertEquals("Coffee lover", queuedBeverage.getCustomer());
        Assertions.assertEquals("1234", queuedBeverage.getOrderId());
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        Beverage queuedBeverage = queue.received().get(0).getPayload();
        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());
        Assertions.assertEquals("coffee", queuedBeverage.getBeverage());
        Assertions.assertEquals("Coffee lover", queuedBeverage.getCustomer());
        Assertions.assertEquals("1234", queuedBeverage.getOrderId());
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the in-memory connector in your test class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスにインメモリーコネクタ－を挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信チャンネルを取得します (`orders`) - テストリソース内でチャンネルがインメモリーに切り替えられている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the outgoing channel (`queue`) - the channel must have been switched to in-memory in the test resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信チャネルを取得します (`queue`) - テストリソース内でチャネルがインメモリーに切り替えられている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `send` method to send a message to the `orders` channel. So, the application will process this message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`send` メソッドを使用して、`orders` チャンネルにメッセージを送信します。つまり、アプリケーションはこのメッセージを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `received` method to check the messages produced by the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが生成するメッセージを確認するには、`received` メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting Kafka in a test resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストリソースでの Kafka の起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、テストリソースで Kafka ブローカを起動することもできます。次のスニペットは、https://www.testcontainers.org/modules/kafka/[Testcontainers] 使用して Kafka ブローカを起動するテストリソースを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>public class KafkaResource implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>public class KafkaResource implements QuarkusTestResourceLifecycleManager {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private final KafkaContainer kafka = new KafkaContainer();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private final KafkaContainer kafka = new KafkaContainer();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        kafka.start();
        return Collections.singletonMap("kafka.bootstrap.servers", kafka.getBootstrapServers());  // &lt;1&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public Map&lt;String, String&gt; start() {
        kafka.start();
        return Collections.singletonMap("kafka.bootstrap.servers", kafka.getBootstrapServers());  // &lt;1&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Override
    public void stop() {
        kafka.close();
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Override
    public void stop() {
        kafka.close();
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the Kafka bootstrap location, so the application connects to this broker.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションがこのブローカーに接続するように、Kafka ブートストラップの場所を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka ブローカーが認証メカニズムとして OAuth を使用している場合は、この認証プロセスを有効にするために Kafka コンシューマーを設定する必要があります。まず、以下の依存関係をアプリケーションに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.strimzi&lt;/groupId&gt;
    &lt;artifactId&gt;kafka-oauth-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この依存関係は、OAuth ワークフローを処理するために必要なコールバックハンドラーを提供します。そして、`application.properties` で追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT
mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER
mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT
mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER
mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="team-a-client" \
  oauth.client.secret="team-a-client-secret" \
  oauth.token.endpoint.uri="http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token" ;
mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`oauth.client.id`、`oauth.client.secret`、`oauth.token.endpoint.uri` の値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth authentication works for both JVM and native modes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OAuth 認証は JVM とネイティブモードの両方で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide has shown how you can interact with Kafka using Quarkus.  It utilizes MicroProfile Reactive Messaging to build data streaming applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus を使用して Kafka とやりとりする方法を示しました。MicroProfile Reactive Messaging を利用して、データストリーミングアプリケーションを構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following IDEs have support for the community developed Quarkus Tools:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のIDEは、コミュニティで開発されたQuarkus Toolsをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition IntelliJ has additional support for Quarkus in their Ultimate non-open source version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらにIntelliJは、非オープンソースのUltimate版でQuarkusを追加サポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Visual Studio Code extension to install using the marketplace</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マーケットプレイスを使用してインストールするVisual Studioのコードエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse plugin to install into Eclipse using an updatesite</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アップデートサイトを使ってEclipseにインストールするEclipseプラグイン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>IntelliJ plugin that works in IntelliJ Community and Ultimate. Available from Marketplace.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJ CommunityとUltimateで動作するIntelliJプラグイン。マーケットプレイスから入手可能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Built-in Quarkus features available in Eclipse Che incl. che.openshift.io.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse Cheで利用可能なQuarkusの組込機能にはche.openshift.ioなどがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Status</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステータス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Stable</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Downloads</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ダウンロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[Marketplace]
{empty} +
 https://download.jboss.org/jbosstools/vscode/snapshots/vscode-quarkus/?C=M;O=D[Development Builds]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://marketplace.visualstudio.com/items?itemName=redhat.vscode-quarkus[Marketplace]
{empty} +
 https://download.jboss.org/jbosstools/vscode/snapshots/vscode-quarkus/?C=M;O=D[Development Builds]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://download.jboss.org/jbosstools/photon/snapshots/builds/jbosstools-quarkus_master/[Development Update Site]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://download.jboss.org/jbosstools/photon/snapshots/builds/jbosstools-quarkus_master/[Development Update Site]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://plugins.jetbrains.com/plugin/13234-quarkus/versions[Marketplace]
{empty} +
https://download.jboss.org/jbosstools/intellij/snapshots/intellij-quarkus/[Development Builds]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://plugins.jetbrains.com/plugin/13234-quarkus/versions[Marketplace]
{empty} +
https://download.jboss.org/jbosstools/intellij/snapshots/intellij-quarkus/[Development Builds]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.jetbrains.com/idea/nextversion/[Installer]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://www.jetbrains.com/idea/nextversion/[Installer]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://che.openshift.io/f?url=https://raw.githubusercontent.com/redhat-developer/devfile/master/getting-started/quarkus/devfile.yaml[Start Che Workspace]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://che.openshift.io/f?url=https://raw.githubusercontent.com/redhat-developer/devfile/master/getting-started/quarkus/devfile.yaml[Start Che Workspace]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Closed-Source</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クローズドソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://github.com/redhat-developer/quarkus-ls[Quarkus Language Server]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/redhat-developer/quarkus-ls[Quarkus Language Server]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:check[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>icon:check[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>icon:times[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>icon:times[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wizards w/code.quarkus.io</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>code.quarkus.ioのウィザード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://issues.jboss.org/browse/JBIDE-26950[icon:times[]]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://issues.jboss.org/browse/JBIDE-26950[icon:times[]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Wizard</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムウィザード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config editor</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定エディタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config autocompletion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定の自動補完</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config jump to definition</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定の定義へのジャンプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config profiles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config outline</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定アウトライン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Launch debug/dev:mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>debug/dev:mode の簡単起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection Discovery/Navigation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションディスカバリー/ナビゲーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of web applications are monotonous CRUD applications with REST APIs that are tedious to write.  To streamline this task, REST Data with Panache extension can generate the basic CRUD endpoints for your entities and repositories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くのWebアプリケーションは、REST APIを使った単調なCRUDアプリケーションで、書くのが面倒です。このタスクを合理化するために、REST Data with Panache エクステンションは、エンティティーやリポジトリの基本的なCRUDエンドポイントを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While this extension is still experimental and provides a limited feature set, we hope to get an early feedback for it.  Currently this extension supports Hibernate ORM and MongoDB with Panache and can generate CRUD resources that work with `application/json` and `application/hal+json` content.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションはまだ実験的なものであり、限られた機能しか提供していませんが、早期にフィードバックが得られることを期待しています。現在のところ、このエクステンションは Hibernate ORM と MongoDB with Panache をサポートしており、 `application/json` と `application/hal+json` のコンテンツで動作する CRUD リソースを生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the required dependencies to your `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要な依存関係を `pom.xml` に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache extension (`quarkus-hibernate-orm-rest-data-panache`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM REST Data with Panache エクステンション ( `quarkus-hibernate-orm-rest-data-panache` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBC ドライバーエクステンション ( `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the RESTEasy JSON serialization extensions (`quarkus-resteasy-jackson` or `quarkus-resteasy-jsonb`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy JSON シリアライゼーションエクステンションのどれか ( `quarkus-resteasy-jackson` または `quarkus-resteasy-jsonb` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the Panache entities and/or repositories as explained in the link:hibernate-orm-panache[Hibernate ORM with Panache guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:hibernate-orm-panache[Panacheを使ったHibernate ORM with Panacheガイド] で説明されているように、Panacheエンティティーおよび/またはリポジトリを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the interfaces for generation as explained in the resource generation section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソース生成の項で説明したように、生成用のインターフェースを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB REST Data with Panache extension (`quarkus-mongodb-rest-data-panache`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDB REST Data with Panache エクステンション ( `quarkus-mongodb-rest-data-panache` )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the Panache entities and/or repositories as explained in the link:mongodb-panache[MongoDB with Panache guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:mongodb-panache[MongoDB with Panache ガイド] で説明されているように、Panache エンティティーやリポジトリを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating resources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache generates JAX-RS resources based on the interfaces available in your application.  For each entity and repository that you want to generate, provide a resource interface.  _Do not implement these interfaces and don't provide custom methods because they will be ignored._ You can, however, override the methods from the extended interface in order to customize them (see the section at the end).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST Data with Panache は、アプリケーションで利用可能なインターフェイスに基づいて JAX-RS リソースを生成します。生成したい各エンティティーとリポジトリに対して、リソースインターフェイスを提供してください。 _これらのインターフェイスを実装したり、カスタムメソッドを提供したりしないでください。_ ただし、拡張インターフェースからメソッドをオーバーライドしてカスタマイズすることは可能です(最後のセクションを参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheEntityResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheEntityResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has an entity (e.g. `Person`) that extends either `PanacheEntity` or `PanacheEntityBase` class, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションに `PanacheEntity` または `PanacheEntityBase` クラスを拡張したエンティティー ( `Person` など) がある場合、REST Data with Panache に、次のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheRepositoryResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheRepositoryResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has a simple entity (e.g. `Person`) and a repository (e.g. `PersonRepository`) that implements either `PanacheRepository` or `PanacheRepositoryBase` interface, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが単純なエンティティー(例: `Person` )と、 `PanacheRepository` または `PanacheRepositoryBase` インターフェイスを実装したリポジトリ(例: `PersonRepository` )を持っている場合、REST Data with Panache に、以下のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheMongoEntityResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheMongoEntityResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has an entity (e.g. `Person`) that extends either `PanacheMongoEntity` or `PanacheMongoEntityBase` class, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションに `PanacheMongoEntity` または `PanacheMongoEntityBase` クラスを拡張したエンティティー ( `Person` など) がある場合、REST Data with Panache に、次のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>PanacheMongoRepositoryResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>PanacheMongoRepositoryResource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application has a simple entity (e.g. `Person`) and a repository (e.g. `PersonRepository`) that implements either `PanacheMongoRepository` or `PanacheMongoRepositoryBase` interface, you could instruct REST Data with Panache to generate its JAX-RS resource with the following interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが単純なエンティティー(例: `Person` )と、 `PanacheMongoRepository` または `PanacheMongoRepositoryBase` インターフェイスを実装したリポジトリ(例: `PersonRepository` )を持っている場合、REST Data with Panache に、以下のインターフェイスを使用して JAX-RS リソースを生成するように指示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated resources will be functionally equivalent for both entities and repositories.  The only difference being the particular data access pattern and data storage in use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されるリソースは、エンティティーとリポジトリの両方で機能的に同等となります。唯一の違いは、利用時の特定のデータアクセスパターンとデータストレージです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have defined one of the `PeopleResource` interfaces mentioned above, this extension will generate its implementation using a particular data access strategy.  The implemented class then will be used by a generated JAX-RS resource, which will look like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の `PeopleResource` インターフェイスのいずれかを定義している場合、このエクステンションは特定のデータアクセス戦略を使用してその実装を生成します。実装されたクラスは、生成された JAX-RS リソースによって使用され、以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resource customisation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache provides a `@ResourceProperties` and `@MethodProperties` annotations that can be used to customize certain features of the resource.  It can be used in your resource interface:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST Data with Panache は、リソースの特定の機能をカスタマイズするために使用できる `@ResourceProperties` と `@MethodProperties` のアノテーションを提供します。リソースのインターフェイスで使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Available options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ResourceProperties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ResourceProperties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`exposed` - whether resource could be exposed. A global resource property that can be overridden for each method. Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`exposed` - リソースが公開される可能性があるかどうか。各メソッドに対してオーバーライド可能なグローバルリソースプロパティー。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path` - resource base path. Default path is a hyphenated lowercase resource name without a suffix of `resource` or `controller`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`path` - リソースのベースパス。デフォルトのパスは、 `resource` または `controller` のサフィックスを含まないハイフン付きの小文字のリソース名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`paged` - whether collection responses should be paged or not.  First, last, previous and next page URIs are included in the response headers if they exist.  Request page index and size are taken from the `page` and `size` query parameters that default to `0` and `20` respectively.  Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`paged` - コレクションのレスポンスをページングするかどうか。最初、最後、前、次のページの URI が存在する場合は、レスポンスヘッダに含まれます。リクエストページのインデックスとサイズは、 `page` と `size` のクエリパラメーターから取得され、それぞれのデフォルトは `0` と `20` です。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`hal` - in addition to the standard `application/json` responses, generates additional methods that can return `application/hal+json` responses if requested via an `Accept` header.  Default is `false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`hal` - 標準の `application/json` レスポンスに加えて、 `Accept` ヘッダでリクエストされた場合に `application/hal+json` レスポンスを返す追加のメソッドを生成します。デフォルトは `false` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`halCollectionName` - name that should be used when generating a hal collection response. Default name is a hyphenated lowercase resource name without a suffix of `resource` or `controller`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`halCollectionName` - HAL コレクションレスポンスを生成する際に使用されるべき名前です。デフォルトの名前は `resource` または `controller` のサフィックスなしのハイフン付き小文字のリソース名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@MethodProperties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@MethodProperties`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`exposed` - does not expose a particular HTTP verb when set to `false`. Default is `true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`exposed` - `false` に設定されている場合、特定の HTTP Verb を公開しません。デフォルトは `true` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`path` - operation path (this is appended to the resource base path). Default is an empty string.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`path` - 操作パス (これはリソースベースのパスに追加されます)。デフォルトは空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST Data with Panache supports the following query parameters with the generated resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST Data with Panacheは、生成されたリソースで以下のクエリパラメーターをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`page` - a page number which should be returned by a list operation.  It applies to the paged resources only and is a number starting with 0. Default is 0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`page` - リスト操作で返されるべきページ番号。これはページ化されたリソースにのみ適用され、0 から始まる番号です。 デフォルトは 0 です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`size` - a page size which should be returned by a list operation.  It applies to the paged resources only and is a number starting with 1. Default is 20.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`size` - リスト操作で返されるべきページサイズ。これはページ化されたリソースにのみ適用され、1から始まる数値です。 デフォルトは20です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sort` - a comma separated list of fields which should be used for sorting a result of a list operation.  Fields are sorted in the ascending order unless they're prefixed with a `-`.  E.g. `?sort=name,-age` will sort the result by the name ascending by the age descending.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sort` - リスト操作の結果をソートするために使われるべきフィールドのカンマ区切りのリスト。フィールドの前に `-` を付けない限り、フィールドは昇順でソートされます。例えば `?sort=name,-age` は、名前の昇順、年齢の降順で結果をソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Response body examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスボディの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above REST Data with Panache supports the `application/json` and `application/hal+json` response content types.  Here are a couple of examples of how a response body would look like for the `get` and `list` operations assuming there are five `Person` records in a database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前述の通り、REST Data with Panache は `application/json` と `application/hal+json` のレスポンス コンテンツ タイプをサポートしています。 `Person` ここでは、データベース内に `get` レコードが 5 つあると仮定して、 と `list` 操作を行った場合のレスポンスボディがどのようになるか、いくつかの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GET /people/1</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GET /people/1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Accept: application/json`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Accept: application/json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Accept: application/hal+json`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Accept: application/hal+json`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GET /people?page=0&amp;size=2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GET /people?page=0&amp;size=2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both responses would also contain these headers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>両方のレスポンスには、これらのヘッダも含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `previous` link header (and hal link) would not be included, because the previous page does not exist.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のページが存在しないため、 `previous` リンクヘッダ(および HAL リンク)が含まれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code are a _no go_ (even if we all did it at some point ;-)).  In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードの中にハードコードされた値を使うことは _できません_ (たとえ誰もがどこかの時点でそうしていたとしてもです ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `config-quickstart` {quickstarts-tree-url}/config-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `config-quickstart` {quickstarts-tree-url}/config-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.config.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.config.GreetingResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus reads configuration properties from &lt;&lt;config-reference.adoc#configuration_sources,several sources&gt;&gt;.  For the purpose of this guide, we will use an application configuration file located in `src/main/resources/application.properties`.  Edit the file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus は link:config-reference.html#configuration_sources[複数のソース] から設定プロパティーを読み取ります。このガイドでは、 `src/main/resources/application.properties` にあるアプリケーション設定ファイルを使用します。以下の内容でファイルを編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the application attempts to inject a configuration property that is not set, an error is thrown.  So you can quickly know when your configuration is complete.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが設定されていない設定プロパティーを注入しようとすると、エラーがスローされます。そのため、設定が完了したときにすぐに知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.config.GreetingResource`, and introduce the following configuration properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.config.GreetingResource` を編集し、以下の設定プロパティーを導入します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, modify the `hello` method to use the injected properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `hello` メソッドを修正して、注入されたプロパティーを使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once set, check the application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定したら、アプリケーションを使って確認します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an alternative to injecting multiple related configuration values, you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.  See the &lt;&lt;config-reference.adoc#using_configproperties,Configuration Reference Guide&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の関連する設定値を注入する代わりに、 `@io.quarkus.arc.config.ConfigProperties` アノテーションを使用して、これらのプロパティーをまとめてグループ化することもできます。詳細については、『 link:config-reference.html#using_configproperties[設定リファレンスガイド] 』を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the functional test to reflect the changes made to the endpoint.  Edit the `src/test/java/org/acme/config/GreetingResourceTest.java` file and change the content of the `testHelloEndpoint` method to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、エンドポイントに加えられた変更を反映させるために、機能テストを更新する必要があります。 `src/test/java/org/acme/config/GreetingResourceTest.java` ファイルを編集し、 `testHelloEndpoint` メソッドの内容を変更します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.  You can add the `greeting.suffix`, remove the other properties, change the values, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定ファイルの変更はすぐに反映されます。 `greeting.suffix` の追加、他のプロパティーの削除、値の変更などが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the notion of configuration profiles.  These allow you to have multiple configuration values in the same file and select between them via a profile name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、設定プロファイルという概念をサポートしています。これにより、同じファイル内に複数の設定値を持つことができ、プロファイル名を使用してそれらの間で選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>個の場合、Quarkus の HTTP ポートは9090になります。 `dev` プロファイルがアクティブでない場合は8181になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the &lt;&lt;config-reference.adoc#configuration_profiles,Configuration Reference Guide&gt;&gt; for more information about configuration profiles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロファイルの詳細については、 link:config-reference.html#configuration_profiles[設定リファレンスガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace for its own configuration. For example to configure the HTTP server port you can set `quarkus.http.port` in `application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 自体は、アプリケーションと同じメカニズムで設定されます。Quarkus は、独自の設定のために `quarkus.` ネームスペースを予約します。たとえば、HTTPサーバーのポートを設定するには、 `application.properties` で `quarkus.http.port` を設定します。Quarkusの設定プロパティーはすべて link:all-config[文書化されており、検索可能です] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and therefore `quarkus.` should **never** be used as prefix for application specific properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上述したように、 `quarkus.` で始まるプロパティーは、Quarkus 自体を設定するために実質的に予約されているため、アプリケーション固有のプロパティーのプレフィックスとして `quarkus.` を使用してはいけ *ません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, some extensions do define properties _overridable at runtime_.  A canonical example is the database URL, username and password which is only known specifically in your target environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、いくつかのエクステンションは _実行時にオーバーライド可能な_ プロパティーを定義しています。定型的な例としては、データベースの URL、ユーザー名とパスワードがありますが、これはターゲット環境でしか知られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the &lt;&lt;config-reference.adoc#configuring_quarkus,Configuration Reference Guide&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:config-reference.html#configuring_quarkus[設定リファレンスガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Internally, Quarkus uses JBoss Log Manager and the JBoss Logging facade. + You can use the JBoss Logging facade inside your code as it's already provided, or any of the supported Logging API listed in the next chapter as Quarkus will send them to JBoss Log Manager.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>内部的には、QuarkusはJBoss Log ManagerとJBoss Logging ファサードを使用します。+ JBoss Logging ファサードはすでに提供されているので、コード内部で使用することができますが、QuarkusがJBoss Log Managerに送信するため、次の章でリストアップされているサポートされたロギングAPIのいずれかを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the logging configuration will then be done inside your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのロギング設定は、 `application.properties` の中で実施されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Logging APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているロギング API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applications and components may use any of the following APIs for logging, and the logs will be merged:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションやコンポーネントは、以下のいずれかのAPIを使用してログを出力することができ、ログはマージされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Internally Quarkus uses JBoss Logging; you can also use it inside your application so that no other dependencies should be added for your logs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは内部的にJBoss Loggingを使用しています。アプリケーションの内部で使用することもできるので、ログに他の依存関係を追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use JBoss Logging but one of your libraries uses a different logging API, you may need to configure a link:#logging-adapters[Logging Adapter].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JBoss Logging を使用しているけれども、ライブラリの 1 つが異なるロギング API を使用している場合は、 link:#logging-adapters[ロギングアダプター] を設定する必要がある場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also inject a configured `org.jboss.logging.Logger` instance in your beans and resource classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、設定済みの `org.jboss.logging.Logger` インスタンスを Bean やリソースクラスに注入することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The FQCN of the declaring class is used as a logger name, i.e. `org.jboss.logging.Logger.getLogger(SimpleBean.class)` will be used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.jboss.logging.Logger.getLogger(SimpleBean.class)` 宣言したクラスのFQCNがロガー名として使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the name _foo_ is used as a logger name, i.e. `org.jboss.logging.Logger.getLogger("foo")` will be used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.jboss.logging.Logger.getLogger("foo")` この場合、ロガー名として _foo_ という名前が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The logger instances are cached internally. Therefore, a logger injected e.g. into a `@RequestScoped` bean is shared for all bean instances to avoid possible performance penalty associated with logger instantiation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロガーインスタンスは内部的にキャッシュされます。したがって、例えば `@RequestScoped` Bean に注入されたロガーは、ロガーのインスタンス化に関連する可能性のあるパフォーマンスのペナルティを回避するために、すべての Bean インスタンスで共有されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about Apache Log4j ?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Log4j はどうですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://logging.apache.org/log4j/2.x/[Log4j] is a logging implementation: it contains a logging backend and a logging facade.  Quarkus uses the JBoss Log Manager backend, so you will need to include the `log4j2-jboss-logmanager` library to route Log4j logs to JBoss Log Manager.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://logging.apache.org/log4j/2.x/[Log4j] はロギングの実装の一つです: ロギングバックエンドとロギングファサードが含まれています。QuarkusはJBoss Log Managerバックエンドを使用するため、Log4jログをJBoss Log Managerにルーティングするためには `log4j2-jboss-logmanager` ライブラリをインクルードする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the library needed for Log2J version 2; if you use the legacy Log4J version 1 you need to use `log4j-jboss-logmanager` instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはLog2Jのバージョン2に必要なライブラリです。もしレガシーなLog4Jのバージョン1を使用している場合は、代わりに `log4j-jboss-logmanager` を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then use the Log4J API inside your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、アプリケーション内でLog4J APIを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not include any Log4j dependencies. The `log4j2-jboss-logmanager` library includes what's needed to use Log4j as a logging facade.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Log4jの依存関係を含めないでください。 `log4j2-jboss-logmanager` ライブラリは、Log4j をロギング・ファサードとして使用するために必要なものを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging levels</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログレベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the log levels used by Quarkus:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらはQuarkusで使用されているログレベルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special level to turn off logging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングをオフにするための特別なレベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A critical service failure/complete inability to service requests of any kind.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>致命的なサービス障害/いかなる種類のサービス要求にも完全に対応できないこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A significant disruption in a request or the inability to service a request.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストの大幅な中断、またはリクエストに対応できないこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A non-critical service error or problem that may not require immediate correction.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>重要ではないサービスのエラーや問題で、すぐに修正する必要がない場合があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service lifecycle events or important related very-low-frequency information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスのライフサイクルイベントまたは重要な関連する非常に低頻度の情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messages that convey extra information regarding lifecycle or non-request-bound events which may be helpful for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグに役立つかもしれない、ライフサイクルまたは非リクエストバウンドイベントに関する余分な情報を伝えるメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messages that convey extra per-request debugging information that may be very high frequency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストごとのデバッグ情報を伝えるメッセージで、非常に高い頻度で送信される可能性があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Special level for all messages including custom levels.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムレベルを含むすべてのメッセージのための特別なレベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the following levels may be configured for applications and libraries using link:https://docs.oracle.com/javase/8/docs/api/java/util/logging/Level.html[`java.util.logging`]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>加えて、 link:https://docs.oracle.com/javase/8/docs/api/java/util/logging/Level.html[`java.util.logging`] を利用して、アプリケーションとライブラリに対して以下のレベルを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **ERROR**.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**ERROR** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **WARN**.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**WARN** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service configuration information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービス構成情報</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **DEBUG**.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**DEBUG** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Same as **TRACE**.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**TRACE** と同じ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Event more debugging information than `TRACE`, maybe with even higher frequency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベント `TRACE` よりも多くのデバッグ情報、さらに高頻度である可能性があります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run time logging is configured in the `application.properties` file, for example, to set the default log level to `INFO` logging and include Hibernate `DEBUG` logs:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムロギングは `application.properties` ファイルで設定します。例えばデフォルトのログレベルを `INFO` ロギングに設定し、Hibernate の `DEBUG` ログを含めるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting a log level below `DEBUG` requires the minimum log level to be adjusted, either globally via the `quarkus.log.min-level` property or per-category as shown in the example above, as well as adjusting the log level itself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログレベルを `DEBUG` より下に設定するには、ログレベル自体を調整するだけでなく、グローバルに `quarkus.log.min-level` プロパティーを介して、または上記の例のようにカテゴリごとに、最小ログレベルを調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Minimum logging level sets a floor level that Quarkus will be needed to potentially generate, opening the door to optimization opportunities.  As an example, in native execution the minimum level enables lower level checks (e.g. `isTraceEnabled`) to be folded to `false`, resulting in dead code elimination for code that will never to be executed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最小ロギングレベルは、Quarkusが潜在的に生成するために必要となるフロアレベルを設定し、最適化の機会の扉を開きます。例えば、ネイティブ実行では、最小レベルを設定することで、低レベルのチェック(例: `isTraceEnabled` )を `false` に折りたたむことができ、結果として、実行されることのないコードのデッドコードを排除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All possible properties are listed in &lt;&lt;loggingConfigurationReference, the logging configuration reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>可能なすべてのプロパティーは、 link:#loggingConfigurationReference[ロギング設定リファレンス] に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are adding these properties via command line make sure `"` is escaped.  For example `-Dquarkus.log.category.\"org.hibernate\".level=TRACE`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインでこれらのプロパティーを追加する場合は、 `"` がエスケープされていることを確認してください。例えば `-Dquarkus.log.category.\"org.hibernate\".level=TRACE` とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging categories</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングカテゴリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging is done on a per-category basis.  Each category can be independently configured.  A configuration which applies to a category will also apply to all sub-categories of that category, unless there is a more specific matching sub-category configuration.  For every category the same settings that are configured on ( console / file / syslog ) apply.  These can also be overridden by attaching a one or more named handlers to a category. See example in &lt;&lt;category-named-handlers-example&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングはカテゴリごとに行われます。各カテゴリは独立して設定することができます。あるカテゴリに適用される設定は、より特定の一致するサブカテゴリの設定がない限り、そのカテゴリのすべてのサブカテゴリにも適用されます。すべてのカテゴリに対して、( console / file / syslog ) で設定されているのと同じ設定が適用されます。これらの設定は、1つ以上の名前付きハンドラーをカテゴリにアタッチすることで上書きすることもできます。 link:#category-named-handlers-example[category-named-handlers-example]] の例を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".leve</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.log.category."&lt;category-name&gt;".leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>INFO footnote:[Some extensions may define customized default log levels for certain categories, in order to reduce log noise by default.  Setting the log level in configuration will override any extension-defined log levels.]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>INFO footnote:[いくつかのエクステンションは、ログノイズを削減するために、特定のカテゴリに対してカスタマイズされたデフォルトログレベルを定義しているかもしれません。コンフィグレーションでのログレベル設定は、エクステンション定義のログレベルをオーバーライドします。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The level to use to configure the category named `&lt;category-name&gt;`.  The quotes are necessary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`&lt;category-name&gt;` という名前のカテゴリを設定するために使用するレベル。クオートが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".min-leve</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.log.category."&lt;category-name&gt;".min-leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The minimum logging level to use to configure the category named `&lt;category-name&gt;`.  The quotes are necessary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`&lt;category-name&gt;` という名前のカテゴリを設定するために使用する最小ロギングレベル。クオートが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".use-parent-handler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.log.category."&lt;category-name&gt;".use-parent-handler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tru</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>tru</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify whether or not this logger should send its output to its parent logger.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このロガーがその出力を親ロガーに送信するかどうかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."&lt;category-name&gt;".handlers=[&lt;handler&gt;]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.log.category."&lt;category-name&gt;".handlers=[&lt;handler&gt;]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>empty footnote:[By default the configured category gets the same handlers attached as the one on the root logger.]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>empty footnote:[デフォルトでは設定されたカテゴリはルートロガーにアタッチされたハンドラーと同じものを受け取ります。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The names of the handlers that you want to attach to a specific category.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のカテゴリにアタッチしたいハンドラーの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The quotes shown in the property name are required as categories normally contain '.' which must be escaped. An example is shown in &lt;&lt;category-example&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カテゴリには通常 '.' が含まれているため、プロパティー名に表示されているクオートはエスケープされている必要があります。例を link:#category-example[[category-example]] に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Root logger configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートロガーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The root logger category is handled separately, and is configured via the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルート ロガー カテゴリは個別に処理され、次のプロパティーで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.leve</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.log.leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default log level for every log category.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各ログカテゴリのデフォルトのログレベル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.min-leve</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.log.min-leve</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default minimum log level for every log category.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各ログカテゴリのデフォルトの最小ログレベル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no level configuration exists for a given logger category, the enclosing (parent) category is examined. If no categories are configured which enclose the category in question, then the root logger configuration is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>与えられたロガー カテゴリにレベル設定が存在しない場合、包含(親)カテゴリが検査されます。対象のカテゴリを囲むカテゴリが設定されていない場合、ルート ロガー設定が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging Format</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログフォーマット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus uses a pattern-based logging formatter that generates human-readable text logs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはパターンベースのログフォーマッタを使用して、人間が読めるテキストログを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the format for each log handler via a dedicated property.  For the console handler, the property is `quarkus.log.console.format`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各ログハンドラーのフォーマットは、専用のプロパティーで設定することができます。コンソールハンドラーの場合、プロパティーは `quarkus.log.console.format` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The logging format string supports the following symbols:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログフォーマット文字列は、以下のシンボルをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Symbo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Symbo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders a simple `%` character.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>単に `%` 文字をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%c</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Category</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カテゴリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the category name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カテゴリ名をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source clas</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source class name.footnote:calc[Format sequences which examine caller information may affect performance]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースクラス名をレンダリングします。 footnote:calc[呼び出し元の情報を検査するフォーマットシーケンスはパフォーマンスに影響する可能性があります。]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%d{xxx}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>d{xxx}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dat</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders a date with the given date format string, which uses the syntax defined by `java.text.SimpleDateFormat`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java.text.SimpleDateFormat` で定義されている構文を使用した、指定した日付書式の文字列で日付をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exception</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Exception</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the thrown exception, if any.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>投げられた例外があれば、その例外をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source fil</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source file name.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースファイル名をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Host nam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the system simple host name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムの単純なホスト名をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualified host nam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全修飾ホスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the system's fully qualified host name, which may be the same as the simple host name, depending on OS configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムの完全修飾されたホスト名をレンダリングします。OSの設定によっては、単純ホスト名と同じかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%i</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%i</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Process ID</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロセスID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the current process PID.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のプロセスPIDをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source location</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースの場所</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source location information, which includes source file name, line number, class name, and method name.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースファイル名、行番号、クラス名、メソッド名を含むソース・ロケーション情報をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source lin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースライン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source line number.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソース行番号をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full Messag</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フルメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the log message plus exception (if any).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログメッセージと例外(もしあれば)を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Source metho</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the source method name.footnote:calc[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースメソッド名をレンダリングします。 footnote:calc[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%n</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%n</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Newlin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>改行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the platform-specific line separator string.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォーム固有の改行文字列をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Process nam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロセス名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the name of the current process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のプロセスの名前をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%p</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%p</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Leve</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the log level of the message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージのログレベルをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%r</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%r</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Relative tim</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>相対時間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the time in milliseconds since the start of the application log.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションログの開始からの時間をミリ秒単位でレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple messag</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders just the log message, with no exception trace.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログメッセージのみを表示し、例外のトレースは表示しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%t</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%t</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thread nam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スレッド名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the thread name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スレッド名をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%t{id}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%t{id}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thread ID</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スレッドID</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Render the thread ID.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スレッドIDをレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%z{&lt;zone name&gt;}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%z{&lt;zone name&gt;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time zon</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイムゾーン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the time zone of the output to `&lt;zone name&gt;`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>出力のタイムゾーンを `&lt;zone name&gt;` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%X{&lt;MDC property name&gt;}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%X{&lt;MDC property name&gt;}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapped Diagnostics Context Valu</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マップされた診断コンテキスト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders the value from Mapped Diagnostics Context</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マップされた診断コンテキストの値をレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mapped Diagnostics Context Value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マップされた診断コンテキスト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders all the values from Mapped Diagnostics Context in format {property.key=property.value}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マップされた診断コンテキストのすべての値を {property.key=property.value} 形式でレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>%x</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>%x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nested Diagnostics context value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>入れ子になった診断コンテキスト値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Renders all the values from Nested Diagnostics Context in format {value1.value2}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネストされた診断コンテキストからのすべての値を {value1.value2} 形式でレンダリングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Console Logging Formats</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールログの代替フォーマット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to change the output format of the console log. This can be useful in environments where the output of the Quarkus application is captured by a service which can, for example, process and store the log information for later analysis.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールログの出力形式を変更することができます。これは、Quarkusアプリケーションの出力がサービスによってキャプチャされ、例えば、後で分析するためにログ情報を処理して保存することができる環境で有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to configure the JSON logging format, the `quarkus-logging-json` extension may be employed.  Add this extension to your application POM as the following snippet illustrates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON ログフォーマットを設定するために、 `quarkus-logging-json` エクステンションモジュールを使用することができます。次のスニペットが示すように、このエクステンションをアプリケーションPOMに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  &lt;dependencies&gt;
    &lt;!-- ... your other dependencies are here ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-logging-json&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  &lt;dependencies&gt;
    &lt;!-- ... your other dependencies are here ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-logging-json&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The presence of this extension will, by default, replace the output format configuration from the console configuration.  This means that the format string and the color settings (if any) will be ignored.  The other console configuration items (including those controlling asynchronous logging and the log level) will continue to be applied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションが存在すると、デフォルトではコンソール設定からの出力フォーマット設定を置き換えます。つまり、フォーマット文字列と色の設定(もしあれば)は無視されます。他のコンソール設定項目(非同期ロギングやログレベルを制御するものを含む)は引き続き適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For some, it will make sense to use logging that is humanly readable (unstructured) in dev mode and JSON logging (structured) in production mode. This can be achieved using different profiles, as shown in the following configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの場合、devモードでは人間が読める(構造化されていない)ロギングを使用し、本番モードではJSONロギング(構造化されている)を使用することが理にかなっているでしょう。これは、以下の設定で示されているように、異なるプロファイルを使用して達成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable JSON logging in application.properties for dev and test mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>application.properties で dev および test モードに対する JSONロギングを無効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The JSON logging extension can be configured in various ways.  The following properties are supported:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON ロギングエクステンションは、さまざまな方法で設定することができます。以下のプロパティーがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling pretty printing might cause certain processors and JSON parsers to fail.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プリティプリントを有効にすると、特定のプロセッサーやJSONパーサーで解釈できなくなる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Printing the details can be expensive as the values are retrieved from the caller. The details include the source class name, source file name, source method name and source line number.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>呼び出し元から値を取得するため、詳細を表示するとコストがかかります。詳細には、ソースクラス名、ソースファイル名、ソースメソッド名、ソース行番号が含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log Handlers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A log handler is a logging component responsible for the emission of log events to a recipient.  Quarkus comes with three different log handlers: **console**, **file** and **syslog**.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログハンドラーは、受信者へのログイベントの送信を担当するロギングコンポーネントです。Quarkusには、 **コンソール** 、 **ファイル** 、 **syslog** という3つの異なるログハンドラーが用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Console log handler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールログハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The console log handler is enabled by default.  It outputs all log events to the console of your application (typically to the system's `stdout`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールログハンドラーはデフォルトで有効になっています。これはすべてのログイベントをアプリケーションのコンソールに出力します (通常はシステムの `stdout` )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details of its configuration options, see link:#quarkus-log-logging-log-config_quarkus.log.console[the Console Logging configuration reference].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その構成オプションの詳細については、「 link:#quarkus-log-logging-log-config_quarkus.log.console[コンソール ロギング」の構成リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File log handler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ファイルログハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The file log handler is disabled by default. It outputs all log events to a file on the application's host.  It supports log file rotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ファイルログハンドラーはデフォルトでは無効になっています。すべてのログイベントをアプリケーションのホスト上のファイルに出力します。ログファイルのローテーションをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details of its configuration options, see link:#quarkus-log-logging-log-config_quarkus.log.file[the File Logging configuration reference].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その構成オプションの詳細については、「 link:#quarkus-log-logging-log-config_quarkus.log.file[ファイル ロギング」の構成リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://en.wikipedia.org/wiki/Syslog[Syslog] is a protocol for sending log messages on Unix-like systems using a protocol defined by link:https://tools.ietf.org/html/rfc5424[RFC 5424].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://en.wikipedia.org/wiki/Syslog[Syslogは] 、 link:https://tools.ietf.org/html/rfc5424[RFC 5424] で定義されたプロトコルを用いてUnix系システム上でログメッセージを送信するためのプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syslog handler sends all log events to a syslog server (by default, the syslog server that is local to the application).  It is disabled by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>syslog ハンドラーは、すべてのログイベントを syslog サーバー (デフォルトでは、アプリケーションのローカルにある syslog サーバー) に送信します。デフォルトでは無効になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For details of its configuration options, see link:#quarkus-log-logging-log-config_quarkus.log.syslog[the Syslog Logging configuration reference].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その構成オプションの詳細については、「 link:#quarkus-log-logging-log-config_quarkus.log.syslog[Syslog Logging」の構成リファレンス] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Console DEBUG Logging except for Quarkus logs (INFO), No color, Shortened Time, Shortened Category Prefixes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソール DEBUG ログ、Quarkusのログ(INFO)を除く、カラーなし、時間短縮、カテゴリプレフィックス短縮</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are adding these properties via command line make sure `"` is escaped.  For example `-Dquarkus.log.category.\"io.quarkus\".level=DEBUG`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインでこれらのプロパティーを追加する場合は、 `"` がエスケープされていることを確認してください。例えば `-Dquarkus.log.category.\"io.quarkus\".level=DEBUG` のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>File TRACE Logging Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ファイル TRACE ログ設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we don't change the root logger, console log will only contain `INFO` or higher order logs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートロガーを変更しないので、コンソールログには `INFO` 以上の順位のログしか表示されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named handlers attached to a category</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カテゴリにアタッチされた名前付きハンドラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to send your logs to a centralized tool like Graylog, Logstash or Fluentd, you can follow the link:centralized-log-management[Centralized log management guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログをGraylog、Logstash、Fluentdなどの集中型ツールに送信したい場合は、 link:centralized-log-management[集中型ログ管理ガイド] に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to Configure Logging for `@QuarkusTest`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusTest` のログ設定方法 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to configure logging for your `@QuarkusTest`, don't forget to set up the `maven-surefire-plugin` accordingly.  In particular, you need to set the appropriate `LogManager` using the `java.util.logging.manager` system property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusTest` のロギングを設定したい場合は、それに応じて `maven-surefire-plugin` を設定することを忘れないでください。特に、 `java.util.logging.manager` system プロパティーを使用して適切な `LogManager` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure the `org.jboss.logmanager.LogManager` is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.jboss.logmanager.LogManager` が使用されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable debug logging for all logging categories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのロギングカテゴリのデバッグロギングを有効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle, add this to your `build.gradle`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleを使用している場合は、 `build.gradle` にこれを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See also: &lt;&lt;getting-started-testing.adoc#test-from-ide,Running `@QuarkusTest` from an IDE&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>こちらも参照: &lt;&lt;link:getting-started-testing.html#test-from-ide[IDE から `@QuarkusTest` を実行する &gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging Adapters</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングアダプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus relies on the JBoss Logging library for all the logging requirements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、すべてのロギング要件をJBoss Loggingライブラリに依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using libraries that have dependencies on other logging libraries such as Apache Commons Logging, Log4j or Slf4j, you need to exclude them from the dependencies and use one of the adapters provided by JBoss Logging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Commons Logging、Log4j、Slf4j などの他のロギングライブラリに依存関係があるライブラリを使用している場合は、それらを依存関係から除外し、JBoss Logging が提供するアダプターのいずれかを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is especially important when building native executables as you could encounter issues similar to the following when compiling the native executable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルをコンパイルする際に以下のような問題が発生する可能性があるため、ネイティブ実行ファイルをビルドする際には特に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is due to the logging implementation not being included in the native executable.  Using the JBoss Logging adapters will solve this problem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ロギングの実装がネイティブ実行ファイルに含まれていないことが原因です。JBoss Logging アダプターを使用することで、この問題は解決されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These adapters are available for most of the common Open Source logging components, such as Apache Commons Logging:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのアダプターは、Apache Commons Logging のような一般的なオープンソースのロギングコンポーネントのほとんどで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log4j:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Log4j:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Log4j2:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Log4j2:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And Slf4j:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして Slf4j:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is not needed for libraries that are dependencies of a Quarkus extension as the extension will take care of this for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkusエクステンションの依存関係にあるライブラリには必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logging configuration reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギング設定のリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Glossary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>用語集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントやウェブサイトで好まれる用語を集めたものです。一貫性を保つために、これらの用語の範囲内にとどめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Live coding</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>* ライブコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to measure the test coverage of your application. This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのテストカバレッジを測定する方法をご紹介します。このガイドでは、以下の内容をカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your Unit Tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユニットテストのカバレッジを測定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your Integration Tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合テストのカバレッジを測定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Separating the execution of your Unit Tests and Integration Tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユニットテストと統合テストの実行を分離する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consolidating the coverage for all your tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのテストのカバレッジを統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that code coverage is not supported in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードではコードカバレッジはサポートされていませんのでご注意ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Having completed the link:getting-started-testing[Testing your application guide]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://quarkus.io/guides/getting-started-testing[アプリケーションガイドのテスト] が完了済であること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is just a JAX-RS endpoint (hello world) that relies on dependency injection to use a service.  The service will be tested with JUnit 5 and the endpoint will be annotated via a `@QuarkusTest` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドで構築されたアプリケーションは、サービスを使用するために依存性インジェクションに依存した JAX-RS エンドポイント (hello world) に過ぎません。サービスは JUnit 5 でテストされ、エンドポイントには `@QuarkusTest` のアノテーションが付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step. However, you can go right to the completed example.  Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。しかし、完成した例にすぐに進むことができます。Git リポジトリをクローンします: `git clone {quickstarts-clone-url}` 、または {quickstarts-archive-url}[archive] をダウンロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `tests-with-coverage-quickstart` {quickstarts-tree-url}/tests-with-coverage-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `tests-with-coverage-quickstart` {quickstarts-tree-url}/tests-with-coverage-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting from a simple project and two tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>簡単なプロジェクトと2つのテストから始める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start from an empty application created with the Quarkus Maven plugin:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Mavenプラグインで作成した空のアプリケーションから始めてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, an application serving a hello endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、helloエンドポイントを提供するアプリケーション:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This endpoint uses a greeting service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエンドポイントは、グリーティングサービスを利用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring separately the coverage of each test type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各テストタイプのカバレッジを個別に測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The coverage does not seem to correspond to the reality</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カバレッジが現実と一致していないように見える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the report generation, you may have noticed a warning:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レポート生成中に警告が表示されることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You now have all the information you need to study the coverage of your tests! But remember, some code that is not covered is certainly not well tested. But some code that is covered is not necessarily *well* tested. Make sure to write good tests!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、テストのカバレッジを研究するために必要なすべての情報を手に入れることができました!しかし、カバーされていないコードは、確かに十分にテストされていないものがありますが、カバーされているコードの中には、必ずしも *十分に* テストされていないものもあることを覚えておいてください。良いテストを書くようにしましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Dev UI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the Quarkus Dev UI for link:building-my-first-extension[extension authors].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:building-my-first-extension[エクステンションの作者] のためのQuarkus Dev UIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus now ships with a new experimental Dev UI, which is available in dev mode (when you start quarkus with `mvn quarkus:dev`) at http://localhost:8080/q/dev[/q/dev] and will show you something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは現在、新しく実験的なDev UIを搭載しています。このUIは、 devモード( `mvn quarkus:dev` でquarkusを起動)で利用可能で、link:http://localhost:8080/q/dev[/q/dev] に存在し、以下のようなものが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It allows you to quickly visualize all the extensions currently loaded, see their status and go directly to their documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、現在ロードされているすべてのエクステンションを素早く可視化し、そのステータスを確認し、ドキュメントに直接アクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On top of that, each extension can add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その上で、各エクステンションは以下を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;how-can-i-make-my-extension-support-the-dev-ui,Custom useful bits of runtime information in the overview&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#how-can-i-make-my-extension-support-the-dev-ui[カスタムのランタイム情報の概要]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;adding-full-pages,Full custom pages&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#adding-full-pages[フルカスタムページ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;advanced-usage-adding-actions,Interactive pages with actions&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#advanced-usage-adding-actions[アクション付きのインタラクティブページ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I make my extension support the Dev UI?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをDev UIに対応させるにはどうすればいいですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to make your extension listed in the Dev UI you don't need to do anything!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをDev UIに表示させるためには、何もする必要はありません!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So you can always start with that :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>だから、いつでもそれから始めることができます :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to add a file named `dev-templates/embedded.html` in your link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] extension module's resources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] エクステンションのリソースに `dev-templates/embedded.html` というファイルを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The contents of this file will be included in your extension card, so for example we can place two links with some styling and icons:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルの内容が、エクステンションカードに含まれますので、例えば、次のようにいくつかのスタイリングとアイコンと共に2つのリンクを配置することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the Font Awesome Free icon set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Font Awesome Freeアイコンセットを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template and styling support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートとスタイリングのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both the `embedded.html` files and any full page you add in `/dev-templates` will be interpreted by link:qute[the Qute template engine].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`embedded.html` ファイルと `/dev-templates` に追加したフルページの両方共、 link:qute[Qute テンプレートエンジン] によって処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This also means that you can link:qute-reference#user_tags[add custom Qute tags] in `/dev-templates/tags` for your templates to use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはテンプレートを使用できるようにする為に、 `/dev-templates/tags` に link:qute-reference#user_tags[カスタム Qute タグを追加] 出来ることも意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The style system currently in use is https://getbootstrap.com/docs/4.0/getting-started/introduction/[Bootstrap V4 (4.5.3)] but note that this might change in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在使用されているスタイルシステムは link:https://getbootstrap.com/docs/4.0/getting-started/introduction/[Bootstrap V4(4.5.3)] ですが、将来的に変更される可能性があるので注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main template also includes https://jquery.com/[jQuery 3.5.1], but here again this might change.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メインテンプレートには link:https://jquery.com/[jQuery 3.5.1] も含まれていますが、こちらも変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing Config Properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティーへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `config:property(name)` expression can be used to output the config value for the given property name.  The property name can be either a string literal or obtained dynamically by another expression.  For example `{config:property('quarkus.lambda.handler')}` and `{config:property(foo.propertyName)}`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`config:property(name)` 式を使用して、指定されたプロパティー名の設定値を出力することができます。プロパティー名は、文字列リテラルか、別の式で動的に取得することができます。例えば `{config:property('quarkus.lambda.handler')}` や `{config:property(foo.propertyName)}` が可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding full pages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フルページの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add full pages for your Dev UI extension such as this one:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のようなDev UIエクステンションにフルページを追加するには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to place them in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] module's `/dev-templates` resource folder, like this page for the link:cache[`quarkus-cache` extension]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それらをlink:cache[`quarkus-cache`] エクステンションのこのページのように、
エクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] モジュールの `/dev-templates` リソースフォルダーに配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to benefit from the same style as other Dev UI pages, extend the `main` template</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他の Dev UI ページと同じスタイルを利用するには、 `main` テンプレートを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can pass extra CSS for your page in the `style` template parameter</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`style` テンプレートパラメーターで、ページに追加の CSS を渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to set your page title in the `title` template parameter</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`title` テンプレートパラメーターにページタイトルを設定することを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `body` template parameter will contain your content</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`body` テンプレートパラメーターには、コンテンツが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order for your template to read custom information from your Quarkus extension, you can use the `info` link:qute-reference#namespace_extension_methods[namespace].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートがQuarkusエクステンションからカスタム情報を読み取るためには、 `info` link:qute-reference#namespace_extension_methods[名前空間] を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This shows an &lt;&lt;advanced-usage-adding-actions,interactive page&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、 link:#advanced-usage-adding-actions[インタラクティブページ] を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Linking to your full-page templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フルページテンプレートへのリンク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every full-page template lives under the `/q/dev/{groupId}.{artifactId}/` URI (for example `/q/dev/io.quarkus.quarkus-cache/`), so if you want to link to them from your `embedded.html` file you can use the `urlbase` template parameter to point to them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのフルページテンプレートは `/q/dev/{groupId}.{artifactId}/` URI (例: `/q/dev/io.quarkus.quarkus-cache/` ) の下に存在するので、 `embedded.html` ファイルからそれらにリンクしたい場合は `urlbase` テンプレートパラメーターを使用してそれらを指すようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `urlbase` template parameter to point to where your full-page templates are located</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`urlbase` テンプレートパラメーターを使用して、フルページテンプレートが配置されている場所を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing information to your templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートに情報を渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In `embedded.html` or in full-page templates, you will likely want to display information that is available from your extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`embedded.html` やフルページのテンプレートでは、エクステンションから得られる情報を表示したい場合が多いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to make that information available, depending on whether it is available at build time or at run time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その情報を利用可能にするには、ビルドタイムに利用可能か、ランタイムに利用可能かによって、2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In both cases we advise that you add support for the Dev UI in your `{pkg}.deployment.devconsole` package in a `DevConsoleProcessor` class (in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] module).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらの場合も、 `{pkg}.deployment.devconsole` パッケージの `DevConsoleProcessor` クラス (エクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] モジュール)でDev UIのサポートを追加することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing run-time information</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイム情報を渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to make this link:building-my-first-extension#deploying-the-greeting-feature[build step] conditional on being in dev mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この link:building-my-first-extension#deploying-the-greeting-feature[ビルドステップ]は 、開発者モードであることを条件にすることを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a run-time dev `info:cacheInfos` template value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイム dev `info:cacheInfos` テンプレート値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will map the `info:cacheInfos` value to this supplier in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `info:cacheInfos` の値がエクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`] にマップされます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passing build-time information</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドタイム情報を渡す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes you only need build-time information to be passed to your template, so you can do it like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドタイムの情報だけをテンプレートに渡す必要がある場合もあります。その場合、このようにすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use whatever dependencies you need as input</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要な依存関係を入力として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a build-time `info:devQuteInfos` DEV template value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドタイム `info:devQuteInfos` DEVテンプレート値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Advanced usage: adding actions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>高度な使用法:アクションの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also add actions to your Dev UI templates:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI テンプレートにアクションを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be done by adding another link:building-my-first-extension#deploying-the-greeting-feature[build step] to declare the action in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] module:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、別の link:building-my-first-extension#deploying-the-greeting-feature[ビルドステップ] を追加してエクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`deployment`] モジュールでアクションを宣言することで実現可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark the recorder as optional, so it will only be invoked when in dev mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レコーダーをオプションとしてマークし、開発モードの時にのみ起動されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a `POST {urlbase}/caches` route handled by the given handler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>与えられたハンドラーによって処理される `POST {urlbase}/caches` ルートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: you can see &lt;&lt;action-example,how to invoke this action from your full page&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>NOTE: link:#action-example[アクションを呼び出す方法は、ページ全体から見る] ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now all you have to do is implement the recorder in your extension's link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あとは、エクステンションの link:building-my-first-extension#description-of-a-quarkus-extension[`runtime module`] でrecorderを実装するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you can use https://vertx.io/docs/vertx-web/java/#_routing_by_http_method[any Vert.x handler], the `DevConsolePostHandler` superclass will handle your POST actions nicely, and auto-redirect to the `GET` URI right after your `POST` for optimal behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://vertx.io/docs/vertx-web/java/#_routing_by_http_method[どのVert.x ハンドラーでも] 使用することができますが、 `DevConsolePostHandler` スーパークラスは POST アクションをうまく処理し、最適な動作を実現するために `POST` の直後に `GET` URI に自動リダイレクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the Vert.x `RoutingContext` as well as the `form` contents</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x `RoutingContext` の他、 `form` のコンテンツも入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to add a message for the user to let them know everything went fine</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてがうまくいったことを知らせるために、ユーザーにメッセージを追加することを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also add error messages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エラーメッセージを追加することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flash messages are handled by the `main` DEV template and will result in nice notifications for your users:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フラッシュメッセージは `main` DEV テンプレートで処理され、ユーザーへの素敵な通知になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following Quarkus extensions currently support the Dev UI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在、次のQuarkusエクステンションがDev UIをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./cdi[quarkus-arc]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./cdi[quarkus-arc]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./cache[quarkus-cache]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./cache[quarkus-cache]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./container-image[quarkus-container-image]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./container-image[quarkus-container-image]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./deploying-to-openshift[quarkus-openshift]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./deploying-to-openshift[quarkus-openshift]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./flyway[quarkus-flyway]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./flyway[quarkus-flyway]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./liquibase[quarkus-liquibase]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./liquibase[quarkus-liquibase]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./openapi-swaggerui[quarkus-smallrye-openapi]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./openapi-swaggerui[quarkus-smallrye-openapi]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./qute[quarkus-qute]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./qute[quarkus-qute]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./resteasy-reactive[quarkus-resteasy-reactive]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./resteasy-reactive[quarkus-resteasy-reactive]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:./scheduler[quarkus-scheduler]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:./scheduler[quarkus-scheduler]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>MongoDB is a well known NoSQL Database that is widely used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDBは広く使われているNoSQLデータベースとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we see how you can get your REST services to use the MongoDB database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、RESTサービスでMongoDBデータベースを使用する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elements are stored in MongoDB.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>要素はMongoDBに格納されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `mongodb-quickstart` {quickstarts-tree-url}/mongodb-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson, Mutiny, Context Propagation and MongoDB Client extensions.  After this, the quarkus-mongodb-client extension has been added to your `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RS、Jackson、Mutiny、Context Propagation、MongoDBクライアントエクステンションをインポートするMaven構造を生成します。この後、quarkus-mongodb-client エクステンションが `pom.xml` に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `mongodb-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `mongodb-client` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now create a `org.acme.mongodb.FruitService` that will be the business layer of our application and store/load the fruits from the mongoDB database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今、私たちのアプリケーションのビジネス層となる `org.acme.mongodb.FruitService` を作成し、mongoDB データベースからフルーツを保存/ロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, edit the `org.acme.mongodb.FruitResource` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `org.acme.mongodb.FruitResource` クラスを以下のように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add a simple web page to interact with our `FruitResource`.  Quarkus automatically serves static resources located under the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `FruitResource` .Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリーの下にある静的なリソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリーに、この {quickstarts-blob-url}/mongodb-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html]ファイルの内容を含む `fruits.html` ファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive MongoDB Client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブな MongoDB クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A reactive MongoDB Client is included in Quarkus.  Using it is as easy as using the classic MongoDB Client.  You can rewrite the previous example to use it like the following.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブなMongoDBクライアントがQuarkusに含まれています。これを使うのは、古典的なMongoDBクライアントを使うのと同じくらい簡単です。先ほどの例を以下のように書き換えて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.mongodb.ReactiveMongoClient` client is deprecated and will be removed in the future.  It is recommended to switch to the `io.quarkus.mongodb.reactive.ReactiveMongoClient` client providing the `Mutiny` API.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.mongodb.ReactiveMongoClient` クライアントは非推奨であり、将来的には削除される予定です。 `Mutiny` API を提供する `io.quarkus.mongodb.reactive.ReactiveMongoClient` クライアントに切り替えることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The MongoDB reactive client uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDB のリアクティブクライアントはMunityのリアクティブ型を使っています。 link:getting-started-reactive#mutiny[Reactive入門ガイド]を先にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can use https://tika.apache.org/[Apache Tika] to parse the documents.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus アプリケーションが link:https://tika.apache.org/[Apache Tika] を使用してドキュメントを解析する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://tika.apache.org/[Apache Tika] is a content analysis toolkit which is used to parse the documents in PDF, Open Document, Excel and many other well known binary and text formats using a simple uniform API. Both the document text and properties (metadata) are available once the document has been parsed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://tika.apache.org/[Apache Tika] はコンテンツ分析ツールキットで、シンプルな統合 API を使した PDF、Open Document、Excel やその他多くのよく知られたバイナリーやテキスト形式の文書解析に使われます。文書のテキストとプロパティー (メタデータ) の両方が、文書が解析されると利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `tika` and `resteasy` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、`tika` と `resteasy` のエクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured you can add the `tika` and `resteasy` extensions to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで、次のコマンドを実行することで、 `tika` と `resteasy` のエクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the generated JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたJAX-RS リソースを調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/tika/TikaParserResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/tika/TikaParserResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.tika;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.tika;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next update `TikaParserResource` to accept and parse PDF and OpenDocument format documents:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に `TikaParserResource` を更新して、PDF および OpenDocument 形式の文書を受け入れて解析するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        return text;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        return text;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see the JAX-RS resource method was renamed to `extractText`, `@GET` annotation was replaced with `POST` and `@Path(/text)` annotation was added, and `@Consumes` annotation shows that PDF and OpenDocument media type formats can now be accepted. An injected `TikaParser` is used to parse the documents and report the extracted text. It also measures how long does it take to parse a given document.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご覧のように、JAX-RS のリソースメソッドの名前が `extractText` に変更され、`@GET` アノテーションが `POST` に置き換わり、`@Path(/text)` アノテーションが追加されました。また、`@Consumes` アノテーションでは、PDF と OpenDocument のメディアタイプのフォーマットが受け入れられるようになったことが示されています。注入された `TikaParser` は、文書を解析し、抽出されたテキストを報告するために使用されます。また、指定の文書の解析に要する時間を測定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the REST endpoint is running, we can get it to parse PDF and OpenDocument documents using a command line tool like curl:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST エンドポイントが実行されているので、curl のようなコマンドラインツールを使用して PDF や OpenDocument ドキュメントを解析することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command `./mvnw package -Pnative`.  Running it is as simple as executing `./target/tika-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常のコマンド `./mvnw package -Pnative` でネイティブの実行ファイルをビルドできます。`./target/tika-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can connect to a Redis server using the Redis Client extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがRedisクライアントエクステンションを使用してRedisサーバーに接続する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A running Redis server, or Docker Compose to start one</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行中のRedisサーバー、または1つ起動するためのDocker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.  Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:https://redis.io/commands/incrby[`INCRBY`] コマンドを使用して、数値をインクリメントするシンプルな Rest API を公開します。また、 `GET` 、 `SET` 、 `DEL` 、 、 `KEYS` のような他の Redis コマンドの使い方も見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll be using the Quarkus Redis Client extension to connect to our Redis Server. The extension is implemented on top of the https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis Client], providing an asynchronous and non-blocking way to connect to Redis.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回は、Quarkus Redis Clientエクステンションを使用して、Redisサーバーに接続します。このエクステンションは link:https://vertx.io/docs/vertx-redis-client/java/[Vert.x Redis Client] の上に実装されており、非同期かつノンブロッキングでRedisに接続する方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the Redis extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RedisエクステンションをインポートしてMavenプロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `redis-client` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `redis-client` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, we need to start a Redis instance (if you do not have one already) using the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、以下のコマンドを使用してRedisインスタンスを起動する必要があります(すでにインスタンスを持っていない場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once we have the Redis server running, we need to configure the Redis connection properties.  This is done in the `application.properties` configuration file. Edit it to the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Redis サーバーを起動したら、Redis 接続のプロパティーを設定する必要があります。これは `application.properties` の設定ファイルで行います。以下の内容に編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>接続先のRedisホストを設定します。ここでは、前のセクションで開始したRedisサーバーに接続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment POJO</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インクリメントPOJOの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.  Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Increment` POJO を使用してインクリメントをモデル化します。 `src/main/java/org/acme/redis/Increment.java` ファイルを作成し、以下の内容で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Increment Resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インクリメントリソースの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/java/org/acme/redis/IncrementResource.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modifying the test class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `src/test/java/org/acme/redis/IncrementResourceTest.java` file to the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/test/java/org/acme/redis/IncrementResourceTest.java` ファイルを以下の内容に編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指示に従えば、Redisサーバーが起動しているはずです。あとは、アプリケーションを使って実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open another terminal and run the `curl http://localhost:8080/increments` command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のターミナルを開いて `curl http://localhost:8080/increments` コマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションとの相互作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new increment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいインクリメントの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the above command should return the result below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のコマンドを実行すると、以下のような結果が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See current increments keys</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のインクリメントキーの確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the list of current increments keys, run the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のインクリメントキーのリストを表示するには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The above command should return `["first"]` indicating that we have only one increment thus far.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のコマンドは `["first"]` を返し、これまでのところインクリメントが 1 つしかないことを示しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve a new increment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいインクリメントの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To retrieve an increment using its key, we will have to run the below command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キーを使ってインクリメントを取得するには、以下のコマンドを実行する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running this command, should return the following result:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドを実行すると、以下のような結果が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To increment a value, run the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値をインクリメントするには、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Increment the `first` value by 27.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`first` の値を 27 増やします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments/first` should return the following result:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、コマンドを実行すると `curl http://localhost:8080/increments/first` は次のような結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deleting a key</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キーの削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the command below, to delete an increment given its key.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インクリメントのキーを指定して削除するには、以下のコマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the `first` increment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`first` のインクリメントを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we will need to package it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、パッケージ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the build is finished, you can run the executable with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドが完了したら、実行ファイルを次のように実行することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-smallrye-health` extension, `quarkus-vertx-redis` will automatically add a readiness health check to validate the connection to the Redis server.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-health` エクステンションを使用している場合、 `quarkus-vertx-redis` は、Redis サーバーへの接続を検証するためのreadiness ヘルスチェックを自動的に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This behavior can be disabled by setting the `quarkus.redis.health.enabled` property to `false` in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、 `application.properties` の `quarkus.redis.health.enabled` プロパティーを `false` に設定することで無効にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis Clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の Redis クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis extension allows you to configure multiple clients.  Using several clients works the same way as having a single client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Redis エクステンションを使用すると、複数のクライアントを設定することができます。複数のクライアントを使用しても、単一のクライアントを持つのと同じように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key (the `second` segment).  The syntax is as follows: `quarkus.redis.[optional name.][redis configuration property]`.  If the name is omitted, it configures the default client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キー ( `second` セグメント) に余分なビットがあることに注意してください。構文は次の通りです: `quarkus.redis.[optional name.][redis configuration property]` .名前を省略した場合、デフォルトのクライアントを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Named Redis client Injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前付きRedisクライアントのインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using multiple clients, you can select the client to inject using the `io.quarkus.redis.client.RedisClientName` qualifier.  Using the above properties to configure three different clients, you can also inject each one as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のクライアントを使用する場合は、 `io.quarkus.redis.client.RedisClientName` の修飾子を使用して注入するクライアントを選択することができます。上記のプロパティーを使って3つの異なるクライアントを設定すると、以下のようにそれぞれにインジェクションすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the application to a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをネイティブ実行ファイルにコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the native executable in a container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのコンテナーへのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのデバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、 link:getting-started[入門ガイド] で開発されたアプリケーションを入力としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブな実行可能ファイルをビルドするには、GraalVM のディストリビューションを使用する必要があります。ディストリビューションは3つあります。Oracle GraalVM Community Edition (CE)、Oracle GraalVM Enterprise Edition (EE)、そして Mandrel です。Oracle ディストリビューションと Mandrel ディストリビューションの違いは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは、Oracle GraalVM CEのダウンストリームディストリビューションです。Mandrelの主な目的は、Quarkusをサポートするために特別に設計されたネイティブ実行可能ファイルを構築する方法を提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrel のリリースは、アップストリームのOracle GraalVM CEコードベースから派生したコードベースから構築されており、わずかな変更しか行われていませんが、Quarkusネイティブアプリには必要ない重要な除外事項がいくつかあります。これらのリリースは、Oracle GraalVM CEと同じ機能をサポートしており、機能に大きな変更はありません。特筆すべきは、多言語プログラミングのサポートが含まれていないことです。これらの除外の理由は、大多数のQuarkusユーザーにより良いレベルのサポートを提供するためです。また、これらの除外は、Oracle GraalVM CE/EEと比較して、Mandrelの配布サイズが大幅に縮小されていることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは、標準のOpenJDKプロジェクトを使用して、Oracle GraalVM CEとは少し違った形で構築されています。これは、Oracleが独自のGraalVMダウンロードを構築するために使用するOpenJDKのバージョンに追加したいくつかの小さなエクステンションから利益を得られないことを意味します。アップストリームのOpenJDKはそれらを管理しておらず、保証することができないため、このような機能強化は省略されています。これは、規格適合性とセキュリティーに関しては特に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは現在のところ、Linuxのコンテナー化された環境をターゲットとしたネイティブ実行ファイルの構築にのみ推奨されています。つまり、Mandrelユーザーはコンテナーを使用してネイティブ実行ファイルを構築する必要があります。もしmacOSやWindowsをターゲットにしたプラットフォーム用のネイティブ実行ファイルをビルドする場合、Mandrelは現在これらのプラットフォームをターゲットにしていないため、代わりにOracle GraalVMを使用することを検討すべきです。ベアメタルのLinux上で直接ネイティブ実行ファイルをビルドすることも可能ですが、詳細は https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[rel README]と https://github.com/graalvm/mandrel/releases[Mandrelのリリース]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prerequisites vary slightly depending on whether you are using Oracle GraalVM CE/EE or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前提条件は、Oracle GraalVM CE/EEを使用しているか、Mandrelを使用しているかによって若干異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Java 11 version of GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11 バージョンのGraalVMをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Oracle GraalVM is available for both Java 8 and Java 11 (Mandrel only supports Java 11), Quarkus only works with the Java 11 version.  If you use the Oracle distribution, make sure to install the Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Oracle GraalVM はJava 8とJava 11の両方に対して存在しますが (Mandrel はJava 11のみをサポート)、Quarkus Java 11でのみ動作します。Oracleのディストリビューションを使用する場合は、Java 11をインストールするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11 installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK 11 がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker, podman)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動作するコンテナーランタイム(Docker, podman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:getting-started[入門ガイド]で開発したアプリケーションのコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to &lt;&lt;#container-runtime,this section&gt;&gt; to continue with the guide for Mandrel, and follow the Mandrel-specific instructions in that section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この &lt;&lt;#container-runtime, セクション&gt;&gt;をスキップして、 Mandrel のガイドを続行し、そのセクションの Mandrel 固有の指示に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A xref:configuring-c-development[working C development environment]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>xref:configuring-c-development[動作するC言語の開発環境]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM version {graalvm-version} (be sure to install the Java 11 support) installed and xref:configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM のバージョン {graalvm-version} (必ずJava 11 のサポートをインストールしてください)がインストールされ、 #configuring-graalvm[適切に設定されていること]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does having a working C developer environment mean?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動作するC言語の開発環境があるとはどういう意味でしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Linuxでは、GCC、glibc、zlibヘッダが必要です。一般的なディストリビューションでは次の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XCode provides the required dependencies on macOS:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS では、XCode が必要な依存関係を提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Windowsの場合は、 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools] をインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMをインストールできない場合は、マルチステージのDockerビルドを使用して、GraalVMを含むDockerコンテナー内でMavenを実行することができます。このガイドの最後にこれを行う方法の説明があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required. Using the community edition is enough.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Version {graalvm-version} が必要です。コミュニティエディションで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM (pick the java 11 version) if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだの場合は、GraalVM(のJava 11バージョン)をインストールしてください。いくつかポイントがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォーム固有の方法を用いてください: https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate Community Edition archive from &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.  Make sure to download and install at Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>適切なコミュニティエディションのアーカイブを &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt; からダウンロードし、他のJDK同様に解凍して下さい。Java 11バージョンをダウンロードしてインストールするようにして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイム環境を構成します。 `GRAALVM_HOME` 環境変数をGraalVMインストールディレクトリーに設定します。例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOSでは、変数を `Home`  サブディレクトリーに指定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will have to go through the Control Panel to set your environment variables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Windowsでは、コントロールパネルから環境変数を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing via scoop will do this for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>scoop でインストールすれば自動的に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gu install`  を使用して `native-image`  ツールをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの以前のリリースでは、デフォルトで `native-image`  ツールが含まれていました。現在はそのようになっておらず、GraalVM自体をインストールした後の第二ステップとしてインストールする必要があります。注意: #graal-and-catalina[macOS CatalinaでGraalVMを使用する]際に、未解決の問題が発生しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(オプション) 環境変数 `JAVA_HOME`  を GraalVM のインストールディレクトリーに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(オプション) GraalVM `bin`  ディレクトリーをパスに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues using GraalVM with macOS Catalina</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS CatalinaでGraalVMを使用している場合の問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この https://github.com/oracle/graal/issues/1724[GraalVMの問題]で報告されているように、GraalVMバイナリーは(まだ)macOS Catalinaに対して認証されていません。これは、`gu` 使用時に次のエラーが表示される可能性があることを意味します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>回避策として、次のコマンドを使用して、GraalVMインストールディレクトリー上の `com.apple.quarantine` 拡張属性を再帰的に削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のセクションの手順に従って、アプリケーションを段階的にパッケージ化することをお勧めします。しかしながら、完成したサンプルに直接進むこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started` ディレクトリーに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのネイティブ実行ファイルには、アプリケーション・コード、必要なライブラリ、Java API、および VM の縮小版が含まれます。VM ベースが小さくなることで、アプリケーションの起動時間が改善され、ディスクフットプリントが最小限に抑えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:native-executable-process.png[Creating a native executable]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:native-executable-process.png[ネイティブ実行ファイルの生成]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前回のチュートリアルでアプリケーションを生成した場合は、 `pom.xml` に以下の _プロファイル_ があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`&lt;quarkus.native.additional-build-args&gt;` プロパティーを使用して、 `native-image` コマンドにカスタムオプションを指定できます。複数のオプションはカンマで区切ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つの可能性は、 `application.properties` に `quarkus.native.additional-build-args` 設定プロパティーを含めることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the &lt;&lt;configuration-reference&gt;&gt; section below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージビルド処理の設定方法については、以下の &lt;&lt;設定リファレンス&gt;&gt; の項で詳しく説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルを使用しているのは、すぐにわかると思いますが、ネイティブの実行ファイルをパッケージ化するのに _数_ 分かかるからです。コマンドラインのプロパティーとして -Dquarkus.package.type=native を渡すだけでもいいのですが、プロファイルを使う方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative`  を使用してネイティブ実行ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At `x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Visual Studio の Microsoft Native Tools はパッケージングを行う前に、初期化する必要があります。これは、Visual Studio ビルドツールと一緒にインストールされた `x64 Native Tools Command Prompt`  を起動することで行うことができます。 `x64 Native Tools Command Prompt` で、プロジェクト・フォルダーに移動して `mvnw package -Pnative` を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to write a script to do this for you:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つのソリューションは、これを行うためのスクリプトを書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常のファイルに加えて、このビルドでは `target/getting-started-1.0-SNAPSHOT-runner` を生成します。これを実行するには、次のようにします: `./target/getting-started-1.0-SNAPSHOT-runner` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブな実行ファイルを生成することはいくつかの問題を引き起こす可能性があるので、ネイティブファイルで実行されているアプリケーションに対していくつかのテストを実行するのも良いアイデアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file, the `native` profile contains:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml`  ファイルには、 `native`  プロファイルが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、failsaf-maven-plugin が integration-test を実行するように指示し、生成されたネイティブ実行ファイルの場所を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`  を開きます。次の内容が含まれています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの前にネイティブ ファイルからアプリケーションを起動する別のテスト ランナーを使用します。実行ファイルは、 _Failsafe Maven プラグイン_ で構成された `native.image.path`  システム プロパティーを使用して取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests, but you can also implement your tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のテストを extend していますが、自分でテストを実装することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `NativeGreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`NativeGreetingResourceIT`  がネイティブ実行ファイルに対して実行されているのを見るには、 `./mvnw verify -Pnative` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはネイティブテストを開始し、自動的に失敗するまでに60秒待機します。この時間は、 `quarkus.test.native-image-wait-time`  システムプロパティーを使用して変更できます。たとえば、待機時間を300秒に増やすには、 `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、ネイティブテストは `prod`  プロファイルを使用して実行されます。これは `quarkus.test.native-image-profile`  プロパティーを使用して上書きすることができます。たとえば、 `application.properties`  ファイルに `quarkus.test.native-image-profile=test`  を追加します。あるいは、次のようにしてテストを実行することもできます: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` .ただし、ネイティブの実行ファイルがビルドされたときに `prod`  プロファイルが有効になっていることを忘れないでください。したがって、この方法で有効にしたプロファイルは、生成された実行ファイルと互換性がなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excluding tests when running as a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルとして実行している場合のテストの除外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法でテストを実行する場合、実際にネイティブで実行されるのはアプリケーションのエンドポイントのみで、HTTP 呼び出しでしかテストできません。テストコードは実際にはネイティブには実行されないので、HTTP エンドポイントを呼び出さないコードをテストしている場合は、ネイティブテストの一部として実行するのは良い考えではないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のようにJVMとネイティブ実行でテストクラスを共有している場合、特定のテストをJVM上でのみ実行するために、 `@DisabledOnNativeImage`  アノテーションを付けておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing an existing native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにビルドされているネイティブ実行ファイルに対してテストを再実行することも可能です。これを行うには `./mvnw test-compile failsafe:integration-test`  を実行してください。これにより、既存のネイティブイメージが検出され、フェイルセーフを使用してそれに対してテストが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何らかの理由でプロセスがネイティブイメージを見つけられない場合や、ターゲットディレクトリーにないネイティブイメージをテストしたい場合は、 `-Dnative.image.path=`  システムプロパティーで実行ファイルを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先に進む前に、コンテナーランタイム(Docker、podman)の動作環境が整っていることを確認しておきましょう。WindowsでDockerを使用している場合は、Docker Desktopのファイル共有設定でプロジェクトのドライブを共有し、Docker Desktopを再起動する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの場合、Quarkusアプリケーション用のネイティブLinux実行ファイルを作成する必要があります(例えば、コンテナー化された環境で実行するためなど)、このタスクを達成するために適切なGraalVMバージョンをインストールする手間を省きたいと考えています(例えば、CI環境では、できるだけ少ないソフトウェアをインストールするのが一般的です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このため、Quarkusでは、Dockerやpodmanなどのコンテナーランタイムを利用して、ネイティブのLinux実行ファイルを作成する非常に便利な方法を提供しています。このタスクを達成する最も簡単な方法は、次を実行することです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.  If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはコンテナーランタイムを自動的に検出します。コンテナーランタイムを明示的に選択したい場合は、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは通常のQuarkusの設定プロパティーなので、常にコンテナーでビルドしたい場合は、毎回指定しなくて済むように、 `application.properties`  に追加することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のコマンドはフローティングタグを指していることに注意してください。ビルダーイメージを最新かつ安全に保つために、フローティングタグを使用することを強く推奨します。どうしても必要な場合は、特定のタグをハードコーディングしても構いませんが(利用可能なタグについては https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[こちら]を参照してください)、その方法ではセキュリティーアップデートが受けられず、サポートされていないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the container-image extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージのエクステンションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションからコンテナーイメージを作成する最も簡単な方法は、コンテナーイメージ エクステンションの1つを利用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのエクステンションのいずれかが存在する場合、ネイティブ実行ファイル用のコンテナーイメージを作成することは、基本的には単一のコマンドを実行することになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.container-build=true`  では GraalVM がインストールされていなくても Linux の実行ファイルを作成することができます(ローカルに GraalVM がインストールされていない場合や、ローカルのオペレーティングシステムが Linux ではない場合にのみ必要です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.container-image.build=true`  最終的なアプリケーションアーティファクト(この場合はネイティブの実行ファイル)を使用してコンテナーイメージを作成するようにQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:container-image[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:container-image[コンテナーイメージガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>手動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Mavenプラグインで生成されたJARを使用して、コンテナー内でアプリケーションを実行することができます。ただし、このセクションでは、生成されたネイティブ実行ファイルを使用してコンテナーイメージを作成することに焦点を当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:containerization-process.png[Containerization Process]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:containerization-process.png[alt="Containerization Process"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ローカルのGraalVMインストール環境を使用する場合、ネイティブの実行ファイルは、ローカルのオペレーティングシステム(Linux、macOS、Windowsなど)をターゲットにしています。しかし、コンテナーはオペレーティングシステムによって生成されたものと同じ _実行_ 形式を使用しない場合があるため、コンテナーランタイムを活用して実行形式を生成するようにMavenビルドに指示します(この &lt;&lt;#container-runtime, セクション&gt;&gt; で説明されているように)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成される実行ファイルは64ビットのLinux実行ファイルになりますので、お使いのOSによっては実行できなくなる可能性があります。しかし、コンテナーにコピーするので問題ありません。プロジェクト生成では、 `src/main/docker`  ディレクトリーに `Dockerfile.native`  を用意し、以下のような内容にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ubi?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Ubi?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided `Dockerfiles` use https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI] (Universal Base Image) as parent image.  This base image has been tailored to work perfectly in containers.  The `Dockerfiles` use the https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version] of the base image to reduce the size of the produced image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>提供されている `Dockerfiles`  は親イメージとして https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI](Universal Base Image) を使用しています。このベースイメージはコンテナー内で完全に動作するように調整されています。 `Dockerfiles`  では、生成されるイメージのサイズを小さくするためにベースイメージの https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_最小_バージョン]を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI on:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>UBIについての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, if you didn't delete the generated native executable, you can build the docker image with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あとは、生成されたネイティブ実行ファイルを削除していなければ、dockerイメージを使ってビルドします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして最後に、以下を実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in tiny Docker images, check the {quarkus-images-url}/master/distroless[distroless] version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>小さなDockerイメージに興味がある方は、{quarkus-images-url}/master/distroless[distroless] 版をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a multi-stage Docker build</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチステージDockerビルドの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven, but implicitly required that the proper GraalVM version be installed on the building machine (be it your local machine or your CI/CD infrastructure).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のセクションでは、Mavenを使用してネイティブ実行ファイルをビルドする方法を示しましたが、適切なGraalVMバージョンがビルドマシン(ローカルマシンまたはCI/CDインフラストラクチャ)にインストールされていることが暗黙のうちに要求されていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In cases where the GraalVM requirement cannot be met, you can use Docker to perform the Maven or Gradle build by using a multi-stage Docker build. A multi-stage Docker build is like two Dockerfile files combined in one, the first is used to build the artifact used by the second.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの要件を満たすことができない場合は、Dockerを使ってマルチステージDockerビルドを利用してMavenやGradleのビルドを行うことができます。マルチステージDockerビルドとは、2つのDockerfileファイルを1つにまとめたようなもので、1つ目は2つ目で使用するアーティファクトをビルドするために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will use the first stage to generate the native executable and the second stage to create our runtime image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、第一段階でネイティブ実行ファイルを生成し、第二段階でランタイムイメージを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Maven:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MavenでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルは、Getting started quickstartには含まれていないので、 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Gradle:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GradleでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトでGradleを使用している場合は、このサンプルDockerfileを使用することができます。 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory and as we plan to build inside a container we need to be able to copy the `src` directory. So edit your `.dockerignore` and remove or comment its content.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dockerビルドを起動する前に、デフォルトの `.dockerignore`  ファイルを更新する必要があります。 `target`  ディレクトリー以外は全てフィルタリングされ、コンテナー内でビルドする予定なので、 `src`  ディレクトリーをコピーできるようにする必要があります。そのため、 `.dockerignore`  を編集して、その内容を削除するかコメントしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルにSSLサポートが必要な場合は、Dockerイメージに必要なライブラリを簡単に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:native-and-ssl#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳しくは native-and-ssl#working-with-containers[ネイティブ実行可能ファイルでのSSL利用ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Oracle GraalVM 20.2またはMandrel 20.1から、Linux環境用にネイティブ実行ファイルのデバッグシンボルを生成できるようになりました(Windowsのサポートはまだ開発中です)。これらのシンボルは、 `gdb`  のようなツールを使用してネイティブ実行ファイルをデバッグするために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグシンボルを生成するには、ネイティブ実行ファイルの生成時に `-Dquarkus.native.debug.enabled=true`  フラグを追加してください。ネイティブ実行ファイルのデバッグシンボルは、ネイティブ実行ファイルの隣にある `.debug`  ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions and macOS you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`.debug`  ファイルの生成は `objcopy`  に依存します。一般的な Linux ディストリビューションや macOS では、 `binutils`  パッケージをインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `objcopy` is not available debug symbols are embedded in the executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`objcopy`  が利用できない場合、デバッグシンボルが実行ファイルに埋め込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグシンボルとは別に、 `-Dquarkus.native.debug.enabled=true`  フラグを設定すると、ネイティブ実行ファイル生成時に解決された JDK ランタイムクラス、GraalVM クラス、アプリケーションクラスのソースファイルのキャッシュが生成されます。このソースキャッシュは、シンボルと一致するソースコード間のリンクを確立するために、ネイティブデバッグツールにとって有用です。ネイティブ実行ファイルをデバッグする際に、必要なソースだけをデバッガー/IDEが利用できるようにする便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのソースコードを含むサードパーティのjar依存関係のソースは、デフォルトではソースキャッシュに追加されません。これらを含めるには、まず `mvn dependency:sources`  を起動してください。このステップは、これらの依存関係のソースを引き出し、ソースキャッシュに含めるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースキャッシュは `target/sources`  フォルダーにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If running `gdb` from a different directory than `target`, then the sources can be loaded by running:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gdb`  を `target`  とは異なるディレクトリーから実行している場合、ソースは以下を</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `gdb`  プロンプトで実行することで読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or start `gdb` with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、 `gdb`  を以下のように起動してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Native Executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの生成方法に影響を与える設定オプションがたくさんあります。これらは他の設定プロパティーと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アプリケーション用のネイティブ(バイナリー)実行ファイルの作成について説明しました。これにより、迅速な起動時間と少ないメモリー消費を示すアプリケーションを提供します。しかし、それだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the link:deploying-to-kubernetes[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:deploying-to-kubernetes[KubernetesとOpenShiftへのデプロイ]で探検を続けることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus allows different beans to interact using asynchronous events, thus promoting loose-coupling.  The messages are sent to _virtual addresses_.  It offers 3 types of delivery mechanism:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、異なる Bean が非同期イベントを使用して相互作用することができるため、疎結合化が促進されます。メッセージは _仮想アドレス_ に送信されます。3種類の配信メカニズムを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round robin is applied;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>point-to-point - メッセージを送信し、1 つのコンシューマがそれを受信します。複数のコンシューマがアドレスをリスンしている場合、ラウンドロビンが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>publish/subscribe - publish a message, all the consumers listening to the address are receiving the message;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>publish/subscribe - メッセージをパブリッシュし、アドレスをリスンしているすべてのコンシューマがメッセージを受信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous-fashion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>request/reply - メッセージを送信し、応答を待ちます。受信者は非同期的にメッセージに応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All these delivery mechanism are non-blocking, and are providing one of the fundamental brick to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの配信メカニズムはすべてノンブロッキングであり、リアクティブアプリケーションを構築するための基本的なブロックの1つを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The asynchronous message passing feature allows replying to messages which is not supported by Reactive Messaging.  However, it is limited to single-event behavior (no stream) and to local messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期メッセージパッシング機能は、Reactive Messagingではサポートされていないメッセージへの返信を可能にします。ただし、シングルイベント動作(ストリームなし)とローカルメッセージに限定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` extension to use this feature.  If you are creating a new project, set the `extensions` parameter are follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この仕組みはVert.x EventBusを利用しているので、この機能を利用するには `vertx` エクステンションを有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメーターを以下のように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントのコンシューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントをコンシュームするには、 `io.quarkus.vertx.ConsumeEvent` アノテーションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not set, the address is the fully qualified name of the bean, for instance, in this snippet it's `org.acme.vertx.GreetingService`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定されていない場合、アドレスは Bean の完全修飾名となり、例えばこのスニペットでは `org.acme.vertx.GreetingService` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter is the message body. If the method returns _something_ it's the message response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドのパラメーターはメッセージ本体です。メソッドが _何か_ を返す場合は、それがメッセージのレスポンスになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the code consuming the event must be _non-blocking_, as it's called on the Vert.x event loop.  If your processing is blocking, use the `blocking` attribute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Vert.x イベントループで呼び出されるため、イベントをコンシュームするコードは _ノンブロッキング_ でなければなりません。処理がブロッキングである場合は、 `blocking` 属性を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can annotate your method with `@io.smallrye.common.annotation.Blocking`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、メソッドに `@io.smallrye.common.annotation.Blocking` と注釈を付けることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using `@Blocking`, it ignores the value of the `blocking` attribute of `@ConsumeEvent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Blocking` を使用する場合、 `@ConsumeEvent` の `blocking` 属性の値は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous processing is also possible by returning either an `io.smallrye.mutiny.Uni` or a `java.util.concurrent.CompletionStage`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.smallrye.mutiny.Uni` または `java.util.concurrent.CompletionStage` のどちらかを返すことで、非同期処理も可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous example uses Mutiny reactive types, if you're not familiar with them, we recommend reading the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の例では Mutiny リアクティブタイプを使用していますが、もしよく知らないのであれば、 link:getting-started-reactive#mutiny[Reactive の入門ガイド] を読むことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the address</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アドレスの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@ConsumeEvent` annotation can be configured to set the address:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConsumeEvent` アノテーションでアドレスを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Receive the messages sent to the `greeting` address</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`greeting` アドレスに送信されたメッセージを受信する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Replying</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>応答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _return_ value of a method annotated with `@ConsumeEvent` is used as response to the incoming message.  For instance, in the following snippet, the returned `String` is the response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConsumeEvent` でアノテーションされたメソッドの _戻り値_ が、着信メッセージに対するレスポンスとして使用されます。例えば、次のスニペットでは、 `String` がレスポンスとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also return a `Uni&lt;T&gt;` or a `CompletionStage&lt;T&gt;` to handle asynchronous reply:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `Uni&lt;T&gt;` や `CompletionStage&lt;T&gt;` を返すことで、非同期応答を扱うこともできます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can inject an `executor` if you use the Context Propagation extension:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Context Propagation エクステンションを使えば、 `executor` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing fire and forget interactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>fire and forget インタラクションの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to reply to received messages.  Typically for a _fire and forget_ interaction, the messages are consumed and the sender does not need to know about it.  To implement this, your consumer method just returns `void`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信したメッセージに返信する必要はありません。通常、 _fire and forget_ インタラクションでは、メッセージはコンシュームされ、送信者はそれについて知る必要はありません。これを実装するには、 consumer メソッドは `void` を返すだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, this mechanism is based on the Vert.x event bus. So, you can also use `Message` directly:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上でも述べたように、この仕組みはVert.xイベントバスをベースにしています。なので、直接 `Message` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending messages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ok, we have seen how to receive messages, let's now switch to the _other side_: the sender.  Sending and publishing messages use the Vert.x event bus:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、メッセージを受信する方法を見てきましたが、次は送信者 _側_ に切り替えましょう。メッセージの送信とパブリッシュは Vert.x イベントバスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Event bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントバスのインジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send a message to the address `greeting`. Message payload is `name`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アドレス `greeting` にメッセージを送信。メッセージのペイロードは `name`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `EventBus` object provides methods to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EventBus` オブジェクトは、以下のメソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`send` a message to a specific address - one single consumer receives the message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`send` 特定のアドレスへのメッセージ - 一人のコンシューマーがメッセージを受信する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`publish` a message to a specific address - all consumers receive the messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`publish` 特定のアドレスにメッセージを送る - すべてのコンシューマーがメッセージを受け取る。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Putting things together - bridging HTTP and messages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>物事をまとめる - HTTPとメッセージのブリッジング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.  It uses the request/reply dispatching mechanism.  Instead of implementing the business logic inside the JAX-RS endpoint, we are sending a message.  This message is consumed by another bean and the response is sent using the _reply_ mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>greeting HTTP エンドポイントを再訪し、非同期メッセージパッシングを使用して分離された Bean に呼び出しを委譲してみましょう。リクエスト/レスポンスディスパッチの仕組みを利用しています。JAX-RS エンドポイント内にビジネスロジックを実装する代わりに、メッセージを送信しています。このメッセージは別の Bean によってコンシュームされ、応答は _返信_  機構を使用して送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First create a new project using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、新しいプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can already start the application in _dev mode_ using `./mvnw compile quarkus:dev`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` を実行すると、自動的に _開発者モード_ でアプリケーションを起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, creates a new JAX-RS resource with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、以下の内容の JAX-RS リソースを新規に作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>send the `name` to the `greeting` address and request a response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`greeting` アドレスに  `name`  を送信し、レスポンスを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>when we get the response, extract the body and send it to the user</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスを取得したら、ボディを抽出してユーザーに送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you call this endpoint, you will wait and get a timeout. Indeed, no one is listening.  So, we need a consumer listening on the `greeting` address. Create a `GreetingService` bean with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエンドポイントを呼び出すと、しばらく待ってからタイムアウトになります。実際、誰もリスンしていません。そこで、 `greeting` アドレスをリスンするコンシューマーが必要です。以下の内容の `GreetingService` Bean を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean receives the name, and returns the greeting message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この Bean は name を受け取り、 greeting メッセージを返します.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, open your browser to http://localhost:8080/async/Quarkus, and you should see:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、ブラウザで http://localhost:8080/async/Quarkus を開くと、以下が表示されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To better understand, let's detail how the HTTP request/response has been handled:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より理解しやすくするために、HTTP リクエスト/レスポンスがどのように処理されたかを詳しく見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request is received by the `hello` method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストは `hello` メソッドが受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a message containing the _name_ is sent to the event bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_name_ を含むメッセージがイベントバスに送信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another bean receives this message and computes the response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の Bean がこのメッセージを受信して、レスポンスを計算します.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This response is sent back using the reply mechanism</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このレスポンスは、応答機構を使用して返信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the reply is received by the sender, the content is written to the HTTP response</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信者が応答を受信すると、HTTP レスポンスに内容が書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application can be packaged using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションは、以下の方法でパッケージングできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also compile it as a native executable with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下でネイティブ実行ファイルとしてコンパイルすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using codecs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コーデックを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default codec for local delivery.  So you can exchange objects as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert.xイベントバス] では、コーデックを使用してオブジェクトの _シリアライズ_ と _デシリアライズ_ を行います。Quarkusでは、ローカル配信用のデフォルトのコーデックを提供しています。そのため、以下のようにオブジェクトを交換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use a specific codec, you need to explicitly set it on both ends:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のコーデックを使用したい場合は、両サイドで明示的に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the name of the codec to use to send the message</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージの送信に使用するコーデックの名前を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set the codec to use to receive the message</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージの受信に使用するコーデックを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  In this guide, you learn how to schedule periodic clustered tasks using the http://www.quartz-scheduler.org/[Quartz] extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があることがよくあります。このガイドでは、 link:http://www.quartz-scheduler.org/[Quartz] エクステンションを使用して定期的にクラスター化されたタスクをスケジュールする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you only need to run in-memory scheduler use the link:scheduler[Scheduler] extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インメモリースケジューラーを実行する必要がある場合は、 link:scheduler[Scheduler] エクステンションを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we are going to expose one Rest API `tasks` to visualise the list of tasks created by a Quartz job running every 10 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、10秒ごとに実行されるQuartzジョブによって作成されたタスクのリストを可視化するために、1つのRest API `tasks` を公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `quartz-quickstart` {quickstarts-tree-url}/quartz-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `quartz-quickstart` {quickstarts-tree-url}/quartz-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.quartz.TaskResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.quartz.TaskResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Maven project also imports the Quarkus Quartz extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MavenプロジェクトはQuarkus Quartzエクステンションもインポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `quartz` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `quartz` エクステンションを追加することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use a JDBC store, the `quarkus-agroal` extension, which provides the datasource support, is also required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDBCストアを使用するには、データソースのサポートを提供する `quarkus-agroal` エクステンションも必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating the Task Entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タスクエンティティーの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.quartz` package, create the `Task` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.quartz` パッケージで、以下の内容の `Task` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the entity using link:hibernate-orm-panache[Panache]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:hibernate-orm-panache[Panache] を使用してエンティティーを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.quartz` package, create the `TaskBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.quartz` パッケージで、以下の内容の `TaskBean` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to run this method every 10 seconds and set the unique identifier for this job.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` アノテーションを使用し、このメソッドを10秒ごとに実行し、識別子を付与するようにQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new `Task` with the current start time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の開始時刻で新しい `Task` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Jobs Programmatically</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プログラムによるジョブのスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to leverage the Quartz API directly.  You can inject the underlying `org.quartz.Scheduler` in any bean:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quartz APIを直接利用することも可能です。どのBeanにも、基礎となる `org.quartz.Scheduler` を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the underlying `org.quartz.Scheduler` instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基礎となる `org.quartz.Scheduler` インスタンスを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Schedule a new job using the Quartz API.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quartz APIを使用して新しいジョブをスケジュールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoke the `TaskBean#performTask()` method from the job. Jobs are also link:cdi[container-managed] beans if they belong to a link:cdi-reference[bean archive].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ジョブから `TaskBean#performTask()` メソッドを呼び出します。ジョブは、 link:cdi-reference[Beanアーカイブ] に属している場合、 link:cdi[コンテナー管理された] Beanでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the scheduler is not started unless a `@Scheduled` business method is found. You may need to force the start of the scheduler for "pure" programmatic scheduling. See also &lt;&lt;quartz-configuration-reference&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `@Scheduled` ビジネスメソッドが見つからない限り、スケジューラーは起動されません。純粋なプログラムによるスケジューリングを行うには、スケジューラーを強制的に起動させる必要があるかもしれません。 link:#quartz-configuration-reference[Quartz-configuration-reference] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the below configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` ファイルを編集し、以下の設定を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that the scheduler will be run in clustered mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラーがクラスターモードで実行されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the database store to persist job related information so that they can be shared between nodes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースストアを使用してジョブ関連情報を永続化し、ノード間で共有できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `TaskResource` class, and update the content to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`TaskResource` クラスを編集して、内容を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Retrieve the list of created tasks from the database</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>作成されたタスクのリストをデータベースから取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `TaskResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストも更新する必要があります。 `TaskResourceTest` クラスを一致するように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that we have a `200` response and at least one task created</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`200` のレスポンスが返却されていることと、少なくとも 1 つのタスクが作成されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a SQL migration file named `src/main/resources/db/migration/V2.0.0\__QuarkusQuartzTasks.sql` with the content copied from file with the content from link:{quickstarts-blob-url}/quartz-quickstart/src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql[V2.0.0__QuarkusQuartzTasks.sql].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:{quickstarts-blob-url}/quartz-quickstart/src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql[V2.0.0.0__QuarkusQuartzTasks.sql] からコピーした内容でファイルからコピーした内容で `src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql` という名前のSQLマイグレーションファイルを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the load balancer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロードバランサーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the root directory, create a `nginx.conf` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートディレクトリーに、以下の内容の `nginx.conf` ファイルを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Route all traffic to our tasks application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのトラフィックをタスクアプリケーションにルーティング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting Application Deployment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションデプロイメントの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the root directory, create a `docker-compose.yml` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートディレクトリーに、以下の内容の `docker-compose.yml` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the tasks service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タスクサービスの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the nginx load balancer to route incoming traffic to an appropriate node</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信トラフィックを適切なノードにルーティングするための nginx ロードバランサーを定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define the configuration to run the database</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースを実行するための設定を定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the database</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separate terminal, run the below command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のターミナルで以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start the database instance using the configuration options supplied in the `docker-compose.yml` file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`docker-compose.yml` ファイルで提供されている設定オプションを使用してデータベースインスタンスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application in Dev Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを開発モードで実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw quarkus:dev`.  After a few seconds, open another terminal and run `curl localhost:8080/tasks` to verify that we have at least one task created.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw quarkus:dev` でアプリケーションを実行します。数秒後、別のターミナルを開き、 `curl localhost:8080/tasks` を実行して、少なくとも 1 つのタスクが作成されていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the application and run several instances</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのパッケージ化と複数のインスタンスの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application can be packaged using `./mvnw clean package`. Once the build is successful, run the below command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは `./mvnw clean package` を使用してパッケージ化することができます。ビルドが成功したら、以下のコマンドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start two instances of the application and a load balancer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションとロードバランサーの2つのインスタンスを起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After a few seconds, in another terminal, run `curl localhost:8080/tasks` to verify that tasks were only created at different instants and in an interval of 10 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数秒後、別のターミナルで `curl localhost:8080/tasks` を実行し、タスクが異なるタイミングで、10秒の間隔でのみ作成されていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's the reponsibility of the deployer to clear/remove the previous state, i.e. stale jobs and triggers. Moreover, the applications that form the "Quartz cluster" should be identical, otherwise an unpredictable result may occur.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の状態、つまり古いジョブやトリガーをクリア/削除するのはデプロイ側の責任です。さらに、"Quartzクラスター"を形成するアプリケーションは同一でなければならず、そうでなければ予測不可能な結果が発生する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering Plugin and Listeners</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラグインとリスナーの登録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can register `plugins`, `job-listeners` and `trigger-listeners` through Quarkus configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの設定から、 `plugins` 、 `job-listeners` 、 `trigger-listeners` を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The example below registers the plugin `org.quartz.plugins.history.LoggingJobHistoryPlugin` named as `jobHistory` with the property `jobSuccessMessage` defined as `Job [{1}.{0}] execution complete and reports: {8}`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の例では、 `org.quartz.plugins.history.LoggingJobHistoryPlugin` という名前のプラグインを `jobHistory` として登録し、プロパティー `jobSuccessMessage` を `Job [{1}.{0}] execution complete and reports: {8}` として定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also register a listener programmatically with an injected `org.quartz.Scheduler`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注入された `org.quartz.Scheduler` でリスナーをプログラムで登録することも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Contexts and Dependency Injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Contexts and Dependency Injection</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution (also called ArC) is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.  However, it is not a full CDI implementation verified by the TCK.  Only a subset of the CDI features is implemented - see also &lt;&lt;supported_features,the list of supported features&gt;&gt; and &lt;&lt;limitations,the list of limitations&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の DI ソリューション (ArC とも呼ばれる) は、link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] 仕様に基づいています。しかし、TCK によって検証された CDI の完全な実装ではありません。CDI 機能のサブセットのみが実装されています。link:#supported_features[サポートされている機能の一覧] と link:#limitations[制限事項の一覧] も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you're new to CDI then we recommend you to read the link:cdi[Introduction to CDI] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI が初めての方は、最初に link:cdi[CDI の紹介] を読むことが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the existing CDI code should work just fine but there are some small differences which follow from the Quarkus architecture and goals.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存の CDI コードのほとんどは問題なく動作するはずですが、Quarkus のアーキテクチャや目標との間には、わずかな相違点がいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean discovery in CDI is a complex process which involves legacy deployment structures and accessibility requirements of the underlying module architecture.  However, Quarkus is using a *simplified bean discovery*.  There is only single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window="_blank"] and no visibility boundaries.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI での Bean 検出は、レガシーなデプロイメント構造と、基礎となるモジュールアーキテクチャーのアクセシビリティ要件を含む複雑なプロセスです。しかし、Quarkusは *簡素化された Bean 検出* を使用しています。link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[Bean 検出モード `annotated`, window="_blank"] と可視性の境界線がない単一の Bean アーカイブのみが存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean archive is synthesized from:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean のアーカイブは、次のものから合成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dependencies that contain a `beans.xml` descriptor (content is ignored),</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`beans.xml` 記述子を含む依存関係 (内容は無視される)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dependencies that contain a Jandex index - `META-INF/jandex.idx`,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jandex インデックスを含む依存関係 (`META-INF/jandex.idx`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dependencies referenced by `quarkus.index-dependency` in `application.properties`,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` の `quarkus.index-dependency` で参照される依存関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and Quarkus integration code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の統合コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window="_blank"] are not discovered.  This behavior is defined by CDI.  But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation (this behavior is different to what is defined in CDI).  In fact, the declaring bean classes are considered annotated with `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[Bean 定義アノテーション, window="_blank"] を持たない Bean クラスは検出されない。この動作は CDI で定義されています。しかし、producer  メソッドやフィールド、observer  メソッドは、宣言クラスが Bean 定義アノテーションを持たない場合でも検出されます (この動作は CDI で定義されているものとは異なります)。実際には、宣言 Bean クラスは `@Dependent` でアノテートされていると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions may declare additional discovery rules. For example, `@Scheduled` business methods are registered even if the declaring class is not annotated with a bean defining annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus エクステンションは、追加のディスカバリールールを宣言することができます。たとえば、`@Scheduled` ビジネスメソッドは、宣言するクラスが Bean 定義アノテーションでアノテーションされていなくても登録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A dependency with a Jandex index is automatically scanned for beans.  To generate the index just add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jandex インデックスを持つ依存関係は、自動的に Bean をスキャンします。インデックスを生成するには、以下を `pom.xml` に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are are using gradle, you can apply the following plugin to your `build.gradle`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gradle を使っている場合は、以下のプラグインを `build.gradle` に適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'org.kordamp.gradle.jandex' version '0.6.0'
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>plugins {
    id 'org.kordamp.gradle.jandex' version '0.6.0'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you can't modify the dependency, you can still index it by adding `quarkus.index-dependency` entries to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係を変更できなくても、`quarkus.index-dependency` エントリーを `application.properties` に追加することでインデックスを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.index-dependency.&lt;name&gt;.group-id=
quarkus.index-dependency.&lt;name&gt;.artifact-id=
quarkus.index-dependency.&lt;name&gt;.classifier=(this one is optional)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.index-dependency.&lt;name&gt;.group-id=
quarkus.index-dependency.&lt;name&gt;.artifact-id=
quarkus.index-dependency.&lt;name&gt;.classifier=(this one is optional)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following entries ensure that the `org.acme:acme-api` dependency is indexed:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、次のエントリーは、`org.acme:acme-api` 依存関係が確実にインデックス化されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example application.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>application.properties の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.index-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.index-dependency.acme.artifact-id=acme-api &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.index-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.index-dependency.acme.artifact-id=acme-api &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value is a group id for a dependency identified by name `acme`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値 `acme` は、名前で識別される依存関係のグループ ID です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value is an artifact id for a dependency identified by name `acme`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値は、名前 `acme` で識別される依存関係のアーティファクト ID です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How To Exclude Types and Dependencies from Discovery</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスカバリーから型と依存関係を除外する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It may happen that some beans from third-party libraries do not work correctly in Quarkus.  A typical example is a bean injecting a portable extension.  In such case, it's possible to exclude types and dependencies from the bean discovery.  The `quarkus.arc.exclude-types` property accepts a list of string values that are used to match classes that should be excluded.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サードパーティーのライブラリーからのいくつかの Bean が Quarkus で正しく動作しないことがあります。典型的な例は、ポータブル拡張機能を注入する Bean です。このような場合は、型や依存関係を Bean の検出から除外することができます。`quarkus.arc.exclude-types` プロパティーは、除外すべきクラスに一致するために使用される文字列値のリストを受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Value Examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.Foo`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.Foo`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the fully qualified name of the class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスの完全修飾名と一致させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.*`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match classes with package `org.acme`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme` パッケージとクラスを一致させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.acme.**`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.**`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match classes where the package starts with `org.acme`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージが `org.acme` で始まるクラスを一致させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the simple name of the class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスのシンプルな名前に一致する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.exclude-types=org.acme.Foo,org.acme.*,Bar &lt;1&gt;&lt;2&gt;&lt;3&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.arc.exclude-types=org.acme.Foo,org.acme.*,Bar &lt;1&gt;&lt;2&gt;&lt;3&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exclude the type `org.acme.Foo`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイプ `org.acme.Foo` を除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exclude all types from the `org.acme` package.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme` パッケージからすべてのタイプを除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Exclude all types whose simple name is `Bar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルな名前が `Bar` であるすべてのタイプを除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to exclude a dependency artifact that would be otherwise scanned for beans.  For example, because it contains a `beans.xml` descriptor.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、除外しなければ Bean をスキャンする、依存関係のあるアーティファクトを除外することも可能です。たとえば、`beans.xml` 記述子を含んでいる場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.exclude-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.arc.exclude-dependency.acme.artifact-id=acme-services &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.arc.exclude-dependency.acme.group-id=org.acme &lt;1&gt;
quarkus.arc.exclude-dependency.acme.artifact-id=acme-services &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executables and Private Members</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルとプライベートメンバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is using GraalVM to build a native executable.  One of the limitations of GraalVM is the usage of https://github.com/oracle/graal/blob/master/substratevm/Limitations.md#reflection[Reflection, window="_blank"].  Reflective operations are supported but all relevant members must be registered for reflection explicitly.  Those registrations result in a bigger native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、GraalVM を使用してネイティブ実行ファイルを構築しています。GraalVM の制限事項の 1 つは、link:https://github.com/oracle/graal/blob/master/substratevm/Limitations.md#reflection[リフレクション, window="_blank"] の使用です。リフレクション操作はサポートされていますが、関連するすべてのメンバーを明示的にリフレクション用に登録する必要があります。これらの登録は、より大きなネイティブ実行ファイルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And if Quarkus DI needs to access a private member it *has to use reflection*.  That's why Quarkus users are encouraged __not to use private members__ in their beans.  This involves injection fields, constructors and initializers, observer methods, producer methods and fields, disposers and interceptor methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkus DI がプライベートメンバーにアクセスする必要がある場合は、**リフレクションを使用しなければなりません**。そのため、Quarkus ユーザーは、プライベートメンバーを Bean で _使用しないこと_ が推奨されています。これには、インジェクションフィールド、コンストラクターとイニシャライザー、observer メソッド、producer メソッドおよび producer フィールド、disposers メソッドおよび interceptor メソッドが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How to avoid using private members? You can use package-private modifiers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プライベートメンバーの使用を回避するには、package-private 修飾子を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class CounterBean {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped
public class CounterBean {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    CounterService counterService; &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    CounterService counterService; &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    void onMessage(@Observes Event msg) { &lt;2&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    void onMessage(@Observes Event msg) { &lt;2&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A package-private injection field.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package-private injection フィールド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A package-private observer method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package-private observer メソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or constructor injection:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいはコンストラクターの注入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    private CounterService service;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    private CounterService service;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    CounterBean(CounterService service) { &lt;1&gt;
      this.service = service;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    CounterBean(CounterService service) { &lt;1&gt;
      this.service = service;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A package-private constructor injection. `@Inject` is optional in this particular case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージプライベートコンストラクター挿入。この特定の場合、`@Inject` は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされている機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@PostConstruct` and `@PreDestroy` lifecycle callbacks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルコールバック `@PostConstruct` および `@PreDestroy`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods and fields, disposers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>producer のメソッドおよびフィールド、ディスポーザー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualifiers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatives</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替品</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stereotypes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステレオタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection and lookup</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係の注入とルックアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Field, constructor and initializer/setter injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フィールド、コンストラクター、イニシャライザー/セッター挿入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe resolution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイプセーフ解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatic lookup via `javax.enterprise.inject.Instance`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.Enterprise.inject.instance` を介したプログラムによる検索</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントのプロキシー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection point metadata</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>挿入点メタデータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scopes and contexts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スコープとコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Dependent`, `@ApplicationScoped`, `@Singleton`, `@RequestScoped` and `@SessionScoped`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Dependent`, `@ApplicationScoped`, `@Singleton`, `@RequestScoped` and `@SessionScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom scopes and contexts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムスコープとコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business method interceptors: `@AroundInvoke`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビジネスメソッドインターセプタ―: `@AroundInvoke`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors for lifecycle event callbacks: `@PostConstruct`, `@PreDestroy`, `@AroundConstruct`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルイベントコールバックのためのインターセプター: `@PostConstruct`、`@PreDestroy`、`@AroundConstruct`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events and observer methods, including asynchronous events and transactional observer methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期イベントとトランザクションオブザーバーメソッドを含むイベントとオブザーバーメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ConversationScoped` is not supported</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ConversationScoped` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Decorators are not supported</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デコレータはサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Portable Extensions are not supported</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ポータブル拡張機能はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`BeanManager` - only the following methods are implemented: `getBeans()`, `createCreationalContext()`, `getReference()`, `getInjectableReference()` , `resolve()`, `getContext()`, `fireEvent()`, `getEvent()` and `createInstance()`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BeanManager` - メソッドでは、`getBeans()`、`createCreationalContext()`、`getReference()`、`getInjectableReference()`、`resolve()`、`getContext()`、`fireEvent()`、`getEvent()`、および `createInstance()` のみが実装されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specialization is not supported</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>専門性はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`beans.xml` descriptor content is ignored</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`beans.xml` 記述子の内容は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Passivation and passivating scopes are not supported</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッシベーションおよびパッシベーションスコープはサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptor methods on superclasses are not implemented yet</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スーパークラスのインターセプターメソッドは実装されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Interceptors` is not supported</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Interceptors` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-standard Features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>標準外の機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy By Default</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトではレイジー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, CDI beans are created lazily, when needed.  What exactly "needed" means depends on the scope of a bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、CDI Bean は必要なときに作成されます。何を正確に「必要とされる」かは、Bean のスコープに依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A *normal scoped bean* (`@ApplicationScoped`, `@RequestScoped`, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>挿入されたインスタンス (仕様による文脈参照) からメソッドが呼び出される場合は、*通常のスコープ付き Bean* (`@ApplicationScoped`、`@RequestScoped` など) が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, injecting a normal scoped bean will not suffice because a _client proxy_ is injected instead of a contextual instance of the bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>言い換えれば、通常のスコープ付き Bean を挿入しても、Bean のコンテキストインスタンスの代わりに _クライアントプロキシー_ が挿入されるため、十分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A *bean with a pseudo-scope* (`@Dependent` and `@Singleton` ) is created when injected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>挿入時に *疑似スコープを持つ Bean* (`@Dependent` および `@Singleton`) が作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy Instantiation Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅延インスタンス化の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Singleton // =&gt; pseudo-scope
class AmazingService {
  String ping() {
    return "amazing";
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Singleton // =&gt; pseudo-scope
class AmazingService {
  String ping() {
    return "amazing";
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped // =&gt; normal scope
class CoolService {
  String ping() {
    return "cool";
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped // =&gt; normal scope
class CoolService {
  String ping() {
    return "cool";
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/ping")
public class PingResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/ping")
public class PingResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject
  AmazingService s1; &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @Inject
  AmazingService s1; &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject
  CoolService s2; &lt;2&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @Inject
  CoolService s2; &lt;2&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @GET
  public String ping() {
    return s1.ping() + s2.ping(); &lt;3&gt;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @GET
  public String ping() {
    return s1.ping() + s2.ping(); &lt;3&gt;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection triggers the instantiation of `AmazingService`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>挿入は、`AmazingService` のインスタンス化をトリガーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection itself does not result in the instantiation of `CoolService`. A client proxy is injected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクション自体は、`CoolService` のインスタンス化にはなりません。クライアントプロキシーが挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first invocation upon the injected proxy triggers the instantiation of `CoolService`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>挿入されたプロキシーに対する最初の呼び出しは、`CoolService` のインスタンス化をトリガーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Startup Event</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタートアップイベント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, if you really need to instantiate a bean eagerly you can:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ただし、Bean の性急なインスタンス化が必要な場合は、次のことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare an observer of the `StartupEvent` - the scope of the bean does not matter in this case:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`StartupEvent` のオブザーバーを宣言します。この場合、Bean のスコープは重要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
class CoolService {
  void startup(@Observes StartupEvent event) { &lt;1&gt;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped
class CoolService {
  void startup(@Observes StartupEvent event) { &lt;1&gt;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `CoolService` is created during startup to service the observer method invocation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CoolService` は、起動時に作成され、オブザーバーメソッドの呼び出しを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the bean in an observer of the `StartupEvent` - normal scoped beans must be used as described in &lt;&lt;lazy_by_default&gt;&gt;:    
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`StartupEvent` のオブザーバーで Bean を使用します。link:#lazy_by_default[lazy_by_default] の説明に従って、通常のスコープ付き Bean を使用する必要があります。    
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Dependent
class MyBeanStarter {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Dependent
class MyBeanStarter {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  void startup(@Observes StartupEvent event, AmazingService amazing, CoolService cool) { &lt;1&gt;
    cool.toString(); &lt;2&gt;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  void startup(@Observes StartupEvent event, AmazingService amazing, CoolService cool) { &lt;1&gt;
    cool.toString(); &lt;2&gt;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `AmazingService` is created during injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AmazingService` は注入時に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `CoolService` is a normal scoped bean so we have to invoke a method upon the injected proxy to force the instantiation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CoolService` は通常のスコープ付き Bean であるため、強制的にインスタンス化するために挿入されたプロキシーにメソッドを呼び出さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotate the bean with `@io.quarkus.runtime.Startup` as described in link:lifecycle#startup_annotation[Startup annotation]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:lifecycle#startup_annotation[スタートアップアノテーション] で説明したように、`@io.quarkus.runtime.Startup` で Bean をアノテーションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Startup // &lt;1&gt;
@ApplicationScoped
public class EagerAppBean {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Startup // &lt;1&gt;
@ApplicationScoped
public class EagerAppBean {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus users are encouraged to always prefer the `@Observes StartupEvent` to `@Initialized(ApplicationScoped.class)` as explained in the link:lifecycle[Application Initialization and Termination] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus ユーザーは、link:lifecycle[アプリケーションの初期化と終了] のガイドで説明されているように、常に `@Initialized(ApplicationScoped.class)` よりも `@Observes StartupEvent` を選択することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Request Context Lifecycle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストコンテキストのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request context is also active:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストコンテキストもアクティブになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>during notification of a synchronous observer method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同期オブザーバメソッドの通知中に</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The request context is destroyed:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストコンテキストは破棄されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>after the observer notification completes for an event, if it was not already active when the notification started.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通知が開始したときにまだアクティブではなかった場合はイベントのオブザーバー通知が完了した後</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An event with qualifier `@Initialized(RequestScoped.class)` is fired when the request context is initialized for an observer notification. Moreover, the events with qualifiers `@BeforeDestroyed(RequestScoped.class)` and `@Destroyed(RequestScoped.class)` are fired when the request context is destroyed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オブザーバー通知のためにリクエストコンテキストが初期化されると、修飾子 `@Initialized(RequestScoped.class)` を持つイベントが発生します。さらに、修飾子 `@BeforeDestroyed(RequestScoped.class)` および `@Destroyed(RequestScoped.class)` を持つイベントは、リクエストコンテキストが破棄されたときに発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualified Injected Fields</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>修飾された注入フィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, if you declare a field injection point you need to use `@Inject` and optionally a set of qualifiers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI では、フィールド注入ポイントを宣言する場合は `@Inject` と任意で修飾子のセットを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject
  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @Inject
  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, you can skip the `@Inject` annotation completely if the injected field declares at least one qualifier.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、注入されたフィールドが少なくとも 1 つの修飾子を宣言している場合は、`@Inject` アノテーションを完全にスキップすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @ConfigProperty(name = "cool")
  String coolProperty;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the notable exception of one special case discussed below, `@Inject` is still required for constructor and method injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>後述する特別なケースを除いて、コンストラクターとメソッドの注入には `@Inject` が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Constructor Injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>簡略化されたコンストラクター注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).  However, this requirement complicates constructor injection - you need to provide a dummy no-args constructor to make things work in CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI では、通常のスコープ付き Bean は常に no-args コンストラクターを宣言しなければなりません (このコンストラクターは、他のコンストラクターを宣言しない限り、通常はコンパイラーによって生成されます)。しかし、この要件はコンストラクターの注入を複雑にします。CDI で動作させるためにはダミーの no-args コンストラクターを提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
public class MyCoolService {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped
public class MyCoolService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  private SimpleProcessor processor;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  private SimpleProcessor processor;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  MyCoolService() { // dummy constructor needed
  }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  MyCoolService() { // dummy constructor needed
  }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Inject // constructor injection
  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @Inject // constructor injection
  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.  Also if there's only one constructor there is no need for `@Inject`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、通常のスコープ付き Bean のためにダミーのコンストラクターを宣言する必要はありません。自動的に生成されます。また、コンストラクターが 1 つしかない場合は、`@Inject` の必要性はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We don't generate a no-args constructor automatically if a bean class extends a class that does not declare a no-args constructor.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>no-args コンストラクターを宣言していないクラスを Bean クラスが継承している場合は、no-args コンストラクターは自動的に生成されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Removing Unused Beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>未使用の Bean の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container attempts to remove all unused beans during build by default.  This optimization can be disabled by setting `quarkus.arc.remove-unused-beans` to `none` or `false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは、デフォルトではビルド中に未使用の Bean をすべて削除しようとします。この最適化は、`quarkus.arc.remove-unused-beans` を `none` または `false` に設定することで無効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An unused bean:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>未使用の Bean:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not a built-in bean or an interceptor,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルトイン Bean でもインターセプターでもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not eligible for injection to any injection point,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>任意の注入点への注入の対象とはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not excluded by any extension,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どのような拡張機能を用いても除外されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>does not have a name,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>does not declare an observer,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オブザーバーを宣言しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>does not declare any producer which is eligible for injection to any injection point,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>任意の注入ポイントへの注入対象となるプロデューサーを宣言しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>is not directly eligible for injection into any `javax.enterprise.inject.Instance` or `javax.inject.Provider` injection point</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.inject.Instance` または `javax.inject.Provider` の注入ポイントに直接注入することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This optimization applies to all forms of bean declarations: bean class, producer method, producer field.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この最適化は、Bean クラス、プロデューサーメソッド、プロデューサーフィールドなど、Bean 宣言のすべての形式に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users can instruct the container to not remove any of their specific beans (even if they satisfy all the rules specified above) by annotating them with `io.quarkus.arc.Unremovable`.  This annotation can be placed on the types, producer methods, and producer fields.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーは、コンテナーに `io.quarkus.arc.Unremovable` をアノテーションすることで、(上で指定したルールをすべて満たしていても) 特定の Bean を削除しないように指示することができます。このアノテーションは、型、producer メソッド、producer フィールドに置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since this is not always possible, there is an option to achieve the same via `application.properties`.  The `quarkus.arc.unremovable-types` property accepts a list of string values that are used to match beans based on their name or package.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは常に可能ではないので、`application.properties` を通して同じことを実現するオプションがあります。`quarkus.arc.unremovable-types` プロパティーは、Bean の名前やパッケージに基づいて一致させるための文字列値のリストを受け付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match beans where the package of the bean class is `org.acme`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean クラスのパッケージが `org.acme` である Bean に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match beans where the package of the bean class starts with `org.acme`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean クラスのパッケージが `org.acme` で開始する Bean に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the simple name of the bean class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean クラスのシンプルな名前に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.unremovable-types=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.arc.unremovable-types=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, extensions can eliminate possible false positives by producing `UnremovableBeanBuildItem`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、エクステンションは `UnremovableBeanBuildItem` を生成することで、可能性のある誤検出を排除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, Quarkus provides a middle ground for the bean removal optimization where application beans are never removed whether or not they are unused, while the optimization proceeds normally for non application classes. To use this mode, set `quarkus.arc.remove-unused-beans` to `fwk` or `framework`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、Quarkus では、アプリケーション Bean が未使用であるかどうかに関わらず削除されることはありませんが、アプリケーション以外のクラスについては通常通り最適化が行われるという、Bean 削除最適化のための妥協点を提供しています。このモードを使用するには、`quarkus.arc.remove-unused-beans` を `fwk` または `framework` に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using the dev mode (running `./mvnw clean compile quarkus:dev`), you can see more information about which beans are being removed by enabling additional logging via the following line in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードを使用する場合 (`./mvnw clean compile quarkus:dev`) は、`application.properties` の次の行で追加のログを有効にすることで、削除されている Bean に関する詳細情報を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.log.category."io.quarkus.arc.processor".level=DEBUG
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.log.category."io.quarkus.arc.processor".level=DEBUG
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default Beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトの Bean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus adds a capability that CDI currently does not support which is to conditionally declare a bean if no other bean with equal types and qualifiers was declared by any available means (bean class, producer, synthetic bean, ...)  This is done using the `@io.quarkus.arc.DefaultBean` annotation and is best explained with an example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、CDI が現在サポートしていない機能を追加します。これは、利用可能な手段 (Beanクラス、producer、合成 Bean など) で同等の型と修飾子を持つ他の Bean が宣言されていない場合に、条件付きで Bean を宣言することです。これは、`@io .quarkus.Arc.DefaultBean` アノテーションを使用して行われ、例を挙げて説明するのが最善です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Say there is a Quarkus extension that among other things declares a few CDI beans like the following code does:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードのようにいくつかの CDI Bean を宣言する Quarkus エクステンションがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The idea is that the extension auto-configures things for the user, eliminating a lot of boilerplate - we can just `@Inject` a `Tracer` wherever it is needed.  Now imagine that in our application we would like to utilize the configured `Tracer`, but we need to customize it a little, for example by providing a custom `Reporter`.  The only thing that would be needed in our application would be something like the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイデアは、エクステンションがユーザーのために自動設定を行い、多くのボイラープレートを排除するということです。必要な場所であれば、`@Inject` を `Tracer` にすることができます。私たちのアプリケーションで、設定された `Tracer` を利用しようとする場合は、、カスタムの `Reporter` を提供するなど、少しカスタマイズする必要があります。アプリケーションで必要になるのは、次のようなものだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@DefaultBean` allows extensions (or any other code for that matter) to provide defaults while backing off if beans of that type are supplied in any way Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@DefaultBean` では、エクステンション (またはそのための他のコード) が Quarkus がサポートする何らかの方法でその型の Bean が提供されている場合、バックオフ中にデフォルトを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time profile is enabled, via the `@io.quarkus.arc.profile.IfBuildProfile` and `@io.quarkus.arc.profile.UnlessBuildProfile` annotations.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, these annotations allow for the creation of different bean configurations for different build profiles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、CDI が現在サポートしていない機能を追加しました。これは、Quarkus のビルドタイムプロファイルが有効になっているときに条件付きで Bean を有効にするというもので、`@io.quarkus.arc.profile.IfBuildProfile` と `@io.quarkus.arc.profile.UnlessBuildProfile` のアノテーションを使用します。`@io.quarkus.arc.DefaultBean` と合わせて使用すると、これらのアノテーションにより、異なるビルドプロファイルに対して異なる Bean 構成を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imagine for instance that an application contains a bean named `Tracer`, which needs to be do nothing when in tests or dev-mode, but works in its normal capacity for the production artifact.  An elegant way to create such beans is the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、アプリケーションが `Tracer` という名前の Bean を含んでいるとします。この Bean は、テストや開発モードでは何もする必要はありませんが、本番の成果物に対しては通常の能力で動作します。このような Bean を作成する洗練された方法は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @IfBuildProfile("prod")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    @IfBuildProfile("prod")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @DefaultBean
    public Tracer noopTracer() {
        return new NoopTracer();
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    @DefaultBean
    public Tracer noopTracer() {
        return new NoopTracer();
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If instead, it is required that the `Tracer` bean also works in dev-mode and only default to doing nothing for tests, then `@UnlessBuildProfile` would be ideal. The code would look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代わりに、`Tracer` Bean も dev モードで動作し、デフォルトではテストのために何もしないことが要求される場合は、`@UnlessBuildProfile` が理想的です。コードは次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @UnlessBuildProfile("test") // this will be enabled for both prod and dev build time profiles
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    @UnlessBuildProfile("test") // this will be enabled for both prod and dev build time profiles
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイムプロファイルは、`@IfBuildProfile` および `@UnlessBuildProfile` を使用した Bean 解決には影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus adds a capability that CDI currently does not support which is to conditionally enable a bean when a Quarkus build time property has a specific value, via the `@io.quarkus.arc.properties.IfBuildProperty` and `@io.quarkus.arc.properties.UnlessBuildProperty` annotation.  When used in conjunction with `@io.quarkus.arc.DefaultBean`, this annotation allow for the creation of different bean configurations for different build properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、CDI が現在サポートしていない機能を追加しました。これは、Quarkus のビルドタイムプロファイルが有効になっているときに条件付きで Bean を有効にするというもので、`@io.quarkus.arc.profile.IfBuildProfile` および `@io.quarkus.arc.profile.UnlessBuildProfile` のアノテーションを使用します。`@io.quarkus.arc.DefaultBean` と合わせて使用すると、これらのアノテーションにより、異なるビルドプロファイルに対して異なる Bean 構成を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The scenario we mentioned above with `Tracer` could also be implemented in the following way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Tracer` を使用して上で述べたシナリオも、以下のように実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @IfBuildProperty(name = "some.tracer.enabled", stringValue = "true")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    @IfBuildProperty(name = "some.tracer.enabled", stringValue = "true")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代わりに、`some.tracer.enabled` プロパティーが `false` でない場合にのみ `RealTracer` Bean が使用されることが要求される場合は、`@UnlessBuildProperty` が理想的です。コードは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Produces
    @UnlessBuildProperty(name = "some.tracer.enabled", stringValue = "false")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Produces
    @UnlessBuildProperty(name = "some.tracer.enabled", stringValue = "false")
    public Tracer realTracer(Reporter reporter, Configuration configuration) {
        return new RealTracer(reporter, configuration);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時に設定されたプロパティーは、 `@IfBuildProperty` を使用しても Bean の解決に全く影響しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declaring Selected Alternatives</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>選択された代替の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, an alternative bean may be selected either globally for an application by means of `@Priority`, or for a bean archive using a `beans.xml` descriptor.  Quarkus has a simplified bean discovery and the content of `beans.xml` is ignored.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI では、代替の Bean は、`@Priority` を使用してアプリケーションに対してグローバルに選択することも、`beans.xml` 記述子を使用した Bean アーカイブ用に選択することもできます。Quarkus には単純化された Bean 検出があり、`beans.xml`の内容は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The disadvantage of `@Priority` is that it has `@Target({ TYPE, PARAMETER })` and so it cannot be used for producer methods and fields.  To address this problem and to simplify the code Quarkus provides the `io.quarkus.arc.AlternativePriority` annotation.  It's basically a shortcut for `@Alternative` plus `@Priority`.  Additionally, it can be used for producers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Priority` の欠点は、`@Priority` には、`@Target({ TYPE, PARAMETER })` があるため、producer メソッドや producer  フィールドには使用できないことです。この問題に対処し、コードを単純化するために、Quarkus は `io.quarkus.arc.AlternativePriority` アノテーションを提供します。基本的には、`@Alternative` および `@Priority` のショートカットです。さらに、producer にも使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, it is also possible to select alternatives for an application using the unified configuration.  The `quarkus.arc.selected-alternatives` property accepts a list of string values that are used to match alternative beans.  If any value matches then the priority of `Integer#MAX_VALUE` is used for the relevant bean.  The priority declared via `@Priority` or `@AlternativePriority` is overridden.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ただし、統一された設定を使用して、アプリケーションの代替を選択することもできます。`quarkus.arc.selected-alternatives` プロパティーは、代替 Bean を照合するために使用される文字列値のリストを受け入れます。一致する値がある場合は、関連する Bean に `Integer#MAX_VALUE` の優先順位が使用されます。`@Priority` または `@AlternativePriority` で宣言された優先度は上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the fully qualified name of the bean class or the bean class of the bean that declares the producer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean クラス、または producer を宣言する Bean の Bean クラスの完全修飾名に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Match the simple name of the bean class or the bean class of the bean that declares the producer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean クラス、または producer を宣言する Bean の Bean クラスの単純名に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.arc.selected-alternatives=org.acme.Foo,org.acme.*,Bar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplified Producer Method Declaration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>簡略化された Producer メソッドの宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI, a producer method must be always annotated with `@Produces`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI では、producer メソッドは常に `@Produces` とアノテーションされていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Producers {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>class Producers {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Produces
  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @Produces
  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, you can skip the `@Produces` annotation completely if the producer method is annotated with a scope annotation, a stereotype or a qualifier.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、producer メソッドにスコープ注釈、ステレオタイプ、または修飾子が付いている場合は、`@Produces` アノテーションを完全に省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @ApplicationScoped
  MyService produceService() {
    return new MyService(coolProperty);
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interception of Static Methods </seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>静的メソッドのインターセプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Interceptors specification is clear that _around-invoke_ methods must not be declared static.  However, this restriction was driven mostly by technical limitations.  And since Quarkus is a build-time oriented stack that allows for additional class transformations, those limitations don't apply anymore.  It's possible to annotate a non-private static method with an interceptor binding:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターの仕様は、_around-invoke_ メソッドを静的宣言してはならないことは明らかです。しかし、この制限は、主に技術的な制限によって設定されました。Quarkus は追加のクラス変換を可能にするビルド時指向のスタックであるため、この制限は適用されなくなりました。インターセプタ―バインディングで非プライベートの静的メソッドに注釈を付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>class Services {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>class Services {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Logged &lt;1&gt;
  static BigDecimal computePrice(long amount) { &lt;2&gt;
    BigDecimal price;
    // Perform computations...
    return price;
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @Logged &lt;1&gt;
  static BigDecimal computePrice(long amount) { &lt;2&gt;
    BigDecimal price;
    // Perform computations...
    return price;
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Logged` is an interceptor binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Logged` はインターセプターバインディングです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each method invocation is intercepted if there is an interceptor associated with `Logged`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各メソッドの呼び出しは、`Logged` に関連付けられたインターセプターがある場合に傍受されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only *method-level bindings* are considered for backward compatibility reasons (otherwise static methods of bean classes that declare class-level bindings would be suddenly intercepted)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>下位互換性の理由から *メソッドレベルのバインディング* のみが考慮されます (そうでないとクラスレベルのバインディングを宣言している Bean クラスの静的メソッドが突然傍受されてしまいます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Private static methods are never intercepted</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プライベートなスタティックメソッドは決して傍受されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`InvocationContext#getTarget()` returns `null` for obvious reasons; therefore not all existing interceptors may behave correctly when intercepting static methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`InvocationContext#getTarget()` は明白な理由により `null` を返します。したがって、静的メソッドを傍受するときに既存のインターセプターがすべて正しく動作するとは限りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors can use `InvocationContext.getMethod()` to detect static methods and adjust the behavior accordingly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターは `InvocationContext.getMethod()` を使用して静的メソッドを検出し、それに応じて動作を調整することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ability to handle 'final' classes and methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>final クラスとメソッドを処理する能力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In normal CDI, classes that are marked as `final` and / or have `final` methods are not eligible for proxy creation, which in turn means that interceptors and normal scoped beans don't work properly.  This situation is very common when trying to use CDI with alternative JVM languages like Kotlin where classes and methods are `final` by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常の CDI では、`final` としてマークされているクラス、または `final` メソッドを持つクラスは、プロキシー作成の対象になりません。これは、インターセプターと通常のスコープ Bean が正しく動作しないことを意味します。このような状況は、クラスおよびメソッドがデフォルトで `final`である Kotlin のような代替 JVM 言語で CDI を使用しようとするときに非常に一般的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、Quarkus では、`quarkus.arc.transform-unproxyable-classes` を `true` (デフォルト値) に設定すると、これらの制限を抑制することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container-managed Concurrency</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナー管理型の並行処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is no standard concurrency control mechanism for CDI beans.  Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.  In that case it should be thread-safe.  You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access.  Quarkus provides `@io.quarkus.arc.Lock` and a built-in interceptor for this interceptor binding.  Each interceptor instance associated with a contextual instance of an intercepted bean holds a separate `ReadWriteLock` with non-fair ordering policy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI Bean の標準的な同時実行制御メカニズムはありません。それにもかかわらず、Bean インスタンスは、複数のスレッドから同時に共有およびアクセスすることができます。その場合は、スレッドセーフでなければなりません。標準の Java コンストラクト (`volatile`、`synchronized`、`ReadWriteLock` など) を使用するか、コンテナーに同時アクセスを制御させることができます。Quarkus は、`@io.quarkus.arc.Lock` と、このインターセプタ―バインディング用の組み込みインターセプターを提供します。傍受された Bean のコンテキストインスタンスに関連付けられた各インターセプターインスタンスは、公平でない順序付けポリシーを持つ `ReadWriteLock` を保持しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for "shared" scopes, e.g. `@Singleton` and `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.arc.Lock` は通常のインターセプターバインディングであるため、任意のスコープを持つ任意の Bean に使用することができます。しかし、特に「共有」スコープ、たとえば `@Singleton` や `@ApplicationScoped` に有益です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container-managed Concurrency Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナー管理された並行処理の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.arc.Lock;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.arc.Lock;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Lock &lt;1&gt;
@ApplicationScoped
class SharedService {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Lock &lt;1&gt;
@ApplicationScoped
class SharedService {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  void addAmount(BigDecimal amount) {
    // ...changes some internal state of the bean
  }
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  void addAmount(BigDecimal amount) {
    // ...changes some internal state of the bean
  }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) &lt;2&gt; &lt;3&gt;
  BigDecimal getAmount() {
    // ...it is safe to read the value concurrently
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) &lt;2&gt; &lt;3&gt;
  BigDecimal getAmount() {
    // ...it is safe to read the value concurrently
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has "exclusive access" and no concurrent invocations will be allowed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスで宣言された (`@Lock (Lock.type.Write)` にマッピングされる) `@Lock` は、任意のビジネスメソッドの呼び出しに対して Bean インスタンスをロックするようにコンテナーに指示します。つまり、クライアントには「排他アクセス」があり、同時呼び出しは許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Lock(Lock.Type.READ)` は、クラスレベルで指定された値を上書きします。これは、Bean のインスタンスが `@Lock(Lock.Type.WRITE)` によってロックされていない限り、任意の数のクライアントが同時にメソッドを呼び出すことができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also specify the "wait time". If it's not possible to acquire the lock in the given time a `LockException` is thrown.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、「待ち時間」を指定することもできます。指定した時間内にロックを取得できない場合は `LockException` が発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Repeatable interceptor bindings</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>反復可能なインターセプターバインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has limited support for `@Repeatable` interceptor binding annotations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、`@Repeatable` インターセプター結合アノテーションのサポートが制限されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.  Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.  This might be added in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプタ―をコンポーネントにバインドする場合は、メソッドに対して複数の `@Repeatable` アノテーションを宣言できます。インターセプター仕様との相互作用に関する未解決の質問があるため、クラスとステレオタイプで宣言された反復可能なインターセプターバインディングはサポートされていません。これは将来追加される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, suppose we have an interceptor that clears a cache.  The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.  If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、キャッシュをクリアするインターセプタ―があるとします。対応するインターセプタ―バインディングは `@CacheInvalidateAll` と呼ばれ、`@Repeatable` として宣言されます。同時に 2 つのキャッシュをクリアしたい場合は、`@CacheInvalidateAll` を 2 回追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@ApplicationScoped
class CachingService {
  @CacheInvalidateAll(cacheName = "foo")
  @CacheInvalidateAll(cacheName = "bar")
  void heavyComputation() {
    // ...
    // some computation that updates a lot of data
    // and requires 2 caches to be invalidated
    // ...
  }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@ApplicationScoped
class CachingService {
  @CacheInvalidateAll(cacheName = "foo")
  @CacheInvalidateAll(cacheName = "bar")
  void heavyComputation() {
    // ...
    // some computation that updates a lot of data
    // and requires 2 caches to be invalidated
    // ...
  }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is how interceptors are used.  What about creating an interceptor?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここまで、インターセプタ―がどのように使用されるかを説明しました。では、インターセプターを作成するにはどうすれば良いでしょうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.  This is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプタ―のインターセプタ―バインディングを宣言する場合は、通常どおり、インターセプタ―クラスに複数の `@Repeatable` アノテーションを追加できます。`@Cached` アノテーションの場合と同様に、アノテーションメンバーが `@Nonbinding` の場合は役に立ちませんが、それ以外の場合は重要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, suppose we have an interceptor that can automatically log method invocations to certain targets.  The interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.  Our implementation could be restricted to console logging and file logging:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、メソッド呼び出しを特定のターゲットに自動的に記録できるインターセプタ―があるとします。インターセプタ―バインディング注釈 `@Logged` には、ログを保存する場所を指定する `target` というメンバーがあります。この実装は、コンソールログとファイルロギングに制限することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Interceptor
@Logged(target = "console")
@Logged(target = "file")
class NaiveLoggingInterceptor {
  // ...
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Interceptor
@Logged(target = "console")
@Logged(target = "file")
class NaiveLoggingInterceptor {
  // ...
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other interceptors could be provided to log method invocations to different targets.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にも、異なるターゲットへのメソッド呼び出しをログに記録するためのインターセプターを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時間延長</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus incorporates build-time optimizations in order to provide instant startup and low memory footprint.  The downside of this approach is that CDI Portable Extensions cannot be supported.  Nevertheless, most of the functionality can be achieved using Quarkus link:writing-extensions[extensions].  See the link:cdi-integration[integration guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、インスタント起動と低メモリフットプリントを提供するために、ビルド時間の最適化を取り入れています。このアプローチの欠点は、CDI ポータブル拡張機能をサポートできないことです。それにもかかわらず、ほとんどの機能は、Quarkus link:writing-extensions[拡張機能] を使用して行うことができます。詳細は、link:cdi-integration[統合ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the development mode, two special endpoints are registered automatically to provide some basic debug info in the JSON format:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードでは、JSON 形式で基本的なデバッグ情報を提供するために、2 つの特別なエンドポイントが自動的に登録されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc` - returns the summary; number of beans, config properties, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP GET `/q/arc` - 要約、Bean の数、設定プロパティーなどを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc/beans` - returns the list of all beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP GET `/q/arc/beans` - すべての Bean のリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use query params to filter the output:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クエリーパラメーターを使用して出力をフィルタリングすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`scope` - include beans with scope that ends with the given value, i.e. `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`scope` - 指定した値で終わるスコープを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?scope=ApplicationScoped`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`beanClass` - include beans with bean class that starts with the given value, i.e. `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`beanClass` - 与えられた値で始まる Bean クラスを持つ Bean を含みます (つまり `http://localhost:8080/q/arc/beans?beanClass=org.acme.Foo`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`kind` - include beans of the specified kind (`CLASS`, `PRODUCER_FIELD`, `PRODUCER_METHOD`, `INTERCEPTOR` or `SYNTHETIC`), i.e. `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`kind` - 指定された種類の Bean (`CLASS`、`PRODUCER_FIELD`、`PRODUCER_METHOD`、`INTERCEPTOR`、または `SYNTHETIC`) を含みます (つまり `http://localhost:8080/q/arc/beans?kind=PRODUCER_METHOD`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc/removed-beans` - returns the list of unused beans removed during build</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP GET `/q/arc/removed-beans` - ビルド中に削除された未使用の Bean のリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP GET `/q/arc/observers` - returns the list of all observer methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP GET `/q/arc/observers` - すべてのオブザーバーメソッドのリストを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These endpoints are only available in the development mode, i.e. when you run your application via `mvn quarkus:dev` (or `./gradlew quarkusDev`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのエンドポイントは開発モードでのみ使用できます。つまり `mvn quarkus:dev` (または `./gradlew quarkusDev`) 経由でアプリケーションを実行したときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application. In addition there are plugins and extensions to all major IDEs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、開発者がライブリロードから Kubernetes アプリケーションのデプロイまでを可能にするツールチェーンが付属しています。加えて、全ての主要なIDEに対するプラグインも存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will explore:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下をみていきます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE でアプリケーションを開発する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing your build tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドツールの選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、すべての開発段階で役立つツールチェーンが付属しています。ビルドツールとして Maven や Gradle を使うことができます。また、使い勝手の良いネイティブ CLI も提供しています (近日公開予定)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:ide-tooling[IDE]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward REST application to demonstrate distributed tracing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、分散トレースを実証するための簡単なRESTアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `smallrye-opentracing` extension, which includes the OpenTracing support and the default https://www.jaegertracing.io/[Jaeger] tracer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、OpenTracing サポートとデフォルトの link:https://www.jaegertracing.io/[Jaeger] トレーサーを含む `smallrye-opentracing` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-opentracing` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで以下のコマンドを実行することで、プロジェクトに `smallrye-opentracing` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/opentracing/TracedResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/opentracing/TracedResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that there is no tracing specific code included in the application. By default, requests sent to this endpoint will be traced without any code changes being required. It is also possible to enhance the tracing information. For more information on this, please see the https://github.com/eclipse/microprofile-opentracing/blob/master/spec/src/main/asciidoc/microprofile-opentracing.asciidoc[MicroProfile OpenTracing specification].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションにはトレースに特化したコードが含まれていないことに注意してください。デフォルトでは、このエンドポイントに送信されたリクエストは、コードの変更を必要とせずにトレースされます。また、トレース情報を強化することも可能です。これについての詳細は、 link:https://github.com/eclipse/microprofile-opentracing/blob/master/spec/src/main/asciidoc/microprofile-opentracing.asciidoc[MicroProfile OpenTracing 仕様] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two ways to configure the Jaeger tracer within the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション内でJaeger トレーサーを設定するには、2つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first approach is by providing the properties within the `src/main/resources/application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のアプローチは、 `src/main/resources/application.properties` ファイル内でプロパティーを提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `quarkus.jaeger.service-name` property (or `JAEGER_SERVICE_NAME` environment variable) is not provided then a "no-op" tracer will be configured, resulting in no tracing data being reported to the backend.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.jaeger.service-name` プロパティー (または `JAEGER_SERVICE_NAME` 環境変数) が提供されていない場合は、"no-op" トレーサーが設定され、結果としてトレースデータはバックエンドに報告されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setup a sampler, that uses a constant sampling strategy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一定のサンプリング戦略を使用するサンプラーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample all requests. Set sampler-param to somewhere between 0 and 1, e.g. 0.50, if you do not wish to sample all requests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのリクエストをサンプリングします。すべてのリクエストをサンプリングしたくない場合は、sampler-param を 0 から 1 の間のどこかに設定します (例: 0.50)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add trace IDs into log message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ログメッセージにトレースIDを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second approach is to supply the properties as https://www.jaegertracing.io/docs/latest/client-features/[environment variables]. These can be specified as `jvm.args` as shown in the following section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つ目の方法は、 link:https://www.jaegertracing.io/docs/latest/client-features/[環境変数] としてプロパティーを供給することです。これらは、次のセクションに示すように `jvm.args` として指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step is to start the tracing system to collect and display the captured traces:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、キャプチャしたトレースを収集して表示するためのトレースシステムを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. If using `application.properties` to configure the tracer:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを実行する準備が整いました。トレーサーの設定に `application.properties` を使用している場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once both the application and tracing system are started, you can make a request to the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションとトレースシステムの両方が起動したら、提供されたエンドポイントにリクエストを行うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the first request has been submitted, the Jaeger tracer within the app will be initialized:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のリクエストが送信されると、アプリ内のJaegerトレーサーが初期化されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then visit the http://localhost:16686[Jaeger UI] to see the tracing information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、 link:http://localhost:16686[Jaeger UI] にアクセスしてトレース情報を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tracing additional methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加メソッドのトレース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST endpoints are automatically traced.  If you need to trace additional methods, you can use the `org.eclipse.microprofile.opentracing.Traced` annotation at class or method level.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST エンドポイントは自動的にトレースされます。追加でメソッドをトレースする必要がある場合は、クラスやメソッドレベルで `org.eclipse.microprofile.opentracing.Traced` アノテーションを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be useful to trace incoming requests from non-REST calls (like request coming from a message) or to create spans inside a trace.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、非RESTコール(メッセージからのリクエストなど)からの着信リクエストをトレースしたり、トレース内にスパンを作成したりするのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here is an example of a `FrancophoneService` which methods are traced.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、メソッドがトレースされている `FrancophoneService` の例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the best way to add OpenTracing capability to reactive messaging based applications is by adding the `Traced` annotation to all incoming methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Messagingベースのアプリケーションに OpenTracing 機能を追加する最善の方法は、すべての受信メソッドに `Traced` アノテーションを追加することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional instrumentation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加の計器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/opentracing-contrib[OpenTracing API Contributions project] offers additional instrumentation that can be used to add tracing to a large variety of technologies/components.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/opentracing-contrib[OpenTracing API Contributionsプロジェクト] では、様々な技術/コンポーネントにトレースを追加するために使用できる追加の計器 (Instrumentation) を提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The instrumentation documented in this section has been tested with Quarkus and works in both standard and native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このセクションで説明されている計器は、Quarkusでテストされており、標準モードとネイティブモードの両方で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/opentracing-contrib/java-jdbc[JDBC instrumentation] will add a span for each JDBC queries done by your application, to enable it, add the following dependency to your pom.xml:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/opentracing-contrib/java-jdbc[JDBC計器]は 、アプリケーションで実行されるJDBCクエリごとにスパンを追加するので、これを有効にするには、以下の依存関係をpom.xmlに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As it uses a dedicated JDBC driver, you must configure your datasource and Hibernate to use it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>専用のJDBCドライバーを使用するため、データソースとHibernateがそれを使用するように設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/opentracing-contrib/java-kafka-client[Kafka instrumentation] will add a span for each message sent to or received from a Kafka topic. To enable it, add the following dependency to your pom.xml:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/opentracing-contrib/java-kafka-client[Kafka 計器] は、Kafka トピックとの間で送受信されるメッセージごとにスパンを追加します。これを有効にするには、以下の依存関係を pom.xml に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It contains OpenTracing interceptors that must be registered on Kafka producers and consumers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>KafkaのProducerとConsumerに登録しなければならないOpenTracingのインターセプターが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the link:kafka[Kafka guide], the interceptors can be added on the `generated-price` and the `prices` channels as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:kafka[Kafkaのガイド] に従った場合、以下のように `generated-price` と `prices` のチャンネルにインターセプターを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`interceptor.classes` accept a list of classes separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`interceptor.classes` はカンマで区切られたクラスのリストを受け付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://picocli.info/[Picocliは] 、リッチなコマンドラインアプリケーションを作成するためのオープンソースツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、Picocli を使用するためのサポートを提供しています。このガイドには、 `picocli` エクステンションの使用例が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus のコマンドモードに詳しくない場合は、まず link:command-mode-reference[コマンドモードのリファレンスガイド] を読むことを検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `picocli` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus プロジェクトを設定すると、プロジェクトのベースディレクトリーで次のコマンドを実行することで、 `picocli` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple command line application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple PicocliApplication with only one `Command` can be created as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Command` を 1 つだけ使ったシンプルな PicocliApplication は、以下のように作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスが 1 つだけある場合、これは Picocli CommandLine のエントリーポイントとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスはすべて CDI Bean として登録されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans with `@CommandLine.Command` should not use proxied scopes (e.g. do not use `@ApplicationScope`)  because Picocli will not be able set field values in such beans. This extension will register classes with `@CommandLine.Command` annotation using `@Depended` scope. If you need to use proxied scope, then annotate setter and not field, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CommandLine.Command` を持つ Bean では、プロキシーされるスコープを使用してはいけません (例: `@ApplicationScope` は使用しないでください)。Picocli はそのような Bean でフィールド値を設定できないためです。このエクステンションは `@CommandLine.Command` アノテーションを持つクラスを `@Depended` スコープを使って登録します。プロキシーされるスコープを使用する必要がある場合は、フィールドではなくセッターを次の例のようにアノテーションしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line application with multiple Commands</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のコマンドを使用したコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes have the `picocli.CommandLine.Command` annotation, then one of them needs to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.  This can be overwritten with the `quarkus.picocli.top-command` property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のクラスが `picocli.CommandLine.Command` アノテーションを持つ場合、そのうちの 1 つに `io.quarkus.picocli.runtime.annotations.TopCommand` アノテーションを付ける必要があります。これは `quarkus.picocli.top-command` プロパティーで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can customize CommandLine classes used by the `picocli` extension by producing your own bean instance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自の Bean インスタンスを生成することで、 `picocli` エクステンションで使用される CommandLine クラスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`PicocliCommandLineFactory` は、 `TopCommand` と `CommandLine.IFactory` を注入した CommandLine のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Different entry command for each profile</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルごとに異なるエントリーコマンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create different entry command for each profile, using `@IfBuildProfile`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@IfBuildProfile` を使用して、プロファイルごとに異なるエントリーコマンドを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return instance of `java.lang.Class` here. In such case `CommandLine` will try to instantiate this class using `CommandLine.IFactory`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは `java.lang.Class` のインスタンスを返すことができます。この場合、 `CommandLine` は `CommandLine.IFactory` を使ってこのクラスのインスタンスを作成しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure CDI Beans with parsed arguments</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>解析された引数での CDI Beans の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Event&lt;CommandLine.ParseResult&gt;` or just `CommandLine.ParseResult` to configure CDI beans based on arguments parsed by Picocli.  This event will be generated in `QuarkusApplication` class created by this extension. If you are providing your own `@QuarkusMain` this event will not be raised.  `CommandLine.ParseResult` is created from default `CommandLine` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli によって解析された引数に基づいて CDI Bean を設定するために、 `Event&lt;CommandLine.ParseResult&gt;` 、または単に `CommandLine.ParseResult` を使用することができます。このイベントは、このエクステンションによって作成された `QuarkusApplication` クラスで生成されます。独自の `@QuarkusMain` を提供している場合、このイベントは発生しません。 `CommandLine.ParseResult` はデフォルトの `CommandLine` Bean から作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing own QuarkusMain</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自の QuarkusMain の提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide your own application entry point annotated with `QuarkusMain` (as described in link:command-mode-reference[Command Mode reference guide]).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `QuarkusMain` でアノテーションされた独自のアプリケーションのエントリーポイントを提供することもできます (link:command-mode-reference[コマンドモードのリファレンスガイド] に記載されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus-compatible `CommandLine.IFactory` bean created by `picocli` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli` のエクステンションで作成された Quarkus 互換の `CommandLine.IFactory` Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native mode support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension uses the Quarkus standard build steps mechanism to support GraalVM Native images. In the exceptional case that incompatible changes in a future picocli release cause any issue, the following configuration can be used to fall back to the annotation processor from the picocli project as a temporary workaround:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションでは、Quarkus 標準のビルドステップメカニズムを使用して、GraalVM Nativeイメージをサポートしています。将来のpicocliリリースで互換性のない変更が問題を引き起こす例外的なケースでは、一時的な回避策として、以下の設定を使用してpicocliプロジェクトのアノテーションプロセッサーにフォールバックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Gradle, you need to add the following in `dependencies` section of the `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle の場合は、 `build.gradle` ファイルの `dependencies` セクションに以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to test your Quarkus Application.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションのテスト方法について説明します。このガイドでは、以下の内容について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing in native mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of resources into tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへのリソースの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The completed greeter application from the link:getting-started[Getting Started Guide]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:getting-started[入門ガイド]の完成済のgreeterアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、入門ガイドの一部として作成された最初のテストを拡張します。テストへのインジェクションと、ネイティブの実行ファイルをテストする方法もカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started-testing`  {quickstarts-tree-url}/getting-started-testing[ディレクトリー] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide assumes you already have the completed application from the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 `getting-started`  ディレクトリーの完成したアプリケーションをすでに持っていることを前提としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have started from the Getting Started example you should already have a completed test, including the correct `pom.xml` setup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はじめにのサンプルから始めた場合は、正しい `pom.xml`  の設定を含めて、すでにテストが完了しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file you should see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml`  ファイルには、2つのテスト依存関係があるはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-junit5`  は、テストフレームワークを制御する `@QuarkusTest`  アノテーションを提供するため、テストには必須です。 `rest-assured`  は必須ではありませんが、HTTP エンドポイントをテストするのに便利な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JUnit 5を使用しているので、 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin]のバージョンを設定する必要があります。デフォルトのバージョンはJUnit 5をサポートしていない為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `java.util.logging.manager`  システムプロパティーを設定して、テストが正しい logmanager と `maven.home`  を使用して、 `${maven.home}/conf/settings.xml` からのカスタム設定が適用されるようにしています (存在する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project should also contain a simple test:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトには簡単なテストも含まれているはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストはHTTPを使用して、RESTエンドポイントを直接テストします。テストが実行されると、テストが実行される前にアプリケーションが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Controlling the test port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートの制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはデフォルトではポート `8080`  をリッスンしますが、テストを実行する場合はデフォルトで `8081`  をリッスンします。これにより、アプリケーションを並行して実行しながらテストを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the test port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `application.properties` の `quarkus.http.test-port` を設定することで、を HTTP 用にテストで使われるポートを設定出来、 `quarkus.http.test-ssl-port` を設定することで HTTPS 用にテストで使用するポートを設定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`0` will result in the use of a random port (assigned by the operating system).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`0` を使用すると、(オペレーティングシステムによって割り当てられた)ランダムなポートが使用されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはまた、テストを実行する前にRestAssuredによって使用されるデフォルトのポートを更新するRestAssuredインテグレーションも提供しているため、追加の設定は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストで REST Assured を使用する場合、接続と応答のタイムアウトは 30 秒に設定されます。この設定は `quarkus.http.test-timeout`  プロパティーでオーバーライドできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>URLをテストに直接注入することも可能で、別のクライアントを使用するのが簡単になります。これは `@TestHTTPResource`  アノテーションで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>静的なリソースをロードするための簡単なテストを書いてみましょう。まず、シンプルなHTMLファイルを `src/main/resources/META-INF/resources/index.html` に作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will create a simple test to ensure that this is being served correctly:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが正しく提供されているかどうかを確認するための簡単なテストを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションを使用すると、QuarkusインスタンスのURLを直接注入することができます。アノテーションの値は、URLのパス部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ `@TestHTTPResource`  では、URL の `URI` , `URL` , `String`  表現を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a specific endpoint</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のエンドポイントのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured と `@TestHTTPResource`  の両方で、パスをハードコーディングするのではなく、テストするエンドポイントクラスを指定することができます。これは現在、JAX-RS エンドポイント、サーブレット、リアクティブルートの両方をサポートしています。これにより、特定のテストがどのエンドポイントをテストしているかを正確に確認することが非常に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of these examples I am going to assume we have an endpoint that looks like the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの例では、以下のようなエンドポイントを想定しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは現在、JAX-RS のコンテキストパスを設定するための `@ApplicationPath()`  アノテーションをサポートしていません。カスタムのコンテキストパスを設定したい場合は、代わりに `quarkus.resteasy.path`  の設定値を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TestHTTPResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストHTTPリソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用してエンドポイントのパスを指定することが出来、指定されたエンドポイントからパスが抽出されます。 `TestHTTPResource`  エンドポイントにも値を指定すると、エンドポイントパスの最後に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because `GreetingResource` is annotated with `@Path("/hello")` the injected URL will end with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingResource`  は `@Path("/hello")`  とアノテーションされているので、注入された URL は `/hello`  で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTassured</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured ベースパス (すなわち、すべてのリクエストのルートとなるデフォルトパス) を制御するには、 `io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用できます。これはクラスやメソッドレベルで適用できます。グリーティングリソースをテストするには、以下のようにします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells RESTAssured to prefix all requests with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、RESTAssured はすべてのリクエストの前に `/hello` を付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note we don't need to specify a path here, as `/hello` is the default for this test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストでは `/hello`  がデフォルトなので、ここでパスを指定する必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection into tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、HTTP エンドポイントを介してアプリをテストする統合スタイルのテストしか取り上げてきませんでしたが、ユニットテストを行い、Beanを直接テストしたい場合はどうでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、 `@Inject`  アノテーションを介してテストにCDI Beanを注入できるようにすることで、これをサポートしています(実際、Quarkusのテストは完全なCDI Beanなので、すべてのCDI機能を使用することができます)。HTTPを使用せずにグリーティングサービスを直接テストするシンプルなテストを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GreetingService` bean will be injected into the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingService`  Beanがテストに注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applying Interceptors to Tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへのインターセプターの適用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前述したように、Quarkusのテストは実際には完全なCDI Beanであり、通常のようにCDIインターセプターを適用することができます。例えば、トランザクションのコンテキスト内でテストメソッドを実行したい場合、 `@Transactional`  アノテーションをメソッドに適用するだけで、トランザクションインターセプターがそれを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this you can also create your own test stereotypes. For example we could create a `@TransactionalQuarkusTest` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これに加えて、独自のテスト・ステレオタイプを作成することもできます。例えば、次のように `@TransactionalQuarkusTest`  を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションをテストクラスに適用すると、 `@QuarkusTest`  と `@Transactional`  の両方のアノテーションを適用したかのように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tests and Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストとトランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストでは標準のQuarkus `@Transactional`  アノテーションを使用することができますが、これは、テストでデータベースに加えた変更が永続化されることを意味します。テストの終了時に変更をロールバックしたい場合は、 `io.quarkus.test.TestTransaction`  アノテーションを使用することができます。これは、トランザクション内でテストメソッドを実行しますが、テストメソッドが完了したらロールバックして、データベースの変更を元に戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターの代わりに、あるいはインターセプターに加えて、以下のコールバックインターフェースを実装することで、 *すべての* `@QuarkusTest` クラスを充実させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback` has been deprecated in favor of `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback` and will be removed in future releases of Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback`  は `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`  に代わって非推奨となり、Quarkusの将来のリリースでは削除される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a callback implementation has to be registered as a "service provider" as defined by `java.util.ServiceLoader`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなコールバックの実装は、 `java.util.ServiceLoader`  で定義されている「サービスプロバイダ」として登録する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g. the following sample callback:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、以下のようなサンプルコールバックです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to read annotations from the test class or method to control what the callback shall be doing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスやメソッドからアノテーションを読み込んで、コールバックが何をするかを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has
         to run tests in a custom classloader which JUnit is not aware of.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BeforeEachCallback` のような JUnit Jupiter コールバックインターフェイスを使うことも可能ですが、QuarkusはJUnitが把握しないカスタムクラスローダーでテストを実行する必要がある為、クラスローディングの問題にぶつかるかもしれません。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Different Profiles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるプロファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shutdown at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでのところ、すべての例では、すべてのテストに対して一度だけQuarkusを起動しています。最初のテストが実行される前にQuarkusが起動し、次にすべてのテストが実行され、最後にQuarkusがシャットダウンします。これにより、非常に高速なテストが可能になりますが、異なる設定をテストすることができないため、少し制限があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この問題を回避するために、Quarkusはテストプロファイルの考え方をサポートしています。以前に実行したテストとは異なるプロファイルを持つテストがある場合、Quarkusはテストを実行する前にシャットダウンされ、新しいプロファイルで開始されます。これは、テスト時間にシャットダウン/起動サイクルが追加されるため、明らかに少し遅くなりますが、非常に大きな柔軟性が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to reduce the amount of times Quarkus needs to restart it is recommended that you place all tests that need a specific profile into their own package, and then run tests alphabetically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの再起動の回数を減らすために、特定のプロファイルを必要とするすべてのテストを独自のパッケージに入れ、アルファベット順にテストを実行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Profile</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロフィールの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストプロファイルを実装するには、 `io.quarkus.test.junit.QuarkusTestProfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to override configuration properties. Here we are changing the JAX-RS root path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法では、設定プロパティーをオーバーライドすることができます。ここでは、JAX-RSのルートパスを変更しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to enable CDI `@Alternative` beans. This makes it easy to mock out certain beans functionality.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドを使うことで、CDI `@Alternative`  Beanを有効にすることができます。これにより、特定のBeanの機能を簡単にモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to change the config profile. As this default is `test` this does nothing, but is included for completeness.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは設定プロファイルを変更するために使用できます。このデフォルトは `test`  なので、これは何もしませんが、完全性を保つために含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to apply **additional** `QuarkusTestResourceLifecycleManager` classes, specific for this profile only. If this method is not overridden, then only the `QuarkusTestResourceLifecycleManager` classes enabled via the `@QuarkusTestResource` class annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドを使用すると、このプロファイル専用の `QuarkusTestResourceLifecycleManager`  クラスを *追加で* 適用することができます。このメソッドがオーバーライドされていない場合は、 `@QuarkusTestResource`  クラスアノテーションを介して有効化された `QuarkusTestResourceLifecycleManager`  クラスのみが、このプロファイルを使用するテストに使用されます (これは、プロファイルを全く使用しないテストと同じ動作です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have defined our profile we need to include it on our test class. We do this with `@TestProfile(MockGreetingProfile.class)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルを定義したので、それをテストクラスに含める必要があります。 `@TestProfile(MockGreetingProfile.class)` で、これを行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the test profile config is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストプロファイルの設定はすべて単一のクラスに保存されているので、前回のテストが同じ設定で実行されたかどうかが簡単にわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>モックサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、2つの異なるアプローチを使用したモックオブジェクトの使用をサポートしています。CDIの代替品を使用してすべてのテストクラスのBeanをモックアウトするか、 `QuarkusMock`  を使用してテストごとにBeanをモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI `@Alternative` mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI `@Alternative`  メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使用するには、 `src/test/java`  ディレクトリーのクラスでモックしたいBeanをオーバーライドし、 `@Alternative`  と `@Priority(1)`  アノテーションをBeanに配置するだけです。あるいは、便利な `io.quarkus.test.Mock`  ステレオタイプアノテーションを使用することもできます。この組み込みステレオタイプは、 `@Alternative`  、 `@Priority(1)`  、 `@Dependent`  を宣言します。例えば、以下のようなサービスがあるとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I could mock it with the following class in `src/test/java`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/test/java`  で以下のクラスでモックできました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overrides the `@Dependent` scope declared on the `@Mock` stereotype.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Mock`  ステレオタイプで宣言された `@Dependent`  スコープをオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替品が `src/main/java`  ではなく `src/test/java`  ディレクトリーに存在することが重要です。そうでなければ、テスト以外も常に有効になってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that at present this approach does not work with native image testing, as this would required the test alternatives to be baked into the native image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、このアプローチはネイティブイメージテストでは機能しないことに注意してください。テスト代替品がネイティブイメージに焼き込まれる必要がある為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.QuarkusMock`  クラスは、通常のスコープ付きBeanを一時的にモックアウトするために使用することができます。 `@BeforeAll`  メソッドでこのメソッドを使用した場合、モックは現在のクラスのすべてのテストに対して有効になりますが、test メソッドでこれを使用した場合、モックは現在のテストの間のみ有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法は、通常のスコープ付き CDI Bean(例: `@ApplicationScoped` , `@RequestScoped`  など、 `@Singleton`  と `@Dependent`  以外の基本的にすべてのスコープ)に対して使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage could look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用例は次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションされたインスタンスはここでは利用できないので、 `installMockForType` を使用します。このモックは両方のテストメソッドに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは `installMockForInstance`  を使用して注入されたBeanを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mockitoには依存しないことに注意してください。好きなモッキングライブラリを使うことができますし、必要な動作を提供するためにオブジェクトを手動でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further simplification with `@InjectMock`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock` での更なる単純化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusMock`  で提供されている機能をベースに、Quarkusでは、 `QuarkusMock`  でサポートされているBeanをモックするために link:https://site.mockito.org/[Mockito を]簡単に利用できるようにしています。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectMock`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock`  を使用すると、先ほどの例は次のように書くことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@InjectMock` results in a mock being and is available in test methods of the test class (other test classes are *not* affected by this)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock` により、モックがテストクラスのテストメソッドに存在することになり、利用可能になります (他のテストクラスはこの影響を受け *ません* )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mockableBean1` is configured here for every test method of the class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスのすべてのテストメソッドに対して `mockableBean1`  が設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the `mockableBean2` mock has not been configured, it will return the default Mockito response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mockableBean2`  のモックが設定されていないので、デフォルトの Mockito レスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this test the `mockableBean2` is configured, so it returns the configured response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストでは、 `mockableBean2`  が設定されているので、設定されたレスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のテストは `@InjectMock`  の機能を示すのには良いですが、実際のテストを上手く表してはいません。実際のテストでは、ほとんどの場合、モックを設定し、モックされたBeanを使用するBeanをテストします。以下に例を示します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`greetingService`  をモックとして設定したので、 `GreetingService`  Beanを使用する `GreetingResource`  は、通常の `GreetingService` Beanのレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spies instead of Mocks with `@InjectSpy`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `@InjectSpy` で、モックの代わりにスパイを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`InjectMock`  で提供されている機能をベースに、 `QuarkusMock`  でサポートされているBeanをスパイするために link:https://site.mockito.org/[Mockito ]を簡単に利用できるようにしました。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectSpy`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを行う際に、特定の論理パスが取られたかどうかを確認するだけで済む場合もありますし、Spied クローン上で残りのメソッドを実行している間に、1つのメソッドのレスポンスをスタブアウトするだけで済む場合もあります。Spy パーシャル モックの詳細については link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito のドキュメント]を参照してください。いずれの場合も、オブジェクトの Spy が望ましいでしょう。 `@InjectSpy`  を使用して、先ほどの例は次のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値をオーバーライドするのではなく、 `GreetingService`  の greet メソッドがこのテストで呼び出されたことを確認したいだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we are telling the Spy to return "hi" instead of "hello". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、"hello"の代わりに"hi"を返すようにSpyに指示しています。 `GreetingResource`  が `GreetingService`  から挨拶を要求するとき、通常の `GreetingService`  Bean のレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are verifying that we get the mocked response from the Spy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、スパイからのモックされた応答を得ることを検証しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock` with `@RestClient`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock`  との併用 `@RestClient`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@RegisterRestClient`  は、実行時に rest-client の実装を登録しています。Beanは通常のスコープである必要があるため、インターフェイスに `@ApplicationScoped` を付与する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the test class here is an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスの例です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that this injection point is meant to use an instance of `RestClient`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この注入ポイントが `RestClient`  のインスタンスを使用することを意味していることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the link:hibernate-orm-panache#mocking[Hibernate ORM with Panache Mocking] and link:mongodb-panache#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-hibernate-orm-panache`  や `quarkus-mongodb-panache` のエクステンションを使っている場合は、 link:hibernate-orm-panache#mocking[Hibernate ORM とPanache Mocking]や link:mongodb-panache#mocking[MongoDB とPanache Mocking]のドキュメントをチェックして、データアクセスをモックする最も簡単な方法を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus Security, check out the link:security-testing[Testing Security] section for information on how to easily test security features of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityを使用している場合、アプリケーションのセキュリティー機能を簡単にテストする方法については、「 link:security-testing[セキュリティーのテスト]」のセクションをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非常に一般的なニーズは、Quarkusアプリケーションがテストを開始する前に、Quarkusアプリケーションに依存するいくつかのサービスを開始することです。このニーズに対応するために、Quarkusでは、 `@io.quarkus.test.common.QuarkusTestResource`  と `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[here]), or starting a mock HTTP server using http://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here]).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、 `QuarkusTestResourceLifecycleManager`  の実装がいくつか提供されていますが(H2データベースを起動する `io.quarkus.test.h2.H2DatabaseTestResource` や、モックKubernetes APIサーバーを起動する `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource`  を参照)、特定のアプリケーションのニーズに対応するためにカスタム実装を作成するのが一般的です。一般的なケースとしては、 link:https://www.testcontainers.org/[Testcontainers]を使ってdockerコンテナーを起動したり(その例は link:https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[こちら]にあります)、 link:http://wiremock.org/[Wiremock]を使ってモックHTTPサーバを起動したり(その例は link:https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[こちら]にあります)などがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to test native executables using `@NativeImageTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@NativeImageTest` を使用してネイティブ実行ファイルをテストすることも可能です。これは、テストに注入すること(そして、ネイティブ実行可能ファイルは別の非JVMプロセスで実行されることーこれは実際には可能ではありません)を除いて、このガイドで述べたすべての機能をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is covered in the link:building-native-image[Native Executable Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは link:building-native-image[ネイティブ実行可能ファイルガイド] で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running `@QuarkusTest` from an IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE から `@QuarkusTest`  を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most IDEs offer the possibility to run a selected class as JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ほとんどの IDE では、選択したクラスを JUnit テストとして直接実行できるようになっています。そのためには、選択した IDE の設定でいくつかのプロパティーを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.logging.manager` (see link:logging[Logging Guide])</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java.util.logging.manager`  (ロ link:logging[ギングガイド]を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`maven.settings`  (カスタム版の `settings.xml`  ファイルをテストに使用する場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy your current "Installed JRE" definition into a new one, where you will add the properties as a new VM arguments:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の"Installed JRE"定義を新しい定義にコピーし、新しいVMの引数としてプロパティーを追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Dmaven.home=&lt;path-to-your-maven-installation&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`-Dmaven.home=&amp;amp;lt;path-to-your-maven-installation&amp;amp;gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any "Run as JUnit" configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このJRE定義をQuarkusプロジェクトのターゲットランタイムとして使用すると、「Run as JUnit」設定に回避策が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VSCode "run with" configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VSCode "run with" 設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `settings.json` placed in the root of your project directory or in the workspace will need the workaround in your test configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトディレクトリーやワークスペースのルートにある `settings.json`  は、テスト設定で回避策が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing needed in IntelliJ because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJでは何も必要ありません。なぜなら、IDEは `systemPropertyVariables` を `pom.xml`のsurefireプラグイン設定から取得するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `kubernetes-config` extension which allows developers to use Kubernetes https://cloud.google.com/kubernetes-engine/docs/concepts/configmap[ConfigMaps] and https://cloud.google.com/kubernetes-engine/docs/concepts/secret[Secrets] as a configuration source, without having to mount them into the https://kubernetes.io/docs/concepts/workloads/pods/pod/[Pod] running the Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、 `kubernetes-config` エクステンションが含まれており、開発者はQuarkusアプリケーションを実行している link:https://kubernetes.io/docs/concepts/workloads/pods/pod/[Pod] にマウントしなくても、Kubernetes link:https://cloud.google.com/kubernetes-engine/docs/concepts/configmap[ConfigMaps] と link:https://cloud.google.com/kubernetes-engine/docs/concepts/secret[Secrets] を設定ソースとして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `kubernetes-config` extension by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリーで以下のコマンドを実行して、 `kubernetes-config` エクステンションを追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension works by reading ConfigMaps and Secrets directly from the Kubernetes API server using the link:kubernetes-client[Kubernetes Client].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、Kubernet link:kubernetes-client[Kubernates クライアント] を使用してKubernetes APIサーバーから直接ConfigMapsとSecretsを読み込むことで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension understands the following types of ConfigMaps and Secrets as input sources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、以下のタイプの ConfigMaps と Secrets を入力ソースとして理解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMaps and Secrets that contain literal data (see https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values[this] for an example on how to create one)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リテラルデータを含む ConfigMaps と Secrets (作成方法の例は link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-literal-values[こちら] を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMaps and Secrets created from files named `application.properties`, `application.yaml` or `application.yml` (see https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files[this] for an example on how to create one).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsとSecretsは、 `application.properties` 、 `application.yaml` 、または `application.yml` という名前のファイルから作成されます(作成方法の例は link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-configmaps-from-files[こちら] を参照してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have to explicitly enable the retrieval of ConfigMaps and Secrets by setting `quarkus.kubernetes-config.enabled=true`.  The default is `false` in order to make it easy to test the application locally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMaps と Secrets の取得を明示的に有効にするには、 `quarkus.kubernetes-config.enabled=true` を設定する必要があります。デフォルトは `false` で、ローカルでのアプリケーションのテストを容易にするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Afterwards, set the `quarkus.kubernetes-config.config-maps` property to configure which ConfigMaps should be used.  Set the `quarkus.kubernetes-config.secrets` property to configure which Secrets should be used.  To access ConfigMaps and Secrets from a specific namespace, you can set the `quarkus.kubernetes-config.namespace` property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、 `quarkus.kubernetes-config.config-maps` プロパティーを設定して、どの ConfigMaps を使用するかを設定します。 `quarkus.kubernetes-config.secrets` プロパティーを設定して、どの Secrets を使用するかを設定します。特定の名前空間の
 ConfigMaps と Secrets にアクセスするには、 `quarkus.kubernetes-config.namespace` プロパティーを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Priority of obtained properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>取得したプロパティーの優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties obtained from the ConfigMaps and Secrets have a higher priority than (i.e. they override) any properties of the same name that are found in `application.properties` (or the YAML equivalents), but they have lower priority than properties set via Environment Variables or Java System Properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsとSecretsから取得したプロパティーは、 `application.properties` (またはYAMLの等価物)にある同名のプロパティーよりも高い優先度を持っています(すなわち、それらは上書きされます)が、環境変数やJavaシステムプロパティーを介して設定されたプロパティーよりも優先度は低くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, when multiple ConfigMaps (or Secrets) are used, ConfigMaps (or Secrets) defined later in the list have a higher priority that ConfigMaps defined earlier in the list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、複数のConfigMap(またはSecret)を使用している場合、後から定義されたConfigMap(またはSecret)は、先に定義されたConfigMap(またはSecret)よりも優先度が高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, when both ConfigMaps and Secrets are used, the latter always a higher priority than the former.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ConfigMapsとSecretsの両方を使用する場合、常に後者の方が前者よりも優先度が高くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since reading ConfigMaps involves interacting with the Kubernetes API Server, when https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] is enabled on the cluster, the https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[ServiceAccount] that is used to run the application needs to have the proper permissions for such access.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsの読み込みにはKubernetes API Serverとのやりとりが含まれるため、クラスター上で link:https://kubernetes.io/docs/reference/access-authn-authz/rbac/[RBAC] が有効になっている場合、アプリケーションを実行するために使用される link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[ServiceAccount] に適切なアクセス権限が必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thankfully, when using the `kubernetes-config` extension along with the link:deploying-to-kubernetes[Kubernetes] extension, all the necessary Kubernetes resources to make that happen are automatically generated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ありがたいことに、 link:deploying-to-kubernetes[Kubernetes] エクステンションと一緒に `kubernetes-config` エクステンションを使うと、それを実現するために必要なKubernetesリソースがすべて自動的に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secrets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Secrets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the link:deploying-to-kubernetes[Kubernetes] extension doesn't generate the necessary resources to allow accessing secrets.  Set `quarkus.kubernetes-config.secrets.enabled=true` to generate the necessary role and corresponding role binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 link:deploying-to-kubernetes[Kubernetes] エクステンションは秘密にアクセスできるようにするために必要なリソースを生成しません。 `quarkus.kubernetes-config.secrets.enabled=true` を設定して、必要なロールと対応するロールバインディングを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Introduction to Contexts and Dependency Injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - コンテキストと依存性注入(CDI)の紹介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we're going to describe the basic principles of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本原理について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OK. Let's start simple. What is a bean?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OK、簡単なことから始めましょう。Beanとは何でしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanは _コンテナーで管理された_ オブジェクトです。依存性の注入、ライフサイクルコールバック、インターセプターなどの基本的なサービスのセットをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wait a minute. What does "container-managed" mean?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ちょっと待ってください。「コンテナーで管理された」とはどういう意味ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simply put, you don't control the lifecycle of the object instance directly.  Instead, you can affect the lifecycle through declarative means, such as annotations, configuration, etc.  The container is the _environment_ where your application runs.  It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>簡単に言えば、オブジェクトインスタンスのライフサイクルを直接制御することはできません。その代わりに、アノテーションや設定などの宣言的な手段でライフサイクルに影響を与えることができます。コンテナーはアプリケーションが動作する _環境_ です。コンテナーは、Beanのインスタンスを作成したり破棄したり、指定されたコンテキストにインスタンスを関連付けたり、他のBeanに注入したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is it good for?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何に使うと適切ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An application developer can focus on the business logic rather than finding out "where and how" to obtain a fully initialized component with all of its dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション開発者は、「どこで、どのように」ではなく、ビジネスロジックに集中して、すべての依存関係を持つ完全に初期化されたコンポーネントを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_制御の反転_ (Inversion of Control, IoC )というプログラミングの原理を聞いたことがあると思います。依存性注入はIoCの実装技術の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are several kinds of beans.  The most common ones are class-based beans:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanにはいくつかの種類があります。一番多いのは、クラスベースのBeanです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Bean Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなBeanの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all other beans that inject `Translator`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはスコープアノテーションです。これはコンテナーに、Beanのインスタンスをどのコンテキストに関連付けるかを伝えます。この特定のケースでは、 *単一のBeanインスタンス* がアプリケーション用に作成され、 `Translator`の注入を行う他の全てのBeanによって使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはフィールド注入ポイントです。 `Translator`  が `Dictionary`  Beanに依存していることをコンテナーに伝えます。マッチするBeanがない場合、ビルドは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics. We will talk about &lt;&lt;interceptors,interceptors&gt;&gt; later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはインターセプター結合アノテーションです。この場合、アノテーションは MicroProfile Metrics から来ています。関連するインターセプターは呼び出しをインターセプトし、関連するメトリクスを更新します。 &lt;&lt;interceptors,インターセプター&gt;&gt;については後述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nice. How does the dependency resolution work? I see no names or identifiers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いいですね。依存関係の解決方法はどのように動作しますか?名前も識別子も見当たりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's a good question.  In CDI the process of matching a bean to an injection point is *type-safe*.  Each bean declares a set of bean types.  In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.  Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.  We'll talk about qualifiers later.  For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>良い質問ですね。CDIでは、Beanをインジェクションポイントにマッチングするプロセスは *タイプセーフ* です。各Beanは、Beanタイプのセットを宣言します。上の例では、 `Translator` Beanには、 `Translator` と `java.lang.Object` の 2 つのBeanタイプがあります。その後、Beanが _必要な型_ にマッチするBean型を持ち、 _必要な_ すべての _修飾子を_ 持っている場合、Beanはインジェクションポイントに代入可能です。この後、修飾子について説明します。今のところ、上記のBeanが `Translator` と `java.lang.Object` のタイプのインジェクションポイントに代入可能であることを知っていれば十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hm, wait a minute. What happens if multiple beans declare the same type?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ふむ、ちょっと待ってください。複数のBeanが同じ型を宣言した場合はどうなるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.  If none is assignable the build fails with `UnsatisfiedResolutionException`.  If multiple are assignable the build fails with `AmbiguousResolutionException`.  This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなルールがあります: *正確に1つのBeanがインジェクションポイントに割り当て可能でなければならず、そうでなければビルドは失敗します。* 割り当て可能なBeanがない場合、ビルドは `UnsatisfiedResolutionException` で失敗します。複数のBeanが割り当て可能な場合、ビルドは `AmbiguousResolutionException` で失敗します。これは非常に便利です。コンテナーがどのインジェクションポイントに対しても明確な依存関係を見つけることができない場合、アプリケーションは早く失敗するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your can use programmatic lookup via `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.inject.Instance`  を通じてプログラム的なルックアップを使用して、実行時に曖昧さを解決したり、指定された型を実装しているすべてのBeanを反復処理したりすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このインジェクションポイントは、 `Dictionary`  型を実装した複数のBeanがあっても、曖昧な依存関係にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.inject.Instance` extends `Iterable`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.inject.Instance` は `Iterable` を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I use setter and constructor injection?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セッターやコンストラクタのインジェクションは使えますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, you can.  In fact, in CDI the "setter injection" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window="_blank"].  Initializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、できます。実際には、CDIでは「セッターインジェクション」は、より強力な link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[イニシャライザメソッド, window="_blank"] に取って代わられています。イニシャライザは複数のパラメーターを受け入れることができ、JavaBeanの命名規則に従う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initialized and Constructor Injection Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初期化とコンストラクタのインジェクション例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a constructor injection.  In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor and the bean constructor must be annotated with `@Inject`.  However, in Quarkus we detect the absence of no-args constructor and "add" it directly in the bytecode.  It's also not necessary to add `@Inject` if there is only one constructor present.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはコンストラクタのインジェクションです。実際には、このコードは通常のCDI実装では動作しません。通常のスコープを持つBeanは常にno-argsコンストラクタを宣言しなければならず、Beanのコンストラクタは `@Inject`  でアノテーションされなければなりません。しかし、Quarkusでは、no-argsコンストラクタが存在しないことを検出し、バイトコードに直接「追加」します。また、コンストラクタが1つしかない場合は、 `@Inject`  を追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer method must be annotated with `@Inject`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イニシャライザメソッドには `@Inject`  をアノテーションしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer may accept multiple parameters - each one is an injection point.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イニシャライザは複数のパラメーターを受け付けることができ、それぞれがインジェクションポイントとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You talked about some qualifiers?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>修飾子の話をしましたか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window="_blank"] are annotations that help the container to distinguish beans that implement the same type.  As we already said a bean is assignable to an injection point if it has all the required qualifiers.  If you declare no qualifier at an injection point the `@Default` qualifier is assumed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[修飾子, window="_blank"] は、コンテナーが同じ型を実装したBeanを区別するのに役立つアノテーションです。既に述べたように、Beanは必要な修飾子をすべて持っていれば、インジェクションポイントに割り当てることができます。インジェクションポイントで修飾子を宣言しない場合は、 `@Default` の修飾子が想定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and annotated with the `@javax.inject.Qualifier` meta-annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Qualifier型は、 `@Retention(RUNTIME)`  として定義された Java アノテーションで、 `@javax.inject.Qualifier`  メタアノテーションでアノテーションされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>修飾子の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanの修飾子は、Beanクラスやプロデューサのメソッドやフィールドに修飾子タイプをアノテーションすることで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean With Custom Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム修飾子を持つ Bean の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Superior`  は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[修飾子アノテーション, window=_blank]です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject Translator`.  The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.  And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このBeanは `@Inject @Superior Translator`  と `@Inject @Superior SuperiorTranslator`  には割り当てられますが、 `@Inject Translator`  には割り当てられません。その理由は、 `@Inject Translator`  はタイプセーフ解決の際に自動的に `@Inject @Default Translator`  に変換されるからです。また、私たちの `SuperiorTranslator`  は `@Default`  を宣言していないので、元の `Translator`  Beanだけが代入可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Looks good. What is the bean scope?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>良いですね。Beanスコープとは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanのスコープはインスタンスのライフサイクルを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every bean has exactly one scope.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのBeanは、正確に1つのスコープを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What scopes can I actually use in my Quarkus application?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実際にQuarkusアプリケーションで使用できるスコープは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.context.ConversationScoped` 以外の仕様で言及されているすべてのビルトインスコープを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description   
//----------------------</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>説明   
//----------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.ApplicationScoped`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@javax.enterprise.context.ApplicationScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the &lt;&lt;client_proxies, client proxy&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>単一のBeanインスタンスがアプリケーションに使用され、すべてのインジェクションポイント間で共有されます。 link:#client_proxies[インスタンス] は遅延的に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.inject.Singleton`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@javax.inject.Singleton`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just like `@ApplicationScoped` except that no client proxy is used. The instance is created when an injection point that resolves to a @Singleton bean is being injected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシーを使用しないことを除いて、 `@ApplicationScoped` と同じです。インスタンスは、@Singleton Beanに解決するインジェクションポイントがインジェクションされたときに生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.RequestScoped`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@javax.enterprise.context.RequestScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean instance is associated with the current _request_ (usually an HTTP request).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanインスタンスは、現在の _リクエスト_ (通常はHTTPリクエスト)に関連付けられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.Dependent`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@javax.enterprise.context.Dependent`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a pseudo-scope. The instances are not shared and every injection point spawns a new instance of the dependent bean. The lifecycle of dependent bean is bound to the bean injecting it - it will be created and destroyed along with the bean injecting it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは疑似スコープです。インスタンスは共有されておらず、すべての注入ポイントは依存Beanの新しいインスタンスをスポーンします。依存Beanのライフサイクルは、それを注入するBeanに拘束されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@javax.enterprise.context.SessionScoped`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@javax.enterprise.context.SessionScoped`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This scope is backed by a `javax.servlet.http.HttpSession` object. It's only available if the `quarkus-undertow` extension is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このスコープは `javax.servlet.http.HttpSession` オブジェクトによってバックアップされています。 `quarkus-undertow` エクステンションを使用している場合のみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There can be other custom scopes provided by Quarkus extensions. For example, `quarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションによって提供される他のカスタムスコープもあります。例えば、 `quarkus-narayana-jta` は `javax.transaction.TransactionScoped` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` and `@Singleton` look very similar. Which one should I choose for my Quarkus application?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ApplicationScoped` と `@Singleton` は非常に似ているように見えます。Quarkusアプリケーションにはどれを選べばいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It depends ;-).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは場合によりけりです ;-)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `@Singleton` bean has no &lt;&lt;client_proxies,client proxy&gt;&gt; and hence an instance is _created eagerly_ when the bean is injected. By contrast, an instance of an `@ApplicationScoped` bean is _created lazily_, i.e.  when a method is invoked upon an injected instance for the first time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Singleton` Beanは link:#client_proxies[クライアントプロキシー] を持たないので、Beanがインジェクトされるとインスタンスは _熱心に(eagerly)生成され_ ます。対照的に、 `@ApplicationScoped` Beanのインスタンスは _怠惰(lazily)に生成されます。_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, client proxies only delegate method invocations and thus you should never read/write fields of an injected `@ApplicationScoped` bean directly.  You can read/write fields of an injected `@Singleton` safely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、クライアントプロキシーはメソッドの呼び出しを委譲するだけなので、注入された `@ApplicationScoped` Bean のフィールドを直接読み書きしてはいけません。注入された `@Singleton` のフィールドは安全に読み書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Singleton` should have a slightly better performance because the is no indirection (no proxy that delegates to the current instance from the context).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Singleton` はインダイレクトがない(コンテキストから現在のインスタンスをデリゲートするプロキシーがない)ため、パフォーマンスが若干向上するはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the other hand, you cannot mock `@Singleton` beans using &lt;&lt;getting-started-testing.adoc#quarkus_mock,QuarkusMock&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一方、 link:getting-started-testing.html#quarkus_mock[QuarkusMockを] 使って `@Singleton` Beanをモックすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` beans can be also destroyed and recreated at runtime.  Existing injection points just work because the injected proxy delegates to the current instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ApplicationScoped` Beanは、実行時に破棄して再作成することもできます。既存のインジェクションポイントは、インジェクションされたプロキシーが現在のインスタンスにデリゲートするので、単に機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Therefore, we recommend to stick with `@ApplicationScoped` by default unless there's a good reason to use `@Singleton`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>したがって、 `@Singleton` を使用する正当な理由がない限り、デフォルトで `@ApplicationScoped` を使用することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I don't understand the concept of client proxies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシーの概念が理解できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window="_blank"] could be hard to grasp but they provide some useful functionality.  A client proxy is basically an object that delegates all method invocations to a target bean instance.  It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実際、 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[クライアントプロキシー, window=_blank]は理解するのが難しいかもしれませんが、いくつかの有用な機能を提供します。クライアントプロキシーは基本的に、すべてのメソッド呼び出しをターゲットのBeanインスタンスに委譲するオブジェクトです。これは `io.quarkus.arc.ClientProxy`  を実装し、Bean クラスを拡張したコンテナー構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies only delegate method invocations. So never read or write a field of a normal scoped bean, otherwise you will work with non-contextual or stale data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシーはメソッドの呼び出しをデリゲートするだけです。そのため、通常のスコープされたBeanのフィールドを読み書きしてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generated Client Proxy Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたクライアントプロキシーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Translator_ClientProxy` instance is always injected instead of a direct reference to a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[contextual instance, window="_blank"] of the `Translator` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Translator_ClientProxy`  インスタンスは、 `Translator`  Beanの link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[コンテキストインスタンス, window=_blank]への直接参照の代わりに、常に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies allow for:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシーは、以下のことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy instantiation - the instance is created once a method is invoked upon the proxy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅延インスタンス化 - メソッドがプロキシーに呼び出されるとインスタンスが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ability to inject a bean with "narrower" scope to a bean with "wider" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>「狭い」スコープのBeanを「広い」スコープのBeanに注入する機能、すなわち、 `@RequestScoped`  Beanを `@ApplicationScoped`  Beanに注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, but sometimes it's inevitable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係グラフの円形の依存関係。循環的な依存関係を持つことは、しばしば再設計を検討すべきであることを示していますが、時には避けられないこともあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まれなケースでは、手動でBeanを破棄するのが現実的です。直接参照を注入すると、古くなったBeanのインスタンスになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OK. You said that there are several kinds of beans?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そうですか。Beanは何種類かあるんですよね?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes. In general, we distinguish:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、一般的には以下に区別しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer fields</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans are usually provided by extensions. Therefore, we are not going to cover them in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>合成Beanは通常、エクステンションによって提供されます。そのため、このガイドではそれらを取り上げません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods and fields are useful if you need additional control over instantiation of a bean.  They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサ・メソッドとフィールドは、Beanのインスタンス化を追加で制御する必要がある場合に便利です。また、サードパーティのライブラリを統合する際に、クラスソースを制御できず、追加のアノテーションなどを追加できない場合にも便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producers Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the field annotations to build a bean metadata.  The _type_ is used to build the set of bean types.  In this case, it will be `double` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは,フィールドアノテーションを分析して,Beanのメタデータを構築します。 _型_ は,Beanの型の集合を構築するために使用されます。この場合、 `double`  と `java.lang.Object` .スコープアノテーションは宣言されていないので、デフォルトは `@Dependent` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will read this field when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは、Beanのインスタンスを作成するときにこのフィールドを読みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the method annotations to build a bean metadata.  The _return type_ is used to build the set of bean types.  In this case, it will be `List&lt;String&gt;`, `Collection&lt;String&gt;`, `Iterable&lt;String&gt;` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは,メソッドのアノテーションを解析して,Beanのメタデータを構築します。戻り値の _型_ は、Bean型のセットを構築するために使用されます。この場合、 `List&lt;String&gt;` と `Collection&lt;String&gt;`、 `Iterable&lt;String&gt;`、 `java.lang.Object` となります。スコープアノテーションは宣言されていないので、デフォルトは `@Dependent`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will call this method when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーは、Beanのインスタンスを作成する際にこのメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's more about producers.  You can declare qualifiers, inject dependencies into the producer methods parameters, etc.  You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーについては他にもあります。修飾子を宣言したり、プロデューサーメソッドのパラメーターに依存性を注入したりすることができます。プロデューサについては、例えば link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld, window=_blank] のドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OK, injection looks cool. What other services are provided?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OK、インジェクションは便利ですね。他にはどんなサービスが提供されていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルコールバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanクラスは、ライフサイクル `@PostConstruct`  と `@PreDestroy`  コールバックを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルコールバックの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコールバックは、Beanインスタンスがサービスに投入される前に呼び出されます。ここでいくつかの初期化を行うのが安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコールバックは、Beanインスタンスが破棄される前に呼び出されます。ここでいくつかのクリーンアップタスクを実行しても安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a good practice to keep the logic in the callbacks "without side effects", i.e. you should avoid calling other beans inside the callbacks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コールバック内のロジックを「副作用なし」に保つこと、つまり、コールバック内で他のBeanを呼び出すことは避けるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors are used to separate cross-cutting concerns from business logic.  There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターは、横断的な問題をビジネス・ロジックから分離するために使用されます。基本的なプログラミングモデルとセマンティクスを定義した Java Interceptors という別の仕様があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Interceptor Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなインターセプターの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、インターセプターをBeanにバインドするために使用されるインターセプターバインディングアノテーションです。Beanクラスに `@Logged`  をアノテーションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Priority` enables the interceptor and affects the interceptor ordering. Interceptors with smaller priority values are called first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Priority`  はインターセプターを有効にし、インターセプターの順序に影響を与えます。優先度の値が小さいインターセプターが最初に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Marks an interceptor component.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターコンポーネントをマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interceptor instance may be the target of dependency injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターインスタンスは、依存性注入の対象となる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AroundInvoke` denotes a method that interposes on business methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AroundInvoke`  とは、ビジネスの方法に口出しする方法を指します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターチェーンの次のインターセプターに進むか、インターセプターされたビジネスメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepted bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプタのインスタンスは、インターセプトするBeanのインスタンスに依存するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events and Observers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントとオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans may also produce and consume events to interact in a completely decoupled fashion.  Any Java object can serve as an event payload.  The optional qualifiers act as topic selectors.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanは、完全に分離された方法で相互作用するために、イベントを生成したり消費したりすることもできます。任意の Java オブジェクトをイベントのペイロードとして使用できます。オプションの修飾子は、トピックセレクタとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Event Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなイベントの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.event.Event` is used to fire events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.event.Event`  は、イベントの火付けに使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fire the event synchronously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントを同期的に発生させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is notified when a `TaskCompleted` event is fired.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、 `TaskCompleted`  イベントが発生したときに通知されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more info about events/observers visit https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベント/オブザーバーの詳細については、 link:https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docsを, window=_blank]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we've covered some of the basic topics of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.  However, a full CDI implementation is not used under the hood.  Quarkus only implements a subset of the CDI features - see also &lt;&lt;cdi-reference.adoc#supported_features,the list of supported features&gt;&gt; and &lt;&lt;cdi-reference.adoc#limitations,the list of limitations&gt;&gt;.  On the other hand, there are quite a few &lt;&lt;cdi-reference#nonstandard_features,non-standard features&gt;&gt; and &lt;&lt;cdi-reference.adoc#build_time_apis,Quarkus-specific APIs&gt;&gt;.  We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本的なトピックをいくつか取り上げました。ただし、CDIの完全な実装が使用されている訳ではありません。QuarkusはCDI link:cdi-reference.html#supported_features[機能]のサブセットのみを実装しています。一方で、 link:cdi-reference.html#nonstandard_features[非標準の機能]や link:cdi-reference.html#build_time_apis[Quarkus固有のAPI]もかなりの数があります。私たちの努力は、将来的にビルドタイム指向の開発者スタックに向けてCDI仕様の革新を推進するものと信じています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to learn more about Quarkus-specific features and limitations there is a Quarkus link:cdi-reference[CDI Reference Guide].  We also recommend you to read the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex topics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus固有の機能や制限について詳しく知りたい場合は、Quarkus link:cdi-reference[CDIリファレンスガイド]があります。また、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDIの仕様]や link:https://docs.jboss.org/weld/reference/latest/en-US/html/[Weldのドキュメント](WeldはCDIリファレンスインプリメンテーションです)を読んで、より複雑なトピックに精通することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes how to test Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus Securityのテスト方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring User Information</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー情報の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use link:security-properties[quarkus-elytron-security-properties-file] for testing security. This supports both embedding user info in `application.properties` and standalone properties files.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーをテストするために link:security-properties[quarkus-elytron-security-properties-file] を使用することができます。これは `application.properties` へのユーザー情報の埋め込みとスタンドアロンのプロパティーファイルの両方をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test Security Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーエクステンションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides explicit support for testing with different users, and with the security subsystem disabled. To use this you must include the `quarkus-test-security` artifact:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、異なるユーザーでのテストや、セキュリティーサブシステムを無効にした状態でのテストを明示的にサポートしています。これを使用するには、 `quarkus-test-security` のアーティファクトを含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This artifact provides the `io.quarkus.test.security.TestSecurity` annotation, that can be applied to test methods and test classes to control the security context that the test is run with. This allows you to do two things, you can disable authorization so tests can access secured endpoints without needing to be authenticated, and you can specify the identity that you want the tests to run under.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアーティファクトは `io.quarkus.test.security.TestSecurity` アノテーションを提供します。これをテストメソッドやテストクラスに適用することで、テストが実行されるセキュリティーコンテキストを制御することができます。認証を必要とせずに安全なエンドポイントにテストがアクセスできるように認証を無効にすることができ、テストを実行する際の ID を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A test that runs with authorization disabled can just set the enabled property to false:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可を無効にして実行されるテストは、enabled プロパティーを false に設定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will disable all access checks, which allows the test to access secured endpoints without needing to authenticate.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、すべてのアクセスチェックが無効になり、認証を必要とせずに保護されたエンドポイントにアクセスできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use this to configure the current user that the test will run as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使用して、テストを実行する現在のユーザーを設定することもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will run the test with an identity with the given username and roles. Note that these can be combined, so you can disable authorization while also providing an identity to run the test under, which can be useful if the endpoint expects an identity to be present.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、指定されたユーザー名とロールを持つ ID でテストを実行します。これらを組み合わせることができるので、認証を無効にしながらテストを実行するための ID を提供することができることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The feature is only available for `@QuarkusTest` and will **not** work on a `@NativeImageTest`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能は `@QuarkusTest` でのみ利用可能で、 `@NativeImageTest` では動作 *しません*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixing security tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティーテストの混合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it becomes necessary to test security features using both `@TestSecurity` and Basic Auth (which is the fallback auth mechanism when none is defined), then Basic Auth needs to be enabled explicitly, for example by setting `quarkus.http.auth.basic=true` or `%test.quarkus.http.auth.basic=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@TestSecurity` と Basic Auth の両方を使ってセキュリティー機能をテストする必要が出てきた場合 (何も定義されていない場合のフォールバック認証メカニズムです)、明示的に有効にする必要があり、例えば `quarkus.http.auth.basic=true` や`%test.quarkus.http.auth.basic=true` と設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Wiremock for Integration Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合テストにWiremockを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use Wiremock to mock the authorization OAuth2 and OIDC services: See link:security-oauth2#integration-testing[OAuth2 Integration testing] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Wiremockを使ってauthorization OAuth2とOIDCサービスをモックすることもできます。詳細は link:security-oauth2#integration-testing[OAuth2 統合テスト]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an elastically scalable in-memory data store that you can embed directly in your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanは、アプリケーションに直接埋め込むことができる拡張性の高いインメモリーデータストアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://infinispan.org/documentation/[Infinispan documentation] to find out more about the Infinispan project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanプロジェクトの詳細については、Infinispanの link:https://infinispan.org/documentation/[ドキュメント] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command adds the following dependency to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、以下の依存関係を `pom.xml` に追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feature Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>機能サポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension offers core caching functionality that includes clustered caches, off-heap memory, data persistence, and transactions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションは、クラスター化キャッシュ、オフヒープメモリー、データ永続化、トランザクションを含むコアキャッシング機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension does not currently support indexing capabilities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションは、現在のところインデックス機能をサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Infinispan caches for transactional operations with a specific `TransactionManagerLookup`, as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan キャッシュを特定の `TransactionManagerLookup` でトランザクション処理用に設定するには、以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, see the Quarkus link:transaction[Transaction Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、Quarkus link:transaction[トランザクションガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Limitations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブの制限</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running Infinispan in native mode, some limitations apply:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードでInfinispanを実行する場合、いくつかの制限が適用されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX management is not supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JMX管理には対応していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM does not allow native VM interfaces.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMは、ネイティブVMインターフェースを許可していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`UDP`/`Multicast` is not supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`UDP` / `Multicast` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must use `TCP` transport and a non-UDP based membership protocol with JGroups.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JGroupsでは、 `TCP` トランスポートと非UDPベースのメンバーシッププロトコルを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection (CDI)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクション(CDI)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension provides injection capabilities so you do not have to configure and start caches manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションはインジェクション機能を提供するので、手動でキャッシュを設定して起動する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional injection functionality will be available in future versions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のインジェクション機能は、将来のバージョンで利用可能になる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the main entry point to configure and obtain caches.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュを設定したり取得したりするためのメインのエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX elements are disabled during native runtime so you can use the same configuration file in JVM and native modes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JMX要素はネイティブ実行時には無効化されるので、JVMとネイティブモードで同じ設定ファイルを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, you need to configure Maven as indicated in the link:maven-config.html[Maven configuration page].  Then, you can scaffold a new project with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:maven-config.html[Mavenの設定ページ] に示されているように、Mavenを設定する必要があることを覚えておいてください。その後、以下のように新しいプロジェクトをスキャフォールド (枠組みの生成) 出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you decide to generate a REST resource (using the `className` attribute), the endpoint is exposed at: `http://localhost:8080/$root/$path`.  If you use the default `root` and `path`, the URL is: http://localhost:8080/hello.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST リソースを生成することにした場合 ( `className` 属性を使用)、エンドポイントは次の場所で公開されます。 `http://localhost:8080/$root/$path` .デフォルトの `root` と `path` を使用する場合、URL は http://localhost:8080/hello です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `Dockerfile` is also generated in `src/main/docker`.  Instructions to build the image and run the container are written in the `Dockerfile`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Dockerfile` `src/main/docker` も生成されています。イメージをビルドしてコンテナーを実行する手順は `Dockerfile` に書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can list extensions with: `mvn quarkus:list-extensions`.  You can enable an extension using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをリストアップするには、次のようにします: `mvn quarkus:list-extensions` 。エクステンションの有効化は次のコマンドで可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a built-in development mode.  Run you application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには開発モードが組み込まれています。次のようにアプリケーションを実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn compile quarkus:dev</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn compile quarkus:dev</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then update the application sources, resources and configurations.  The changes are automatically reflected in your running application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、アプリケーションのソース、リソース、および設定を更新することができます。変更は、実行中のアプリケーションに自動的に反映されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run a Quarkus application in debug mode using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のコマンドで、Quarkusアプリケーションをデバッグモードで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn compile quarkus:dev -Ddebug=true</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn compile quarkus:dev -Ddebug=true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `mvn compile quarkus:dev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のターミナルで `mvn compile quarkus:dev` を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `mvn compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のターミナルまたは組込ターミナルで、 `mvn compile quarkus:dev` を実行してください。では、お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Apache Netbeans**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Apache Netbeans**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `mvn compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のターミナルまたは組込ターミナルで、プロジェクトのルートに移動し、 `mvn compile quarkus:dev` を実行してください。では、お楽しみください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the outset {project-name} has been designed around a container first philosophy.  What this means in real terms is that {project-name} is optimised for low memory usage and fast startup times in the following ways:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初から {project-name} はコンテナーファーストの哲学に基づいて設計されています。これが実際に意味することは、{project-name} は以下の方法でメモリー使用量を抑え、起動時間を短縮するように最適化されているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Substrate support has been an important part of the design for {project-name} from the beginning.  When an application is compiled down to a native image it starts much faster and can run with a much smaller heap than a standard JVM. {project-name} are all tested in Substrate, and can run without the `-H:+ReportUnsupportedElementsAtRuntime` flag.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サブストレートのサポートは、最初から {project-name} の設計の重要な部分でした。アプリケーションがネイティブイメージにコンパイルされると、標準的なJVMよりもはるかに高速に起動し、より小さなヒープで実行することができます。project-name} はすべて Substrate でテストされており、 `-H:+ReportUnsupportedElementsAtRuntime` フラグなしで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Metadata Processing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドタイムメタデータ処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much processing as possible is done at build time, so your application will only contain the classes that are actually needed at runtime. In a traditional model all the classes required to perform the initial application deployment hang around for the life of the application, even though they are only used once. With {project-name} they are not even loaded into the production JVM. This results in less memory usage, and also faster startup time as all metadata processing has already been done.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>可能な限り多くの処理はビルド時に行われるので、アプリケーションは実行時に実際に必要とされるクラスだけを含みます。従来のモデルでは、最初のアプリケーションのデプロイメントを実行するために必要なすべてのクラスは、一度しか使用されないにもかかわらず、アプリケーションの寿命の間、ぶら下がっています。project-name}では、それらのクラスは本番環境のJVMにロードされません。その結果、メモリー使用量が少なくなり、すべてのメタデータ処理がすでに行われているため、起動時間も速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reduction in Reflection Usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リフレクション使用量の削減</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible {project-name} tries to avoid reflection, reducing startup time and memory usage.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{project-name}は可能な限り反射を避け、起動時間とメモリー使用量を減らすようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Pre Boot</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージのプリブート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in a native image {project-name} pre-boots as much of the framework as possible during the native image build process. This means that the resulting native image has already run most of the startup code and serialized the result into the executable, resulting in even faster startup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージで {project-name}を実行する場合、ネイティブイメージのビルドプロセスの間に、フレームワークの可能な限りの部分をプリブートします。これは、結果として得られるネイティブイメージがすでにほとんどのスタートアップコードを実行し、その結果を実行ファイルにシリアライズしていることを意味し、より高速なスタートアップを実現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our dependency injection solution is based on CDI.  You can use JAX-RS annotations to define the REST endpoints.  You can use JPA annotations to map your persistent entities and JTA annotations to declare the transaction boundaries.  You can use Eclipse MicroProfile to configure and monitor your application.  You can use Vert.x, Apache Camel and we support much more.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>我々の依存性注入ソリューションはCDIに基づいています。 JAX-RS アノテーションを使用して REST エンドポイントを定義できます。 JPA アノテーションを使用して、永続エンティティーをマップし、 JTA アノテーションを使用してトランザクション境界を宣言することができます。 Eclipse MicroProfileを使用して、アプリケーションを構成およびモニターできます。 Vert.x、Apache Camelを使用することが出来、そして更に多くをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we're not limited to standards we can go beyond and extend your possibilities.  Of course, {project-name} is not a passive consumer.  Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>我々は標準に限定されない為、あなたの可能性を広げることが可能です。 もちろん、{project-name} は受動的な消費者ではありません。 私たちのゴールは、使用する技術を改善、革新し、私たちが頼りにしているオープンソースプロジェクトと標準に貢献することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: publications
permalink: /publications/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: publications
permalink: /publications/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} - Publications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{project-name} - 出版物</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Below is a list of articles, blogs, podcast and other tidbits published online around {project-name}.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、{project-name}関連でオンラインで公開されている記事、ブログ、ポッドキャスト、その他の豆知識のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you believe we are missing an article, blog or video https://github.com/quarkusio/quarkusio.github.io[submit an issue].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>記事、ブログ、ビデオが不足していると思われる場合は、 link:https://github.com/quarkusio/quarkusio.github.io[Issueを登録] してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: community
permalink: /community/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: community
permalink: /community/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} - Community</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{project-name} - コミュニティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discussions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ディスカッション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stack Overflow</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Stack Overflow</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mailing list</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メーリングリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer live chat with the developers, we have a {quarkus-chat-url}[Zulip chat] where we all hang out.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発者とのライブチャットがお好きな方は、{quarkus-chat-url}[Zulip chat]をご利用ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Publications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>出版物</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are actively collection interesting blogs, articles, videos and other interesting publications. You can find those on link:{quarkus-site-publications}[Publications] page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは積極的に面白いブログ、記事、ビデオ、その他の興味深い出版物を収集しています。あなたは、 link:{quarkus-site-publications}[出版物] のページでそれらを見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An Open Project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オープンプロジェクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{project-name} is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0]. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and welcome contributors. Let's join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{project-name} は link:https://www.apache.org/licenses/LICENSE-2.0[Apacheライセンスバージョン2.0] でライセンスされたオープンソースプロジェクトです。まず何よりも、貢献やアイデア、議論がオープンに行われ、貢献者を歓迎するオープンコミュニティです。力を合わせて、Javaアプリケーションの未来を築いていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Code and issue tracker</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードと課題管理システム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of ways to contribute to {project-name} development:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{project-name} の開発に貢献する方法はたくさんあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing documentation and quickstarts,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントやクイックスタートを書いたり、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{quarkus-issues-url}[Fixing bugs or even just opening an issue],</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quarkus-issues-url}[バグを修正したり、Issueを登録するだけでも構いません]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing new extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいエクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are an extension developer or want to contribute to {project-name} development, join our mailing list either:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もしあなたがエクステンションの開発者であったり、{project-name}の開発に貢献したい場合は、私たちのメーリングリストに参加してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>by visiting the Google Groups page {quarkus-mailing-list-index}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Googleグループのページ{quarkus-mailing-list-index}にアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you visit our extensive link:{quarkus-writing-extensions-guide}[extension developer guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当社の広範な link:{quarkus-writing-extensions-guide}[エクステンション開発者ガイド] を必ずご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's new?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Come Join Us</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>参加のお誘い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We value your feedback a lot so please report bugs, ask for improvements... Let's build something great together!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私達は皆様からのフィードバックに重きを置いています。バグ報告、改善要望を是非お願いします。一緒に素晴らしいものを作り上げていきましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Quarkus user or just curious, don't be shy and join our welcoming community:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusユーザーの場合でも、単に興味を持っているだけの場合でも、恥ずかしがらずにコミュニティに参加して下さい!:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>provide feedback on https://github.com/quarkusio/quarkus/issues[GitHub];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/issues[GitHub] でフィードバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>craft some code and https://github.com/quarkusio/quarkus/pulls[push a PR];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードを作成し、 https://github.com/quarkusio/quarkus/pulls[プルリクエスト] を送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>discuss with us on https://quarkusio.zulipchat.com/[Zulip] and on the https://groups.google.com/d/forum/quarkus-dev[mailing list];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://quarkusio.zulipchat.com/[Zulip] や https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] でディスカッションに参加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ask your questions on https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow] で質問</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ADOPTERS.md</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ADOPTERS.md</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus and would like to be interviewed on our blog or simply added to this file, please contact us and we will be happy to oblige.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusをご利用の方で、ブログで取材を受けたい方や、このファイルに単純に追加したい方は、ご連絡いただければ、喜んでお受けいたします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We took a little break, but now another Newsletter round of stories found!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>少しお休みをとっていましたが、かなりの量の見つかったストーリーのニュースレターを発行します!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the news below - give it a read and if you feel something is missing or have an article coming out for future Quarkus Newsletter install the https://github.com/quarkusio/url2quarkuspub[bookmarklet] on your laptop and phone to easily submit a story. If you prefer the manual way please https://github.com/quarkusio/quarkusio.github.io/issues[open an issue] with a short description and a url.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のニュースを読んで、もし、何かが欠けていると感じたり、将来のQuarkus ニュースレターのために記事をお持ちの場合は、 link:https://github.com/quarkusio/url2quarkuspub[ブックマークレット] をラップトップやスマートフォンにインストールして、簡単に記事を投稿することができます。あなたが手動の方法を好む場合は、短い説明とURLを link:https://github.com/quarkusio/quarkusio.github.io/issues[Issueを登録] してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>楽しんで!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving Forward</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>将来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have any questions, suggestions or feedback, by all means please https://github.com/redhat-developer/intellij-quarkus/issues[open an issue].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご質問、ご意見、ご感想などがありましたら、ぜひ link:https://github.com/redhat-developer/intellij-quarkus/issues[イシューを開いて]ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thank you for reading and stay tuned for the next release!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お読みいただきありがとうございました。次のリリースをお待ちください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Links</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リンク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is my pleasure to announce the release of Quarkus 1.12.0.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.12.0.Finalのリリースを発表できることを嬉しく思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It comes with some significant changes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それはいくつかの重要な変更を含みます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fast jar is now the default packaging when you build a jar.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Fast jar は、jar をビルドする際のデフォルトのパッケージングになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive keeps improving and it now has support for multipart.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactiveは改善を続け、multipartをサポートするようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x Axle and RX Java managed instances have been dropped.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x AxleとRX Javaのマネージドインスタンスを削除しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We upgraded to GraalVM 21.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 21.0にアップグレードしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Migration Guide</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>移行ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[our migration guide for 1.12].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか？ここに link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[1.12の移行ガイド]があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has always offered several types of jar packaging.  Historically, we had either a standard jar packaging (the one with the `-runner.jar` and the `lib/` directory) or an uber jar.  In Quarkus 1.5, we introduced a new packaging type called Fast jar, which main objective was to further improve our boot time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、常にいくつかのタイプのjarパッケージを提供してきました。歴史的には、標準のjarパッケージ（ `-runner.jar` と `lib/` ディレクトリのあるもの）か、uber jarがありました。Quarkus 1.5では、Fast jarと呼ばれる新しいパッケージタイプを導入しました。その主な目的は、ブート時間の更なる改善でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus time, 1.5 means a century ago and we think Fast jar is now ready for prime time and brings enough improvements to justify the change.  Thus the decision to make it the default starting with 1.12.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの時間軸では、1.5は100年前のことを意味し、Fast jarはもうゴールデンアワーの準備ができており、変更を正当化するのに十分な改善をもたらしていると考えています。そのため、1.12からデフォルトにすることを決定しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This change will have consequences on your workflow as the produced artifacts are now under a `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この変更は、生成された成果物が `quarkus-app` ディレクトリの下に置かれるようになったため、ワークフローに影響を及ぼします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So instead of starting your application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを以下で起動するのではなく、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will now start it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これからは以下で起動します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When deploying your application, you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをデプロイする際には、 `quarkus-app` ディレクトリ全体をデプロイする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your Dockerfiles will also need to be adjusted to take this into account.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Dockerfilesもこれを考慮して調整する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more details in our https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12#fast-jar-as-default[Migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12#fast-jar-as-default[移行ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it's not the right time for you to change your workflow, you can easily go back to the previous packaging by adding the following property to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ワークフローを変更するタイミングではない場合は、 `application.properties`に以下のプロパティを追加することで、簡単に以前のパッケージングに戻ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We continue improving RESTEasy Reactive at a steady pace, and this time, we introduced Multipart support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactiveの改善を着実に続けており、今回はMultipart対応を導入しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is very similar to the Multipart support of RESTEasy and looks like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyのMultipart対応に非常に似ていて、以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about it in the updated https://quarkus.io/guides/resteasy-reactive#handling-multipart-form-data[RESTEasy Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それについての詳細は、更新された link:https://quarkus.io/guides/resteasy-reactive#handling-multipart-form-data[RESTEasy Reactiveガイド]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 21</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 21</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended version of GraalVM for Quarkus 1.12 is GraalVM 21.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.12のGraalVMの推奨バージョンはGraalVM 21.0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They had been deprecated for quite a while, they are now gone.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>かなり前から非推奨になっていましたが、今はもうありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Either use the raw Vert.x instance of the Mutiny one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生のVert.xインスタンスを使用するか、Munityのを利用してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full Changelog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.12.0.CR1[1.12.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.12.0.Final[1.12.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.12.0.CR1[1.12.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.12.0.Final[1.12.0.Final]の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To share stories about Quarkus usage, we added https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[an `ADOPTERS.md` file] at the root of the repository.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの使用に関する情報を共有するために、リポジトリのルートに https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[ADOPTERS.mdファイル]を追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributors</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>貢献者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[445 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[445人の貢献者]がいます。一人ひとりの貢献者に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.12 release, thanks to Alex Soto, Alexey Loubyansky, Andy Damevin, artsemstones, Auri Munoz, Bernhard Lutzmann, Bill Burke, Clement Escoffier, Erin Schnabel, Ertunc Aybars, essobedo, Falko Modler, Florian Heubeck, Foivos Zakkak, Galder Zamarreño, Gaétan Collaud, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Henrique Prange, Ioannis Canellos, Jaikiran Pai, James Netherton, Jan Martiška, JiriOndrusek, Johnnes Souza, Joost Baas, Jose, Jose Ignacio Gil Jaldo, Josef Smrcka, Julien Ponge, Katia Aresti, Ken Finnigan, Knut Wannheden, kstrempel, Ladislav Thon, Loïc Mathieu, Lucas Reeh, Maciej Walkowiak, Mahieddine Cherif, Maik Möwes, manusa, Manyanda Chitimbo, Martin Kouba, Martin Panzer, Matej Novotny, Matej Vasek, Maxime DAVID, Mayank Kunwar, Michał Szynkiewicz, Moritz Becker, mrizzi, Nuno Alves, Oscar, PAPADOPOULOS Nikolaos, Peter Palaga, Petr Široký, Phillip Krüger, René Grob, Robert Stupp, Roberto Cortez, Rostislav Svoboda, Sanne Grinovero, SaumyaSingh1, sebthom, Sergey Beryozkin, S.H, Stuart Douglas, Stéphane Épardaud, Suleimenov Yelzhas, Ted Won, Thomas McWork, Thomas Pfaff, Thomas Segismont, Timothy Power, Tobias Stadler, Vasilis Andritsoudis, Vincent Sevel, xstefank, and Yoann Rodière.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に1.12リリースについては、以下の皆様に感謝します: Alex Soto, Alexey Loubyansky, Andy Damevin, artsemstones, Auri Munoz, Bernhard Lutzmann, Bill Burke, Clement Escoffier, Erin Schnabel, Ertunc Aybars, essobedo, Falko Modler, Florian Heubeck, Foivos Zakkak, Galder Zamarreño, Gaétan Collaud, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Henrique Prange, Ioannis Canellos, Jaikiran Pai, James Netherton, Jan Martiška, JiriOndrusek, Johnnes Souza, Joost Baas, Jose, Jose Ignacio Gil Jaldo, Josef Smrcka, Julien Ponge, Katia Aresti, Ken Finnigan, Knut Wannheden, kstrempel, Ladislav Thon, Loïc Mathieu, Lucas Reeh, Maciej Walkowiak, Mahieddine Cherif, Maik Möwes, manusa, Manyanda Chitimbo, Martin Kouba, Martin Panzer, Matej Novotny, Matej Vasek, Maxime DAVID, Mayank Kunwar, Michał Szynkiewicz, Moritz Becker, mrizzi, Nuno Alves, Oscar, PAPADOPOULOS Nikolaos, Peter Palaga, Petr Široký, Phillip Krüger, René Grob, Robert Stupp, Roberto Cortez, Rostislav Svoboda, Sanne Grinovero, SaumyaSingh1, sebthom, Sergey Beryozkin, S.H, Stuart Douglas, Stéphane Épardaud, Suleimenov Yelzhas, Ted Won, Thomas McWork, Thomas Pfaff, Thomas Segismont, Timothy Power, Tobias Stadler, Vasilis Andritsoudis, Vincent Sevel, xstefank, and Yoann Rodière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.12.1.Final released - Bugfixes'
date: 2021-03-03
tags: release
synopsis: 1.12.1.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.12.1.1.Finalリリース - バグフィックス
date: 2021-03-03
tags: release
synopsis: 1.12.1.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.1.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.12.1.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.1.Final is a safe upgrade for everyone using Quarkus 1.12.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.12.1.Finalは、Quarkus 1.12を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.12 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[1.12 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.12を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.12[1.12移行ガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full changelog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.12.1.Final[the full changelog of 1.12.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.12.1.Final[GitHubで1.12.1.1.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-tools1.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-tools1.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.3.Final released - Bugfixes'
date: 2020-12-08
tags: release
synopsis: 1.10.3.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.10.3.Finalリリース - バグフィックス
date: 2020-12-08
tags: release
synopsis: 1.10.3.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.3.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.3.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it really helped a lot!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題を報告し、再現手順を提供してくれたすべてのコントリビューターに感謝します。非常に助かりました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.10.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.10を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.10 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.10をお使いでない方は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10移行ガイド] をご参照ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリリースはメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[the full changelog of 1.10.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[GitHub上の1.10.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.8.2.Final released - Bugfixes'
date: 2020-10-06
tags: release
synopsis: 1.8.2.Final fixes some bugs and includes some documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.8.2.Finalリリース - バグフィックス
date: 2020-10-06
tags: release
synopsis: 1.8.2.Finalでは、いくつかのバグを修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today, we released Quarkus 1.8.2.Final with some bugfixes and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本日、Quarkus 1.8.2.Finalをリリースし、いくつかのバグフィックスとドキュメントの改善を行いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.8.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.8を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release that fixes various bugs found in 1.8.1.Final and provides some documentation updates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリリースは、1.8.1.Final で発見された様々なバグを修正し、いくつかのドキュメントの更新を提供するメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.8.2.Final[the full changelog of 1.8.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.2.Final[GitHubで1.8.2.Finalの完全な変更履歴] は入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.5.Final released - Bugfixes'
date: 2020-12-16
tags: release
synopsis: 1.10.5.Final fixes several important issues in Quarkus 1.10.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.10.5.Finalリリース - バグフィックス
date: 2020-12-16
tags: release
synopsis: 1.10.5.Finalでは、Quarkus 1.10のいくつかの重要な問題が修正されました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.5.Final is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.5.Final はメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It fixes some important issues in Quarkus, most notably in the Hibernate ORM extension which got Hibernate ORM upgraded to 5.4.26.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの幾つかの重要な課題を修正します。特に注目すべき点として、Hibernate ORMエクステンションにおいて、Hibernate ORMが5.4.26.Finalにアップグレードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[the full changelog of 1.10.4.Final] and the https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[full changelog for 1.10.5.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[1.10.4.Finalの完全な変更履歴]と https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[1.10.5.Finalの完全な変更履歴] をGitHubで取得出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few months back, I blogged about https://quarkus.io/blog/kafka-avro/[Quarkus, Kafka, and Avro] (using the Apicurio schema registry).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数ヶ月前に、 https://quarkus.io/blog/kafka-avro/[QuarkusとKafka、Avro] (Apicurio schema registryを使用)についてブログを書きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We developed a simple application, receives HTTP requests, writes Kafka records, and reads them from Kafka.  It uses Avro to serialize and deserialize the records.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTPリクエストを受信し、Kafkaのレコードを書き込み、Kafkaからレコードを読み出すというシンプルなアプリケーションを開発しました。  Avroを使ってレコードのシリアライズとデシリアライズを行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that time, the https://github.com/cescoffier/quarkus-kafka-and-avro[application] was **NOT** working in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その時は、 https://github.com/cescoffier/quarkus-kafka-and-avro[アプリケーション] はネイティブモードで動作して **いません** でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why didn't it work?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜうまくいかなかったのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native compiler does not support everything that is possible to do in Java.  There are cases not yet supported, and Avro is using some of these unsupported constructs.  Fortunately, we can implement _substitutions_ (to replace unsupported constructs in the code directly) and use Quarkus extensions to configure the compiler correctly.  As a result, your application does not have to configure anything, "it just works™️".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブコンパイラは、Javaでできることをすべてサポートしているわけではありません。  まだサポートされていないケースがあり、Avroではこれらのサポートされていない構文のいくつかを使用しています。幸いなことに、_substitutions_(コード内のサポートされていない構文を直接置き換える)を実装し、Quarkusのエクステンションを使用してコンパイラを正しく設定することができます。その結果、アプリケーションは何も設定する必要がなく、「it just works™️」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's come back to Avro.  Avro uses https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[method handles] that are not supported by the GraalVM native compiler.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Avro の話に戻りましょう。  Avro は GraalVM ネイティブコンパイラがサポートしていない https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[メソッドハンドル] を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To workaround the unsupported constructs used by Avro, we implemented a set of https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions].  We replaced method handles with reflection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Avro が使用するサポートされていない構文を回避するために、 https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions] のセットを実装しました。 メソッドハンドルをリフレクションに置き換えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GenericDatumReader` also needs a bit of work as it touches threads at build time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `GenericDatumReader` は、ビルド時にスレッドに触れるため、少し作業が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, in the Quarkus Avro Processor (part of the Quarkus extension), we register for reflection all the classes annotated with `@AvroGenerated`, as we are using reflection to create new instances of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、Quarkus Avro Processor(Quarkusエクステンションの一部)で、 `@AvroGenerated` でアノテーションされたすべてのクラスをリフレクションの為に登録します。新しいインスタンスの生成にリフレクションを使用している為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>見せて!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the https://github.com/cescoffier/quarkus-kafka-and-avro[code] of the application, and make sure you have GraalVM installed.  Then, build the native executable using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの https://github.com/cescoffier/quarkus-kafka-and-avro[コード] を取得し、GraalVMがインストールされていることを確認してください。そして、ネイティブ実行ファイルを次のようにビルドします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grab a coffee or tea, as it may take a few minutes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数分かかる場合がありますので、コーヒーや紅茶を淹れましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, run the application with `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、 `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner` でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send some movies to the application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの映画をアプリに送信します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check they are processed successfully in the application log output:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>正常に処理されていることをアプリケーションログ出力で確認してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Avro support in native is still experimental.  In the last Quarkus version, we made significant progress, but there may be some uncovered areas.  Let us know if you find anything https://github.com/quarkusio/quarkus/issues/new/choose[odd]!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブでのAvroサポートはまだ実験的なものです。前回のQuarkusバージョンでは、かなりの進歩を遂げましたが、いくつかの未発見の部分があるかもしれません。 https://github.com/quarkusio/quarkus/issues/new/choose[何かおかしな点を見つけましたら教えてください] !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I had the question multiple times: how do I use Eclipse Vert.x in Quarkus? Indeed, you can use Vert.x in Quarkus.  You can deploy _verticles_, communicate with the event bus, or use anything from the Vert.x ecosystem.  But, you can also use the Mutiny variant of Vert.x in Quarkus, and get a seamless experience with the other reactive APIs offered by Quarkus.  Several posts have already mentioned this, but it deserves a specific blog post.  So, here we are.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>よく次の質問をされます:「QuarkusでEclipse Vert.xを使うにはどうすればいいですか?」確かに、QuarkusではVert.xを使用することができます。 _Verticles_ をデプロイしたり、イベントバスと通信したり、Vert.xエコシステムのものなら何でも使えます。しかし、QuarkusでVert.xのMutinyバリアントを使用して、Quarkusが提供する他のReactive APIとシームレスな体験を得ることもできます。これについてはすでにいくつかの記事で触れていますが、具体的なブログ記事に値する内容です。というわけで、ここで紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse Vert.x</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse Vert.x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit to build reactive applications.  The Vert.x ecosystem is enormous.  From HTTP and data access abilities to messaging clients via microservice and security facilities, the Vert.x ecosystem is remarkably diverse and versatile.  To understand that variety, just check the https://vertx.io/docs/[Vert.x documentation].  That makes Vert.x popular in many areas such as web applications, IoT gateways, banking applications and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://vertx.io[Vert.x] はリアクティブなアプリケーションを構築するためのツールキットです。Vert.x のエコシステムは膨大です。HTTP やデータアクセス機能からマイクロサービスやセキュリティー機能を介したメッセージングクライアントまで、Vert.x のエコシステムは非常に多様で汎用性に富んでいます。その多様性を理解するには、Vert https://vertx.io/docs/[Vert.xのドキュメント]をチェックしてください。そのため、Vert.xはWebアプリケーション、IoTゲートウェイ、銀行アプリケーションなど、多くの分野で人気があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you may know, Quarkus is based on Vert.x.  Under the hood, there is a managed Vert.x instance that powers the rest of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご存知のように、QuarkusはVert.xをベースにしています。裏側では、マネージドのVert.xのインスタンスが存在し、Quarkusに力を与えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus serves a HTTP endpoint, under the hood, there is a Vert.x HTTP server handling the request and response.  That's also true for messaging, gRPC and almost any I/O.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusがHTTPエンドポイントを提供する場合、フードの下には、リクエストとレスポンスを処理するVert.x HTTPサーバーがあります。これは、メッセージング、gRPC、およびほぼすべてのI/Oにも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vert.x "bare" API and friends</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.xの「素の」APIとその仲間たち</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x provides multiple APIs.  Let's focus on the "bare" one for now.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.xは複数のAPIを提供しています。ここでは「素」のものに注目してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the reactive nature of Vert.x, the API contains mostly asynchronous methods.  These methods are following a syntax convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x のリアクティブな性質にしたがって、API のほとんどを非同期メソッドが占めています。これらのメソッドは構文規則に従っています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part is the last parameter.  It's a function, a callback to be more precise, that gets called when the operation completes or fails.  Indeed, the asynchronous nature of Vert.x does not allow using `try/catch` blocks.  So you need to pass a continuation callback, invoked with the outcome.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>興味深いのは最後のパラメーターです。これは関数、より正確にはコールバックで、操作が完了したときや失敗したときに呼び出されます。実際、Vert.xの非同期の性質上、 `try/catch`  ブロックを使用することはできません。そのため、結果に応じて呼び出される継続コールバックを渡す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AsyncResult` is a structure capturing this outcome.  It contains the result (of type `&lt;T&gt;`) produced by the operation, or the failure if it failed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AsyncResult`  は、この結果をキャプチャする構造体です。これは、操作によって生成された結果 ( `&lt;T&gt;`  型)、または失敗した場合の失敗を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を挙げてみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code reads a file, and as it's an asynchronous operation, invokes the callback when the file is read.  The `readFile` method reads the complete content of the file and accumulates it in a _buffer_.  The callback receives the asynchronous result containing either the file's content (`ar.result()`) or a failure.  Vert.x invokes this callback when the operation has either completed or failed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコードはファイルを読み込み、非同期操作であるため、ファイルが読み込まれたときにコールバックを呼び出します。 `readFile`  メソッドは、ファイルの完全な内容を読み込み、 _バッファ_ に蓄積します。コールバックは、ファイルの内容 ( `ar.result()` ) または失敗を含む非同期の結果を受け取ります。Vert.x は、操作が完了または失敗したときにこのコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x also supports streams thanks to the `ReadStream` and `WriteStream` classes.  A `ReadStream` represents a stream of data you can read.  So you can attach a callback invoked on every item traversing the stream.  A `WriteStream` is a data source.  You can push items to a `WriteStream.` These items will be consumed by a `ReadStream`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x は `ReadStream`  と `WriteStream`  クラスのおかげでストリームもサポートしています。 `ReadStream`  は読み込み可能なデータのストリームを表します。そのため、ストリームを通過するすべての項目で呼び出されるコールバックをアタッチすることができます。 `WriteStream`  はデータソースです。アイテムを `WriteStream.`  にプッシュすることができます。 これらのアイテムは `ReadStream`  によって消費されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x streams do not implement Reactive Streams.  Vert.x provides a different back-pressure protocol.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x ストリームは、Reactive Streams を実装していません。Vert.x は別のバックプレッシャープロトコルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why are these API shaping rules important? Vert.x does not provide a single API.  The "bare" API presented above is just one of the proposed API.  It also provides API in Kotlin, API for RX Java, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜこれらの API シェーピングルールが重要なのか?Vert.xは単一のAPIを提供していません。上で紹介した「素の」APIは、提案されているAPIの1つに過ぎません。他にもKotlinでのAPIやRX JavaでのAPIなども提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These APIs are **generated**.  Vert.x provides a code generator that _ translates_ the Vert.x "bare" API into the other APIs.  Because all methods are well-formed, the generator understands how they should be adapted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの API は *生成され* ます。Vert.x は、Vert.x の "むき出しの" API を他の API に変換するコード ジェネレーターを提供します。すべてのメソッドは整形されているので、ジェネレータはどのように適応されるべきかを理解しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated code exposes a different API; each method delegating to the "bare" API.  Asynchronous methods and streams can follow different transformations, so the resulting API uses the right idioms.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたコードは、異なる API を公開しており、各メソッドは「素」の API にデリゲートします。非同期メソッドとストリームは異なる変換を行うことができるので、生成されたAPIは適切なイディオムを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven reactive programming library.  It's not related to Vert.x.  However, we have written a code generator that generates the Mutiny variant for the Vert.x API:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。Vert.xとは関係ありませんが、Vert.x API用のMutiny版を生成するコードジェネレータを書いています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/mutiny.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;span class="image"&gt;&lt;img src="/assets/images/posts/mutiny-vertx/mutiny.png" alt="mutiny"&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transformations are straightforward:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>変換は簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx` package =&gt; `io.vertx.mutiny` package</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.vertx`  パッケージ ⇒ `io.vertx.mutiny`  パッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous methods =&gt; method returning a `Uni&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期メソッド⇒メソッドが返す `Uni&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ReadStreams&lt;T&gt;` =&gt; can be consumed as `Multi&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReadStreams&lt;T&gt;`  ⇒消費することができます。 `Multi&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WriteStreams&lt;T&gt;` =&gt; can be consumed as Reactive Streams `Subscriber&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`WriteStreams&lt;T&gt;` ⇒ リアクティブストリームとして消費することができます。 `Subscriber&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also adapts the Vert.x back pressure protocol to Reactive Streams, as Mutiny implements Reactive Streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、MutinyがReactive Streamsを実装しているため、Vert.xのバックプレッシャープロトコルをReactive Streamsに適応させています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the first example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、上から1番目の例では、次のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One difference between the two APIs is related to laziness. The Vert.x "bare" API triggers the operation as soon as the method is called.  The Mutiny variant expects a subscription to trigger the operation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つのAPIの違いの1つは、怠惰性に関連しています。Vert.x の "素の" API は、メソッドが呼び出されるとすぐに操作をトリガーします。Mutiny 版では、操作をトリガーするためにサブスクリプションを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The stream example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上からのストリームの例は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit more than this</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう少し補足</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny variant does not only apply the rules exposed in the previous section.  For asynchronous methods, it also provides:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny版は、前のセクションで公開されたルールを適用するだけではありません。非同期メソッドに対しても提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndAwait()` methods - blocks the caller thread until the outcome is received. In the case of a failure, throws a `RuntimeException`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`xAndAwait()`  メソッド - 結果を受け取るまで呼び出し元のスレッドをブロックします。失敗した場合は `RuntimeException` を発生させます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndForget()` methods - triggers the operation, discard the outcome</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`xAndForget()`  methods - 操作をトリガし、結果を破棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can we find this API?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このAPIはどこにありますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment of writing, we only provide Vert.x core and Vert.x clients (MongoDB, Redis, Web client, Mqtt, and so on).  We are extending the support to cover the full Vert.x stack.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>執筆時点では、Vert.xコアとVert.xクライアント(MongoDB、Redis、Webクライアント、Mqttなど)のみを提供しています。私たちはVert.x スタック全体をカバーするようにサポートを拡張しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the Mutiny clients, you need to add the right dependency to your project.  Browse https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[the list of dependency] to pick the one you need.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyクライアントを使用するには、適切な依存関係をプロジェクトに追加する必要があります。 https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[依存関係のリスト]を見て、必要なものを選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to you use the Mutiny variant of the Vert.x Web client, add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Vert.x Web クライアントの Mutiny 版を使用するには、以下の依存関係を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have the dependency, just create the web client instance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係ができたら、あとはWebクライアントのインスタンスを作成するだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Something missing? Open an issue on https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何か足りないものがあった場合は、 https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils] に課題を提起してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Javadoc is available http://smallrye.io/smallrye-reactive-utils/apidocs/[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javadocは http://smallrye.io/smallrye-reactive-utils/apidocs/[こちら] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The road ahead: Vert.x 4!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今後の道:Vert.x 4!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x 4 is coming soon! We are already working in Quarkus and the different satellite projects to migrate.  With Vert.x 4, a new generator has been implemented (following the same code generation approach), paving the road to a smooth upgrade.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x 4が間もなく登場します!既にQuarkusと異なるサテライトプロジェクトで移行作業を行っています。Vert.x 4では、新しいジェネレータが実装されており(同じコード生成アプローチを踏襲しています)、スムーズなアップグレードへの道が開かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.8.1.Final released - Bugfixes, RESTEasy Multipart extension'
date: 2020-09-18
tags: release
synopsis: 1.8.1.Final fixes some regressions and bugs and introduces the RESTEasy Multipart extension.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.8.1.1.Finalリリース - バグフィックス、RESTEasy Multipartエクステンション
date: 2020-09-18
tags: release
synopsis: 1.8.1.Finalでは、いくつかの回帰やバグを修正し、RESTEasy Multipartエクステンションを導入しました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today, we released Quarkus 1.8.1.Final with some bugfixes and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本日、Quarkus 1.8.1.Finalをリリースし、いくつかのバグフィックスとドキュメントの改善を行いました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also introduced a new RESTEasy Multipart extension to fix an recurring encoding issues with multipart.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、新しい RESTEasy Multipart エクステンションを導入し、multipart で繰り返し発生するエンコーディングの問題を修正しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using 1.8.0.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.8.0.Finalを使っている人なら誰でも安心してアップグレードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release that fixes various bugs found in 1.8.0.Final and provides some documentation updates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリリースは、1.8.0.Final で発見された様々なバグを修正し、いくつかのドキュメントを更新するメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.8.1.Final[the full changelog of 1.8.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.1.Final[GitHubで1.8.1.1.Finalの完全な変更履歴] は入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Multipart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default encoding for multipart requests in RESTEasy is US-ASCII which is not very convenient in 2020.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyでのマルチパートリクエストのデフォルトエンコーディングはUS-ASCIIで、2020年にはあまり便利ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the `quarkus-resteasy-multipart` extension, the default encoding is now UTF-8 and it can be configured if needed.  If working with multipart, make sure you use this extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-resteasy-multipart` エクステンションのおかげで、デフォルトのエンコーディングが UTF-8 になり、必要に応じて設定できるようになりました。マルチパートに取り組む場合は、このエクステンションを使用するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More on this in the link:/guides/rest-json#multipart-support[Writing JSON REST Services guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これについての詳細は、 link:/guides/rest-json#multipart-support[JSON RESTサービスの作成ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kafka.apache.org/[Apache] Kafka is a prevalent distributed streaming platform offering a unique set of characteristics such as message retention, replay capabilities, consumer groups, and so on.  Kafka is highly scalable, fault-tolerant, and is becoming the spine of many modern systems.  That being said, Kafka is not the only one out there, and choosing the right messaging technology for your application can be challenging.  There are many articles to help you drive your decision, such as https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[this one].  This post is about Kafka, and an equivalent post about AMQP will be published later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://kafka.apache.org/[Apache Kafka] は、メッセージの保持、再生機能、コンシューマーグループなどのユニークな特性を提供する分散型ストリーミングプラットフォームとして広く普及しています。Kafka は非常に拡張性が高く、耐障害性に優れており、多くの近代的なシステムの要になりつつあります。とはいえ、Kafka単体で存在するものではなく、アプリケーションに適したメッセージング技術を選択するのは難しいことです。 link:https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[このリンク先] のように、あなたの決定を後押しするために役立つ記事がたくさんあります。この記事は Kafka についてのもので、AMQP についての同等の記事は後日公開される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, you will learn how to get started with Apache Kafka in your Quarkus application in less than 10 steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] - a declarative approach to build event-driven microservices, but you can also use _bare_ Kafka APIs or Kafka Streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この投稿では、QuarkusアプリケーションでApache Kafkaを10ステップ未満で使い始める方法を学びます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] を使用しますが、 _ベア_ Kafka APIやKafka Streamsを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub]から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 1 - Generate your project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ 1 - プロジェクトの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the very beginning, getting a new project structure with the right dependencies.  Go to https://code.quarkus.io, enter your group id and artifact id.  Then in the extension list, select:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の一歩として、正しい依存関係を持つ新しいプロジェクト構造を取得してみましょう。 https://code.quarkus.io  にアクセスして、グループIDとアーティファクトIDを入力します。そして、エクステンションのリストで以下を選択します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project to contain examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Example Code"を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, click on __Generate your application__, download the project as a zip file, unzip it, and load it in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 _Generate your application_ をクリックして、プロジェクトをzipファイルとしてダウンロードし、解凍して、お気に入りのIDEにロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-kafka` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-kafka` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 2 - What are we going to exchange?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ2 - 何を交換するか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need something to exchange.  Without much originality, let's say we will send and receive `Movie` objects.  In your project, create the `org.acme.Movie` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>交換するものが必要です。あまりオリジナリティを持たずに、 `Movie` オブジェクトを送受信するとしましょう。プロジェクトの中で、以下の内容の `org.acme.Movie` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Kafka, we produce and consume records.  A record contains a key and a value.  Let's say we will use the movie's publication year as key and the title as value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka では、レコードを生成、消費します。レコードにはキーと値が含まれています。例えば、映画の公開年をキーにして、タイトルを値にするとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to decide on which topic we are going to send these records.  Let's keep things simple and name our topic __movies__.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、これらのレコードを送信するトピックを決める必要があります。単純化して、トピックを _movies_ としましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 3 - Configure the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ3 - アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  In our application, we must indicate that our reception and publication channels will use the __movies__ Kafka channel.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の通り、Reactive Messagingを使用します。Reactive Messagingを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、基礎となるメッセージング技術に設定によってマッピングされます。このアプリケーションでは、受信および配信チャンネルが _movies_ Kafkaチャンネルを使用することを指定する必要があります。 `src/main/resources/application.properties` で、以下の内容を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location with `kafka.bootstrap.servers`, we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーの場所を `kafka.bootstrap.servers` で設定した後、 `movies-in` (レコードを受信)と `movies-out` (レコードを配信)の 2 つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the Kafka connector.  We also need to configure the key and value deserializers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mp.messaging.incoming.movies-in` というプレフィックスを使ってチャネルを設定します。 `connector` 属性は、このチャネルを担当するコネクタ (ここでは Kafka コネクタ) を示しています。また、キーと値のデシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicate who's responsible for that channel, we also need to configure the key and value serializers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` のプレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、キーと値のシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ 4 - Kafkaにムービーを公開する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send a record to Kafka.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、いよいよKafkaにレコードを送信します。以下の内容で `org.acme.MovieProducer` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter`, i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and so will send messages to Kafka).  We are sending `Record` objects containing the movie's publication year as key and its title as value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスでは、 `Emitter` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (つまり、Kafka にメッセージを送信します)。映画の公開年をキーに、タイトルを値にして `Record` オブジェクトを送信しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can simply use the `sendMovieToKafka` method to send a movie to our Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、残りのアプリケーションは `sendMovieToKafka` メソッドを使って、Kafka トピックにムービーを送信するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 5 - Consuming movies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ5 - 映画を消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今度は反対側に目を向けて、Kafkaからムービーを取り出してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here, we use the `@Incoming` annotation to indicate to Quarkus to call the `receive` method for every received record.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、 `@Incoming` アノテーションを使用して、受信したレコードごとに `receive` メソッドを呼び出すようにQuarkusに指示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 6 - Sending movies from a REST endpoint</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ6 - RESTエンドポイントからのムービーの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to Kafka from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST エンドポイントから Kafka にメッセージを送信することはよくあることです。そのためには、以下のような内容の `org.acme.MovieResource` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 7 - Let's get this running!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ7 - これを実行してみましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need a Kafka broker.  You can follow the https://kafka.apache.org/quickstart[Apache Kafka quickstart], or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、まずはKafkaブローカーが必要です。 link:https://kafka.apache.org/quickstart[Apache Kafka のクイックスタート] に従うか、以下の `docker-compose.yaml` ファイルを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します: `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、アプリケーションを次のように実行します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application runs in dev mode, meaning that you can still update the code.  It will reload it automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションはdevモードで動作します。つまり、コードをまだ変更することが出来、変更した場合、自動的にリロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, emit a few HTTP POST request such as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の端末で、次のようなHTTP POSTリクエストをいくつか送信します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the terminal running the application, you will see:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行しているターミナルでは、以下のように表示されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It works!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動いています!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 8 - Native packaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ8 - ネイティブパッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have https://quarkus.io/guides/building-native-image[GraalVM installed and configured correctly], you can package this application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://quarkus.io/guides/building-native-image[GraalVMが正しくインストールされ、設定されている場合] 、このアプリケーションをネイティブの実行ファイルとしてパッケージ化することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using Kafka starting in a few milliseconds and consuming a ridiculous amount of memory: less than 30Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、Kafkaを使用したQuarkusアプリケーションが数ミリ秒で起動し、消費するメモリー量はとんでもない量:100レコードを取り込んでも30MB未満!になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using Apache Kafka.  If you want to go further, check the https://quarkus.io/guides/kafka[Kafka guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>10分もしないうちに、Apache Kafkaを使った新しいQuarkusアプリケーションができました。さらに進みたい場合は、 link:https://quarkus.io/guides/kafka[Kafkaガイド]をチェックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloudevents.io/[Cloud Events] is a specification for describing events.  It aims to ease interoperability.  With the rise of event-driven architecture, it's not surprising to see Cloud Events gaining popularity.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://cloudevents.io/[クラウドイベントは]、イベントを記述するための仕様です。相互運用性を容易にすることを目的としています。イベント駆動型アーキテクチャの台頭により、Cloud Eventsの人気が高まっているのは驚くに値しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post explains how you can generate and consume Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを生成して消費する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Cloud Event?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントとは?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's look at the why.  Events are everywhere.  Many modern systems are using events one way or another.  Events can be used to implement event sourcing, communicate facts, trigger out-of-band processing, or send notifications.  Events become an essential piece of any system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは「なぜ」を見てみましょう。イベントはどこにでもあります。最近のシステムの多くは、何らかの方法でイベントを使用しています。イベントは、イベントソーシングの実装、事実の伝達、帯域外処理のトリガー、通知の送信などに使用できます。イベントはどんなシステムにも欠かせないものとなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yet event publishers tend to describe events differently.  I don't mean the content is different, but the envelope and the event's format are heterogeneous, even if these events transit on the same event mesh.  Some applications choose JSON and encode everything in the event's payload; some other systems prefer binary formats, such as Avro or Protobuf, and use the protocol capability, such as headers or properties, to transport metadata about the wrapped payload.  While event-driven architecture claims to ease the integration with external systems, this disparity is doing the opposite.  It's not rare to need a specific event translator with the only purpose to adapt events from one format to another.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、イベント発行者はイベントを異なる形で表現する傾向があります。内容が違うという意味ではありませんが、エンベロープとイベントのフォーマットは異種混在で、たとえこれらのイベントが同じイベントメッシュ上を通過するとしてもです。アプリケーションの中には JSON を選択してイベントのペイロードにすべてをエンコードするものもあれば、Avro や Protobuf のようなバイナリー形式を好み、ヘッダやプロパティーのようなプロトコル機能を使って、ラップされたペイロードに関するメタデータを転送するものもあります。イベント駆動型アーキテクチャは外部システムとの統合を容易にすると主張していますが、この不均衡はその逆を行っています。イベントをあるフォーマットから別のフォーマットに適応させることだけを目的とした特定のイベントトランスレータを必要とすることは珍しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, what's Cloud Event? Cloud Event proposes a common way to describe events.  The goal is, obviously, interoperability and easing the integration burden.  Cloud Event 1.0 was released almost a year ago.  Over the past year, many Cloud Providers adopted this format, such as Azure and Oracle.  Several middlewares have also added support for Cloud Events, such as Knative, Kogito, Debezium, and Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、クラウドイベントとは何か?クラウドイベントは、イベントを記述するための共通の方法を提案しています。目的は明らかに相互運用性と統合負担の軽減です。クラウドイベント1.0はほぼ1年前にリリースされました。この1年で、AzureやOracleなど、多くのクラウドプロバイダーがこの形式を採用しました。また、Knative、Kogito、Debezium、Quarkusなど、いくつかのミドルウェアがクラウドイベントのサポートを追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me some examples!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を見せてください!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ok, so, how does it look? The easiest way to understand Cloud Event is to look at one of them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さてさて、どんな感じでしょうか?クラウドイベントを理解する一番簡単な方法は、そのうちの一つを見てみることです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This event is described in JSON, but that's just one of the possibilities.  Let's look at the fields.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このイベントはJSONで記述されていますが、それは可能性の一つに過ぎません。フィールドを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the `specversion` indicates which version of Cloud Event it is using (1.0).  The `id` field provides an id for that specific event.  The `source` attribute is a URI identifying the event source, i.e., the context in which an event happened or the application that emitted that specific event.  Combining the `id` and the `source` provides a unique identifier.  Such uniqueness is essential to implement idempotence and handle potential duplicates.  The `type` is the last mandatory attribute.  It indicates the _type_ of the event.  Here, I use the fully qualified class name, but you can imagine anything.  It should refer to the kind of event you have defined in your system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、 `specversion`  は、使用しているクラウドイベントのバージョン(1.0)を示しています。 `id`  フィールドは、その特定のイベントの ID を提供します。 `source`  属性は、イベントソースを識別する URI であり、イベントが発生したコンテキストや、特定のイベントを発生させたアプリケーションを示します。 `id`  と `source`  を組み合わせることで、一意な識別子が得られます。このような一意性は、冪等性を実装し、潜在的な重複を処理するために不可欠です。 `type`  は最後の必須属性です。これはイベントの _タイプ_ を示します。ここでは完全修飾クラス名を使用していますが、何を想像しても構いません。システムで定義されているイベントの種類を参照する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other attributes are optional.  `datacontenttype` defines the content-type of the `data` attribute.  `subject` allows passing extra details about the event, such as an additional hint about the context or the type of event.  `time` is a timestamp, generally indicating the creation time.  There is another optional attribute not used in my example.  The `dataschema` attribute lets you pass the schema of the event data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`datacontenttype`  は `data`  属性の content-type を定義します。 `subject`  では、コンテキストやイベントのタイプに関する追加のヒントなど、イベントに関する追加の詳細を渡すことができます。 `time`  はタイムスタンプで、一般的には作成時刻を示します。私の例では使用していない別のオプションの属性があります。 `dataschema`  属性は、イベントデータのスキーマを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `data` attribute contains the wrapped business event.  It is an essential part, and the other attributes are just providing details about that specific business event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`data`  属性には、ラップされたビジネスイベントが含まれています。これは本質的な部分であり、他の属性はその特定のビジネスイベントについての詳細を提供しているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also define _extensions_.  These extensions would be a set of custom attributes used when the proposed set of attributes is not enough for your use case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_拡張_ を定義することもできます。これらの拡張は、提案された属性のセットがユースケースに十分でない場合に使用されるカスタム属性のセットになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's it! So, we can summarize Cloud Events as _just enough metadata to understand an event_ - its source, an id, a type, and the business data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これだ!これだ!と思ったイベントをまとめてみました。ということで、クラウドイベントを、 _イベントを理解するために必要な最低限のメタデータ、つまり、イベントの_ ソース、ID、タイプ、ビジネスデータとしてまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Events on the wire - the bindings</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>転送におけるクラウドイベント - バインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, how would these events be encoded? The previous example using JSON is nice, but some protocols may want to leverage their own capabilities to transmit these metadata.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、これらのイベントはどのようにエンコードされるのでしょうか?JSON を使った先ほどの例もいいですが、プロトコルによっては、独自の機能を活用してこれらのメタデータを送信したい場合もあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's why Cloud Events also proposes bindings.  A binding is a set of recommendations specific to one protocol.  It explains how each protocol should encode Cloud Events.  For example, there is a binding for HTTP, one for Kafka, and another for AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、Cloud Eventsではバインディングも提案しています。バインディングとは、あるプロトコルに固有の推奨事項のセットです。各プロトコルがどのようにCloud Eventsをエンコードすべきかを説明します。例えば、HTTP用のバインディング、Kafka用のバインディング、AMQP用のバインディングがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of these bindings propose two approaches:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのバインディングのほとんどは、2つのアプローチを提案しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>structured</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>structured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>binary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>binary</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach keeps event metadata and data together in the payload of the message or request.  It generally uses JSON to encode that data.  If you pass the Cloud Event example (from above), in an HTTP request, it will use the structured mode.  It will also use the structured mode when you write that JSON snippet in a Kafka record's value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構造化されたアプローチは、イベントのメタデータとデータをメッセージやリクエストのペイロードにまとめて保持します。一般的には JSON を使用してデータをエンコードします。Cloud Event の例 (上記) を HTTP リクエストで渡すと、構造化モードを使用します。また、Kafka レコードの値にその JSON スニペットを書き込む場合も構造化モードを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach allows simple forwarding across multiple protocols.  However, it may not be efficient and may constraint the type of business data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構造化されたアプローチでは、複数のプロトコルをまたいで簡単に転送することができます。しかし、効率的でない場合があり、ビジネスデータの種類を制約する場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other approach relies on protocol capabilities and enables efficient transfer and encoding.  If we use the binary mode with Kafka, we will store the `data` attribute value in the Kafka record's value and pass the other attributes using the record's headers.  Consequently, business data can be encoded using binary protocols such as Avro, leading to higher efficiency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つのアプローチはプロトコルの能力に依存しており、効率的な転送とエンコードを可能にします。Kafkaでバイナリーモードを使用する場合、Kafkaレコードの値に `data`  属性の値を格納し、レコードのヘッダを使用して他の属性を渡すことになります。その結果、Avroなどのバイナリープロトコルを使ってビジネスデータをエンコードすることができ、効率化につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the post explains how you can send and receive Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>残りの記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを送受信する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Cloud Events on Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントをKafkaで送信する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector used by Quarkus has built-in support for Cloud Events.  It can send and consume Cloud Events using the structured mode (encoding everything in a JSON payload) or the binary mode (using Kafka headers).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusが使用するKafkaコネクタは、Cloud Eventsをビルトインでサポートしています。構造化モード(JSONペイロードですべてをエンコード)またはバイナリーモード(Kafkaヘッダーを使用)を使用して、クラウドイベントを送信したり消費したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write your outgoing messages as Cloud Event, you only need to specify the `cloud-events-type` and `cloud-events-source` attributes on your channel:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信メッセージをクラウドイベントとして記述するには、チャンネルに `cloud-events-type`  と `cloud-events-source`  属性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the connector writes Cloud Events using the binary mode.  The connector generates a random `id` for each message.  You can also customize the other Cloud Event attributes using `cloud-events-$attribute`, such as `cloud-events-subject`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、コネクタはバイナリーモードを使用してクラウドイベントを書き込みます。コネクタはメッセージごとにランダムな `id`  を生成します。 `cloud-events-$attribute`  を使用して、 `cloud-events-subject`  などの他のクラウドイベント属性をカスタマイズすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration shown above is applied to all the outgoing messages.  Sometimes, you want to customize the value for each message individually.  To achieve this, you can also attach `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` to your message to customize the id, source, type and subject for each message:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の設定は、すべての送信メッセージに適用されます。場合によっては、各メッセージの値を個別にカスタマイズしたいこともあるでしょう。これを実現するには、メッセージに `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata`  を添付して、各メッセージの id、ソース、タイプ、件名をカスタマイズすることもできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector also supports the _structured_ mode.  You can write structured Cloud Events by setting the `cloud-events-mode` attribute to `structured`.  It only supports JSON at the moment.  The written record gets its `content-type` header set to `application/cloudevents+json; charset=UTF-8`, which allows the receiver to understand that it's a structured Cloud Event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コネクタは _構造化_ モードもサポートしています。 `cloud-events-mode`  属性を `structured`  に設定することで、構造化された Cloud Events を書くことができます。現時点では JSON のみサポートしています。書き込まれたレコードの `content-type`  ヘッダーは `application/cloudevents+json; charset=UTF-8`  に設定され、これにより受信者はそれが構造化されたクラウドイベントであることを理解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming Cloud Event from Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントをKafkaから消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, the connector can also consume Cloud Events.  The connector detects Cloud Events automatically by checking the record's headers.  It also determines the mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当然のことながら、コネクタはクラウドイベントを消費することもできます。コネクタは、レコードのヘッダをチェックすることで、自動的にクラウドイベントを検出します。また、モードも決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the connector receives a Cloud Event, it attaches an `IncomingKafkaCloudEventMetadata` to the message metadata.  So, you can retrieve the various attributes as well as the extensions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コネクタはクラウドイベントを受信すると、メッセージのメタデータに `IncomingKafkaCloudEventMetadata`  をアタッチします。そのため、拡張だけでなく様々な属性を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the rise of event-driven architecture, Cloud Events are becoming highly popular.  Since Quarkus 1.9, the Kafka Connector used in Quarkus has built-in support for Cloud Events.  This post introduced Cloud Events and showed how you could write and read Cloud Events easily.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベント駆動型アーキテクチャの台頭に伴い、クラウドイベントの人気が高まっています。Quarkus 1.9以降、Quarkusで使用されているKafka ConnectorはCloud Eventsをビルトインでサポートしています。この投稿では、Cloud Eventsを紹介し、Cloud Eventsを簡単に書いたり読んだりする方法を紹介しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many more options are http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[available], and Kafka is not the only part of Quarkus with Cloud Events support.  For example, Funqy[https://quarkus.io/guides/funqy#context-injection] also supports Cloud Event out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にも多くのオプションが http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[用意]されており、KafkaだけがクラウドイベントをサポートしているQuarkusの一部ではありません。例えば、Funqy https://quarkus.io/guides/funqy#context-injection ]もクラウドイベントをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.2.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.12.2.Finalは、バグの修正とドキュメントの改善を行ったメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a recommended upgrade for everyone using Quarkus 1.12.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus 1.12を使用しているすべての人に推奨されるアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two important regressions fixed</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つの重要なリグレッションの修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.12.2.Final fixes two important regressions that were introduced in 1.12.1.Final:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.12.2.Finalでは、1.12.1.Finalで発生した2つの重要なリグレッションが修正されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building native images on Windows was broken.  We added a CI check to be sure we don't break it again in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Windows でのネイティブイメージのビルドが壊れていました。今後、二度と壊れないように、CIチェックを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying to OpenShift was also not working properly in 1.12.1.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.12.1.Finalでは、OpenShiftへのデプロイも正常に動作していませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.12.2.Final[the full changelog of 1.12.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.12.2.Final[GitHubに1.12.2.Finalの完全な変更履歴]は掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have been hard at work during Summer to bake Quarkus 1.8.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>夏の間、Quarkus1.8を作り上げるために頑張ってきました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It comes with some shiny new features, among them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それはいくつかのピカピカの新機能が付属していますが、中でも以下のような機能があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A new Micrometer extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいMicrometerエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, it also comes with its fair share of bugfixes and usability and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、バグ修正や使い勝手の改善、ドキュメントの改善なども行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.8[our migration guide for 1.8].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか? link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.8[1.8の移行ガイドは] こちらです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11に対応したGraalVM 20.2が推奨バージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, with standard Quarkus configuration, the Hibernate ORM extension only supported a single persistence unit.  You could work around this limitation by using a `persistence.xml` but it was unpractical at best.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまで、Quarkusの標準的な設定では、Hibernate ORMエクステンションは単一の永続化ユニットしかサポートしていませんでした。 `persistence.xml` を使用することでこの制限を回避できましたが、せいぜい実用的ではありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.8 introduces support for multiple persistence units in the Hibernate ORM extension.  The feature is still experimental, not because it's unstable, but because we might tweak how you configure it depending on your feedback.  So if you use this feature, please provide your feedback on Zulip or on our `quarkus-dev` mailing list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.8 では、Hibernate ORM エクステンションに複数の永続化ユニットのサポートが導入されています。この機能はまだ実験的なもので、不安定だからというわけではありません。ですから、もしこの機能を使っているのであれば、Zulip や `quarkus-dev` メーリングリストでフィードバックをお願いします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about this new feature and how to use it in your applications, please refer to link:/guides/hibernate-orm[the Hibernate ORM extension guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この新機能の詳細とアプリケーションでの使用方法については、 link:/guides/hibernate-orm[Hibernate ORM エクステンションガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While standard Hibernate ORM entities can belong to several persistence units, Panache entities can only belong to one persistence unit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>標準のHibernate ORMエンティティは複数の永続化ユニットに所属できますが、Panacheエンティティは1つの永続化ユニットにしか所属できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer is a widely used library to collect metrics from your application.  One big advantage over our existing MicroProfile Metrics implementation is that a lot of dashboards are available out there for your usual monitoring tools.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Microrometer はアプリケーションからメトリクスを収集するために広く使われているライブラリです。既存の MicroProfile Metrics の実装と比較した場合の大きな利点は、通常のモニターリングツールに多くのダッシュボードが用意されていることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.8 introduces a new extension for Micrometer called `quarkus-micrometer`.  Please refer to link:/guides/micrometer[its guide] to learn more about it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.8では、 `quarkus-micrometer` と呼ばれるMicrometerのための新しいエクステンションが導入されました。詳細については、 link:/guides/micrometer[このガイドを] 参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scripting with jbang</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangを使ったスクリプト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.8 provides integration with https://jbang.dev[jbang]] which allows you to write Java scripts/applications requiring no Maven nor Gradle to get running.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.8は link:https://jbang.dev[jbang] との統合を提供します。これにより、MavenやGradleを実行する必要のないJavaのスクリプトやアプリケーションを書けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing quick scripts using the Quarkus stack becomes easy.  Learn more about it in link:/guides/scripting[the Scripting with jbang guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusスタックを使用したクイックスクリプトの作成が簡単になりました。詳細については、 link:/guides/scripting[jbangを使ったスクリプト作成ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 20.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you build native executables from your Quarkus applications, it is time to update to GraalVM 20.2, which is the recommended version from now on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのアプリケーションからネイティブの実行ファイルをビルドしている場合は、今から推奨バージョンであるGraalVM 20.2にアップデートする時期になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye OpenAPI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye OpenAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye OpenAPI users often request the ability to save the generated API document.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye OpenAPIのユーザーは、生成されたAPIドキュメントを保存する機能をしばしば要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The new `quarkus.smallrye-openapi.store-schema-directory` property allows you to do exactly that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい `quarkus.smallrye-openapi.store-schema-directory` プロパティーを使用すると、まさにそれが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quartz</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is now possible to configure the Quartz by setting the `quarkus.quartz.instance-name` configuration property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.quartz.instance-name` 設定プロパティーを設定することで、Quartzの設定が可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with 1.8, you can use CDI injection in Quartz jobs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.8からは、QuartzジョブでCDIインジェクションを使用できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension points (trigger listeners, job listeners, plugins) configuration have changed, so if you are using this feature, please refer to link:/guides/quartz#quartz-configuration-reference[the updated documentation] to migrate your configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>拡張ポイント(トリガーリスナー、ジョブリスナー、プラグイン)の設定が変更されていますので、この機能をご利用の方は、 link:/guides/quartz#quartz-configuration-reference[更新されたドキュメントを] 参照して設定を移行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of our extensions requires some additions to properly support Kotlin.  This is the case of the MongoDB with Panache extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのエクステンションの中には、Kotlin を適切にサポートするためにいくつかの追加を必要とするものがあります。これは MongoDB with Panache エクステンションがそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using MongoDB with Panache and Kotlin, please add the `quarkus-mongodb-panache-kotlin` extension to your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MongoDBをPanacheとKotlinで使用している場合は、 `quarkus-mongodb-panache-kotlin` のエクステンションをプロジェクトに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.8.0.CR1[1.8.0.CR1] and https://github.com/quarkusio/quarkus/releases/tag/1.8.0.Final[1.8.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.0.CR1[1.8.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.8.0.Final[1.8.0.Final] の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[356 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコミュニティは成長を続けており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[356人の貢献者] がいます。一人ひとりの貢献者に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.8 release, thanks to Aaron Coburn, Alex Soto, Alexey Loubyansky, Andreas Eberle, Andrej Petras, Andy Damevin, Antonio Goncalves, antonwiens, Bill Burke, Bobby Alex Philip, Charlie Powicki, Clement Escoffier, Daniel Platz, Dmitry Shohov, Enercido Alcantara, Erin Schnabel, Fabian Stäber, Falko Modler, Foivos Zakkak, Galder Zamarreño, Garima Monga, Gautier de Saint Martin Lacaze, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Jaikiran Pai, Jan Martiška, Juri Berlanda, Justin Lee, Katia Aresti, kdnakt, Ken Finnigan, ketoketo, Kevin Viet, Knut Wannheden, Ladislav Thon, Laurent Broudoux, Luca Burgazzoli, Leandro, Loïc Hermann, Loïc Mathieu, Manyanda Chitimbo, MarceloArraes, Martin Kouba, Martin Schoene, Matej Novotny, Matthias Harter, Max Rydahl Andersen, Michael Simons, Michał Górniewski, Michał Szynkiewicz, Moncef, Moritz Becker, noelo, Pasquale Congiusti, Paul Carter-Brown, Phillip Kruger, Radim Vansa, Rafael T. C. Soares (A.K.A Tuelho), Raffael Hertle, Ramiz Ismailov, Roberto Cortez, Rohan Maity, Romain Quinio, Rostislav Svoboda, Sanne Grinovero, Sebastian Daschner, Sergey Beryozkin, Steffen Vinther Sørensen, Stuart Douglas, Stéphane Épardaud, Thomas Segismont, TNM Technologies, tomekl007, Yashar Imanlou and Yoann Rodière.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に1.8 リリースでは、Aaron Coburn, Alex Soto, Alexey Loubyansky, Andreas Eberle, Andrej Petras, Andy Damevin, Antonio Goncalves, antonwiens, Bill Burke, Bobby Alex Philip, Charlie Powicki, Clement Escoffier, Daniel Platz, Dmitry Shohov, Enercido Alcantara, Erin Schnabel, Fabian Stäber, Falko Modler, Foivos Zakkak, Galder Zamarreño, Garima Monga, Gautier de Saint Martin Lacaze, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Jaikiran Pai, Jan Martiška, Juri Berlanda, Justin Lee, Katia Aresti, kdnakt, Ken Finnigan, ketoketo, Kevin Viet, Knut Wannheden, Ladislav Thon, Laurent Broudoux, Luca Burgazzoli, Leandro, Loïc Hermann, Loïc Mathieu, Manyanda Chitimbo, MarceloArraes, Martin Kouba, Martin Schoene, Matej Novotny, Matthias Harter, Max Rydahl Andersen, Michael Simons, Michał Górniewski, Michał Szynkiewicz, Moncef, Moritz Becker, noelo, Pasquale Congiusti, Paul Carter-Brown, Phillip Kruger, Radim Vansa, Rafael T. C. Soares (A.K.A Tuelho), Raffael Hertle, Ramiz Ismailov, Roberto Cortez, Rohan Maity, Romain Quinio, Rostislav Svoboda, Sanne Grinovero, Sebastian Daschner, Sergey Beryozkin, Steffen Vinther Sørensen, Stuart Douglas, Stéphane Épardaud, Thomas Segismont, TNM Technologies, tomekl007, Yashar Imanlou そして Yoann Rodièreのおかげです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The just released Quarkus 1.10.2.Final comes with a lot of improvements and new features:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リリースされたばかりのQuarkus 1.10.2.Finalには、多くの改善と新機能が搭載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default media type is now JSON</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのメディアタイプがJSONになりました</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts is now the default project generation tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CodeStarts はデフォルトのプロジェクト生成ツールになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Qute error pages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい Qute のエラーページ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Part of the Hibernate ORM configuration is now overridable at runtime</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HibernateのORM設定の一部が実行時にオーバーライド可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients support multiple datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ SQL クライアントが複数のデータソースをサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Amazon IAM extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいAmazon IAMのエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[our migration guide for 1.10].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか?ここに  https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10への移行ガイド]があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is still the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11 対応の GraalVM 20.2 は、まだ推奨の GraalVM のバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where is my 1.10.0.Final (and my 1.10.1.Final)?!?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.0.Final(と1.10.1.Final)はどこにあるの!?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We spotted a regression in the Caffeine extension and decided to skip the announcement of 1.10.0.Final altogether.  And then we spotted an issue with the Platform BOM and had to release a 1.10.2.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Caffeine エクステンションのリグレッションを発見しました。そのため 1.10.0.Final の発表をスキップしました。そして、Platform BOM の問題を発見しました。なので 1.10.2.Final をリリースしなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All in all, we managed to fix a few more issues in the meantime so that makes 1.10.2.Final a greater release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その間にいくつかの問題を修正することができたので、1.10.2.Final はより大きなリリースとなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON as the Default Content Type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのコンテンツタイプとしての JSON</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In an effort to make your REST resources less verbose and considering nowadays JSON is the most widely used content type for REST services, it is now the default in Quarkus for your REST resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST リソースを冗長にならないようにするための努力と、最近では JSON が REST サービスで最も広く使用されているコンテンツタイプであることを考慮して、Quarkus では REST リソースのデフォルトとして JSON が使用されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It means that, if you are using JSON, you don't need to add `@Produces` and `@Consumes` annotations anymore.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、JSON を使用している場合は、`@Produces` と `@Consumes` のアノテーションを追加する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also means that if you were relying on content type negotiation, you will have to add these annotations with the content types you support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コンテンツタイプネゴシエーションに頼っていた場合、サポートしているコンテンツタイプでこれらのアノテーションを追加しなければいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts as Default Project Generation Tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのプロジェクト生成ツールとしてのCodeStarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CodeStarts project has been a long and steady effort.  Good news: it is now the default project generation tool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CodeStarts プロジェクトは、長い間地道な努力を続けてきました。朗報:今はデフォルトのプロジェクト生成ツールになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From an end user perspective, it brings a better UI, more flexibility and code examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドユーザーの視点から見ると、より良い UI、より柔軟性のあるコード例をもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two new registries were added:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新たに2つのレジストリーが追加されました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StatsD</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>StatsD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SignalFX</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SignalFX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also added more metrics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらにメトリクスを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of work has been done to make the Swagger/GraphQL/Health/OpenAPI UIs consistent and Quarkus-themed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Swagger/GraphQL/Health/OpenAPI UI を一貫して Quarkus をテーマにしたものにするために、多くの作業が行われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also now disable them at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、実行時にそれらを無効にすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More specifically on the Swagger UI front, all the Swagger UI configuration knobs have been exposed as Quarkus configuration properties.  You can learn more about it in link:/blog/stylish-api/[the just published Stylish API blog post].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より具体的には、Swagger UI の前面では、すべての Swagger UI 設定のつまみが Quarkus の設定プロパティーとして公開されています。それについては、  https://quarkus.io/blog/stylish-api/[先日公開されたばかりの Stylish API のブログ記事]で紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Qute, our template engine, you will be pleased to see our shiny new error pages, which points you to the error and makes you even more productive:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートエンジンのQuteをお使いの方は、ピカピカのエラーページをご覧になって喜んでいただけると思います。これがエラーを指摘し、さらに生産性を高めてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before 1.10, all of the Hibernate ORM configuration properties were fixed at build time.  Mostly for optimization purposes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10 以前では、すべての Hibernate ORM 構成プロパティーがビルド時に修正されていました。主に最適化のためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With 1.10, we started to relax this rule for some carefully chosen properties and you can now override the following properties at runtime:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10 では、慎重に選択したいくつかのプロパティーについてこのルールを緩和しました。以下のプロパティーを実行時にオーバーライドできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Reactive Changes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>更なるリアクティブの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.5.0 which includes several improvements and Mutiny to 0.11.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging  が 2.5.0 にアップグレードされました。これにより、いくつかの改善と Mutiny が 0.11.0 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reactive SQL Clients now support multiple datasources: you can connect to several databases, exactly in the same way as for JDBC datasources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive SQL クライアントは複数のデータソースをサポートするようになりました。これによって複数のデータベースに接続できるようになりました。JDBC データソースの場合と全く同じ方法で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Amazon Services extensions got a new friend: a brand new Amazon IAM extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon サービスのエクステンションに新しい友人ができました。真新しい Amazon IAM エクステンションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More on this one in link:/guides/amazon-iam[the Amazon IAM guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これについては、 https://quarkus.io/guides/amazon-iam[Amazon IAM ガイド]で詳しく紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of Google Cloud-related work is taking place in the https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud 関連の仕事の多くは https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse] で行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And if you wonder how you will deploy your Quarkus application to Google Cloud, we have a link:/guides/deploying-to-google-cloud[new guide] for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkus アプリケーションをどのように Google Cloud にデプロイするのか疑問に思っている方のために、 https://quarkus.io/guides/deploying-to-google-cloud[新しいガイド]をご用意しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Changes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.24.Final</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM が 5.4.24.Final にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[1.10.0.CR1], https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final], https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1.Final] and https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[1.10.2.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[1.10.0.CR1]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1.Final]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[1.10.2.Final] の完全な変更ログはGitHubで入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[395 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには現在 https://github.com/quarkusio/quarkus/graphs/contributors[395人の貢献者]がいます。皆様、本当にありがとうございました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.10 release, thanks to Alexey Loubyansky, Andrea Cosentino, Andreas Eberle, Andrej Petras, Andrew Hatch, Andy Damevin, Anton Fagerberg, Antonio Goncalves, antonwiens, Arne Mejlholm, Auri Munoz, Bill Burke, Bobby Alex Philip, Bobby Philip, Cem Nura, Clement Escoffier, Daniel Platz, David M. Lloyd, Denis Fuenzalida, Dheeraj Nalluri, Dmitry Telegin, Dominik Henneke, Dušan Križan, Erin Schnabel, Falko Modler, Felix Wong, Foivos Zakkak, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Gytis Trikleris, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Antosik, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, jyemin, jzuriaga, Jérôme TAMA, Jörg von Frantzius, kdnakt, Kevin Viet, Knut Wannheden, Kuba Antosik, Ladislav Thon, Libor Krzyzanek, Lovekesh Garg, Loïc Mathieu, luneo7, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Martin Kouba, Matej Novotny, Matej Vasek, Matthias Harter, Michal Szynkiewicz, Nathan Erwin, osaka-svg, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Kruger, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Samuel Le Berrigaud, Sanne Grinovero, seregamorph, Sergey Beryozkin, Simon Bengtsson, Stefan Hacker, Stephane Epardaud, Stuart Douglas, Thorasine, Vincent Sevel, Vincent Sourin, Vinod Anandan, xstefank, Xumk, Yoann Rodière.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に1.10リリースについてはみなさんのおかげです: Alexey Loubyansky, Andrea Cosentino, Andreas Eberle, Andrej Petras, Andrew Hatch, Andy Damevin, Anton Fagerberg, Antonio Goncalves, antonwiens, Arne Mejlholm, Auri Munoz, Bill Burke, Bobby Alex Philip, Bobby Philip, Cem Nura, Clement Escoffier, Daniel Platz, David M. Lloyd, Denis Fuenzalida, Dheeraj Nalluri, Dmitry Telegin, Dominik Henneke, Dušan Križan, Erin Schnabel, Falko Modler, Felix Wong, Foivos Zakkak, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Gytis Trikleris, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Antosik, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, jyemin, jzuriaga, Jérôme TAMA, Jörg von Frantzius, kdnakt, Kevin Viet, Knut Wannheden, Kuba Antosik, Ladislav Thon, Libor Krzyzanek, Lovekesh Garg, Loïc Mathieu, luneo7, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Martin Kouba, Matej Novotny, Matej Vasek, Matthias Harter, Michal Szynkiewicz, Nathan Erwin, osaka-svg, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Kruger, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Samuel Le Berrigaud, Sanne Grinovero, seregamorph, Sergey Beryozkin, Simon Bengtsson, Stefan Hacker, Stephane Epardaud, Stuart Douglas, Thorasine, Vincent Sevel, Vincent Sourin, Vinod Anandan, xstefank, Xumk, Yoann Rodière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.3.Final mainly fixes a regression introduced in 1.11.2.Final that makes it impossible to build native executables while using both the RESTEasy and OpenTracing extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.3.Finalは主に1.11.2.Finalで導入された、RESTEasy と OpenTracing の両方のエクステンションを使用している場合にネイティブの実行ファイルをビルドできないようにするリグレッションを修正しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.11 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.11を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11移行ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[the full changelog of 1.11.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[GitHubで1.11.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.amqp.org/[AMQP 1.0] is a standard for passing messages between applications or organizations.  It connects systems, feeds business processes with the information they need, and reliably handles communication between systems.  AMQP is a robust and mature protocol widely used in event-driven applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://www.amqp.org/[AMQP 1.0] は、アプリケーションや組織間でメッセージを渡すための標準規格です。AMQP はシステムを接続し、ビジネスプロセスに必要な情報を供給し、システム間の通信を確実に処理します。AMQP は、イベント駆動型のアプリケーションで広く使用されている堅牢で成熟したプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post is the equivalent of the https://quarkus.io/blog/getting-started-kafka/[Kafka getting started post], but focuses on the usage of AMQP.  You will learn how to get started with AMQP in your Quarkus application in less than ten steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] - a declarative approach to building event-driven microservices.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この投稿は、 link:https://quarkus.io/blog/getting-started-kafka/[Kafkaの入門記事] と同等の内容を説明しますが、AMQPの使用方法に焦点を当てています。QuarkusアプリケーションでAMQPを使い始める方法を10ステップ以内で学ぶことができます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub] から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project containing examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Example Code" を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-amqp` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-amqp` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。なのでコードを書く準備が出来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With AMQP, we exchange http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[messages], which can have multiple _data_ sections (or multiple AMQP sequences, or a single AMQP value section).  In our application, as we are exchanging `Movie` object, it encodes the instances as JSON and transfers it in a single _data_ section.  The `content-type` header is set to `application/json`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AMQPでは、複数の _データ_ セクション(または複数のAMQPシーケンス、または単一のAMQP値セクション)を持つことができる link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[メッセージ] を交換します。私たちのアプリケーションでは、 `Movie` オブジェクトを交換しているので、インスタンスを JSON としてエンコードし、単一の _データ_ セクションで転送しています。 `content-type` ヘッダは `application/json` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP messages are sent to a destination.  To keep things simple, let's name it __movies__.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AMQPメッセージを送信先に送信します。簡単にするために、 __movies__ という名前にしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  We must indicate that our reception and publication channels will use the __movies__ address in our application.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の通り、Reactive Messagingを使用します。リアクティブメッセージングを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、設定によって基礎となるメッセージング技術にマッピングされます。受信および公開チャンネルがアプリケーションで __movies__ アドレスを使用することを示す必要があります。 `src/main/resources/application.properties` で、次の内容を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location and credentials (`amqp-` properties), we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーの場所と資格情報( `amqp-` プロパティー)を設定した後、 `movies-in` (レコードを受信)と `movies-out` (レコードを公開)の2つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the AMQP connector.  We also need to specify the consumed destination using the `address` attribute.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>チャンネルの設定には、 `mp.messaging.incoming.movies-in` というプレフィックスを使用します。 `connector` 属性は、このチャネルの責任者(ここでは AMQP コネクタ)を示します。また、 `address` 属性を使用して、消費先を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicating who's responsible for that channel, we also need to configure the address.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` プレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、アドレスも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to AMQP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ4 - AMQPへのムービーの公開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send messages.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、いよいよメッセージを送信する時が来ました。以下の内容で `org.acme.MovieProducer` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter,` i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and will send messages to AMQP).  The connector automatically encoded the content as JSON and set the `content-type` header.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスでは、 `Emitter,` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (AMQP にメッセージを送信します)。コネクタは自動的にコンテンツを JSON としてエンコードし、 `content-type` ヘッダを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to make sure your payload can be encoded to JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ペイロードが JSON にエンコードできることを確認する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can use the `send` method to send a movie to our AMQP destination.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、私たちのアプリケーションの残りの部分は、 `send` メソッドを使用して、AMQP の宛先にムービーを送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今度は反対側に目を向けて、AMQPからムービーを取得してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, the movie is encoded into JSON, so we need to help the connector produce a `Movie` from the received JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ムービーは JSON にエンコードされていることを思い出してください。コネクタが受信した JSON から `Movie` を生成するのを支援する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `org.acme.JsonToObjectConverter` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `org.acme.JsonToObjectConverter` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class is a _converter_.  It maps the content of a `Message` to another type.  In the `canConvert` method, we verify that the incoming message is coming from AMQP (so contain the `IncomingAmqpMetadata` metadata) and that the content-type is set to `application/json`.  The `convert` method maps the received `JsonObject` into the target type (`Movie` in our case).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは _converter_ です。 `Message` の内容を別の型にマッピングします。 `canConvert` メソッドでは、受信メッセージが AMQP からのものであること (つまり `IncomingAmqpMetadata` メタデータを含むこと) と、content-type が `application/json` に設定されていることを確認します。 `convert` メソッドは、受信した `JsonObject` をターゲット型 (私たちの場合は `Movie` ) にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this converter, our `consume` method will receive the `Movie` objects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコンバータにより、 `consume` メソッドは `Movie` オブジェクトを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to AMQP from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントからAMQPにメッセージを送信することはよくあることです。これを行うには、以下の内容で `org.acme.MovieResource` クラスを作成します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class uses the `MovieProducer` we implemented above to send the `movies`.  You could also use an `Emitter` directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは、上で実装した `MovieProducer` を使用して `movies` を送信します。 `Emitter` を直接使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need an AMQP broker, for example http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis].  You can follow the http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] documentation, or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、AMQPブローカー、例えば link:http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis] が必要です。 link:http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] のドキュメントに従うか、以下の `docker-compose.yaml` ファイルを使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d'</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します: `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using AMQP starting in a few milliseconds and consuming a ridiculous amount of memory: only 33Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、AMQPを使用したQuarkusアプリケーションが数ミリ秒で起動し、とんでもない量:100レコードを取り込んでもたったの33MB!になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using AMQP.  If you want to go further, check the https://quarkus.io/guides/amqp[AMQP guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>10分もしないうちに、AMQPを使った新しいQuarkusアプリケーションができました。もっと詳しく知りたい方は、 link:https://quarkus.io/guides/amqp[AMQPガイド] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just before my PTO, someone told me: '_I don't like magic._' In this context, _magic_ refers to the amount of hidden _stuff_ done by Quarkus under the hood for the sake of simplicity.  It includes dependency injection, annotations, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>有休の直前に 誰かに言われました _"私はマジックが好きじゃない"_ って。この文脈では、 _マジック_ とは、シンプルにするためにQuarkusが裏側で行っている隠れた _作業_ のことを指します。これには依存性注入やアノテーションなどが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not the first time that I get that kind of comment, and coming from the Vert.x project, it makes sense.  Vert.x has (almost) no magic, and for a good reason: too much magic can be terrible and make production tuning utterly expensive.  Sometimes you want to have more control and avoid unexpected behaviors: execute the code you wrote, and nothing else.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなコメントを受けるのは初めてではないし、Vert.xプロジェクトから来ているので、それは理にかなっています。Vert.x には(ほとんど)マジックがありませんが、それには正当な理由があります: マジックが多すぎるとひどいことになり、プロダクションチューニングが全く大変になります。時には、より多くの制御をして予期せぬ動作を避けたい場合があります: ただ書いたコードだけが実行され、それ以外は何もしないで欲しい、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But magic is not inherently bad.  Magic is power that can be used for good or for bad.  After all, your application runs on a silicon with microcode magic powering an Operating System with abstraction magic powering the Java Virtual Machine with Just In Time magic.  There is magic, it's just magic you have enough knowledge (or trust) of vs magic you don't.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、マジックは本質的に悪いものではありません。マジックは良いことにも悪いことにも使えるパワーなのです。結局のところ、あなたのアプリケーションは、マイクロコードで力を与えられた半導体上で実行される、抽象化のマジックで力を与えられたオペレーティングシステム上の、JITのマジックで力を与えられたJava仮想マシンで動いています。マジックはありますが、それはあなたが十分な知識を持っている(または信頼している)マジックと、そうでないマジックのことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may think that Quarkus has a lot of magic tricks.  It is true in some sense but it is easily understood and comes with strong benefits in either memory optimization, startup time optimization or last but not least developer experience improvements.  You can decide the amount of magic that you want and the amount of control you feel comfortable with.  You don't have to use dependency injection or managed clients if you prefer doing things yourself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusにはたくさんのマジックのトリックがあると思うかもしれません。ある意味ではそうなのですが、簡単に理解でき、メモリーの最適化、起動時間の最適化、または開発者の経験の向上のいずれかにおいて強力なメリットがあります。あなたが望むマジックの量と、あなたが快適に感じるコントロールの量を決めることができます。もし自分でやりたいのであれば、依存性注入や管理クライアントを使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, we will cover three different approaches to reducing the amount of magic.  We will go from almost no magic to just enough to get a good developer experience.  Examples from this blog post are available on https://github.com/cescoffier/quarkus-magic-control[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回の記事では、マジックの量を減らすための3つの異なるアプローチを取り上げます。マジックをほとんど使わない状態から、良い開発者体験を得るために必要なだけの状態にしていきます。このブログ記事の例は link:https://github.com/cescoffier/quarkus-magic-control[GitHub]で公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _almost no magic_ approach</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_ほとんどマジックがない_ アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are Java applications.  So, somewhere there is a `public static void main(String... args)`.  While you don't need to write that method when using Quarkus, it can still be convenient and give you more control about your application startup.  It's also a good trick to start your Quarkus application directly from your IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのアプリケーションはJavaアプリケーションです。そのため、どこかに `public static void main(String…​ args)` が存在します。Quarkusを使用する際にそのメソッドを記述する必要はありませんが、それでも便利で、アプリケーションの起動についてより多くのコントロールが可能になります。また、IDEから直接Quarkusアプリケーションを起動するのも良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, we will implement a straightforward HTTP application. Nothing fancy:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例として、簡単な HTTP アプリケーションを実装します。派手なものは何もありません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete source code is available https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[here].  Don't expect much more; the application had only one Java class, but let's look into it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なソースコードは link:https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[ここ]にあります。アプリケーションにはJavaクラスが1つしかありませんが、それを調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@QuarkusMain` indicates that Quarkus should use this class as the _main entry point_ of the application.  The `run` method contains your application logic.  We will come back to this logic later.  First, look at the `public static void main(String... args)` method.  It just starts the application.  You can use this entry point directly from your IDE.  Yes, there is still a bit of magic behind `Quarkus.run`; that's where the extension initialization happens - not unlike _any_ framework initialization including Vert.x.  As this application does not use any extension, nothing much will happen.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusMain` は、Quarkusがこのクラスをアプリケーションの _メインエントリーポイント_ として使用することを示しています。 `run` メソッドには、アプリケーションのロジックが含まれています。このロジックについては後ほど説明します。まず、 `public static void main(String…​ args)` メソッドを見てください。これはアプリケーションを起動するだけです。このエントリーポイントは、IDE から直接使用できます。そう、 `Quarkus.run` の背後にはまだちょっとしたマジックがあります。エクステンションの初期化が行われるのは、 Vert.x を含む _どの_ フレームワークの初期化とも異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[depends] directly on Vert.x Web and Vert.x Core.  The only Quarkus dependency is Arc (not used directly but required):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションは Vert.x Web と Vert.x Core に直接 link:https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[依存します]。Quarkusの依存関係はArcだけです(直接は使用しませんが必須です):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go back to the `run` method.  It contains the application logic, here, a dummy Vert.x application.  It creates the `Vertx` instance, a `Router`, registers a few routes, and starts the HTTP server.  Because we don't want the application to stop immediately, we _wait for exit_.  The `/bye` request handler illustrates how you can programmatically trigger the application shutdown.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`run` メソッドに戻りましょう。これにはアプリケーション・ロジックが含まれており、ここではダミーの Vert.x アプリケーションを使用しています。 `Vertx` インスタンス、 `Router` を作成し、いくつかのルートを登録し、HTTP サーバーを起動します。アプリケーションをすぐに停止させたくないので、 _終了を待ちます_。 `/bye` リクエスト・ハンドラーは、アプリケーションのシャットダウンをプログラムでトリガーする方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application has almost no magic, just a single annotation, and a regular Java entry point.  You may wonder why not using a bare Java program? Even used that way, Quarkus provides benefits. For example, you can access the built-in configuration support as illustrated in the snippet:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションにはマジックはほとんどなく、ただのアノテーション1つと、普通のJavaのエントリーポイントがあるだけです。なぜむき出しのJavaプログラムを使わないのかと疑問に思うかもしれません。そのように使用しても、Quarkusには利点があります。例えば、スニペットに示されているように、組み込みの設定サポートにアクセスすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is located in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定は、 `application.properties` ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This first approach has a few drawbacks.  It does not benefit from the built-time processing of Quarkus.  The logic executed at build time is packaged inside extensions, and in this case, we don't use extensions (except Arc).  Another issue is that compiling this application to native will fail because extensions are also involved during the native compilation.  Finally, the hot reload won't work, but you can directly restart the application from your IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この最初のアプローチには、いくつかの欠点があります。これはQuarkusのビルド時処理の恩恵を受けていません。ビルド時に実行されるロジックはエクステンションの中にパッケージ化されており、この場合はエクステンションは使用されません(Arcを除く)。もう一つの問題は、このアプリケーションをネイティブにコンパイルすると、ネイティブのコンパイル時にエクステンションも絡んでくるので失敗するということです。最後に、ホットリロードはうまくいきませんが、IDEから直接アプリケーションを再起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses Vert.x heavily.  The `quarkus-vertx-core` extension manages the Vert.x instance used by Quarkus.  You can use that instance directly and avoid creating the Vert.x instance.  If you need to configure the instance, you can configure it from https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[the `application.properties`].  It also enables native packaging (as that extension contains the directive to compile Vert.x applications to native).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはVert.xを多用しています。 `quarkus-vertx-core` エクステンションは、Quarkusが使用するVert.xインスタンスを管理します。そのインスタンスを直接使用することができ、Vert.xインスタンスを作成する必要はありません。インスタンスを設定する必要がある場合は、 link:https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[`application.properties`] から設定することができます。また、ネイティブパッケージングも可能になります(このエクステンションには Vert.x アプリケーションをネイティブにコンパイルするためのディレクティブが含まれているため)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your pom.xml file, just add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pom.xmlファイルに以下の依存関係を追加します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, the _run_ method becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 _run_ メソッドは以下のようになります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how it retrieves the managed Vert.x instance.  While you can use `@Inject`, you can also retrieve it programmatically, the rest of the code does not change.  See? No magic for you! We can still start it from the IDE using the _main_ method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されている Vert.x インスタンスを取得する方法に注目してください。 `@Inject` を使用することができますが、プログラムで取得することも出来、残りのコードは変更しません。ご覧になりましたか?魔法はありません! _メイン_ メソッドを使用して、IDE から起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't include the `quarkus-vertx-core` extension (or any extension depending on it), Quarkus won't create the Vert.x instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-vertx-core` エクステンション(またはそれに依存するエクステンション)を含まない場合、QuarkusはVert.xインスタンスを作成しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using extensions gives you some property wiring as well as the build time optimisations and native image compilation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを使用すると、プロパティーの設定や、ビルド時間の最適化、ネイティブイメージのコンパイルも行うことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, still no hot reload 😿.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、やはりホットリロードはダメですね😿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of using only the `quarkus-vertx-core` extension, we can choose to delegate the HTTP server to Quarkus.  You may see that as a loss of control, but actually, we rarely do much around it, and again, you can configure it from the `application.properties` file if needed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-vertx-core` のエクステンションだけを使用するのではなく、HTTPサーバーをQuarkusに委任することもできます。 これは制御できないと思われるかもしれませんが、実際には、そのようなことは滅多にしませんが、必要なら、 `application.properties` ファイルから設定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of ``quarkus-vertx-core`, use `quarkus-vertx-http`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>``quarkus-vertx-core` の代わりに、 `quarkus-vertx-http` を使用してください:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No need to depend on Vert.x Web directly, it's included.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x Webに直接依存する必要はなく、含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will still register your routes, but using a managed `Router`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートの登録は引き続き行いますが、管理されている `Router` を使用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That approach enables the Quarkus hot reload as it intercepts the HTTP requests.  You are still in control of everything related to your application logic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチでは、HTTPリクエストをインターセプトするため、Quarkusのホットリロードが可能になります。アプリケーションロジックに関連するすべてのことを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can start the hot reload using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次を使ってホットリロードを開始することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final _magic touch_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後の _マジックタッチ_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The question, now, is how far are we from a _regular_ Quarkus application? Quite close, actually.  The equivalent application using RESTEasy Reactive would be something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題は、Quarkusの _通常の_アプリケーションからどれくらい離れているかということです。実際には、かなり近いです。RESTEasy Reactiveを使った同等のアプリケーションは、次のようなものです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the previous approaches, this one leverages a declarative (annotation-based) model.  Under the hood, it's not that different from the last approach.  Quarkus registers a route (on the router), which then calls the `hello` method when a matching request is received.  The router gets initialized during the `Quarkus.run` method.  No need for the _main_ endpoint, but you can still use one, often convenient in IDEs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでのアプローチとは異なり、このアプローチは宣言的な(アノテーションベースの)モデルを活用しています。内部では、前のアプローチとそれほど違いはありません。Quarkusは(ルーター上で)ルートを登録し、一致するリクエストを受信すると `hello` メソッドを呼び出します。ルータは、 `Quarkus.run` メソッドの間に初期化されます。 _メインエンドポイント_ は必要ありませんが、1つのエンドポイントを使用することができ、IDEでは便利なことが多いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our relation to magic depends on our background and experience.  Quarkus lets you decide how much magic you accept.  This post presented fours configurations, going from almost no magic to the _regular_ Quarkus code.  Each approach has pros and cons:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのマジックとの関係は、私たちのバックグラウンドや経験によって異なります。Quarkusでは、どの程度のマジックを受け入れるかを決めることができます。この記事では、ほとんど魔法を使わない状態から _通常の_ Quarkusコードまで、4つの設定を紹介しました。それぞれのアプローチには長所と短所があります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Control</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コントロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build time optimizations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot Reload</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホットリロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Almost no magic_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_殆どマジックなし_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Regular_ Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_通常の_ Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pick the approach that fits your needs.  Besides, most of Quarkus services are also available using a programmatic approach, as we have seen for configuration.  So, if you prefer avoiding managed objects, feel free just to use the available APIs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ニーズに合ったアプローチを選びましょう。また、設定について見てきたように、Quarkusのサービスのほとんどは、プログラム的なアプローチを使用して利用することもできます。管理されたオブジェクトを避けたい場合は、利用可能なAPIを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.9.2.Final released - Bugfixes'
date: 2020-11-05
tags: release
synopsis: 1.9.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.9.2.Finalリリース - バグフィックス
date: 2020-11-05
tags: release
synopsis: 1.9.2.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just a week after 1.9.1.Final, here comes 1.9.2.Final with some bugfixes and documentation improvements.  Thanks a lot to everyone providing feedback and pull requests!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.9.1.Finalからちょうど一週間後、バグフィックスとドキュメントの改善を加えた1.9.2.Finalがやってきました。フィードバックとプルリクエストを提供してくださった皆様、ありがとうございました!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.9.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus 1.9を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.9 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.9を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9移行ガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[the full changelog of 1.9.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[1.9.2.Finalの完全な変更履歴はGitHub]で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Metrics are the measurements of any aspect of an application such as resource usage or behaviors. We can expose these metrics from our Quarkus applications by using the https://quarkus.io/guides/micrometer[Micrometer] extension via the `/q/metrics` endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メトリクスは、リソースの使用状況や動作など、アプリケーションのあらゆる側面の測定値です。Quarkusのアプリケーションからこれらのメトリクスを公開するには、 `/q/metrics` エンドポイント経由で link:https://quarkus.io/guides/micrometer[Micrometer]エクステンションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What metrics will be exposed? Only by adding the Micrometer extension, a lot of metrics are exposed by default for example metrics about the JVM engine like the number of current live threads `jvm_threads_live_threads` or metrics about the system itself like the current CPU usage `system_cpu_usage`. Additionally, more metrics will automatically be exposed depending on other Quarkus extensions we might be using. For example, if we are using a Quarkus REST extension such as Resteasy, it will automatically expose metrics about your running services:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どのようなメトリクスが公開されますか?Micrometerエクステンションを追加するだけで、多くのメトリクスがデフォルトで公開されます。例えば、現在のライブスレッド数のようなJVMエンジンに関するメトリクス `jvm_threads_live_threads` や、現在のCPU使用率のようなシステム自体に関するメトリクス `system_cpu_usage` などがあります。さらに、使用している他のQuarkusエクステンションに応じて、より多くのメトリクスが自動的に公開されます。例えば、ResteasyのようなQuarkusのRESTエクステンションを使用している場合、実行中のサービスに関するメトリクスが自動的に公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>``` http_server_requests_seconds_count{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 1.0 http_server_requests_seconds_sum{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 0.018198043 ```</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>``` http_server_requests_seconds_count{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 1.0 
http_server_requests_seconds_sum{method="GET",outcome="SUCCESS",status="200",uri="/hello",} 0.018198043 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same will happen if we're using the Kafka extension. All this configuration is well documented in https://quarkus.io/guides/micrometer[the Quarkus Micrometer guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafkaエクステンションを使用している場合も同様です。これらの設定については、 link:https://quarkus.io/guides/micrometer[Quarkus Micrometerガイド]によく書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>__How are these metrics consumed?__ As said, Micrometer exposes the metrics on the `/q/metrics` endpoint in order to be consumed by third parties like https://prometheus.io/[Prometheus]. OpenShift provides an embedded Prometheus instance that we can use. So, let's see what we need to do to integrate our Quarkus Applications metrics and the Prometheus embedded instance provided in OpenShift.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>__これらのメトリクスはどのように消費されるのですか？__ 前述の通り、Micrometer は link:https://prometheus.io/[Prometheus] のようなサードパーティが利用できるように `/q/metrics` エンドポイントでメトリクスを公開しています。OpenShiftにはPrometheusのインスタンスが埋め込まれているので、それを利用することができます。それでは、Quarkus Applicationsのメトリクスと、OpenShiftで提供されているPrometheusの埋め込みインスタンスを統合するために必要なことを見ていきましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basically, we need to complete the next following steps:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基本的には、次のようなステップを踏む必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a Service monitor in our project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトにサービスモニターを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requirements</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.openshift.com/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html[Openshift CLI]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://docs.openshift.com/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html[Openshift CLI]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 1 - Enable Monitoring for user-defined projects in OpenShift</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ1 - OpenShiftでユーザー定義のプロジェクトのモニタリングを有効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to enable the Monitoring for user-defined projects, we need to follow the instructions https://docs.openshift.com/container-platform/4.7/monitoring/enabling-monitoring-for-user-defined-projects.html[from OpenShift documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー定義のプロジェクトのモニタリングを有効にするためには、 link:https://docs.openshift.com/container-platform/4.7/monitoring/enabling-monitoring-for-user-defined-projects.html[OpenShiftのドキュメント]の指示に従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In essence, we need to create a ConfigMap in the namespace `openshift-monitoring`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>突きつめると、名前空間 `openshift-monitoring` に ConfigMap を作成する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`cluster-monitoring-config.yaml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`cluster-monitoring-config.yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And apply it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、それを以下のように適用します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Openshift will automatically create the `openshift-user-workload-monitoring` namespace and deploy the required resources for Prometheus to it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Openshiftは自動的に `openshift-user-workload-monitoring` 名前空間を作成し、そこにPrometheusに必要なリソースをデプロイします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After the required infrastructure in OpenShift is ready, then let's continue with the Quarkus application. We'll implement a REST API and enable micrometer with prometheus which requires the addition of two Quarkus extensions to our `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShiftで必要なインフラの準備ができたら、次にQuarkusアプリケーションを進めていきましょう。REST APIを実装し、prometheusでmicrometerを有効にします。そのためには、 `pom.xml` ファイルに2つのQuarkusエクステンションを追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we'll add the Greeting resource:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、Greetingリソースを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we can see, we use the micrometer registry facade to create a counter with a tag by name that will be incremented every time it's invoked.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご覧のように、micrometer レジストリファサードを使用して、タグ名を持つカウンタを作成し、起動するたびにインクリメントしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try this application by running it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションを実行して試してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we should be able to call our service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、私たちのサービスを呼び出すことができるはずです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And it should return `Hello!`. So good so far, we can also see the metrics in `http://localhost:8080/q/metrics` where should see our `greeting_counter` counter:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `Hello!` を返すはずです。ここまではいいとして、 `http://localhost:8080/q/metrics` でメトリクスを見ることもできます。ここでは、 `greeting_counter` のカウンターを確認できます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next, we need to deploy our Quarkus application into OpenShift. For ease this step, Quarkus provides a super useful extension called `quarkus-openshift`, let's add it into our `pom.xml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、QuarkusアプリケーションをOpenShiftにデプロイする必要があります。このステップを簡単にするために、Quarkusは `quarkus-openshift` という非常に便利なエクステンションを提供していますので、これを `pom.xml` ファイルに追加しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, let's deploy our application into a newly created project `my-project` in OpenShift:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、OpenShiftで新たに作成したプロジェクト `my-project` にアプリケーションをデプロイしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The label `app-with-metrics` will be used in a later step to select the applications to monitor by OpenShift.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラベル `app-with-metrics` は、後のステップで OpenShift が監視するアプリケーションを選択するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before moving forward, let's explain first how Prometheus works. Prometheus uses a pull model to get metrics from applications. This means that Prometheus will scrape or watch endpoints to pull metrics from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先に進む前に、まずPrometheusの仕組みを説明しましょう。Prometheus は、アプリケーションからメトリクスを取得するためにプル・モデルを使用します。つまり、Prometheus はメトリクスを取得するためにエンドポイントをスクレイピングしたり、ウォッチしたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the previous step, our service is now running in OpenShift, but we didn't configure anything in Prometheus to scrape our service yet. This is done by the Service Monitor resource:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のステップから、サービスは OpenShift で実行されていますが、Prometheus でサービスをスクレイプするための設定はまだ何もしていません。これは Service Monitor リソースで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`service-monitor.yaml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`service-monitor.yaml`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What we have just done is to create a Service Monitor named `prometheus-app-monitor` that will select apps with the label `app-with-metrics: quarkus-app` that was added in the previous step. Then, OpenShift will call the endpoint `/q/metrics` for all the services labeled with `app-with-metrics: quarkus-app` every 30 seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今行ったのは、前のステップで追加した `app-with-metrics: quarkus-app` というラベルのついたアプリを選択する `prometheus-app-monitor` という名前の Service Monitor を作成することです。すると、OpenShiftは30秒ごとに、 `app-with-metrics: quarkus-app` というラベルのついたサービスすべてについて、エンドポイント `/q/metrics` を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's start using it!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いよいよ、使ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to call our greetings service: `http://quarkus-micrometer-my-project.ocp.host/hello/quarkus`. This will increment the `greeting_counter_total` counter. But where can we see the metrics? Let's browse to OpenShift Console in the `Developer &gt; Monitoring` view, select `Metrics`, then `Custom Query` and type `greeting_counter_total{name = "quarkus"}`, we should see now:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、グリーティングサービスを呼び出す必要があります: `http://quarkus-micrometer-my-project.ocp.host/hello/quarkus` 。これで `greeting_counter_total` カウンターが増加します。しかし、このメトリクスはどこで見ることができるでしょうか？OpenShift Console の `Developer &gt; Monitoring` view, select `Metrics` を開き、 `Metrics` を選択し、次に `Custom Query` を選択し、 `greeting_counter_total{name = "quarkus"}` と入力してみましょう。これで次のように表示されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Great! We are now exposing our Quarkus Application metrics in OpenShift!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>素晴らしい!OpenShiftにQuarkus Applicationのメトリクスを公開出来ています!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Stylish API'
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: Swagger UI configuration and custom styling
author: phillipkruger
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: スタイリッシュAPI
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: SwaggerのUI設定とカスタムスタイリング
author: phillipkruger
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stylish API</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイリッシュAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this blog post we are going to look at the new styling and other new options available in OpenAPI and Swagger UI Quarkus extensions (version 1.10+).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のブログ記事では、OpenAPIとSwagger UIのQuarkusエクステンション(バージョン1.10+)で利用できる新しいスタイリングやその他の新しいオプションについて見ていきたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the source code for the examples below is https://github.com/phillip-kruger/openapi-example[available here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の例のすべてのソースコードは、 https://github.com/phillip-kruger/openapi-example[ここ]にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Styling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default style</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトスタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default style for Swagger UI has changed from the vanilla Swagger UI to a Quarkus branded page:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Swagger UIのデフォルトスタイルがバニラのSwagger UIからQuarkusブランドのページに変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post we mostly focus on Swagger UI, but the styling options also apply to the https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI] and the https://quarkus.io/guides/microprofile-health#health-ui[Health UI].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この記事では主に Swagger UI に焦点を当てていますが、スタイリングオプションは https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI]と https://quarkus.io/guides/microprofile-health#health-ui[Health UI] にも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テーマ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://ostranme.github.io/swagger-ui-themes/[Swagger UI Themes] are now available in configuration, with the default theme being 'feeling blue'.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://ostranme.github.io/swagger-ui-themes/[SwaggerのUIテーマ]が設定で利用できるようになり、デフォルトのテーマは「フィーリングブルー」になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the theme by setting the `quarkus.swagger-ui.theme` property, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `quarkus.swagger-ui.theme` プロパティーを設定することでテーマを変更することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also go back to the original (vanilla) Swagger UI theme:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、元の(バニラの)Swagger UIテーマに戻すこともできます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme options available:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テーマのオプションが用意されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>feeling-blue (default)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>feeling-blue (default)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>flattop</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>flattop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>material</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>material</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>monokai</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>monokai</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>muted</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>muted</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>newspaper</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>newspaper</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>outline</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>outline</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロゴマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As part of the custom branding, you can supply your own logo to replace the Quarkus logo. For example, let's say you own a company that makes everything, ACME, and you are using REST Services for your online store, and wants to brand the Swagger UI Page:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムブランディングの一環として、Quarkusのロゴの代わりに独自のロゴを付与することができます。例えば、なんでも屋のACMEという会社を経営していて、オンラインストアにRESTサービスを利用していて、Swagger UIページをブランディングしたいとします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme logo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme logo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot reload is not working for logo changes, and remember browser cache, you might need to https://refreshyourcache.com/en/cache/[force refresh] your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホットリロードは、ロゴ変更には動作しません。とブラウザのキャッシュを覚えておいてください。ブラウザを https://refreshyourcache.com/en/cache/[強制的にリフレッシュする]必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To supply your own logo, you need to place a file called `logo.png` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自のロゴを提供するには、 `logo.png`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Style</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go further, and supply your own `style.css`, to fine-tune the branding. As an example, to change the `topbar` of the Swagger UI screen to fit the corporate colors of ACME:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、独自の `style.css`  を提供して、ブランディングを微調整することもできます。例として、Swagger UI画面の `topbar`  を ACME のコーポレートカラーに合わせて変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>here set the `topbar` background color.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは `topbar`  の背景色を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme css</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme css</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change any styling element in this css file, you need to place this file called `style.css` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このCSSファイルの中で、任意のスタイル要素を変更することができます。 `style.css`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other styling options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のスタイリングオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Along with other OpenAPI Header fields that can be set via configuration properties (as discussed in link:/blog/openapi-for-everyone/[this post]):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティーを介して設定できる他の OpenAPI Header フィールドと一緒に( /blog/openapi-for-everyone/[この記事]で説明しています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme footer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme footer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Swagger UI Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のスワガーUIオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another new feature available in Quarkus (version 1.10+) is the ability to set any of the https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[configuration options] available in Swagger UI. As an example, we can set the `urls` and add the petstore (as the default selected option) to Swagger UI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus(バージョン1.10+)で利用できるもう一つの新機能は、Swagger UIで利用できる https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[設定オプション]を任意に設定できることです。例えば、 `urls`  を設定して、Swagger UI にペットストア(デフォルトで選択されているオプションとして)を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will change the `topbar` to have a dropdown box with the urls provided:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `topbar`  は、提供されたURLのドロップダウンボックスを持つように変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>petstore</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>petstore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example, `supportedSubmitMethods` can hide the `Try it out` button for certain HTTP Method Types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の例として、 `supportedSubmitMethods`  は特定の HTTP メソッドタイプに対して `Try it out`  ボタンを非表示にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note below the missing `Try it out` button on the `POST`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`POST` の `Try it out`  ボタンがなくなっていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>try it out</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>try it out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the other Swagger UI options are now available to configure the UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のSwagger UIオプションはすべてUIの設定が可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other small new features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の小さな新機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let me present you two small new features in OpenAPI and Swagger UI: the ability to add the Health Endpoints and the ability to disable the UI and/or Schema at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenAPIとSwagger UIの2つの小さな新機能を紹介します。Health Endpointsを追加する機能と、実行時にUIやSchemaを無効にする機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `smallrye-health` extension, you can add the Health Endpoints to OpenAPI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`smallrye-health`  エクステンションを使用している場合は、OpenAPI にヘルスエンドポイントを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable at Runtime</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時に無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you included the UI in your app (`quarkus.swagger-ui.always-include=true`), you can now disable it when starting the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリにUIが含まれている場合( `quarkus.swagger-ui.always-include=true` )、アプリ起動時にUIを無効にできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will return a *HTTP 404 (Not Found)* on the Swagger UI page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは Swagger UI ページで *HTTP 404 (Not Found) を* 返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly you can disable the schema (usually under `/openapi`) by doing:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同様に、以下のようにしてスキーマを無効にすることができます (通常は `/openapi`  の下にあります):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each Quarkus release, it's the same story: it comes with a ton of exciting new features and enhancements... But believe it or not, it's true.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのリリースのたびに、同じことが起きています:沢山の刺激的な新機能や機能強化が行われています、、信じられないかもしれませんが、本当です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Dev UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it also comes with many other enhancements be it for Micrometer, for jbang or for our Spring compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、Micrometer、jbang、スプリング互換性レイヤーなどに対しても、他にも多くの機能強化が施されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And this release wouldn't be so great without all the people who tested our Betas and CR so a big thanks to everyone who participated in testing this release!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、このリリースはBetaとCRをテストしてくれた全ての人がいなければ、ここまで素晴らしいものにはならなかったでしょう。このリリースのテストに参加したすべての人に感謝します!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[our migration guide for 1.11].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか? link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11の移行ガイド]はこちらです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3 in its Java 11 flavor is the newly recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11のフレーバーのGraalVM 20.3は、新たに推奨されているバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you probably guessed from the name, this work is a *new JAX-RS implementation* written from the ground up to work on our common *Vert.x* layer and is thus fully *reactive*, while also being very *tightly integrated with Quarkus* and consequently moving a lot of framework specific work (like annotation scanning and metamodel generation) to *build time*.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前からお察しの通り、この作品は共通の *Vert.x* レイヤー上で動作するように一から書かれた *新しいJAX-RSの実装* であり、完全に *リアクティブ* であると同時に、 *Quarkusと緊密に統合されて* いるため、フレームワーク固有の作業(アノテーションスキャンやメタモデル生成など)の多くを *ビルド時に* 移行させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive allows you to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、広く使用されている非常に強力な JAX-RS API を活用してアプリケーションの REST レイヤーを公開し、アプリケーションが達成できる最大スループットを大幅に向上させることができます。また、アプリケーションの起動がわずかに速くなり、メモリーの消費量が少し減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It got presented in great details by Georgios in https://quarkus.io/blog/resteasy-reactive/[the RESTEasy Reactive announcement].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは link:https://quarkus.io/blog/resteasy-reactive/[RESTEasy Reactiveの発表] の中で、Georgios氏によって非常に詳細に紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A detailed documentation is available in the link:/guides/resteasy-reactive[RESTEasy Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細なドキュメントは、 link:/guides/resteasy-reactive[RESTEasy Reactiveガイド] にございます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the beginning of a great story: Quarkus 1.11 offers a UI dedicated to development to make it easier than ever.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは素晴らしい物語の始まりです。Quarkus 1.11では、開発をこれまで以上に簡単にする為に、特化したUIが提供されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each extension can expose features in this Dev UI, be it to list the CDI beans, list your endpoints, replay your Flyway migrations, deploy to OpenShift... Sky is the limit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各エクステンションは、CDI Beanのリスト、エンドポイントのリスト、Flywayマイグレーションのリプレイ、OpenShiftへのデプロイなど、このDev UIで機能を公開することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.11 introduces the infrastructure of this Dev UI and some features already.  If you are an extension developer or wants to do some frontend work, additions and improvements are very welcome.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.11では、このDev UIのインフラと、すでにいくつかの機能が提供されています。もしあなたがエクステンションの開発者であったり、フロントエンドの仕事をしたいと思っているなら、追加や改善は大歓迎です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Dev UI is available in dev mode only (e.g. `mvn quarkus:dev`) and accessible at the `/q/dev` endpoint by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI は開発モードでのみ利用可能で(例: `mvn quarkus:dev` )、デフォルトでは `/q/dev` エンドポイントからアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Want to add a feature to the Dev UI? Just have a look at link:/guides/dev-ui[our Dev UI guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI に機能を追加したいですか? link:/guides/dev-ui[Dev UI ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Micrometer support is continuously improving:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当社のMicrometer対応は常に改善しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Streams metrics are now exposed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams のメトリクスが公開されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registries were moved to extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリーはエクステンションに移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for registries, the one for **Prometheus** is part of our Core extensions: `io.quarkus:quarkus-micrometer-registry-prometheus`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリーに関しては、 **Prometheus** 用のものはCoreエクステンション: `io.quarkus:quarkus-micrometer-registry-prometheus` の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the registries are hosted in the Quarkiverse (our home for additional extensions):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>残りのレジストリーはQuarkiverseでホストされています(追加のエクステンションのためのホーム):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Monitor</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure Monitor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datadog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Datadog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stackdriver</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Stackdriver</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you feel like contributing to these registries or creating new ones, the https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registry project] is the place you are looking for.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのレジストリーに貢献したい、または新しいレジストリーを作成したいとお考えの方は、 link:https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registryプロジェクト] をご利用ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Spring Data REST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using our Spring Data compatibility layer, you can now benefit from the Spring Data REST extension to simplify writing a CRUD REST layer.  It is very similar to our REST with Panache extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>弊社のSpring Data互換レイヤーを使用している場合、Spring Data RESTエクステンションの恩恵を受けて、CRUD RESTレイヤーの記述を簡単にすることができます。これはREST with Panacheエクステンションと非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about it in link:/guides/spring-data-rest[the dedicated guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:/guides/spring-data-rest[専用のガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non application endpoints moved to `/q/`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション以外のエンドポイントは `/q/` に移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus exposes some technical endpoints that are not part of your application (for example, the Health endpoints).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、アプリケーションの一部ではない技術的なエンドポイント(Healthエンドポイントなど)をいくつか公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid conflicts with your application endpoints, they have all been moved to the `/q/` namespace.  Redirects have been added to redirect the old URLs to the new ones.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのエンドポイントとの衝突を避けるために、これらはすべて `/q/` 名前空間に移動されました。古い URL を新しい URL にリダイレクトするためのリダイレクトが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This root path can be customized with `quarkus.http.non-application-root-path`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このルートパスは、 `quarkus.http.non-application-root-path`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, it was only possible to inject the JPA `EntityManagerFactory` and `EntityManager` in your applications.  Starting with 1.11, you can inject the Hibernate ORM-specific `SessionFactory` and `Session` if you need to access their specific methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、JPA `EntityManagerFactory` と `EntityManager` をアプリケーションに注入することしかできませんでした。1.11 からは、Hibernate ORM 固有の `SessionFactory` と `Session` の特定のメソッドにアクセスする必要がある場合は、注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`FAIL_ON_UNKNOWN_PROPERTIES` is now disabled by default for the default CDI-enabled `ObjectMapper`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトで CDI で有効になっている `ObjectMapper` で `FAIL_ON_UNKNOWN_PROPERTIES` が無効になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See https://quarkus.io/guides/rest-json#jackson for more details about how to go back to the previous behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の動作に戻す方法については、 https://quarkus.io/guides/rest-json#jackson を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The integration with https://jbang.dev[jbang] now supports enabling development mode and can use Quarkus platforms (BOM) for version management.  For this you need to use jbang v0.62+.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://jbang.dev[jbang]との統合は、開発モードの有効化をサポートするようになり、バージョン管理にQuarkusプラットフォーム(BOM)を使用できるようになりました。このためには、jbang v0.62+を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run it, just pass in `-Dquarkus.dev`, i.e.:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行するには、 `-Dquarkus.dev` を渡すだけです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of `@pom` in the first line; that instructs jbang to load the pom for the platform and use it for version management and the other dependency versions can be left out.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の行で `@pom` を使用していることに注意してください。これは jbang にプラットフォーム用の pom をロードしてバージョン管理に使用するように指示しており、他のバージョン指定をしないで済むようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then with dev mode you can edit that file and save it again and Quarkus live reload feature will take care of applying the changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、開発モードでファイルを編集して再度保存すると、Quarkusのライブリロード機能が変更の適用の世話をしてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other dev mode features like `https://localhost:8080/q/dev` and `https://localhost:8080/q/swagger-ui` are also available.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にも `https://localhost:8080/q/dev` や `https://localhost:8080/q/swagger-ui` のような開発モードの機能が用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now this only works for single file jbang scripts, future releases will enable it to work for multiple files too.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ、これは単一ファイルのjbangスクリプトに対してのみ動作しますが、将来のリリースでは複数のファイルに対しても動作するようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 20.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended version of GraalVM for Quarkus 1.11 is GraalVM 20.3.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.11に対するGraalVMの推奨バージョンはGraalVM 20.3です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final]の全変更履歴は GitHub で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[417 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[417人の貢献者] がいます。一人ひとりに多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.11 release, thanks to Alex Soto, Alexey Loubyansky, Amos Feng, Andy Damevin, Auri Munoz, Bill Burke, Bruno Gonçalves, Cem Nura, Chin Huang, Chris Laprun, Christian von Atzigen, Christoph Hermann, Clement Escoffier, cristhiank, David M. Lloyd, Davide D'Alto, Dejan Bosanac, Dennis Kieselhorst, Erin Schnabel, essobedo, Falko Modler, Foivos Zakkak, Galder Zamarreño, Geoffrey De Smet, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Henrique Prange, Ioannis Canellos, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, Jérôme TAMA, Kai Hudalla, Katia Aresti, kdnakt, Ken Finnigan, Ken Kwan, Kevin Viet, Knut Wannheden, Ladislav Thon, Loïc Mathieu, Lucca Biagi de Paula Prado, luneo7, Manyanda Chitimbo, Mark Little, Martin Kouba, Martin Panzer, Masafumi Miura, Matej Vasek, Max Rydahl Andersen, Mayank Kunwar, Michael Edgar, Michał Szynkiewicz, mrizzi, Nicolas Gimenez, nragon, Oscar, Peter Palaga, Phillip Kruger, Pierre Smeyers, Piotr Delert, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Rustam Sultansoy, Samuel Le Berrigaud, Sanne Grinovero, Saumya Singh, Sergey Beryozkin, Simon Bengtsson, Slava, Stuart Douglas, Stéphane Épardaud, Timothy Power, Viacheslav Medvediev, Vincent Sevel, Willem Jan Glerum, Yoann Rodière, Zach Kimberg, and Àngel Ollé Blázquez.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に 1.11 のリリースについては、以下の方々に感謝します: Alex Soto, Alexey Loubyansky, Amos Feng, Andy Damevin, Auri Munoz, Bill Burke, Bruno Gonçalves, Cem Nura, Chin Huang, Chris Laprun, Christian von Atzigen, Christoph Hermann, Clement Escoffier, cristhiank, David M. Lloyd, Davide D'Alto, Dejan Bosanac, Dennis Kieselhorst, Erin Schnabel, essobedo, Falko Modler, Foivos Zakkak, Galder Zamarreño, Geoffrey De Smet, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Henrique Prange, Ioannis Canellos, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, Jérôme TAMA, Kai Hudalla, Katia Aresti, kdnakt, Ken Finnigan, Ken Kwan, Kevin Viet, Knut Wannheden, Ladislav Thon, Loïc Mathieu, Lucca Biagi de Paula Prado, luneo7, Manyanda Chitimbo, Mark Little, Martin Kouba, Martin Panzer, Masafumi Miura, Matej Vasek, Max Rydahl Andersen, Mayank Kunwar, Michael Edgar, Michał Szynkiewicz, mrizzi, Nicolas Gimenez, nragon, Oscar, Peter Palaga, Phillip Kruger, Pierre Smeyers, Piotr Delert, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Rustam Sultansoy, Samuel Le Berrigaud, Sanne Grinovero, Saumya Singh, Sergey Beryozkin, Simon Bengtsson, Slava, Stuart Douglas, Stéphane Épardaud, Timothy Power, Viacheslav Medvediev, Vincent Sevel, Willem Jan Glerum, Yoann Rodière, Zach Kimberg, and Àngel Ollé Blázquez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What’s nice about Extension codestarts is that it’s useful for fresh Quarkus developers as well as experienced ones. This is because of the wide range (and growing) of Quarkus extensions, you simply can’t know them all.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Extension codestartsの良い点は、新しくQuarkusを開発したばかりの開発者だけでなく、経験豊富な開発者にも役立つ点です。これは、Quarkusのエクステンションの範囲が広い(そして増え続けている)ため、すべてを知っていることが単純に不可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When I am comparing frameworks, I think that Doc is a very important factor, but I am also often pretty lazy when it comes to reading it... don't you?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フレームワークの比較をしていると、ドキュメントはとても重要な要素だと思うのですが、私もいざ読むとなるとかなり怠けてしまうとが多いです...あなたはどうですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By the way you can see that Quarkus is pretty well https://quarkus.io/guides/[documented,role=external,window=_blank].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ちなみにQuarkusはかなり https://quarkus.io/guides/[ガイド, role=external, window=_blank]が充実しているのがわかるかと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this feature, we tried to take it a step further and transform that boring learning part to the thing we love most *CODING*..</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能では、さらに一歩進んで、退屈な学習の部分を、私たちが最も好きな *コーディング* に変えようとしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting now, when you wish to try some new extensions, you directly have the code showing you their true power, ready to run in your favorite IDE in a matter of seconds!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今から、いくつかの新しいエクステンションを試してみたいときには、その真の力を示すコードが直接表示され、お気に入りのIDEであっという間に実行できるようになります!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this, using your chosen build tool (Maven, Gradle or also Gradle with Kotlin DSL) and your chosen language (Java, Kotlin or Scala).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらはすべて、選択したビルドツール(Maven、Gradle、またはKotlin DSLによるGradle)と選択した言語(Java、Kotlin、またはScala)を使用して行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Existing Extension codestarts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のエクステンションのコードスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already prepared examples for a dozen of extensions, you may spot them on https://code.quarkus.io[code.quarkus.io,role=external,window=_blank] (with the jet fighter icon).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちはすでに沢山のエクステンションの例を用意しており、 https://code.quarkus.io[code.quarkus.io, role=external, window=_blank](ジェット戦闘機のアイコンが付いている)で見ることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also find them on most of our Quarkus tooling:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkusのほとんどのツールでも見つけることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI, it is still experimental, and we don't provide an installer yet. Still, you can easily try it using the amazing https://jbang.dev/[JBang,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLIは、まだ実験的なもので、インストーラーはまだ提供されていません。それでも、素晴らしい https://jbang.dev/[JBang, role=external, window=_blank]を使って簡単に試すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://quarkus.io/blog/march-of-ides/[IDE plugins,role=external,window=_blank] which support "Wizards w/code.quarkus.io"</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Wizards w/code.quarkus.io" をサポートする https://quarkus.io/blog/march-of-ides/[IDEプラグイン, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit of fun in some of our examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの例の中で、ちょっとした楽しみ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>My favorite one is the new Qute example with a subatomic-particles generator :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私のお気に入りは、素粒子ジェネレーターを備えた新しいQuteのサンプルです :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;a=subatomic-particles-generator&amp;v=1.0.0-SNAPSHOT&amp;b=MAVEN&amp;s=xTN&amp;cn=code.quarkus.io[Here on code.quarkus.io,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;amp;a=subatomic-particles-generator&amp;amp;v=1.0.0-SNAPSHOT&amp;amp;b=MAVEN&amp;amp;s=xTN&amp;amp;cn=code.quarkus.io[code.quarkus.ioでは、以下のようになっています。, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>With the CLI:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need more Extension codestarts!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もっとエクステンションのcodestartsが必要です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts are designed to make it easy and quick to provide new examples for extensions. So whether you are an extension owner, or you are keen to create an example for an extension you like, contributions are very welcome!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードスタートは、エクステンションのための新しいサンプルを簡単かつ迅速に提供できるように設計されています。ですから、あなたがエクステンションの所有者の場合でも、あなたが好きなエクステンションの例を作りたい場合でも、貢献は大歓迎です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We provide https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[doc and tooling,role=external,window=_blank] for it, you may also https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[come and ping me (@ia3andy) on Zulip,role=external,window=_blank] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちはそれのための https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[ドキュメントとツール, role=external, window=_blank]を提供しています。 https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[チャットに来て、私(@ia3andy)にpingを打って, role=external, window=_blank] 詳細について聞くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, we focus on the https://github.com/quarkusio/quarkus/blob/master/extensions[core extensions,role=external,window=_blank], but we will make it available to the broader ecosystem soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところは https://github.com/quarkusio/quarkus/blob/master/extensions[コアなエクステンション, role=external, window=_blank]に焦点を当てていますが、近いうちにより広いエコシステムで利用できるようにする予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.9 comes with a lot of improvements on top of our existing feature set:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.9 では、既存の機能セットに対して多くの改良が加えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis clients are supported (as well as Sentinel connections)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の Redis クライアントのサポート (Sentinel 接続も同様)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, we also started &lt;&lt;quarkiverse,the Quarkiverse initiative&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後ですが重要なことに、 link:#quarkiverse[Quarkiverseの取組] も開始しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[our migration guide for 1.9].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか?ここに link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9の移行ガイド] があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The biggest change is that the old datasource (JDBC and reactive) configuration that was deprecated in 1.3 is now gone.  So if your datasources don't work anymore, that's probably because you haven't migrated to the new configuration yet.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最大の変更点は、1.3 で非推奨となった古いデータソース (JDBC とリアクティブ) の設定がなくなったことです。ですから、もしあなたのデータソースが動作しなくなった場合、それはおそらくあなたがまだ新しい設定に移行していないことが原因です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.8 introduced a new Micrometer extension.  During the 1.9 development cycle, it matured a lot and is now the recommended way to collect metrics in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.8 では、新しく Micrometer エクステンションが導入されました。1.9 の開発サイクルの間に、このエクステンションは大きく発展し、現在では Quarkus でメトリクスを収集するための推奨される方法となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, you now get metrics for Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Kafka のメトリクスを取得できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Validation constraints are now taken into account for parameters and return values (`Uni` is supported but not `Multi`) of Reactive Routes methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean Validation 制約が Reactive Routes メソッドのパラメーターと戻り値 ( `Uni` はサポートされていますが、 `Multi` はサポートされていません) で考慮されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.4.0 which includes several improvements - including Cloud Event support for Kafka - and bugfixes and Mutiny to 0.9.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging は 2.4.0 にアップグレードされました。KafkaのCloud Event サポートを含むいくつかの改善、バグ修正などが含まれています。Mutinyは 0.9.0 へアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/quarkusio/quarkus/pull/12470[pull request description] lists the main changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/pull/12470[プルリクエストの説明] に主な変更点が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is now easier than ever to use Mutiny with the REST Client thanks to the `quarkus-rest-client-mutiny` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-rest-client-mutiny` エクステンションのおかげで、REST クライアントで Mutiny を使用することがこれまで以上に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation is our response to a recurring request from the community: having the ability to rollback changes made in a test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、コミュニティからの繰り返し要望のあった、テストで行われた変更をロールバックする機能への対応です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of annotating your test with `@Transactional` (which will persist the changes), annotate your test with `@TestTransaction` and the changes will be automatically rolled back at the end of the test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを (変更を持続させる) `@Transactional` でアノテーションするのではなく、テストを `@TestTransaction` でアノテーションすると、テストの最後に変更が自動的にロールバックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, you could only connect to one Redis instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは 1 つの Redis インスタンスにしか接続できませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with 1.9, you can connect to multiple instances.  Also Sentinel is now supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.9 からは、複数のインスタンスに接続できるようになりました。また、Sentinel にも対応しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now have a separate JAXP extension. Until now, it was intertwined with the JAXB extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAXP のエクステンションを別に用意するようになりました。今までは JAXB エクステンションと絡み合っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.22.Final and Hibernate Reactive to 1.0.0.Alpha10</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM が 5.4.22.Final に、Hibernate Reactive が 1.0.0.Alpha10 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] and https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus wouldn't be as successful if it weren't for its extension ecosystem.  In the beginning, we were adding all extensions to the core Quarkus repository, but eventually it became too much of an overhead or just not always sensible to include an extension into the core.  Some have since then created their own repositories external to Quarkus, but others just never happened because not everyone wants the overhead of maintaining a build setup while in other cases we actually had an idea for an extension but not solidified enough yet to be included in core (and consequently failed to find other community members interested and eager to help).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのエコシステムがなければ、Quarkus はこれほどの成功を収められなかったでしょう。当初は、すべてのエクステンションを Quarkus のコアリポジトリーに追加していました。しかし、最終的にはオーバーヘッドが大きすぎたり、エクステンションをコアに含めることが必ずしも賢明とは限らなくなってしまいました。それ以来、Quarkus の外部に独自のリポジトリーを作成した人もいますが、誰もがビルドセットアップを維持するためのオーバーヘッドを望んでいるわけではないので、それが実現しなかった人もいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse is a separate GitHub organization (https://github.com/quarkiverse) that offers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse は GitHub とは別の組織 (https://github.com/quarkiverse) で、以下を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inclusion in registry used by Quarkus tooling to browse extensions (i.e. code.quarkus.io, command line and IDE tools).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション (code.quarkus.io、コマンドライン、IDEツールなど) を参照するための Quarkus ツールで使用されるレジストリーへの収録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consistent formatting and release of projects</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトの一貫したフォーマットとリリース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bigger Community outreach and a great place to collaborate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より大きなコミュニティのアウトリーチと素晴らしいコラボレーションの場</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to lead the development of an extension, see if it wasn't already https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[proposed on GitHub] or https://github.com/quarkusio/quarkus/issues/new/choose[create an Extension Proposal issue].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの開発をリードしたい場合は、 link:https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[GitHub でまだ提案されていないかどうか] を確認したり、 link:https://github.com/quarkusio/quarkus/issues/new/choose[エクステンションの提案課題を作成] してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A blog post is in the works and should give more details.  In the meantime, check out https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[the extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブログ記事を作成中ですので、そちらで詳細をお知らせします。それまでは、 link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[すでにあるエクステンション] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[378 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus コミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[378人のコントリビューター] がいます。一人一人に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.9 release, thanks to Abel Salgado Romero, Adam Bien, Alex Soto, Alexey Loubyansky, AlexeyAnufriev, Andrea Cosentino, Andy Damevin, Anh Le (Andy), Armel Soro, Arne Mejlholm, asodja, Auri Munoz, Bill Burke, Bobby Philip, Centro de Computos, Chris Laprun, Clement Escoffier, Daniel Badawi, Daniel Platz, David M. Lloyd, Dillon Fearns, Dmitry Shohov, Driss Amri, Dušan Križan, Emanuel Alves, Enercido Alcantara, Erin Schnabel, Fabian Stäber, Fabio Iwakoshi, Falko Modler, Foivos Zakkak, Galder Zamarreño, Garima Monga, Gautier de Saint Martin Lacaze, Geoffrey De Smet, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gytis Trikleris, Harsh Madhani, Harsha R, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Scholz, Jan Martiška, João Lucas Scharf, Julien Ponge, Justin Lee, kdnakt, Ken Finnigan, Kevin Viet, Knut Wannheden, Ladislav Thon, Laurent Broudoux, lburgazzoli, Loïc Mathieu, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Markus Heberling, Martin Kouba, Matej Vasek, Max Rydahl Andersen, Michal Krzywanski Michał Górniewski, Michał Szynkiewicz, Miguel Serra, Nathan Erwin, Oliver Libutzki, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Krüger, Roberto Cortez, Rohan Maity, Ron Sigal, Rostislav Svoboda, Sanne Grinovero, Sergey Beryozkin, Simon Bengtsson, Stephane Epardaud, Stuart Douglas, Thomas Pfaff, Vincent Sevel, Vincent Sourin, Vinícius Ferraz Campos Florentino, William Burns, xstefank, Xumk and Yoann Rodière.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に 1.9 リリースでは、以下の皆様に感謝します: Abel Salgado Romero, Adam Bien, Alex Soto, Alexey Loubyansky, AlexeyAnufriev, Andrea Cosentino, Andy Damevin, Anh Le (Andy), Armel Soro, Arne Mejlholm, asodja, Auri Munoz, Bill Burke, Bobby Philip, Centro de Computos, Chris Laprun, Clement Escoffier, Daniel Badawi, Daniel Platz, David M. Lloyd, Dillon Fearns, Dmitry Shohov, Driss Amri, Dušan Križan, Emanuel Alves, Enercido Alcantara, Erin Schnabel, Fabian Stäber, Fabio Iwakoshi, Falko Modler, Foivos Zakkak, Galder Zamarreño, Garima Monga, Gautier de Saint Martin Lacaze, Geoffrey De Smet, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gytis Trikleris, Harsh Madhani, Harsha R, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Scholz, Jan Martiška, João Lucas Scharf, Julien Ponge, Justin Lee, kdnakt, Ken Finnigan, Kevin Viet, Knut Wannheden, Ladislav Thon, Laurent Broudoux, lburgazzoli, Loïc Mathieu, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Markus Heberling, Martin Kouba, Matej Vasek, Max Rydahl Andersen, Michal Krzywanski Michał Górniewski, Michał Szynkiewicz, Miguel Serra, Nathan Erwin, Oliver Libutzki, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Krüger, Roberto Cortez, Rohan Maity, Ron Sigal, Rostislav Svoboda, Sanne Grinovero, Sergey Beryozkin, Simon Bengtsson, Stephane Epardaud, Stuart Douglas, Thomas Pfaff, Vincent Sevel, Vincent Sourin, Vinícius Ferraz Campos Florentino, William Burns, xstefank, Xumk and Yoann Rodière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It gives the Quarkus and RESTEasy teams great pleasure to announce that RESTEasy Reactive integration in Quarkus has landed in the main Quarkus repo footnote:disclaimer[Currently the main RESTEasy Reactive component resides at https://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactive in the main Quarkus repository; the plan is however that once things settle, this code will move to https://github.com/resteasy/resteasy-reactive. This move should not affect users of the quarkus-resteasy-reactive extensions in any way, just a heads up if anyone reads this blog post in the future and can’t find it.] and will be part of the next Quarkus release 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusとRESTEasyチームは、QuarkusにおけるRESTEasy Reactiveの統合がメインのQuarkusレポジトリに到着したことを発表することに大きな喜びを感じています。 footnote:disclaimer[現在、メインのRESTEasy Reactiveコンポーネントは、メインのQuarkusリポジトリのhttps://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactiveにあります。この移動は、quarkus-resteasy-reactive エクステンションのユーザーには何ら影響を与えないはずです。このブログポストを将来読んだ人が見つけられなかった場合に備えての追記。] 次のQuarkusリリース 1.11 に含まれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are looking forward to everyone testing it and providing us as much feedback as possible.  In typical Quarkus fashion, the project is consumable as a new set of extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>皆さまにテストしていただき、できるだけ多くのフィードバックを提供していただけると幸いです。 典型的なQuarkusのやり方で、このプロジェクトは新しいエクステンションのセットとして利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは何ですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why should I care?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜ重要なのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest answer is that you can continue to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最も単純な答えは、アプリケーションの REST レイヤを公開する為に広く使われている非常に強力な JAX-RS API を活用し続けながら、アプリケーションが達成できる最大スループットを大幅に向上できるということです。また、アプリケーションは起動が少し速くなり、メモリーの消費量が少し減るはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our benchmarks reveal that the measurable performance with this new extension is almost identical to what we would achieve using Quarkus' Reactive Routes API (which is a very interesting API in its own right, but is generally more low level - not to mention the fact that it's a new API developers would need to learn).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベンチマークでは、この新しいエクステンションを使った測定可能なパフォーマンスは、QuarkusのReactive Routes API(それ自体は非常に興味深いAPIですが、一般的には低レベルなものです)とほぼ同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, when comparing our results to other competing enterprise Java frameworks that provide annotation based REST layers, Quarkus provided as much as double the throughput depending on the benchmark.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、アノテーションベースのRESTレイヤーを提供する他の競合するエンタープライズJavaフレームワークと結果を比較すると、ベンチマークによっては、Quarkusは2倍ものスループットを提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What other benefits are there?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にはどんなメリットがあるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As if the familiar API and the much improved runtime characteristics of the new extension weren't enough, we have added some really exciting and convenient new features (which are not part of the JAX-RS spec) that have either been requested by the community, or are things we feel improve the developer experience and soften some of the spec’s rough edge.  These new features are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おなじみのAPIと、新しいエクステンションの大幅に改善されたランタイム特性だけでは十分ではないかのように、コミュニティからの要望に基づき、あるいは開発者の経験を向上させ、仕様の粗いエッジを和らげてくれると我々が考える、本当にエキサイティングで便利な新機能(JAX-RS仕様の一部ではありません)をいくつか追加しました。これらの新機能は以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-blocking by default</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでノンブロッキング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All endpoints are now running on the IO thread by default. You can use `@Blocking` to change that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトではすべてのエンドポイントが IO スレッド上で実行されます。 `@Blocking` を使えばこれを変更出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scoring system</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スコアリングシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On dev-mode startup, the application will show you a list of your endpoints, along with a performance score telling you why your endpoint is slower than an optimal version. This helps a lot in figuring out how to improve REST performance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>devモードで起動すると、アプリケーションはエンドポイントのリストを表示し、エンドポイントが最適なバージョンよりも遅い理由を示すパフォーマンススコアを表示します。これは、REST のパフォーマンスを向上させる方法を見つけるのに非常に役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New request/response filter design</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエスト/レスポンスフィルターの新しい設計</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JAX-RS filters require implementing an interface and injecting context objects as fields, which is costly and inflexible. Based on our success in the Quarkus build system, filters are now simply annotated methods and any parameter is automatically injected:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSのフィルターは、インターフェースを実装し、コンテキストオブジェクトをフィールドとして注入する必要がありますが、これはコストがかかり、柔軟性に欠けます。Quarkus ビルドシステムでの成功に基づき、フィルタは単にアノテーション付きのメソッドになり、全てのパラメーターは自動的に注入されるようになりました:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, if filters need to perform blocking operations, then they can return `Uni&lt;Void&gt;` and RESTEasy Reactive will not block the event-loop thread while executing the filter.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、フィルタがブロッキング操作を行う必要がある場合は `Uni&lt;Void&gt;` を返すことができ、RESTEasy Reactive はフィルタを実行している間はイベントループスレッドをブロックしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, although we haven’t done it yet, this approach could easily be extended to other types of JAX-RS Providers thus completely forgoing the need to use `@Context` in their code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、まだ実施していませんが、このアプローチは他のタイプのJAX-RSプロバイダにも簡単に拡張でき、コード中で `@Context` を使用する必要が完全になくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New `*Param` annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい `*Param` アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These annotations are meant to be used instead of the JAX-RS `@PathParam`, `@QueryParam` etc. annotations, without having the need to specify a name.  The reason we chose not to reuse the same annotation names is to avoid conflicting with either JAX-RS or other EE specs:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのアノテーションは、JAX-RSの `@PathParam`, `@QueryParam` などのアノテーションの代わりに、名前を指定することなく使用することを意図しています。  同じアノテーション名を再利用しないことにしたのは、JAX-RSや他のEE仕様との衝突を避けるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simpler parameter and context injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>よりシンプルなパラメーターとコンテキストインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With RESTEasy Reactive you don’t even need to use `@PathParam` or `@RestPath` if your parameter has the same name as a path parameter, and similarly you can skip `@Context` for all the known context types, which makes it even simpler:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive では、パラメーターがパスパラメーターと同じ名前であれば `@PathParam` や `@RestPath` を使用する必要はありませんし、同様に、既知のすべてのコンテキストタイプに対して `@Context` を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New optimal message body reader / writer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい最適なメッセージボディのリーダー/ライター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no filters and interceptors are invoked when an endpoint is serviced, you can use more efficient message body writers that directly write to vert.x and don’t require reflection and annotations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントがサービスされるときにフィルタやインターセプタが呼び出されない場合、 リフレクションやアノテーションを必要としない、vert.x に直接書き込む、更に効率的なメッセージボディライターを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default content types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのコンテンツタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Endpoints that return a String default to producing text/plain. We plan to do the same for JSON and other types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>String を返すエンドポイントは、デフォルトで text/plain を生成します。JSON やその他の型についても同様のことを行う予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All injections via JAX-RS’s @Context are delegated to Arc. This provides users with the benefits of build time injection that Arc brings to all other parts of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSの@Contextを介したインジェクションはすべてArcに委譲されます。これにより、ユーザーは、ArcがQuarkusの他のすべての部分にもたらすビルドタイムインジェクションのメリットを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Per-class Exception Mapper</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスごとの例外マッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JAX-RS specification there’s no way to handle exceptions differently for a specific JAX-RS Resource Class - all exception mapping is done in a global manner.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS仕様では、特定のJAX-RSリソースクラスに対して異なる例外を処理する方法はありません - すべての例外のマッピングはグローバルな方法で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In RESTEasy Reactive however you can simply do something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、RESTEasy Reactive では、次のようなことができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to customize the exception handling of certain Resource Classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のリソースクラスの例外処理をカスタマイズする為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that `@ServerExceptionMapper` can be used to handle exceptions in a global manner, just as JAX-RS does with `ExceptionMapper`.  To do that, simply annotate a method that does not belong to a Resource class with `@ServerExceptionMapper`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、`@ServerExceptionMapper`は、JAX-RSが`ExceptionMapper`を使うのと同じように、グローバルな方法で例外を扱うことができることにも注意する必要があります。  そのためには、Resourceクラスに属さないメソッドに `@ServerExceptionMapper` をアノテーションするだけで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do other extensions work with it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のエクステンションでも動作しますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extensions that integrate with the existing quarkus-resteasy extension also integrate with quarkus-resteasy-reactive extensions. So you can continue to use _CDI_, _Security_, _Metrics_, _JSON_, _Qute_, _Bean Validation_, _OpenAPI_ and enjoy a great out of the box and complete development experience.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のquarkus-resteasyエクステンションと統合するエクステンションは、quarkus-resteasy-reactiveエクステンションとも統合されます。そのため、_CDI_、_Security_、_Metrics_、_JSON_、_Qute_、_Bean Validation_、_OpenAPI_を使い続けることができ、素晴らしいアウトオブボックスと完全な開発体験を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I try it out?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どうやって試してみたらいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project has landed in the Quarkus master branch, so if you’re eager to try it out, you'll have to build Quarkus from source by following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this] and use the proper BOM and version following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロジェクトはQuarkus masterブランチにありますので、試してみたい方は、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this]のようにソースからQuarkusをビルドし、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this]のように適切なBOMとバージョンを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, you can also use Maven Snapshots (as Quarkus snapshot builds are uploaded to Sonatype once a day), by specifying version `999-SNAPSHOT` as the Quarkus version and using `quarkus-bom` instead of `quarkus-universe-bom` as the BOM.  There are various ways to enable snapshot versions in Maven. https://stackoverflow.com/a/7717234/2504224[This] StackOverflow answer shows configuration that can be used either on a per project basis or globally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、バージョン `999-SNAPSHOT` をQuarkusのバージョンとして指定し、BOMとして `quarkus-universe-bom` の代わりに `quarkus-bom` を使用することで、Mavenのスナップショットを使用することもできます(Quarkusのスナップショットビルドは1日1回Sonatypeにアップロードされるため)。  Mavenでスナップショットバージョンを有効にするには、さまざまな方法があります。 https://stackoverflow.com/a/7717234/2504224[This] StackOverflowの回答では、プロジェクト単位でもグローバルでも使える設定が示されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The available RESTEasy Reactive extensions are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能な RESTEasy Reactive エクステンションは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These extensions are the equivalent to the existing _quarkus-resteasy_* extensions, so simply switching from _quarkus-resteasy-jackson_ to _quarkus-resteasy-reactive-jackson_ in your application should allow you to try RESTEasy Reactive with Jackson integration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのエクステンションは、既存の _quarkus-resteasy_* エクステンションと同等ですので、アプリケーション内で _quarkus-resteasy-jackson_ から _quarkus-resteasy-reactive-jackson_ に切り替えるだけで、Jackson 統合による RESTEasy Reactive を試すことができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the _quarkus-jaxrs-client_ extension can be used if you need to use the JAX-RS client (this is not the declarative MicroProfile REST Client, but the programmatic client specified by the JAX-RS spec).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、JAX-RSクライアントを使用する必要がある場合は、_quarkus-jaxrs-client_ エクステンションを使用することができます (これは宣言型MicroProfile RESTクライアントではなく、JAX-RS仕様で定義されたプログラマティッククライアントです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What should I be careful of?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どんなことに気をつければいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for the time being this set of extensions is currently considered experimental. Although the project passes almost the entirety of the JAX-RS TCK, it’s just the first release, so keep in mind that it might have more bugs than a typical battle hardened library, while some of the new APIs and SPIs might break.  Despite this being a first release, we do envision this work becoming the default REST layer for Quarkus in the near future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初に注意しなければならないのは、当面の間、この一連のエクステンションは実験的なものと考えられているということです。このプロジェクトはJAX-RS TCKのほぼ全体を通過していますが、まだ最初のリリースに過ぎませんので、典型的な実績のあるライブラリよりも多くのバグがあるかもしれないことを覚えておいてください。 これは最初のリリースですが、近い将来、このライブラリがQuarkusのデフォルトのRESTレイヤーになることを見通しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in the new features section, requests are served on the event-loop threads by default. This ensures maximum throughput, but also means that no blocking work should be performed on these threads. If you use Blocking IO (for example by accessing a database with Hibernate Panache), be sure to use the `@Blocking` annotation on either the method or the class.  This will ensure that the request will be served on a worker thread. It goes without saying that we are also very interested in hearing your feedback about this default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新機能のセクションで述べたように、デフォルトではリクエストはイベントループスレッド上で処理されます。これは最大のスループットを保証しますが、これらのスレッドでブロッキング作業を行うべきではないことも意味します。ブロッキング IO を使用する場合 (例えば、Hibernate Panache でデータベースにアクセスするなど)、メソッドまたはクラスのいずれかで `@Blocking` アノテーションを必ず使用してください。  これにより、リクエストがワーカースレッドで処理されるようになります。言うまでもなく、このデフォルトについてのフィードバックも非常に興味を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no docs yet. Docs will be added before the formal 1.11 release and will be progressively enhanced.  This email should contain all the information you need to get started, but should you run into any trouble, we are available to help on any of the usual channels (Zulip chat, mailing list, GitHub Issues, StackOverflow).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントはまだありません。ドキュメントは正式な1.11リリースの前に追加され、徐々に強化されていく予定です。  このメールには開始に必要な情報がすべて含まれているはずですが、何か問題が発生した場合は、通常のチャネル(Zulip チャット、メーリングリスト、GitHub Issues、StackOverflow)のいずれかで支援を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What JAX-RS features are missing?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どのJAX-RSの機能が欠けていますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We decided to focus on what most users need from a modern REST layer instead of implementing every single feature required by the JAX-RS TCK.  So in that vein, there is no XML support in RESTEasy Reactive, while various arcane features of the spec are also not supported (like _javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、JAX-RS TCK が必要とする機能をすべて実装するのではなく、ほとんどのユーザーが最新の REST レイヤから必要とするものに焦点を当てることにしました。  そのため、RESTEasy Reactive には XML サポートがなく、仕様の様々な難解な機能もサポートされていません(_javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_ のようなもの)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, worth noting is that the first release will not contain an implementation of the MicroProfile REST Client based on the new JAX-RS Client (for which there is a dedicated extension). This will most likely change in the near future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、最初のリリースには、 (専用のエクステンションが存在する) 新しい JAX-RS Clientをベースにした MicroProfile REST Client の実装が含まれていないことも注目に値する。これは近い将来に変更される可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new extensions will be available with the regular _1.11_ release, we are considering doing a `1.11.0.Alpha1` release to make it as easy as possible for you to try out the new extensions and provide early feedback.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいエクステンションは通常の _1.11_ リリースで利用可能になりますが、新しいエクステンションを出来る限り簡単に試せるように、そしてフィードバックを簡単に出来るように、私たちは `1.11.0.Alpha1` リリースを行うことを検討しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very much looking forward to hearing your thoughts about and experience using RESTEasy Reactive in Quarkus and plan to put it to good use to further improve the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのさらなる改善の為に、RESTEasy ReactiveをQuarkusで使用した感想や経験を是非お聞かせ下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very pleased to announce the 1.4.0 release of Quarkus Tools for IntelliJ.  This release enhances codestarts support in the Quarkus project wizard.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Tools for IntelliJの1.4.0リリースを発表できることを大変嬉しく思います。このリリースでは、Quarkusプロジェクトウィザードのcodestartsのサポートが強化されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Codestarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus project wizard now highlights codestarts enabled extension with a specific icon (right to the extension name), similar to code.quarkus.io, allowing users to better identify codestarts enabled extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトウィザードでは、code.quarkus.ioと同様に、codestartsを有効にしたエクステンションを特定のアイコン（エクステンション名の右側）で強調表示するようになり、ユーザーはcodestartsを有効にしたエクステンションをよりよく識別できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very pleased to announce the 1.3.0 release of Quarkus Tools for IntelliJ.  This release brings codestarts support in the Quarkus project wizard.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Tools for IntelliJの1.3.0リリースを発表できることを大変嬉しく思います。このリリースでは、Quarkusプロジェクトウィザードにcodestartsのサポートが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus project wizard adds a new codestarts option, allowing to enable/disable codestarts generation for Quarkus extensions that support this feature.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトウィザードに新しいcodestartsオプションが追加され、この機能をサポートするQuarkusエクステンションのcodestarts生成を有効/無効にすることができるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have had an unusually bumpy ride the last few weeks. Path resolution can be sneakily complicated, and in trying to make things better, we accidentally made them worse! We've fixed it all now, but you might notice some changes. Hopefully, this post will make clear what those changes are, what they mean, and what you can do to put everything back the way you want it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここ数週間、私たちは通常になく揺れ動いていました。パスの解決はこっそりと複雑になることがあり、物事を良くしようとしているうちに、私たちは誤って悪化させてしまったのです!今はすべて修正しましたが、いくつかの変更点があることに気づくかもしれません。うまくいけば、この記事でその変更が何であるか、その意味、そしてあなたが望むようにすべてを元の状態に戻すために何ができるか明確になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**TL;DR:** As of `1.11.5.Final` and `1.12.1.Final`, leading slashes matter in config. So if you use `/endpoint`, that endpoint will be served from the absolute root. If you want it relative to some containing bucket, omit that leading slash. For example, `quarkus.http.non-application-root-path` is now `q` by default, which nests it under `quarkus.http.root-path`, matching the original behavior. You can use an absolute path, e.g. `/q`, to serve non-application endpoints from the absolute root (as a sibling of the http root, if that is set). To remove the non-application endpoint behavior entirely, set `quarkus.http.non-application-root-path` to the same value as `quarkus.http.root-path`. The most foolproof way to do this is using a variable: `quarkus.http.non-application-root-path=${quarkus.http.root-path}`.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**TL;DR:** `1.11.5.Final` と `1.12.1.Final` の時点では、設定における先頭のスラッシュは重要です。つまり、 `/endpoint` を使用した場合、そのエンドポイントは絶対ルートから提供されます。もし、包含するバケットからの相対的なものにしたいのであれば、先頭のスラッシュを省略してください。例えば、 `quarkus.http.non-application-root-path` はデフォルトでは `q` になり、 `quarkus.http.root-path` の下に入れ子になり、元の動作と一致します。アプリケーション以外のエンドポイントを絶対ルートから (設定されている場合は http ルートの兄弟として) 提供するために、例えば `/q` のような絶対パスを使うことができます。アプリケーション以外のエンドポイントの動作を完全に削除するには、 `quarkus.http.non-application-root-path` を `quarkus.http.root-path` と同じ値に設定します。これを行う最も簡単な方法は、変数を使用することです: `quarkus.http.non-application-root-path=${quarkus.http.root-path}`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The long story</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>長文での説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once upon a time, Quarkus defined additional endpoints for things like health checks and metrics. They were served from the `quarkus.http.root-path` alongside any endpoints the application defined. This isn't always obvious, as `quarkus.http.root-path` is `/` by default, making it effectively invisible.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>昔々、Quarkusでは、ヘルスチェックやメトリクスなどのエンドポイントを追加で定義していました。これらは、アプリケーションが定義したエンドポイントと一緒に `quarkus.http.root-path` から提供されていました。デフォルトでは `quarkus.http.root-path` は `/` であり、事実上見えないようになっているため、これは必ずしも明らかではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As these proliferated, we started worrying about link:https://groups.google.com/g/quarkus-dev/c/FMnmlDIcGRY[polluting the application endpoint namespace], and thinking about how we could group these non-application endpoints together to avoid colliding with application endpoints and make it easier to deal with security and access policies. Some users further asked if we could serve these non-application endpoints from link:https://github.com/quarkusio/quarkus/issues/13602[another port entirely] (we haven't gotten there yet).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 link:https://groups.google.com/g/quarkus-dev/c/FMnmlDIcGRY[アプリケーションエンドポイント]との衝突を避け、セキュリティやアクセスポリシーの処理を容易にするために、アプリケーション以外のエンドポイントをどのようにグループ化するかを考え始めました。さらに何人かのユーザからは、これらの非アプリケーションエンドポイントを link:https://github.com/quarkusio/quarkus/issues/13602[完全に別のポートから提供できないか]という意見もありました (まだ実現していません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first step was to group all of these extension-defined endpoints together. This was the genesis of the link:https://github.com/quarkusio/quarkus/pull/13601[non-application endpoint path]. The default location of this new path was `/q`, and it was nested under the HTTP root path, just as the other endpoints had been. The effect was to move `/health` to `/q/health`, as an example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のステップは、これらのエクステンションで定義されたエンドポイントをすべて一緒にグループ化することでした。これが、 link:https://github.com/quarkusio/quarkus/pull/13601[非アプリケーションエンドポイントパス]の始まりでした。この新しいパスのデフォルトの場所は `/q` で、他のエンドポイントと同様に HTTP ルートパスの下に入れ子になっていました。この効果は、例えば `/health` を `/q/health` に移動させることでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We knew that moving some of these endpoints, like metrics and health, would be problematic for already deployed applications and human muscle memory. To ease the transition, we added redirects for some of these endpoints, so that if you visited `/metrics` you would be redirected to `/q/metrics`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、メトリクスやヘルスなどのエンドポイントの一部を移動することは、すでに展開されているアプリケーションや人間の記憶にとって問題があることを知っていました。移行を容易にするために、これらのエンドポイントの一部にリダイレクトを追加し、 `/metrics` にアクセスした場合は `/q/metrics` にリダイレクトされるようにしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-application endpoint support shipped in `1.11.0.Final`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション以外のエンドポイントのサポートは `1.11.0.Final` で出荷されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And then things started to link:https://github.com/quarkusio/quarkus/pull/14179[go] link:https://github.com/quarkusio/quarkus/issues/15030[sideways]. Some cloud hosting providers only accept `200` as a definition of health, for example, so the redirect (a `301`) didn't have the intended effect. There was also some confusion about how to turn the non-application endpoint off to return to previous behavior, and further questions about how to move specific endpoints out of this non-application endpoint collection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、事態は link:https://github.com/quarkusio/quarkus/issues/15030[悪化]  link:https://github.com/quarkusio/quarkus/pull/14179[し]始めました。クラウドホスティングプロバイダの中には、例えば、ヘルスの定義として `200` のみを受け入れるものがあり、リダイレクト ( `301`) は意図した効果を発揮しませんでした。また、アプリケーション以外のエンドポイントをオフにして以前の動作に戻す方法についても混乱があり、特定のエンドポイントをこのアプリケーション以外のエンドポイントコレクションから移動させる方法についても疑問が残りました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an aside, how we got into this situation is not helped by differences in how libraries behave. Vert.x always wants segments beginning with leading slashes when creating routes, for example, while JAX-RS effectively ignores leading slashes in `@Path` annotations. Anyone used to Vert.x always adds leading slashes, and anyone using JAX-RS just does whatever and it magically works.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>余談ですが、どのようにしてこのような状況になったかというと、ライブラリの挙動の違いによるものではありません。Vert.x は、例えばルートを作成する際に、常に先頭のスラッシュで始まるセグメントを求めますが、JAX-RS は `@Path` のアノテーションでは先頭のスラッシュを事実上無視します。Vert.x に慣れている人は常に先頭のスラッシュを追加し、JAX-RS を使用している人は何をしても魔法のように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, an implementation detail was exposed by accident: non-application endpoints defined by extensions are based on Vert.x routes. Default path configuration values started with slashes to enable quick route creation and allow simple append behavior. There wasn't anything in the early days of Quarkus to suggest this was a bad idea, and developers with experience in JAX-RS didn't have any warnings one way or the other, because JAX-RS handles it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、実装の詳細が偶然にも露わになりました。エクステンションによって定義されたアプリケーション以外のエンドポイントは、Vert.xのルートをベースにしています。デフォルトのパス設定値はスラッシュで始まり、迅速なルート作成を可能にし、単純な追加動作を可能にします。Quarkusの初期の頃は、これが悪い考えであることを示唆するようなものは何もなく、JAX-RSの経験がある開発者は、JAX-RSが処理するので、どちらにしても警告を受けることはありませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, however, we were in the situation where paths weren't being resolved as people expected, and the configuration changes required to resolve that situation either weren't intuitive or lead to other problems. We ended up putting all of the possible configuration permutations into a spreadsheet so we could see side by side what happened when you combined different configuration values. The results were not awesome. However, the exercise allowed us to step back and look at the big picture to evaluate what needed to change to allow application and non-application endpoints to behave as you need them to.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、人々が期待していた通りにパスが解決されず、その状況を解決するために必要な設定の変更が直感的ではなかったり、別の問題を引き起こしたりする状況に陥りました。そこで私たちは、異なる設定値を組み合わせたときに何が起こるかを並べて見ることができるように、すべての可能な設定の組み合わせをスプレッドシートに入れてみました。結果はそれほど素晴らしいものではありませんでした。しかし、この演習により、アプリケーションと非アプリケーションのエンドポイントが必要な動作をするようにするために何を変更する必要があるかを評価するために、一歩下がって全体像を見ることができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the set of configuration attributes used to configure paths in Quarkus remains unchanged, how configured values are interpreted is different:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでパスを設定するために使用される設定属性のセットは変更されませんが、設定された値がどのように解釈されるかは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Endpoint path configuration defaults are now relative values.** `/q` is now `q`, `/metrics` is now `metrics`, etc. This means that, out of the box, these endpoints will resolve relative to the containing root, which is what JAX-RS does per spec, and is what we believe most users intuitively expect.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**エンドポイントのパス設定のデフォルト値が相対値になりました。** `/q` は `q` に、 `/metrics` は `metrics` になりました。これは、設定変更なしで、これらのエンドポイントが含まれているルートに対して相対的に解決されることを意味します。これは、JAX-RSが仕様ごとに行うことであり、ほとんどのユーザーが直感的に期待していることです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Leading slashes in explicitly configured values matter.** We know some of you want to move endpoints to specific places, and the most consistent way to express that intent is to allow you to specify the exact uri you want an endpoint to use. If you specify `/metrics`, that is where you will find the metrics endpoint.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**明示的に設定された値の先頭のスラッシュは重要です。** エンドポイントを特定の場所に移動させたいと考えている人がいることは承知しており、その意図を表現する最も一貫した方法は、エンドポイントに使用させたい URI を正確に指定できるようにすることです。 `/metrics` を指定すると、それがメトリクス・エンドポイントを見つける場所になります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These updates have been made available and the dust should all have settled with `1.11.5.Final` and `1.12.1.Final`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`1.11.5.Final` と `1.12.1.Final` でこれらのアップデートが利用可能になり、埃は全て解消するはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that convenience redirects for non-application endpoints are still present, but they can be disabled by setting `quarkus.http.redirect-to-non-application-root-path` to `false`. That hasn't changed at all.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション以外のエンドポイントのための便利なリダイレクトはまだ存在しますが、 `quarkus.http.redirect-to-non-application-root-path` を `false` に設定することで無効にすることができます。これは全く変わっていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Resolution of configured paths</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定されたパスの解決</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go through some examples of how paths resolve using our new rules. We'll start with the following assumptions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいルールを使用してパスがどのように解決されるか、いくつかの例を見てみましょう。まず、以下の前提条件から始めましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a Hello World application that defines `@ApplicationPath("/hello")`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `@ApplicationPath("/hello")` という定義のあるHello World アプリケーションがあるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application specifies two endpoints using `@Path("world")` and `@Path("/aliens")`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは、 `@Path("world")` と `@Path("/aliens")` のある2つのエンドポイントを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration attributes we care most about are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちが最も気にしている設定属性は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.root-path` - The HTTP root path. All web content is served relative to this root path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.root-path` - HTTP ルートパス。すべてのウェブコンテンツはこのルートパスからの相対パスで提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path` - The non-application endpoint root path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.non-application-root-path` - アプリケーション以外のエンドポイントのルートパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll also highlight some configurable non-application endpoints of interest:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、設定可能なアプリケーション以外のエンドポイントにも注目しています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.micrometer.export.prometheus.path` - The location of the micrometer metrics endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.micrometer.export.prometheus.path` - Micrometerメトリクスのエンドポイントの場所。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.root-path` - The location of the all-encompassing health endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.smallrye-health.root-path` - すべてを網羅したヘルスエンドポイントの場所。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.liveness-path` - The location of the liveness endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.smallrye-health.liveness-path` - liveness エンドポイントの場所。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's look at what happens when we start pulling levers. In the examples below, pay attention to punctuation in config, as that will be the key to why things behave the way they do.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レバーを引き始めると何が起こるかを見てみましょう。以下の例では、config の句読点に注意を払ってください。句読点が、そのように動作する鍵となるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defaults</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here are the default configuration values:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトの設定値は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.root-path=/`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.root-path=/`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path=q`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.non-application-root-path=q`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.micrometer.export.prometheus.path=metrics`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.micrometer.export.prometheus.path=metrics`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.root-path=health`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.smallrye-health.root-path=health`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.liveness-path=liveness`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.smallrye-health.liveness-path=liveness`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That configuration (combined with the declared application endpoints) leads to the following valid URLs if our Quarkus application is running in dev mode:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>（宣言されたアプリケーションエンドポイントと組み合わされた）この設定は、Quarkusアプリケーションがdevモードで実行されている場合、次のような有効なURLになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/world</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/hello/world</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/hello/aliens</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/hello/aliens</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/q/metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/q/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/q/health</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/q/health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/q/health/liveness</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/q/health/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that the `quarkus.http.root-path` is hiding in this example, because its value is `/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では `quarkus.http.root-path` が隠れていることに注意してください。値が `/` だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are convenience redirects in this case as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. In this configuration, `/metrics` will be redirected to `/q/metrics`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、 `quarkus.http.non-application-root-path` と `quarkus.http.root-path` は同じではないので、利便性の為のリダイレクトがあります。この設定では、 `/metrics` は `/q/metrics` にリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's change the HTTP root path to `/root` so the impact it has on resource resolution is visible:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP のルートパスを `/root` に変更して、リソース解決への影響が見えるようにしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.root-path=/root`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.root-path=/root`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This results in the following dev mode URLs:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その結果、以下のようなdevモードのURLになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/hello</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/hello/world</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/hello/world</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/hello/aliens</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/hello/aliens</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/q/metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/q/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/q/health</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/q/health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/q/health/liveness</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/q/health/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are convenience redirects in this case, too, as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. In this configuration, `/root/metrics` will be redirected to `/root/q/metrics`. This is consistent with previous behavior, where non-application endpoints were implicitly relative to the HTTP root path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合も、 `quarkus.http.non-application-root-path` と `quarkus.http.root-path`.は同じではないので、便利なリダイレクトがあります。この設定では、 `/root/metrics` は `/root/q/metrics` にリダイレクトされます。これは、アプリケーション以外のエンドポイントが暗黙のうちに HTTP ルートパスから相対化されていた以前の動作と一致しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move the non-application root path (/q)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション以外のルートパスを移動 (/q)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try something we couldn't do before. We'll move the non-application endpoint outside of the HTTP root path by specifying an absolute path, `/q`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今までできなかったことをやってみましょう。絶対パス `/q` を指定して、アプリケーション以外のエンドポイントをHTTPルートパスの外側に移動させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path=/q`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.non-application-root-path=/q`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are still convenience redirects in this case, as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. Redirected URLs are still relative to HTTP root, so `/root/metrics` will be redirected to `/q/metrics`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合も、 `quarkus.http.non-application-root-path` と `quarkus.http.root-path` が同一ではない為、利便性の為のリダイレクトが存在します。リダイレクトされた URL はまだ HTTP ルートに対する相対的なものなので、 `/root/metrics` は `/q/metrics` にリダイレクトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Move individual non-application endpoints (/metrics and /liveness)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション以外のエンドポイントを個別に移動 (/metrics と /liveness)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is is another configuration that was not previously possible. We can individually move configurable non-application endpoints to a specified absolute path, specifically `/metrics` and `/liveness` in this example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、以前は不可能だったもう一つの設定です。設定可能なアプリケーション以外のエンドポイントを、指定された絶対パスに個別に移動させることができます。特にこの例では `/metrics` と `/liveness` に移動させることが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.micrometer.export.prometheus.path=/metrics`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.micrometer.export.prometheus.path=/metrics`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.smallrye-health.liveness-path=/liveness`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.smallrye-health.liveness-path=/liveness`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/liveness</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are still convenience redirects in this case, as `quarkus.http.non-application-root-path` is not the same as `quarkus.http.root-path`. However, these redirects only apply to non-application endpoints controlled by the non-application endpoint root. We've essentially removed the metrics and liveness endpoints from that root, so they won't be redirected. In this configuration, if you request `/root/health`, it will be redirected to `/q/health`. A redirect will not be provided for `/root/health/liveness` or `/root/metrics`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.non-application-root-path` は `quarkus.http.root-path` と同じではないので、この場合も利便性の為のリダイレクトがあります。しかし、これらのリダイレクトは、非アプリケーションエンドポイントのルートによって制御される非アプリケーションエンドポイントにのみ適用されます。私たちは、基本的にそのルートからメトリクスとlivenessのエンドポイントを削除しているので、リダイレクトされることはありません。この設定では、 `/root/health` をリクエストすると `/q/health` にリダイレクトされます。 `/root/health/liveness` や `/root/metrics` にはリダイレクトされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remove the non-application endpoint root</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非アプリケーションエンドポイントのルートの削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some of you have asked how to turn this non-application endpoint root stuff off entirely. A clear expression of your intent is best. To disable the non-application endpoint, make it identical to the HTTP root path. In essence, you are telling the runtime to "serve all non-application endpoints from the HTTP root". This example uses a variable to ensure the values remain the same:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何人かの方から、このアプリケーション以外のエンドポイントルートのものを完全にオフにするにはどうすればよいかという質問を受けました。あなたの意図を明確に表現するのがベストです。非アプリケーションエンドポイントを無効にするには、HTTPルートパスと同じにしてください。要するに、ランタイムに「HTTPルートからすべての非アプリケーションエンドポイントを提供する」ように指示していることになります。この例では、値が同じであることを保証するために変数を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.http.non-application-root-path=${quarkus.http.root-path}`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.http.non-application-root-path=${quarkus.http.root-path}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/health</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://localhost:8080/root/health/liveness</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>http://localhost:8080/root/health/liveness</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no convenience redirects in this scenario, as the non-application endpoint behavior has been disabled entirely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このシナリオでは、アプリケーション以外のエンドポイントの動作が完全に無効化されているため、利便性のためのリダイレクトはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Knock-on effects</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ノックオン効果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the most part, we hope this will be transparent. We discovered some very inconsistent path handling along the way, which lead us to believe that many (or even most) of these values are never customized.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ほとんどの部分では、これが透明であることを願っています。途中で非常に一貫性のないパス処理を発見し、これらの値の多く（あるいはほとんど）がカスタマイズされることはないと考えさせられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You are most likely to see a behavior change if you have customized the HTTP root path. In that case, we hope the new rules and examples above will help you understand how to tweak your configuration to get everything to behave the way you want it to.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP ルートパスをカスタマイズしている場合は、挙動の変化に気づく可能性が高いでしょう。その場合は、上記の新しいルールと例が、設定を微調整してすべてを思い通りに動作させる方法を理解するのに役立つことを願っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extension writers will see the biggest change. The link:https://quarkus.io/guides/writing-extensions#extension-defined-endpoints[Writing extensions guide] has been updated to describe changes to the build items used to create non-application endpoints. The general rule, however, is to avoid constructing your own endpoint paths, and rely on `NonApplicationRootPathBuildItem` and `HttpRootPathBuildItem` to construct them for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション開発者は最も大きな変更点を目にすることになるでしょう。 link:https://quarkus.io/guides/writing-extensions#extension-defined-endpoints[エクステンション開発ガイド]が更新され、アプリケーション以外のエンドポイントを作成するために使用されるビルド項目の変更が記述されています。しかし、一般的なルールとしては、自分でエンドポイントパスを構築することは避け、 `NonApplicationRootPathBuildItem` と `HttpRootPathBuildItem` に頼って構築してもらうようにしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Parting thoughts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おわりに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While we know it is impossible to make everyone happy, we hope we have at least managed to acheive a pattern for configuration that leads to more predictable and consistent results. And we apologize (again), for any behavior changes you may have observed as we sorted this out.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての人を幸せにすることは不可能であることはわかっていますが、少なくとも、より予測可能で一貫性のある結果につながる設定のパターンを達成することができたことを願っています。また、この問題を解決した際に観察された挙動の変化については、（再度）お詫び申し上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven Reactive Programming library.  Like other reactive programming libraries, it uses streams as the primary construct.  These streams convey events, and your code processes these events.  Most of the time, your code is only interested in item and failure events.  But there are other kinds of events such as cancellation, request, completion, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。他のリアクティブ・プログラミング・ライブラリと同様に、主要な構成要素としてストリームを使用します。これらのストリームはイベントを伝え、あなたのコードはこれらのイベントを処理します。ほとんどの場合、あなたのコードはアイテムイベントと失敗イベントにしか興味がありません。しかし、キャンセル、リクエスト、完了などの他の種類のイベントもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not rare that you need to look at these various events to understand better what's going on or implement specific side effects. For example, you may need to close a resource after a completion event or log a message on failure or cancellation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何が起こっているのかをよりよく理解したり、特定の副作用を実装したりするために、これらの様々なイベントを見る必要があることは稀ではありません。例えば、完了イベントの後にリソースを閉じたり、失敗やキャンセル時にメッセージをログに記録したりする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each kind of event, there is an associated _group_ providing the methods to handle that specific event: `onItem()`, `onFailure()`, `onCompletion()` and so on.  These groups provide two methods to peek at the various events without impacting its distribution: `invoke` and `call`.  It does not transform the received event; it notifies you that something happened and let you react.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントの種類ごとに、その特定のイベントを処理するための方法を提供する関連 _グループ_ があります: `onItem()`, `onFailure()`, `onCompletion()` など。これらのグループは、配信に影響を与えずに様々なイベントを覗くための 2 つの方法を提供しています: `invoke` と `call` 。これらのグループは、受信したイベントを変換するのではなく、何かが起こったことを通知して反応させてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The invoke method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>invoke メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method is synchronous and does not return anything.  Mutiny invokes the configured callback when the observed stream dispatches the event:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` メソッドは同期で、何も戻りません。Mutinyは、観測されたストリームがイベントをディスパッチするときに、設定されたコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, `invoke` is synchronous.  Mutiny invokes the callback and propagates the event downstream when the callback returns. It blocks the dispatching.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上で述べたように、 `invoke` は同期です。Mutinyはコールバックを呼び出し、コールバックが戻ってきたらイベントを下流に伝播させます。ディスパッチをブロックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, we highly recommend you not to block.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もちろん、ブロックしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippets show how you can log the different types of events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のスニペットは、さまざまな種類のイベントをログに記録する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The arrows from the previous code snippet indicate if the event comes from the upstream (source) or downstream (consumer).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のコードスニペットの矢印は、イベントが上流(ソース)から来るのか、下流(コンシューマ)から来るのかを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method does not change the event, except in one case.  If the `invoke` callback throws an exception, the downstream does not get the actual event but get a failure event instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` メソッドは、1 つのケースを除いて、イベントを変更しません。 `invoke` コールバックが例外をスローした場合、ダウンストリームは実際のイベントを取得せず、代わりに失敗イベントを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When observing the failure event, if the callback throws an exception, Mutiny propagates a `CompositeException` aggregating the original failure and the callback failure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>失敗イベントを観測しているときに、コールバックが例外を投げると、Mutinyは元の失敗とコールバックの失敗を集約した `CompositeException` を伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The call method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>呼び出し方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike `invoke`, `call` is asynchronous, and the callback returns a `Uni&lt;?&gt;` object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` とは異なり、 `call` は非同期で、コールバックは `Uni&lt;?&gt;` オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call` is often used when you need to implement asynchronous side-effects, such as closing resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`call` リソースを閉じるなど、非同期の副作用を実装する必要がある場合によく使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny does not dispatch the original event downstream until the Uni returned by the callback emits an item:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyは、コールバックによって返されたUniがアイテムを放出するまで、元のイベントを下流にディスパッチしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As shown in the previous snippet, you can use this approach to delay items. 
But the primary use case is about completing asynchronous actions:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のスニペットが示すように、このアプローチを使用してアイテムを遅らせることもできます。
ただし、主なユースケースは非同期アクションの完了に関するものです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Under the hood, Mutiny gets the `Uni` (by invoking the callback) and subscribes to it. 
It observes the item or failure event from that `Uni`. 
It discards the item value as only the emission matters in this case.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>内部的には、Mutinyは `Uni` を(コールバックを呼び出すことによって)取得し、サブスクライブします。 
`Uni`からアイテムまたは障害イベントを監視します。
この場合、排出のみが重要であるため、アイテムの値は破棄されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the callback throws an exception or the produced `Uni` produces a failure, Mutiny propagates that failure (or a `CompositeException`) downstream, replacing the original event. 
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コールバックが例外をスローするか、生成された `Uni` が失敗を生成した場合、Mutinyはその失敗(または `CompositeException` )をダウンストリームに伝播し、元のイベントを置き換えます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` and `call` methods are handy when you need to observe a stream without changing the transiting events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` と `call` メソッドはストリームをイベントを変更せずに観察するのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `invoke` for implementing synchronous side-effects or logging events.  The asynchronous nature of `call` makes it perfect for implementing asynchronous side-effects, such as closing resources, flushing data, delay items, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke`を同期の副作用操作やイベントのロギングの実装の為に使用してください。 `call`の非同期性は、非同期副作用操作、例えばリソースのクローズ、データのフラッシュ、アイテムの遅延などを実装するのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table highlights the key differences:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のテーブルが主な違いを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`invoke`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`call`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nature</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>戻り値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`void`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`void`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Main Use cases</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>主なユースケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These methods are available for every kind of event in the associated group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのメソッドは、関連するグループ内のあらゆる種類のイベントに対して利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Conclusion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.1.Final released - Bugfixes'
date: 2021-01-27
tags: release
synopsis: 1.11.1.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.11.1.Finalリリース - バグフィックス
date: 2021-01-27
tags: release
synopsis: 1.11.1.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.1.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it allowed us to make steady progress on fixing issues.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題点を報告し、再現手順を提供してくれたすべての貢献者に感謝します。問題の修正の確かな進捗に繋がりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also a big thanks to all the contributors providing pull requests, be they for the code or the documentation!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コードであれドキュメントであれ、プルリクエストを提供してくれたすべての貢献者にも感謝しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.1.Finalは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended GraalVM version is now GraalVM 20.3.1.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの推奨バージョンはGraalVM 20.3.1になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[the full changelog of 1.11.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[GitHubで1.11.1.Finalの完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of this blog post is to clear up some confusion about RESTEasy Reactive and answer some commonly asked questions around it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このブログ記事の目的は、RESTEasy Reactive についての混乱を解消し、よくある質問に答えることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Acknowledgement</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>謝辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and Reactive: the elevator pitch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令型とリアクティブ型: エレベーターピッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our quest to understand why RESTEasy Reactive is important and how it differs from RESTEasy Classic, it helps to paraphrase a very important message that was first introduced https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が重要な理由と、RESTEasy Classic と異なる点を理解するために、link:https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[ここ] で最初に紹介した非常に重要なメッセージを再び考察してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, Java web applications use imperative programming combined with blocking IO operations. This is incredibly popular because it is easier to reason about the code.  Things get executed sequentially. When the application receives a request, the framework associates this request to a worker thread.  When the request processing needs to interact with a database or another remote service, it relies on blocking IO.  The thread is blocked waiting for the answer, making the communication synchronous. With this model one request is not affected by another as they are run on different threads.  Even when one thread is waiting, other requests running on different threads are not slowed down significantly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的に、Java のWeb アプリケーションでは、ブロッキング IO 操作と組み合わせた命令型プログラミングを使用します。これは、コードを推論するのが簡単なので、非常に人気があります。物事は順次実行されます。アプリケーションがリクエストを受け取ると、フレームワークはこのリクエストをワーカースレッドに関連付けます。リクエスト処理がデータベースや他のリモートサービスと対話する必要があるときは、ブロッキング IO に依存します。スレッドは応答を待ってブロックされ、通信を同期化します。このモデルでは、1 つのリクエストは別のスレッドで実行されるので、別のリクエストの影響を受けません。1 つのスレッドが待機している場合でも、異なるスレッド上で実行されている他のリクエストが大幅に遅くなることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, with this model, you need one thread for every concurrent request, which places a limit on the achievable concurrency.  On the other side, the reactive execution model embraces asynchronous development models and non-blocking IO.  With this model, multiple requests can be handled by the same thread. When the processing of a request can no longer make progress (because it requests a remote service, or interacts with a database for example), it uses non-blocking IO.  Instead of blocking the thread, it schedules the operation and passes a continuation which would be invoked after the completion of the operationfootnote:[This article won’t detail how operating systems and non-blocking IO libraries enable such a model. Under the hood, kernel mechanisms such as select, epoll and ICMP are making the handling of IO very efficient, in terms of speed and resource utilization.].  This releases the thread immediately, which can then be used to serve another request. When the result of the IO operation is available, the processing of the request is resumed and continues its execution.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、このモデルでは、同時実行リクエストごとに1つのスレッドが必要となり、達成可能な同時実行性に制限が生じます。一方、リアクティブ実行モデルでは、非同期開発モデルとノンブロッキング IO を採用しています。このモデルでは、複数のリクエストを同じスレッドで処理することができます。(リモートサービスをリクエストしたり、データベースと対話したりするために) リクエストの処理が進まなくなった場合は、ノンブロッキング IO を使用します。スレッドをブロックする代わりに、操作をスケジュールし、操作の完了後に呼び出される継続を渡します footnote:[この記事ではOSとノンブロッキング IO ライブラリがどのようにそういったモデルを実現しているかの詳細には踏み込みません。内部的に、select、epoll、ICMPといったカーネルメカニズムがIO処理をスピードとリソース利用の観点で非常に効率的にしています]。これによりスレッドはすぐに解放され、別のリクエストに対応するために使用することができます。IO 操作の結果が利用可能になると、リクエストの処理が再開され、その実行が継続されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This model enables the usage of a single IO thread to handle multiple requests. There are three significant benefits.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このモデルでは、単一の IO スレッドを使用して複数のリクエストを処理することができます。3 つの大きなメリットがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the response time is smaller because it does not have to jump to another thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、別のスレッドにジャンプする必要がないので、レスポンス時間が短くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, it reduces memory consumption as it decreases the usage of threads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>第 2 に、スレッドの使用量が減るため、メモリーの消費量を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Third, your concurrency is no longer limited by the number of threads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>第 3 に、並行処理はスレッド数に制限されなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive model uses the hardware resources more efficiently, but... a significant pitfall lurks. If the processing of a request starts to block, things can go south really quickly as no other request can be handled. To avoid this, you need to learn how to write asynchronous and non-blocking code, how to schedule operations, how to write continuations, how to chain actions.  Basically, we need a way to structure asynchronous processing, and use non-blocking IO. No doubt, that consists of a paradigm shift.  In Quarkus, we want to make the shift as easy as possible, so RESTEasy Reactive allows you to choose whether an endpoint is blocking or non-blocking (an application is free to mix and match blocking and non-blocking methods at will).  So don’t be intimidated by the reactive word, the infrastructure is reactive, but your code can be either reactive or imperative. That’s what we mean by unification of reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブモデルはハードウェアリソースをより効率的に使用しますが、重大な落とし穴が潜んでいます。もしリクエストの処理がブロックされ始めると、他のリクエストが処理できなくなるため、本当にすぐに事態が悪化してしまいます。これを避けるためには、非同期でノンブロッキングなコードの書き方、操作のスケジュールの立て方、連続処理の書き方、アクションの連鎖の仕方などを学ぶ必要があります。基本的には、非同期処理を構造化し、ノンブロッキングIOを使う方法が必要です。これは間違いなく、パラダイムシフトであることは間違いありません。Quarkusでは、このシフトをできるだけ簡単にしたいと考えているので、RESTEasy Reactiveでは、エンドポイントがブロッキングかノンブロッキングかを選択することができます (アプリケーションはブロッキングとノンブロッキングのメソッドを自由に組み合わせて使用することができます)。インフラストラクチャはリアクティブですが、あなたのコードはリアクティブ型にも命令型にもなり得ます。これが、リアクティブ型と命令型の統一の意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive by default handles each HTTP request on an IO thread (otherwise known as an event-loop thread)footnote:[More information about the execution model of RESTEasy Reactive can be found https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[here]].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、デフォルトでは IO スレッド(イベントループスレッドとして知られている)上の各 HTTP リクエストを処理します footnote:[RESTEasy Reactiveの実行モデルについて詳細は https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[ここ] にあります]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following image shows what that looks at a high level:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のイメージでは、ハイレベルの様子を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-non-blocking.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RR-non-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ensures that maximum throughput can be achieved, but it also means that the implementation of an endpoint method should complete in a timely fashion otherwise the thread will be used for too longfootnote:["Too long" depends on your target concurrency. You may consider 1ms as too long for some endpoint heavily used, but 100ms might be acceptable for less used endpoints] and other requests will be queued up and lead to degraded throughput.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、最大のスループットを達成することがきます。ただし、エンドポイントメソッドの実装がタイムリーに完了しなければならないことも意味しています。そうでなければ、スレッドの使用が長くなり過ぎてしまい footnote:["長過ぎる" は目標とする並列度次第です。頻繁に使用されるエンドポイントでは 1ms も長過ぎると考える場合もありますし、あまり使われないエンドポイントでは 100ms でも許容可能かもしれません。]、他のリクエストがキューイングされ、スループットの低下につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to understand that a method body that uses imperative code only becomes a problem when it takes a long time to execute - which is almost always the case for blocking IO operations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令型コードを使用するメソッド本体が問題になるのは、実行に長い時間がかかるときだけ - ブロッキング IO 処理がほぼ全てのケース - であることを理解することが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For that reason, when the body of the method performs some kind of blocking IO operation (or even some CPU bound operation that requires time to complete), the request needs to be offloaded to a worker thread.  In RESTEasy Reactive that is done declaratively using the `@Blocking` annotation - no reactive programming or complex Java concurrency related code is needed.  Quarkus also warns you when you attempt to use blocking IO on an IO thread.  If however the method body performs non-blocking IO (or some CPU bound operation that completes very quickly) then RESTEasy Reactive can continue to serve the entire request on the IO thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、メソッドの本体が何らかのブロッキング IO 操作 (あるいは完了までに時間を要する CPU バインド操作) を実行する場合、リクエストはワーカースレッドにオフロードされる必要があります。RESTEasy Reactiveでは、`@Blocking` アノテーションを使用して宣言的に行われます。Quarkus は、IO スレッドでブロッキング IO を使用しようとした場合にも警告します。しかし、メソッド本体がノンブロッキング IO (または非常に速く完了するCPUバインド操作) を実行する場合、RESTEasy Reactive は、IO スレッド上でリクエスト全体を提供し続けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely not!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もちろん違います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although RESTEasy Reactive was built from the ground up to do non-blocking IO and serve requests from the event loop threads (thus avoiding the needless usage of worker pool threads)  it can effortlessly work with blocking IO and any piece of code that provides a blocking API (such as Hibernate) without blocking the event loop.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、ノンブロッキング IO とイベントループスレッドからのリクエストを処理するために一から構築されていますが(そのため、ワーカープールスレッドの不要な使用を避けることができます)、ブロッキング IO と、(Hibernate のような) ブロッキング APIを提供するあらゆるコードをイベントループをブロッキングせずに簡単に動作させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only thing you have to do is add `@Blocking` on your endpoint method or class.  That’s it! If you use `@Blocking` you are back to the regular dispatching mechanism: a worker thread is used to execute your method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントのメソッドやクラスに `@Blocking` を追加するだけです。これだけです。`@Blocking` を使用すると、通常のディスパッチの仕組み:ワーカースレッドがメソッドの実行に使用される方式に戻れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At a high level it this looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ハイレベルでは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-blocking.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RR-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can probably guess from the answer to the previous question, the answer is no.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の質問の答えからわかる通り、答えは「ノー」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate, the `@Blocking` annotation should be placed on the endpoint methods that interact with Hibernate.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が Hibernate と一緒に使用されるシナリオでは、 `@Blocking` アノテーションを Hibernate と相互作用するエンドポイントメソッドに配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate Reactive, no `@Blocking` annotation is necessary on the endpoint methods that interact with Hibernate Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が Hibernate Reactive とともに使用されるシナリオでは、Hibernate Reactive と相互作用するエンドポイントメソッドに `@Blocking` アノテーションは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the performance implication of using @Blocking?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Blocking を使用することによるパフォーマンスへの影響について</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the absolute highest throughput is achieved when an endpoint method is non-blocking (that is the HTTP request is served completely from the event loop thread), great performance can nonetheless be achieved even when `@Blocking` is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントメソッドがノンブロッキング (つまり、HTTP リクエストがイベントループスレッドから完全に提供される) の場合には、絶対的に最高のスループットが達成されますが、 `@Blocking` を使用していても優れたパフォーマンスを達成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our benchmarks we see the use of `@Blocking` reduce maximum throughput by around 30%footnote:[This is basically the cost we have to pay for dispatching the request to a worker thread. The percentage of the slowdown decreases the longer the target method takes to execute].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのベンチマークでは、`@Blocking` を使用することで最大スループットが約 30%footnote 低下することがわかります footnote:[これは基本的にワーカースレッドにリクエストを振り分けるためにかかるコストです]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, an endpoint method using `@Blocking` in RESTEasy Reactive still achieves around 50% higher throughput than the same method using RESTEasy Classic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、RESTEasy Reactive で `@Blocking` を使用したエンドポイントメソッドでは、RESTEasy Classic を使用した同じメソッドよりも約 50% 高いスループットを達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why does RESTEasy Reactive using @Blocking perform better than RESTEasy Classic?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜ @Blocking を使用した RESTEasy Reactive は RESTEasy Classic よりもパフォーマンスが良いのですか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is able to gain its performance advantage over RESTEasy Classic by:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、RESTEasy Classic と比較して、以下のような特徴を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integrating very tightly with Eclipse Vert.x for everything IO related. Vert.x has been extremely well optimized for IO operations and so tight integration with it allows RESTEasy Reactive to benefit from all that work.  You might recall that RESTEasy Classic on Quarkus uses Vert.x under the hood as well, but in that case the integration is not as deep and is therefore unable to fully utilize the power of Vert.x.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IO に関連するすべてを Eclipse Vert.x と緊密に統合します。Vert.x は IO 操作のために非常によく最適化されています。そのため、RESTEasy Reactive はそれとの緊密な統合により、その恩恵を受けることができます。RESTEasy Classic on Quarkus も同様に Vert.x を使用しています。ただし、その場合、統合はそれほど深くないため、Vert.x のパワーを十分に活用することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving a lot of work to build time. As RESTEasy Reactive was built from the ground up to serve the needs of Quarkus, it benefits from the tightest possible integration with Quarkus and is probably the extension that does the most build time work.  This in turn results in creating an optimal data pipeline for serving each request, helping the JIT compiler by generating bytecode to inline runtime operations, eliminating reflection at runtime (both for invoking methods and for determining types) and reducing memory allocations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの作業をビルド時に移行しています。RESTEasy Reactive は、Quarkus のニーズに応えるためにゼロから構築されています。そのため、Quarkus との統合が可能な限り緊密に行われており、おそらく最も多くをビルド時に作業を行うエクステンションとなっています。これにより、各リクエストを処理するための最適なデータパイプラインを作成し、実行時の操作をインラインで行うバイトコードを生成することで JIT コンパイラを支援し、実行時の (メソッドの呼び出しと型の決定のための) リフレクションを排除し、メモリーの割り当てを削減します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Avoiding the use of ThreadLocals and instead by utilizing a context object that contains all the necessary information.  ThreadLocals are a convenient way to make data available to different parts of a framework, but their frequent use comes at a cost and are thus fully avoided in RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ThreadLocals の使用を避け、代わりに必要な情報をすべて含むコンテキストオブジェクトを利用します。ThreadLocals はフレームワークのさまざまな部分でデータを利用できるようにする便利な方法です。ただし、その頻繁な使用にはコストがかかるため、RESTEasyReactive では完全に回避されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Utilizing Arc in an optimal manner for all necessary injections. RESTEasy Classic provides an abstraction layer that performs the various injection operations, which for the needs of Quarkus is entirely unnecessary since Arc provides the same functionality with better performance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要なすべてのインジェクションに最適な方法でArcを活用します。RESTEasy Classic は、さまざまなインジェクション操作を実行する抽象化レイヤーを提供しますが、Arcは同じ機能をより優れたパフォーマンスで提供するため、Quarkus のニーズには全く不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might recall that Quarkus allows you to use Mutiny return types (Uni and Multi) when using RESTEasy Classic via the `quarkus-resteasy-mutiny` extension and thus might be wondering how that compares to using RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Classic を使用しているときに Quarkus では、`quarkus-resteasy-mutiny` エクステンションを介して Mutiny 戻り値の型 (UniとMulti) を使用することができることや、これが RESTasy Reactive の使用と、どのように異なるかと思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main thing to understand about RESTEasy Classic is that it *always* handles requests on a worker thread as it does not use the event-loop concept at all.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Classic について最も理解しておくべきこととして、RESTEasy Classic はイベントループの概念を一切使用しないため、*常に*ワーカースレッド上でリクエストを処理することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is best shown by the following image:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを最もよく表しているのは、以下の画像です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CR.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CR.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when using RESTEasy Classic even when you return a reactive type like `Uni` or `Multi` the initial request is still being handled on a worker thread and while the call to the library may result in non-blocking IO, nevertheless there is no way for RESTEasy Classic to reuse the worker thread once it is blocked waiting on IO.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、RESTEasy Classic を使用する場合、`Uni` や `Multi` のようなリアクティブ型を返しても、最初のリクエストはワーカースレッドで処理され、ライブラリーの呼び出しはノンブロッキング IO になることがあります。それでも IO の待機中にブロックされると、RESTEasyClassic がワーカースレッドを再利用する方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the gain of using reactive return types in RESTEasy Classic is a syntactic gain, not a runtime gain - the underlying hardware isn’t used more efficiently despite the use of reactive types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように、RESTEasy Classic でリアクティブな戻り値型を使用することで得られる利益は、ランタイムの利益ではなく、構文的な利益です。リアクティブ型を使用していても、基礎となるハードウェアが、より効率的に使用されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When returning Mutiny types using RESTEasy Reactive, everything happens on the IO Thread (except if the endpoint is annotated with `@Blocking`). By the way, no need for an external extension to use Mutiny with RESTEasy Reactive, it’s built-in!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive を使用して Mutiny 型を返す場合、すべての処理は IO スレッド上で行われます (エンドポイントが `@Blocking` でアノテーションされている場合を除く)。RESTEasy Reactive で Mutiny を使用するための外部エクステンションは不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do I have to use the new RESTEasy Reactive APIs to achieve maximum performance?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最大のパフォーマンスを実現するためには、新しい RESTEasy Reactive API を使用する必要がありますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading through the RESTEasy Reactive documentation you soon come across the new APIs for writing request filters (https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[@ServerRequestFilter]), response filters (`@ServerResponseFilter`) and exception mappers (https://quarkus.io/guides/resteasy-reactive#exception-mapping[@ServerExceptionMapper]).  You might wonder if their usage affects performance in any way compared to the standard JAX-RS APIs (`ContainerRequestFilter`, `ContainerResponseFilter` and `ExceptionMapper`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive のドキュメントを読むと、すぐにリクエストフィルター link:https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[(@ServerRequestFilter])、レスポンスフィルター (`@ServerResponseFilter`)、例外マッパー link:https://quarkus.io/guides/resteasy-reactive#exception-mapping[(@ServerExceptionMapper]) を記述するための新しい API に出くわします。これらの使用法が標準の JAX-RS API (`ContainerRequestFilter`, `ContainerResponseFilter`, `ExceptionMapper`) と比べてパフォーマンスに影響を与えるかどうかを疑問に思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new APIs will give a tiny performance advantage over using the old APIs if the use of `@Context` is involved in the latter case, the advantage is negligible and should not worry you unless you are trying to squeeze out every inch of performance you can find.  One thing to keep in mind when writing filters with either API, is that using `org.jboss.resteasy.reactive.server.SimpleResourceInfo` instead of `javax.ws.rs.container.ResourceInfo` is advised as the latter results in reflection being performed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>後者のケースで `@Context` を使用する場合、新しい API は古い API を使用するよりもわずかなパフォーマンスの優位性を与えます。ただし、その優位性は取るに足らない程度で、可能な限りのパフォーマンスを限界まで引き出すのでない限り、心配する必要はありません。どちらの API を使ってフィルターを書く場合でも注意すべきことは、`javax.ws.rs.container.ResourceInfo` の代わりに `org.jboss.resteasy.reactive.server.SimpleResourceInfo` を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A special (albeit rather advanced) case where the new APIs do result in noticeably better performance is the case of `MessageBodyReader` and `MessageBodyWriter` classes.  When reading the HTTP request and writing the HTTP response, the use of https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader] and `ServerMessageBodyWriter` allows RESTEasy Reactive to optimize the data-path for serving the request.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい API によってパフォーマンスが顕著に向上する特別なケースとして、`MessageBodyReader` と `MessageBodyWriter` クラスがあります。HTTP リクエストの読み込みと HTTP レスポンスの書き込みの際に、 link:https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader]と `ServerMessageBodyWriter` を使用することで、RESTEasy Reactive はリクエストを提供するためのデータパスを最適化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about Reactive Routes?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブルートは?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was already providing a way to handle HTTP requests from the IO thread. Reactive Routes provides a declarative model to implement HTTP API. Each route can be called on the IO thread (default) or on a worker thread (using the `@Blocking` annotation).  Reactive Routes provide very good throughput and performance as highlighted in https://quarkus.io/blog/io-thread-benchmark/[this] article. How does reactive routes compare to RESTEasy Reactive?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはすでに IO スレッドから HTTP リクエストを処理する方法を提供していました。Reactive Routes (リアクティブルート) は、HTTP API を実装するための宣言モデルを提供します。各ルートは、IO スレッド (デフォルト) またはワーカースレッド (`@Blocking` アノテーションを使用) で呼び出すことができます。link:https://quarkus.io/blog/io-thread-benchmark/[この]記事で強調されているように、Reactive Routes は非常に優れたスループットとパフォーマンスを提供します。リアクティブルートは RESTEasy Reactive と比較してどうでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main complaints we got about Reactive Routes was about the development model: it’s very different from the one used with RESTEasy. However, Reactive Routes allowed us to verify the performance and efficiency benefits of using an end-to-end reactive model on top of Quarkus.  RESTEasy Reactive can be seen as the “next generation”: you get the runtime benefits while also using a familiar development model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Routes についての主な不満の 1 つは、開発モデルに関するものでした。RESTEasy で使用したものとは大きく異なります。しかし、Reactive Routes を使用することで、Quarkus 上にエンドツーエンドのリアクティブモデルを使用することで得られるパフォーマンスと効率性のメリットを検証することができました。RESTEasy Reactive は「次世代」と考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is the next generation of HTTP framework. It unifies reactive (non-blocking IO, asynchronous APIs) and imperative (thanks to the `@Blocking` annotation). It improves raw performances without constraining the user experience.  Its reactive/imperative duality makes it fit any use cases, from highly concurrent HTTP APIs, to more traditional transactional CRUD applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は次世代の HTTP フレームワークです。リアクティブ型 (ノンブロッキング IO、非同期 API) と命令型 (`@Blocking` アノテーションを使用) を統合しています。ユーザーエクスペリエンスを制限することなく、生のパフォーマンスを向上させます。その命令型/リアクティブ型の二面性により、高度に並列化された HTTP API から、より伝統的なトランザクション型の CRUD アプリケーションまで、あらゆるユースケースに適合するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We see RESTEasy Reactive as becoming the default HTTP layer in Quarkus in the near future and are completely committed to making it perform at the best possible level while also introducing new features that spark developer joy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、近い将来 Quarkus のデフォルト HTTP レイヤーになると思われます。また、開発者にうれしい新機能を導入しながら、可能な限り最高のパフォーマンスを実現することに完全にコミットしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In that vein, we hope that this short blog post will provide you with some insight on what makes RESTEasy Reactive special and clear up any misconceptions you may have had about it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この短いブログ記事が、RESTEasy Reactive が特別である理由と、RESTEasy Reactive について抱いていた誤解を解き明かすためのヒントになればと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.8.3.Final released - Bugfixes'
date: 2020-10-09
tags: release
synopsis: 1.8.3.Final downgrades slf4j-jboss-logging to fix a regression.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.8.3.Finalリリース - バグフィックス
date: 2020-10-09
tags: release
synopsis: 1.8.3.Finalではリグレッションを修正するためにslf4j-jboss-loggingをダウングレードしました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today, we released Quarkus 1.8.3.Final which contains a fix for an annoying regression and some other fixes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本日、Quarkus 1.8.3.Finalをリリースしました。このリリースには、迷惑なリグレッションの修正やその他いくつかの修正が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release that fixes various bugs found in 1.8.2.Final and provides some documentation updates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリリースは、1.8.2.Final で発見された様々なバグを修正し、ドキュメントを更新したメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main change we made is a downgrade of `slf4j-jboss-logging` motivated by a regression in `slf4j-jboss-logging`: https://github.com/quarkusio/quarkus/issues/12615 .</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>我々が行った主な変更点は、 `slf4j-jboss-logging`:https://github.com/quarkusio/quarkus/issues/12615 のリグレッションを理由とした `slf4j-jboss-logging` のダウングレードです .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.8.3.Final[the full changelog of 1.8.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.8.3.Final[GitHubで1.8.3.Finalの完全な変更履歴] は入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.2.Final released - Bugfixes'
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.11.2.Final リリース - バグ修正
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final では問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.2.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.2.Final は、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We upgraded to Hibernate ORM 5.4.27.SP1 which fixes an important issue, potentially causing data losses.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM 5.4.27.SP1 にアップグレードし、データ損失を引き起こす可能性のある重要な問題が修正されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the upgrade is highly recommended.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>したがって、アップグレードを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[the full changelog of 1.11.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[GitHub 上で 1.11.2.Final の完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today we're proud to announce link:https://github.com/quarkiverse[Quarkiverse Hub], a GitHub organization where any contributor can host their Quarkus extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今日は、コントリビューターが誰でもQuarkusのエクステンションをホストできるGitHub Organizationである https://github.com/quarkiverse[Quarkiverse Hub]を発表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hosting your extension in the Quarkiverse Hub makes it available to all Quarkus users through the Quarkus tooling.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをQuarkiverse Hubでホスティングすると、Quarkusツールを介してすべてのQuarkusユーザーが利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So read on to discover more and find out how you can make your extension available to all Quarkus developers today!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細をお読みになり、すべてのQuarkus開発者が今すぐエクステンションを利用できるようにする方法をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering and publishing artifacts to Maven central can become a daunting task. In Quarkiverse that is automated by GitHub Actions, requiring no manual interaction with any command line tools.  Releasing an artifact is as simple as opening a pull-request changing the https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[`.github/project.yml`] file in the extension's repository.  Once the pull-request is merged, a GitHub action is triggered invoking `mvn release:prepare release:perform` and the extension is deployed to Maven central.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven centralに成果物を登録して公開するのは、大変な作業になることがあります。Quarkiverseでは、GitHub Actionsによって自動化されており、コマンドラインツールを使って手動で操作する必要はありません。アーティファクトのリリースは、プルリクエストを開いて  https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[.github/project.yml]ファイルを作成します。プルリクエストがマージされると、GitHub アクションがトリガーされて `mvn release:prepare release:perform` が呼び出され、エクステンションが Maven セントラルにデプロイされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Core releases happen constantly and keeping up with the latest changes before a release is performed is crucial. Quarkiverse extensions are built daily against the latest https://github.com/quarkusio/quarkus[Quarkus core] using the https://github.com/quarkusio/quarkus-ecosystem-ci[Quarkus Ecosystem CI] and listed in the https://status.quarkus.io/[Quarkus Status] page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコアのリリースは常に行われており、リリースを実行する前に最新の変更点を把握しておくことは非常に重要です。Quarkiverseのエクステンションは、Quark https://github.com/quarkusio/quarkus-ecosystem-ci[us Ecosystem CI]を使用して最新の https://github.com/quarkusio/quarkus[Quarkusコア]に対して毎日ビルドされ、Quark https://status.quarkus.io/[usのステータス]ページに表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkiverse-parent` artifact (inherited by each extension in Quarkiverse) enables plugins that will format your source code to the same format used in Quarkus core.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkiverse-parent` アーティファクト(Quarkiverseの各エクステンションに継承されています)は、プラグインがソースコードをQuarkusコアで使用されているのと同じフォーマットにフォーマットすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation aggregation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントの集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get your versioned extension documentation automatically published (including guides)! Quarkiverse Hub uses https://antora.org[Antora] to aggregate each extension documentation in the Quarkiverse docs website.  Although the layout is still a work in progress, you can check it out at https://quarkiverse.github.io/quarkiverse-docs/</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バージョン管理されたエクステンションドキュメント(ガイドを含む)を自動的に公開しましょう!Quarkiverse Hubでは、 https://antora.org[Antora]を使用して、Quarkiverse docsのウェブサイト内の各エクステンションドキュメントを集約しています。レイアウトはまだ作業中ですが、 https://quarkiverse.github.io/quarkiverse-docs/ で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automated inclusion in the upcoming Extension registry</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今後のエクステンションレジストリーへの自動インクルード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Extension registry is still a work in progress (https://registry.quarkus.io), but the gist of it is to have a single place to browse for extensions (including https://code.quarkus.io, command line and IDE plugins).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Extension レジストリーはまだ作業中ですが( https://registry.quarkus.io )、その要旨は、エクステンション ( https://code.quarkus.io 、コマンドライン、IDE プラグインを含む) を単一の場所で閲覧できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to automate extension releases and publication of docs, there are some rules that need to be followed for projects under the Quarkiverse organization:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのリリースやドキュメントの公開を自動化するために、Quarkiverseの組織の下にあるプロジェクトでは、いくつかのルールに従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension repository should be named `quarkiverse-&lt;project&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのリポジトリの名前は `quarkiverse-&lt;project&amp;amp&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkiverse extension MUST belong to the `io.quarkiverse.&lt;project&gt;` groupId</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverseのエクステンションは、 `io.quarkiverse.&lt;project&gt;` groupIdに属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The root pom.xml MUST inherit from `io.quarkiverse:quarkiverse-parent`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルート pom.xml は `io.quarkiverse:quarkiverse-parent` を継承しなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *deployment*, *runtime* and *integration-test* directories containing the extension classes. See link:https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[How to create new extension modules using Maven] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*デプロイメント* 、 *ランタイム* 、および *統合テスト* のディレクトリーがエクステンションクラスを含みます。詳細は「 https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[Mavenを使って新しいエクステンションを作成する方法]」を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*docs* (optional): The docs should follow the link:https://docs.antora.org/antora/2.3/standard-directories/[Antora's Standard File and Directory Set]. See an example link:https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[here].
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*docs* (オプション)。docsは https://docs.antora.org/antora/2.3/standard-directories/[Antoraの標準ファイルとディレクトリーセット]に従ってください。サンプルは https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[ここ] を参照して下さい。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, look at the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I sign-up?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どうやったら申し込めますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an *Extension Proposal* ticket in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] (first check if the extension you're proposing is not created yet) and let us know if you want to lead the development of this extension by commenting on the issue.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/issues[Quarkusの課題管理]で *エクステンション提案の* チケットを作成し(まず、提案しているエクステンションがまだ作成されていないかどうかを確認してください)、このエクステンションの開発をリードしたい場合は、イシューにコメントをつけてお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team will get you started with the boring stuff of setting up a brand new repository and deployment scripts, so you'll have fun coding it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusチームは、ブランドの新しいリポジトリやデプロイメントスクリプトを設定するという退屈な作業すませるので、あなたは楽しくコーディングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, we're always improving, so take a look at link:https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse] for the process we are currently using.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他と同様に、我々は常に改善していますので、現在使用しているプロセスについては、 https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What extensions are in Quarkiverse already?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkiverseにはどのようなエクステンションがあるのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;amp;type=Repositories[すでにあるエクステンション]をチェックしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stay tuned for the latest info about Quarkiverse in the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]では、Quarkiverseの最新情報をご確認いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I reuse this setup for an extension outside the Quarkiverse organization?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定をQuarkiverseの組織外のエクステンションに再利用することはできますか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, right now we're in the process of documenting the extra steps to make your extension releases visible to our tooling in this case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、現在、外部のエクステンションのリリースを我々のツールから見えるようにするための追加のステップを文書化しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a https://quarkus.io/blog/kafka-failure-strategy/[previous blog post], we have looked at failure strategies provided by the Reactive Messaging Kafka connector.  But, imagine it's our lucky day, and for once it worked.  We should inform Kafka that the processing succeeded.  In Kafka terminology, we call this: _offset commit_.  This post covers the different strategies to commit offsets with the Reactive Messaging Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://quarkus.io/blog/kafka-failure-strategy/[以前のブログ記事]では、Reactive Messaging Kafkaコネクタが提供する失敗戦略を見てきました。しかし、想像してみてください、それは幸運な日で、一度だけ成功しました。処理が成功したことをKafkaに知らせなければなりません。Kafkaの用語では、これを _オフセットコミット_ と呼びます。この記事では、Reactive Messaging Kafka コネクタを使ったオフセットコミットのさまざまな戦略について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Kafka Consumer Group and Offsets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafkaコンシューマーグループとオフセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka organizes records (_i.e._ messages) around _topics_.  Each topic has a name, and applications send records to topics and poll records from topics.  So far, nothing out of the ordinary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka は、 _トピックを_ 中心にレコード ( _即ち_ メッセージ) を整理します。各トピックには名前があり、アプリケーションはトピックにレコードを送り、トピックからレコードをポーリングします。今のところ、特別なことは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Topics are divided into partitions.  Each partition is an ordered, immutable sequence of records.  Sending a message to a topic appends it to the selected partition.  Each message from a partition gets a sequential id number called _offset_.  It uniquely identifies each message within the partition.  So, with Kafka, you can identify an individual record using a `&lt;topic, partition, offset&gt;` tuple.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トピックはパーティションに分割されます。各パーティションは、順序立てられた不変のレコードのシーケンスです。トピックにメッセージを送信すると、選択したパーティションにメッセージが追加されます。パーティションからの各メッセージは、 _offset_ と呼ばれる連続した ID 番号を取得します。これはパーティション内の各メッセージを一意に識別します。つまり、Kafka を使うと、 `&lt;topic, partition, offset&gt;` タプルを使って個々のレコードを識別することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an application consumes messages from Kafka, it uses a Kafka consumer.  With this consumer, it polls batches of messages from a specific topic, for example, `movies` or `actors`.  Retrieved messages belong to partitions assigned to this consumer.  And that aspect is essential.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが Kafka からのメッセージを消費するとき、アプリケーションは Kafka コンシューマを使用します。このコンシューマでは、特定のトピック、例えば `movies` や `actors` などからのメッセージのバッチをポーリングします。取得したメッセージは、このコンシューマに割り当てられたパーティションに属します。そして、この点が重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumers belong to a consumer group, identified with a name (`A` and `B` in the picture above).  A group contains one or more consumers.  In general, when you scale up your application, it creates a consumer joining the same group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンシューマーは、名前(上の図では `A` と `B` )で識別されるコンシューマーグループに属しています。1 つのグループには 1 つ以上のコンシューマーが含まれます。一般的に、アプリケーションをスケールアップすると、同じグループに参加するコンシューマーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each consumer group receives each record from a topic once.  To achieve this, it assigns each consumer from a group to a set of partitions.  For example, in the above picture, the consumer from the application A1 receives the records from the partitions 0 and 1.  A2 receives the records from the partition 2.  App B is the only consumer from its consumer group.  So, it gets the records from all three partitions.  Consequently (ignore rebalance or other subtilities for now), each record from a topic is only received once per consumer group, by a specific consumer from that group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各コンシューマーグループは、トピックから各レコードを一度だけ受け取ります。これを実現するために、グループからの各コンシューマーをパーティションのセットに割り当てます。例えば、上の図では、アプリケーションA1のコンシューマーはパーティション0と1からレコードを受信し、A2はパーティション2からレコードを受信します。アプリBは、そのコンシューマグループからの唯一のコンシューマーです。したがって、3つのパーティションすべてからレコードを取得します。したがって、(今のところリバランスや他のサブユーティリティーは無視して)あるトピックの各レコードは、そのグループの特定のコンシューマーによって、コンシューマーグループごとに 1 回だけ受信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To orchestrate each consumer group's progress, each consumer periodically informs the broker of its current position - the last processed offset.  It commits the offset, indicating that all the previous records from that partition have been processed.  So, if a consumer stops and comes back later, it restarts from the last committed position (if assigned to that partition again).  Note that this behavior is configurable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各コンシューマーグループの進捗を調整するために、各コンシューマーは定期的に現在の位置、つまり最後に処理されたオフセットをブローカに通知します。コンシューマは、そのパーティションの以前のレコードがすべて処理されたことを示すオフセットをコミットします。つまり、あるコンシューマーが停止して後で戻ってきた場合、最後にコミットされた位置から再スタートします(再びそのパーティションに割り当てられた場合)。この動作は設定可能であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's important to notice is the periodic aspect of the commit.  Offset commit is expensive, and to enhance performance, we should not commit the offset after each processed record.  In this regard, Kafka behaves differently from traditional messaging solutions, such as JMS, which acknowledges each message individually.  Another important characteristic is the positional aspect of the commit.  You commit the position indicating that all the records located before that position are processed.  But is it really the case?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注目すべきは、コミットの周期的な側面です。オフセットコミットはコストがかかるので、パフォーマンスを向上させるためには、処理された各レコードの後にオフセットをコミットするべきではありません。この点で、Kafkaは、JMSのような従来のメッセージングソリューションとは異なる振る舞いをしており、各メッセージを個別に認識します。もう一つの重要な特徴は、コミットの位置的な側面です。位置をコミットすると、その位置より前にあるすべてのレコードが処理されることを示します。しかし、本当にそうなのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>### The Kafka default behavior</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka のデフォルトの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Apache Kafka consumer uses an auto-commit approach by default.  Applications using such a consumer are structured around a polling loop:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Kafka のコンシューマーはデフォルトで自動コミットアプローチを使用しています。このようなコンシューマを使うアプリケーションはポーリングループを中心に構成されています:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a program polls a batch of records, processes them, and then polls the next set.  While calling the `poll` method, the consumer periodically commits the last offset of the previous batches transparently.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなプログラムは、レコードのバッチをポーリングして処理し、次のセットをポーリングします。 `poll` メソッドを呼び出している間、コンシューマーは定期的に前のバッチの最後のオフセットを透過的にコミットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite nice, right? If the application fails to process a message, it throws an exception, which either interrupts the while loop or is handled gracefully (within the `processRetrievedRecords` method).  In the first case, it means that it won't commit anymore (as it happens in the `poll` method, not called anymore).  If the application restarts, it resumes from the last committed offset (or apply the `auto.offset.reset` strategy, defaulting to `latest`, if there are no offsets for this group yet).  It may re-process a set of messages (it's the application's responsibility to handle duplicates), but at least nothing is lost.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なかなかいいですよね?アプリケーションがメッセージの処理に失敗した場合、アプリケーションは例外をスローし、while ループを中断するか、( `processRetrievedRecords` メソッド内で) 優雅に処理されます。最初のケースでは、それはもうコミットしないことを意味します( `poll` メソッド内で発生するので、もう呼ばれません)。アプリケーションが再起動した場合、最後にコミットされたオフセットから再開します (または `auto.offset.reset` ストラテジーを適用し、このグループのオフセットがまだない場合は `latest` をデフォルトとして使用します)。一連のメッセージを再処理するかもしれませんが(重複を処理するのはアプリケーションの責任です)、少なくとも何も失われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, is there anything wrong with this? Looks wonderful... until you add a pinch of asynchrony.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それで、これに何か問題があるの?見た目は素晴らしい...非同期のピンチを追加するまでは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What if the message's processing is asynchronous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## メッセージの処理が非同期の場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the message processing is asynchronous (offloaded to another thread, use non-blocking I/O...), failures may not interrupt the while loop from above.  Failure happens asynchronously, outside the polling thread.  If the `poll` method gets called again despite a failed processing, and _auto-commit_ is still enabled, we may commit offsets while something wrong happened.  If some processing of previously retrieved records is not completed yet, while this auto commit happens, it may consider the record as processed correctly, but the outcome is unknown at that point.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージ処理が非同期(他のスレッドにオフロードされている、ノンブロッキングI/Oを使用している...)であれば、失敗は上からwhileループを中断しないかもしれません。失敗はポーリングスレッドの外で非同期に起こります。処理に失敗したにもかかわらず `poll` メソッドが再び呼び出され、 _オートコミット_ がまだ有効になっている場合、何か間違ったことが起こっている間にオフセットをコミットすることがあります。このオートコミットが発生している間に、以前に取得したレコードの処理がまだ完了していない場合、そのレコードは正しく処理されたとみなされるかもしれませんが、その時点では結果はわかりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So to handle these case, we can disable the auto-commit and switch to manual commit.  In this case, it's the application's responsibility to commit the offsets regularly.  So, the application needs to track the polled records, their processing, failures, and periodically commits the offsets.  It might not look too tricky, but actually, it can become quite challenging.  Again, in asynchronous scenarios, you may complete the processing of messages in various orders.  For example, if you call a remote service for each record, the responses may not come in the same orders as the records.  You need to track messages individually and only commit the offsets if all the previous messages are processed successfully.  Without this, you may commit offsets while there is processing from previous records still in progress or even failed processing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、これらのケースを処理するために、自動コミットを無効にして手動コミットに切り替えることができます。この場合、定期的にオフセットをコミットするのはアプリケーションの責任です。したがって、アプリケーションはポーリングされたレコード、その処理、失敗を追跡し、定期的にオフセットをコミットする必要があります。これはそれほどトリッキーには見えないかもしれませんが、実際には非常に困難になることがあります。繰り返しになりますが、非同期のシナリオでは、様々な順序でメッセージの処理を完了させることができます。例えば、各レコードに対してリモートサービスを呼び出した場合、レスポンスはレコードと同じ順番で来るとは限りません。メッセージを個別に追跡し、前のすべてのメッセージが正常に処理された場合にのみオフセットをコミットする必要があります。これがないと、前のレコードからの処理がまだ進行中であったり、処理に失敗した場合にオフセットをコミットすることになるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What can we do about this?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはどうしたらいいのでしょうか?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Reactive Messaging and the Kafka connector, you entered an asynchronous world.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Messaging と Kafka コネクタを使用すると、非同期の世界に入りました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message processing may not happen synchronously and sequentially.  When a Reactive Messaging `Message` processing completes, it acknowledges the message.  In the case of processing failures, it sends a negative acknowledgment.  The Kafka connector receives these acknowledgments and can decide what needs to be done, basically: to commit or not to commit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージ処理は、同期的・逐次的に行われるとは限りません。リアクティブメッセージング `Message` 処理が完了すると、メッセージを確認します。処理に失敗した場合は、否定的な確認応答を送信します。Kafka コネクタはこれらの確認応答を受信して、コミットするかしないかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can choose among three strategies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>3つの戦略から選択することができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ignore (default if `enabled.auto.commit=true` is set)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>無視 ( `enabled.auto.commit=true` が設定されている場合のデフォルト)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is configured using the `commit-strategy` attribute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `commit-strategy` 属性を使用して設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The throttled strategy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## スロットル化された戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The throttled strategy can be seen as an asynchronous variant of the default "auto-commit" behavior described above.  When enabled, the connector tracks each received message and monitors their acknowledgment.  When the connector finds out that all messages before a position are processed successfully, it commits that position.  This commit happens periodically to avoid committing too often.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スロットル戦略は、上述のデフォルトの「オートコミット」動作の非同期的な変形として見ることができます。有効にすると、コネクタは受信した各メッセージを追跡し、その確認応答を監視します。コネクタは、あるポジションの前のすべてのメッセージが正常に処理されたことを確認すると、そのポジションをコミットします。このコミットは、頻繁にコミットしないように定期的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy provides very good throughput and can handle asynchronous processing.  To enable this strategy configures the channel with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このストラテジーは非常に優れたスループットを提供し、非同期処理を処理することができます。このストラテジーを有効にするには、チャネルを以下のように設定します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one detail to mention.  If an old message is neither acked nor nacked, the strategy cannot commit the position anymore.  It will enqueue messages forever, waiting for that missing ack to happen.  It can lead to out of memory, as the connector would never be able to commit a position and to clear the queue.  Fortunately, the strategy detects this situation and reports a failure to the connector, marking the application unhealthy.  The `throttled.unprocessed-record-max-age.ms` attribute configures the deadline for each message to be acked or nacked before being considered as a poison pill (Default is 1 minute).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一つだけ注意すべき点があります。古いメッセージが ack されず、nack されない場合、ストラテジーはもうポジションをコミットすることができません。それは永遠にメッセージをエンキューし、その欠落したアックが起こるのを待ちます。これは、コネクタがポジションをコミットしてキューをクリアすることができなくなるため、メモリー不足につながる可能性があります。幸いなことに、このストラテジーはこの状況を検出してコネクタに失敗を報告し、アプリケーションが不健全であることをマークします。 `throttled.unprocessed-record-max-age.ms` 属性は、ポイズンピルとみなされる前に、各メッセージが ack されるか nacked されるかの期限を設定します (デフォルトは 1 分です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses this strategy by default if you explicitly enabled Kafka's auto-commit (with the `enable.auto.commit` attribute set to `true`).  In this case, the connector ignores acknowledgment and won't commit the offsets.  The Kafka consumer commits the offset periodically when polling batches, as described above.  This strategy works well if the message processing is synchronous and failures handled gracefully.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka の自動コミットを明示的に有効にした場合 ( `enable.auto.commit` 属性を `true` に設定した場合)、コネクタはデフォルトでこのストラテジーを使用します。この場合、コネクタは確認応答を無視してオフセットをコミットしません。Kafka コンシューマは、前述のように、バッチをポーリングする際に定期的にオフセットをコミットします。この方法は、メッセージ処理が同期的で、失敗があっても潔く処理される場合に有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enable this strategy by configured enabled-auto-commit to true:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>enabled-auto-commitをtrueに設定することで、このストラテジーを有効にすることができます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be aware that starting Quarkus 1.9, auto commit is disabled by default. So you need to explicitly enable it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.9からは、オートコミットがデフォルトで無効になっていることに注意してください。そのため、明示的に有効にする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't enable auto-commit, using this strategy is still possible but will never commit the offsets.  In other words, you would restart from the oldest stored records every time.  While there are use cases for this, double-check that's what you want. In this case, enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オートコミットを有効にしていない場合、この戦略を使用することは可能ですが、オフセットをコミットすることはありません。言い換えれば、保存されている最も古いレコードから毎回再起動することになります。これにはユースケースがありますが、あなたが望むものであることを再確認してください。当てはまる場合、以下のようにこのストラテジーを有効にします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The latest strategy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 最新の戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy commits the offset every time a message is acknowledged.
This strategy tends to commit often, and so decrease the throughput.   
However, it also reduces the risk of duplicates if the messages are processed synchronously. 
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このストラテジーは、メッセージが確認されるたびにオフセットをコミットします。
このストラテジーは頻繁にコミットする傾向があるため、スループットが低下します。
しかし、メッセージが同期的に処理されている場合には、重複のリスクを減らすことができます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この戦略を有効にするのは以下の通りです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, use the `throttled` strategy.  It provides high-throughput and handles the asynchronous use cases.  This strategy is becoming the default strategy in Quarkus 1.10.  You can also switch to the `ignore` strategy if the Kafka auto-commit is acceptable for you, or if you want to skip offset commit altogether.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的には、 `throttled` 戦略を使用します。これはハイスループットを提供し、非同期のユースケースを処理します。このストラテジーは、Quarkus 1.10ではデフォルトのストラテジーになっています。また、Kafkaのオートコミットが許容できる場合や、オフセットコミットを完全にスキップしたい場合は、 `ignore` 戦略に切り替えることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That concludes this blog post.  The next one will discuss how to receive and produce Cloud Events using the Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以上でこのブログ記事は終了です。次回は、Kafkaコネクタを使ってクラウドイベントを受信して生成する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today we're proud to announce our quarkus.io Japanese localization site (https://ja.quarkus.io[https://ja.quarkus.io]) is now open. It is where our valuable guides and blog entries are translated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本日、quarkus.io日本語版サイト (https://ja.quarkus.io[https://ja.quarkus.io]) が公開されましたことをお知らせします。ここでは、Quarkusの価値あるガイドや、ブログエントリの翻訳が公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/ja-quarkus-io/ja-quarkus-io.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/ja-quarkus-io/ja-quarkus-io.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some contents have not been translated yet, but we are continuing to translate them one by one.  We are working on the localization of the contents on a GitHub public repository (https://github.com/quarkusio/ja.quarkus.io[https://github.com/quarkusio/ja.quarkus.io]), and we are welcoming pull-requests to translate them.  If you are interested in localizing quarkus.io, come and join us! For more details about how to contribute the localization project, please see https://github.com/quarkusio/ja.quarkus.io/blob/master/translation-guide.ja.md[translation guide(ja)].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一部のコンテンツはまだ翻訳されていませんが、1つずつ翻訳を続けています。GitHubのパブリックレポジトリ (https://github.com/quarkusio/ja.quarkus.io[https://github.com/quarkusio/ja.quarkus.io]) でコンテンツのローカリゼーションに取り組んでおり、翻訳のPull-Requestは大歓迎です。quarkus.ioのローカライズに興味がある場合は、ぜひご参加ください。ローカリゼーションプロジェクトへの貢献方法の詳細については、 https://github.com/quarkusio/ja.quarkus.io/blob/master/translation-guide.ja.md[翻訳ガイド(ja)] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We hope https://ja.quarkus.io[https://ja.quarkus.io] will be of great help to the user community in Japan.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://ja.quarkus.io[https://ja.quarkus.io] が日本のユーザーコミュニティに大いに役立つことを願っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: Next Monday (8th Feb 21), we will do Quarkus Insights based on your questions.
author: maxandersen
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: 来週の月曜日(2月8日)は、ご質問をもとにQuarkus Insightsを行います。
author: maxandersen
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the next Quarkus Insights episode, we are trying something new.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のQuarkus Insightsのエピソードでは、新しいことを試しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will cover the most often asked questions we have seen and any question tagged with `#quarkusinsights` on our various social media presences: https://twitter.com/search?q=%23quarkusinsights[Twitter], https://www.facebook.com/hashtag/quarkusinsights/[Facebook], https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] or on the https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtube event] directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、私たちが見てきた最も頻繁に質問された質問や、私たちの様々なソーシャルメディアで `#quarkusinsights` とタグ付けされた任意の質問をカバーします( link:https://twitter.com/search?q=%23quarkusinsights[Twitter] 、 link:https://www.facebook.com/hashtag/quarkusinsights/[Facebook] 、 link:https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] 、または link:https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtubeイベント] で直接)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a question about Quarkus you would like answered let us know on one of thoses sites.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>答えてほしいQuarkusに関する質問がある場合は、以下のいずれかのサイトでお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See you all Monday!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>月曜日にお会いましょう!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>get-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>get-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/get-started/</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/get-started/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Be Guided Through First Application]({{site.baseurl}}/guides/getting-started)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[はじめてのアプリケーション入門]({{site.baseurl}}/guides/getting-started)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Getting Started with Reactive]({{site.baseurl}}/guides/getting-started-reactive)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[リアクティブ入門]({{site.baseurl}}/guides/getting-started-reactive)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Quickly Bootstrap Your Application](https://code.quarkus.io)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[アプリケーションのクイック起動](https://code.quarkus.io)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Building Native Executables]({{site.baseurl}}/guides/building-native-image)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[ネイティブ実行ファイルのビルド]({{site.baseurl}}/guides/building-native-image)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Using our Tooling]({{site.baseurl}}/guides/tooling)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[ツールの使用]({{site.baseurl}}/guides/tooling)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guides</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[Get More Guides]({{site.baseurl}}/guides)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[その他のガイド]({{site.baseurl}}/guides)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through Your First Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はじめてのアプリケーション入門</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Bootstrapping an application
- Creating a JAX-RS endpoint
- Injecting beans
- Functional tests
- Packaging of the application
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下をカバーします:
- アプリケーションの起動
- JAX-RSエンドポイントの作成
- Beanの挿入
- ファンクションテスト
- アプリケーションのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.
This guide covers:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでリアクティブアプリケーションを作成する方法を学習し、Quarkusによって提供される様々なリアクティブ機能を学びます。
このガイドは以下をカバーします：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A brief introduction to Mutiny - the reactive programming library used by Quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>概説Mutiny - Quarkusによって使用されているリアクティブプログラミングライブラリ
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping a reactive application
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブアプリケーションのクイック起動
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSエンドポイントの作成（非同期、ストリーム...）
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータベースアクセス
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のリアクティブAPIの使用
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickly Bootstrap Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのクイック起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With &lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt;, in a few clicks, you can bootstrap your Quarkus application and discover its extension ecosystem.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt; では、数クリックでQuarkusアプリケーションを起動し、エクステンションエコシステムを発見出来ます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the wide breadth of technologies Quarkus applications can be made with.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを作成する際に利用できる幅広いテクノロジーをご覧ください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Compiling the application to a native executable
- The packaging of an application in a Docker container
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下をカバーします：
- アプリケーションのネイティブ実行可能ファイルへのコンパイル
- アプリケーションのDockerコンテナへのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide requires:
- Completion of the [Creating Your First Application]({{site.baseurl}}/guides/getting-started) guide
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下を必要とします:
- [最初のアプリケーションの作成]({{site.baseurl}}/guides/getting-started) ガイドの完了
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application.
In this guide, we will explore:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には開発者がライブリロードからKubernetesへのアプリケーションのデプロイまで、ツールチェインが付属しています。
このガイドでは、以下について説明します：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use Maven as a build tool
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenをビルドツールとして使用する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use Gradle as a build tool
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleをビルドツールとして使用する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the native CLI for your toolchain (coming soon)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツールチェインにネイティブCLIを使用する方法（近日公開）
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to create and scaffold a new project
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいプロジェクトをスキャフォールド (骨組を作成) する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDEでアプリケーションを開発する方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to compile your application natively
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDEでアプリケーションをコンパイルする方法
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error 404</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Error 404</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have found nowhere.&lt;br/&gt;The pathway to normal space&lt;br/&gt;is found in the nav.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どこでもないスペースを見つけました。&lt;br/&gt;
通常のスペースへのパスは、&lt;br/&gt;
ナビゲーションメニューに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A haiku for you.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ポエム
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To make testing against a mock Kubernetes API extremely simple, Quarkus provides the `WithKubernetesTestServer` annotation which automatically launches a mock of the Kubernetes API server and sets the proper environment variables needed so that the Kubernetes Client configures itself to use said mock.  Tests can inject the mock server and set it up in any way necessary for the particular testing using the `@KubernetesTestServer` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>モックのKubernetes APIに対するテストを非常に簡単にするために、Quarkusでは、Kubernetes APIサーバーのモックを自動的に起動し、Kubernetesクライアントがそのモックを使用するように設定するために必要な適切な環境変数を設定する `KubernetesMockServerTestResource` を提供しています。テストは、 `@MockServer` アノテーションを使用して、特定のテストに必要な方法でモックを注入し、設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternately, you can create a `CustomKubernetesMockServerTestResource.java` to ensure all your `@QuarkusTest` enabled test classes share the same mock server setup:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CustomKubernetesMockServerTestResource.java` を作成して、 `@QuarkusTest` を有効にしたすべてのテストクラスが同じモックサーバー設定を共有できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file.  You can also generate the native executable with `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative` でネイティブ実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The plugin also exposes a `quarkusDev` configuration. Using this configuration to declare a dependency will restrict the usage of that dependency to development mode.  The `quarkusDev` configuration can be used as following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプラグインは `quarkusDev` の設定も公開しています。この設定を使って依存関係を宣言すると、その依存関係の使用が開発モードに制限されます。 `quarkusDev` の設定は以下のように使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle plugin supports the generation of Uber-Jars by specifying a `quarkus.package.type` argument as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Gradleプラグインは、以下のように `--uber-jar`  引数を指定して UberJar の生成をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using fast-jar</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>fast-jar の使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When configuring `quarkus.package.type=fast-jar` (which will become the default soon) in `application.properties` (or any of the other supporting configuration sources), then the result of executing `./gradlew build` is a new directory under `build` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` (または他のサポートしている設定ソース) で `quarkus.package.type=fast-jar` (もうすぐデフォルトになります) を設定する場合、 `./gradlew build` を実行した結果、 `build` 以下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行するには、次のようにします: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to successfully run the produced jar, you need to have the entire contents of the `quarkus-app` directory. If any of the files are missing, the application will not start or might not function correctly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された jar を正常に実行するためには、 `quarkus-app` ディレクトリのすべての内容が必要です。いずれかのファイルが欠落していると、アプリケーションが起動しなかったり、正しく機能しない可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `fast-jar` packaging results in creating an artifact that starts a little faster and consumes slightly less memory than a legacy Quarkus jar because it has indexed information about which dependency jar contains classes and resources. It can thus avoid the lookup into potentially every jar on the classpath that the legacy jar necessitates, when loading a class or resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`fast-jar` パッケージングでは、どの依存関係のjarにクラスやリソースが含まれているかという情報がインデックス化されているため、レガシーのQuarkus jarよりも起動が少し速く、メモリ消費量もわずかに少ないアーティファクトを作成できます。このため、クラスやリソースをロードする際に、レガシー jar が必要とするクラスパス上のすべての jar を検索する必要がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Only text based media types are supported at the moment as Azure Functions HTTP Trigger for Java does not support a binary format</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure Functions HTTP Trigger for Javaがバイナリ形式をサポートしていないため、現時点ではテキストベースのメディアタイプのみがサポートされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `target/quarkus-app/quarkus-run.jar` file.  You can also generate the native executable using `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、 `./mvnw clean package`  を使ってアプリケーションをパッケージ化し、 `target/quarkus-app/quarkus-run.jar` ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative` を使用してネイティブの実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is packaged using `./mvnw package`.  It produces several outputs in `/target`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは `./mvnw package` を使ってパッケージングされています。 これは `/target` に 2 つの jar ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular artifact produced by the Maven build - it is *not* the runnable jar;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar`: プロジェクトのクラスとリソースだけを含み、Maven ビルドによって生成される通常のアーティファクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `quarkus-app` directory which contains the `quarkus-run.jar` jar file - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into subdirectories of `quarkus-app/lib/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getting-started-1.0.0-SNAPSHOT-runner.jar`: 実行可能な _jar_ です。依存関係が `target/lib` ディレクトリーにコピーされているので、これは _über-jar_ ではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/quarkus-app/quarkus-run.jar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar` を使ってアプリケーションを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to deploy your application soemwhere (typically in a container), you need to deploy the whole `quarkus-app` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをどこかに(通常はコンテナに)デプロイしたい場合は、 `quarkus-app` ディレクトリ全体をデプロイする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section assumes that the configuration property `quarkus.package.type` has either not been configured explicitly, or that it has been set to `legacy-jar` (in `application.properties` or any of the other supported configuration sources).  When the property has been set to `fast-jar` (which will become in Quarkus 1.12), then the result of executing `./mvnw package` is a new directory under `target` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のセクションでは、設定プロパティ `quarkus.package.type` が明示的に設定されていないか、または `application.properties` またはその他のサポートされている設定ソースで `legacy-jar` に設定されていることを前提としています。プロパティが `fast-jar` に設定されている場合（Quarkus 1.12 で設定されます）、 `./mvnw package` を実行した結果、 `target` の下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST over HTTP has become a very common way to write services over the past decade.  While Funqy
has an HTTP binding it is not a replacement for REST.  Because Funqy has to work across a variety
of protocols and function cloud platforms, it is very minimalistic and constrained.  For example, if you
use Funqy you lose the ability to link (think URIs) to the data your functions spit out.  You also
lose the ability to leverage cool HTTP features like `cache-control` and conditional GETs.  Many
developers will be ok with that as many won't be using these REST/HTTP features or styles. You'll
have to make the decision on what camp you are in.  Quarkus does support REST integration (through JAX-RS,
 Spring MVC, Vert.x Web, and Servlet) with
various cloud/function providers, but there are some disadvantages of using that approach as well.  For example,
if you want to do link:amazon-lambda-http[HTTP with AWS Lambda], this requires you to use the AWS API Gateway which may
slow down deployment and cold start time or even cost you more.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP 上の REST は過去 10 年間でサービスを書くための非常に一般的な方法になりました。FunqyはHTTPバインディングを持っていますが、RESTの代替ではありません。Funqyは様々なプロトコルと機能を持つクラウドプラットフォームで動作しなければならないため、非常にミニマムで制約があります。例えば、Funqyを使うと、関数が吐き出すデータにリンクする機能（URIを考えてください）を失うことになります。また、 `cache-control` や条件付き GET のようなクールな HTTP 機能を利用する機能も失います。多くの開発者はこれらの REST/HTTP 機能やスタイルを使用しないので、多くの開発者はこれで大丈夫でしょう。自分がどちらの立場にいるのかを判断する必要があります。Quarkusは、さまざまなクラウドプロバイダーや機能プロバイダーとのREST統合（JAX-RS、Spring MVC、Vert.x Web、Servletを介して）をサポートしていますが、このアプローチを使用することにもいくつかのデメリットがあります。例えば、 link:amazon-lambda-http[AWS LambdaでHTTPを] 行いたい場合、AWS API Gatewayを使用する必要があり、デプロイやコールドスタート時間が遅くなったり、コストが高くなったりする可能性があります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging your application is as simple as `./mvnw clean package`.  It can be run with `java -jar target/quarkus-app/quarkus-run.jar`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのパッケージングは `./mvnw clean package` のように簡単です。 `java -jar target/amazon-dynamodb-quickstart-1.0-SNAPSHOT-runner.jar` で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When configuring `quarkus.package.type=fast-jar` (which will become the default soon), then the result of executing `./mvnw package` is a new directory under `target` named `quarkus-app`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.package.type=fast-jar` を設定している場合 (これはもうすぐデフォルトになります)、 `./mvnw package` を実行した結果、 `target` の下に `quarkus-app` という名前の新しいディレクトリが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus-amazon-lambda-http` extension allows you to write microservices with RESTEasy (JAX-RS), Undertow (servlet), Vert.x Web, link:funqy-http[Funqy HTTP] or any other Quarkus HTTP API that runs on top of Vert.x Web and deploy them to Amazon Lambda using https://aws.amazon.com/api-gateway/[Amazon's API Gateway] and https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-amazon-lambda-http` エクステンションを使うと、RESTEasy (JAX-RS)、Undertow (サーブレット)、Vert.x Web、または link:funqy-http[Funqy HTTP] でマイクロサービスを書き、 link:https://aws.amazon.com/api-gateway/[AmazonのAPI Gateway] とAmazonの link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[SAMフレームワークを] 使って、これらのマイクロサービスをAmazon Lambdaとしてデプロイ可能な状態にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension has recently been upgraded to use API Gateway V2.  If you need to still use V1 of the API Gateway use the `quarkus-amazon-lambda-http-v1` extension instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは最近、API Gateway V2を使用するようにアップグレードされました。まだ API Gateway V1 を使用する必要がある場合は、代わりに `quarkus-amazon-lambda-http-v1` エクステンションを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての質問に答えると、 Lambda がデプロイされ、API Gatewayへの必要なフックが設定されます。すべてが正常にデプロイされると、マイクロサービスのルート URL がコンソールに出力されます。このような感じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Value` 属性は Lambda のルート URL です。これをブラウザにコピーして、最後に `hello` を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy a native executable, you must build it with Graal.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルをデプロイするには、Graalを使ってビルドする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then test the executable locally with sam local</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、ローカルで sam local を使って実行ファイルをテストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To deploy to AWS Lambda:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AWS Lambda へのデプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This page explains how to start using gRPC in your Quarkus application.  While this page describes how to configure it with Maven, it is also possible to use Gradle.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このページでは、QuarkusアプリケーションでgRPCを使い始める方法を説明します。このページではMavenでの設定方法を説明していますが、Gradleを使用することも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].  The default configuration is enough, but you can also select some extensions if you want.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、 link:https://code.quarkus.io[Quarkusプロジェクトジェネレータ] から生成された通常のQuarkusプロジェクトを想像してみましょう。デフォルトの設定で十分ですが、必要に応じていくつかのエクステンションを選択することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `pom.xml` file to add the Quarkus gRPC extension dependency (just under `&lt;dependencies&gt;`):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml` ファイルを編集して、Quarkus gRPCエクステンションの依存関係を追加します( `&lt;dependencies&gt;` のすぐ下)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure you have `generate-code` goal of `quarkus-maven-plugin` enabled in your `pom.xml`.  If you wish to generate code from different `proto` files for tests, also add the `generate-code-tests` goal:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml` で `generate-code` ゴールの `quarkus-maven-plugin` が有効になっていることを確認してください。テスト用に異なる `proto` ファイルからコードを生成したい場合は、 `generate-code-tests` ゴールも追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this configuration, you can put your service and message definitions in the `src/main/proto` directory.  `quarkus-maven-plugin` will generate Java files from your `proto` files.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定では、サービスとメッセージの定義を `src/main/proto` ディレクトリーに置くことができます。 `quarkus-maven-plugin` は、 `proto` ファイルから Java ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively to using the `generate-code` goal of the `quarkus-maven-plugin`, you can use `protobuf-maven-plugin` to generate these files, more in &lt;&lt;Generating Java files from proto with protobuf-maven-plugin&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-maven-plugin` の `generate-code` ゴールを使用する代わりに、 `protobuf-maven-plugin` を使用してこれらのファイルを生成することができます。詳細は &lt;&lt;protoファイルからprotobuf-maven-pluginでJavaファイルを生成する&gt;&gt; を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with a simple _Hello_ service.  Create the `src/main/proto/helloworld.proto` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは簡単な _Hello_ サービスから始めてみましょう。 `src/main/proto/helloworld.proto` ファイルを以下の内容で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This `proto` file defines a simple service interface with a single method (`SayHello`), and the exchanged messages (`HelloRequest` containing the name and `HelloReply` containing the greeting message).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この `proto` ファイルは、単一のメソッド ( `SayHello` ) と交換されたメッセージ (名前を含む `HelloRequest` と挨拶メッセージを含む `HelloReply` ) を持つシンプルなサービスインターフェースを定義しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before coding, we need to generate the classes used to implement and consume gRPC services.  In a terminal, run:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コーディングの前に、gRPCサービスを実装して消費するためのクラスを生成する必要があります。ターミナルで以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, you can look at the `target/generated-sources/grpc` directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたら、 `target/generated-sources/grpc` ディレクトリーを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are the classes we are going to use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは、これから使うクラスファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every time you update the `proto` files, you need to re-generate the classes (using `mvn compile`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`proto` ファイルを更新するたびに、クラスを再生成する必要があります ( `mvn compile` を使用して)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Protocol Buffers specification provides a way to import `proto` files.  The Quarkus code generation mechanism lets you control the scope of dependencies to scan for possible imports by setting the `quarkus.generate-code.grpc.scan-for-imports` property to one of the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Protocol Buffers仕様では、 `proto` ファイルをインポートする方法を提供しています。Quarkusのコード生成メカニズムでは、 `quarkus.generate-code.grpc.scan-for-imports` プロパティーを以下のいずれかに設定することで、インポートの可能性をスキャンするための依存関係の範囲を制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`groupId1:artifactId1,groupId2:artifactId2` - scan only the dependencies with group id and artifact id in the list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`groupId1:artifactId1,groupId2:artifactId2` - リスト内のグループIDとアーティファクトIDを持つ依存関係のみをスキャンする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If not specified, the property is set to `com.google.protobuf:protobuf-java`.  To override it, set the `quarkus.generate-code.grpc.scan-for-imports` property in your pom.xml (or gradle.properties) to the desired value, e.g.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定されていない場合、このプロパティーは `com.google.protobuf:protobuf-java` に設定されます。これを上書きするには、pom.xml (または gradle.properties) の `quarkus.generate-code.grpc.scan-for-imports` プロパティーを希望の値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a gRPC service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that we have the generated classes let's implement our _hello_ service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたクラスができたので、 _hello_ サービスを実装してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, implementing a service requires to _extend_ the generated service base implementation and expose it as a `@Singleton` CDI bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、サービスを実装するには、生成されたサービスベースの実装を _extend_ し 、 `@Singleton` CDI Beanとして公開する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't use `@ApplicationScoped` as the gRPC service implementation cannot be proxied.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスの実装はプロキシーできないので、 `@ApplicationScoped` を使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing a service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/HelloService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `src/main/java/org/acme/HelloService.java` ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Expose your implementation as bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実装をBeanとして公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extends the `ImplBase` class. This is a generated class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ImplBase` クラスを拡張します。生成されたクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement the methods defined in the service definition (here we have a single method).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービス定義で定義されたメソッドを実装します(ここでは1つのメソッドを使用しています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build and send the response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスを構築して送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Close the response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスを閉じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides an additional model with Mutiny, a Reactive Programming API integrated in Quarkus.  Learn more about Mutiny on the link:getting-started-reactive#mutiny[Getting Started with Reactive guide].  A Mutiny implementation of this service would be:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、Quarkusに統合されたReactive Programming APIであるMutinyを使用した追加モデルも提供しています。Mutinyの詳細については、 link:getting-started-reactive#mutiny[Getting Started with Reactiveガイド] を参照してください。このサービスのMutinyの実装は次のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main differences are the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>主な違いは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>it extends the `ImplBase` from `MutinyGreeterGrpc` instead of `GreeterGrpc`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreeterGrpc` の代わりに `MutinyGreeterGrpc` から `ImplBase` を extend します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the signature of the method is using Mutiny types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドのシグネチャは Mutiny 型を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your service implementation logic is blocking (use blocking I/O for example), annotate your method with `@Blocking`.  The `io.smallrye.common.annotation.Blocking` annotation instructs the framework to invoke the annotated method on a worker thread instead of the I/O thread (event-loop).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスの実装ロジックがブロッキングである (例えば、ブロッキング I/O を使用する) 場合には、メソッドに `@Blocking` をアノテーションします。 `io.smallrye.common.annotation.Blocking` アノテーションは、I/O スレッド (イベントループ) の代わりにワーカースレッドでアノテーションされたメソッドを呼び出すようにフレームワークに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The gRPC server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The services are _served_ by a _server_.  Available services (_CDI beans_) are automatically registered and exposed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスは _サーバー_ によって _提供されます_ 。利用可能なサービス( _CDIBean_ )は自動的に登録され、公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the server is exposed on `localhost:9000`, and uses _plain-text_ (so no TLS).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、サーバーは `localhost:9000` で公開されており、 _プレーンテキスト_ を使用します(そのため TLS は使用しません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application using: `mvn quarkus:dev`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mvn quarkus:dev` を使用してアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming a gRPC service</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスを消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we are going to consume the service we expose.  To simplify, we are going to consume the service from the same application, which in the real world, does not make sense.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、公開しているサービスを消費することにします。簡単に言うと、同じアプリケーションからサービスを消費することになりますが、これは現実の世界では意味がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the existing `org.acme.ExampleResource` class, and edit the content to become:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存の `org.acme.ExampleResource` クラスを開き、内容を編集してこのようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the service and configure its name. This name is used in the application configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスをインジェクトし、その名前を設定します。この名前は、アプリケーションの設定で使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the _blocking_ stub (also a generated class).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_ブロッキング_ スタブ(生成されたクラスでもあります)を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Invoke the service.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need to configure the application to indicate where the `hello` service is found.  In the `src/main/resources/application.properties` file, add the following property:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`hello` サービスがどこにあるかを示すようにアプリケーションを構成する必要があります。 `src/main/resources/application.properties` ファイルで、以下のプロパティーを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`hello` is the name of the service used in the `@GrpcService` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`hello` は `@GrpcService` アノテーションで使用されるサービスの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`host` configures the service host (here it's localhost).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`host` はサービスホストを設定します (ここでは localhost)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open http://localhost:8080/hello/quarkus in a browser, and you should get `Hello quarkus`!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、ブラウザで http://localhost:8080/hello/quarkus を開くと、 `Hello quarkus` と表示されるはずです!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Like any other Quarkus applications, you can package it with: `mvn package`.  You can also package the application into a native executable with: `mvn package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のQuarkusアプリケーションと同様に、 `mvn package` でパッケージングすることができます。また、 `mvn package -Pnative` でアプリケーションをネイティブの実行ファイルにパッケージングすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generating Java files from proto with protobuf-maven-plugin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>protoファイルからprotobuf-maven-pluginでJavaファイルを生成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively to using Quarkus code generation to generate stubs for `proto` files, you can also use `protobuf-maven-plugin`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのコード生成を使用して `proto` ファイルのスタブを生成する代わりに、 `protobuf-maven-plugin` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do it, first define the 2 following properties in the `&lt;properties&gt;` section:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのためには、まず `&lt;properties&gt;` セクションで以下の 2 つのプロパティーを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They configure the gRPC version and the `protoc` version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは gRPC のバージョンと `protoc` のバージョンを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, add to the `build` section the `os-maven-plugin` extension and the `protobuf-maven-plugin` configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `build` セクションに `os-maven-plugin` のエクステンションと `protobuf-maven-plugin` の設定を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `protobuf-maven-plugin` that generates stub classes from your gRPC service definition (`proto` files).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービス定義( `proto` ファイル)からスタブクラスを生成する `protobuf-maven-plugin`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class generation uses a tool named `protoc`, which is OS-specific.  That's why we use the `os-maven-plugin` to target the executable compatible with the operating system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラス生成には、OS固有の `protoc` というツールを使用しています。そのため、OSと互換性のある実行ファイルを対象に `os-maven-plugin` を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This configuration instructs the `protobuf-maven-plugin` to generate the default gRPC classes and classes using Mutiny to fit with the Quarkus development experience.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定は、Quarkusの開発経験に合わせてMutinyを使用してデフォルトのgRPCクラスとクラスを生成するように、 `protobuf-maven-plugin` に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedding a configuration file inside a dependency</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係の中に設定ファイルの埋め込み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can embed a configuration file inside one of your dependencies by adding a `META-INF/microprofile.properties` configuration file to it (this is a standard functionality of MicroProfile Config).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`META-INF/microprofile.properties` 設定ファイルを追加することで、依存関係の中に設定ファイルを埋め込むことができます (これは MicroProfile Config の標準機能です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you add this dependency to your application, its configuration properties will be merged.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この依存関係をアプリケーションに追加すると、その設定プロパティーがマージされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the properties coming from it inside your `application.properties` that takes precedence over it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` で、その設定プロパティーよりも優先されるプロパティーを上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The classifier matching the version of the platform may look confusing at first. But this is what turns the descriptor into a true "fingerprint" of the platform. In both Maven and Gradle, the effective set of the dependency version constraints (or the managed dependencies) is obtained by merging all the imported BOMs and version constraints specified individually in the current project and also its parent(s). The artifact `classifier` is a part of the dependency ID, which could be expressed as `groupId:artifactId:classifier:type`. Which means that if a project is based on a couple of Quarkus platforms (by importing their BOMs), e.g. `io.quarkus:quarkus-universe-bom::pom:1.2.3` and `org.acme:acme-bom::pom:555`, and these two platforms are based on different `io.quarkus:quarkus-bom::pom` versions (which is technically a Quarkus platform in its turn as well), the Quarkus tools will be able to detect this fact and make the user aware of it, since it *might* not be a safe combination. If the descriptor artifact didn't include the classifer containing the version of the platform then the tools wouldn't be able to detect a potentially incompatible mix of different versions of the same platform in the same project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォームのバージョンにマッチする分類は、最初は混乱するように見えるかもしれません。しかし、これがディスクリプタをプラットフォームの真の「フィンガープリント」に変えるものです。MavenとGradleの両方で、依存関係のバージョン制約（または管理された依存関係）の有効なセットは、現在のプロジェクトで個別に指定されたすべてのインポートされたBOMとバージョン制約、およびその親をマージすることによって得られます。アーティファクト `classifier` は依存関係 ID の一部であり、 `groupId:artifactId:classifier:type` と表現できます。つまり、プロジェクトが（BOMをインポートして）いくつかのQuarkusプラットフォームに基づいていて、例えば、 `io.quarkus:quarkus-universe-bom::pom:1.2.3` と `org.acme:acme-bom::pom:555` のように、これら2つのプラットフォームが異なるバージョンの `io.quarkus:quarkus-bom::pom` に基づいている場合（これは技術的には順番にQuarkusプラットフォームでもあります）、Quarkusツールはこの事実を検出して、安全な組み合わせではない *かもしれない* ので、ユーザーに認識させることができます。もし記述子の成果物にプラットフォームのバージョンを含む分類子が含まれていなかった場合、ツールは、同じプロジェクト内で同じプラットフォームの異なるバージョンが混在していても、互換性がない可能性があることを検出することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The table below gives an overview of the current IDEs with links and a high-level overview of their features.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>下の表では、現在のIDEの概要とリンク、その機能のハイレベルな概要をご紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{vscode-logo}[VSCode,100,100]
{empty} +
VSCode Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:{vscode-logo}[VSCode,100,100]
{empty} +
VSCode Quarkus Tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{eclipse-logo}[Eclipse,100,100]
{empty} +
Eclipse Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:{eclipse-logo}[Eclipse,100,100]
{empty} +
Eclipse Quarkus Tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Quarkus Tools</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Quarkus Tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Ultimate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:{intellij-logo}[IntelliJ,100,100]
{empty} +
IntelliJ Ultimate</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:{che-logo}[Eclipse Che,100,100]
{empty} +
Eclipse Che</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:{che-logo}[Eclipse Che,100,100]
{empty} +
Eclipse Che</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are planning to run the application as a native executable and parse documents that may have been created with charsets different than the standard ones supported in Java such as `UTF-8` then you should configure Quarkus to get the native image generator include all the charsets available to the JVM:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをネイティブ実行ファイルとして実行し、`UTF-8` のような Java でサポートされている標準の文字セットと異なる文字セットで作成された可能性のあるドキュメントを解析する場合は、Quarkus Maven Plugin を設定して、ネイティブイメージジェネレーターがJVM で利用可能なすべての文字セットを含むようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ ./mvnw clean compile quarkus:dev
[INFO] Scanning for projects...
[INFO]
INFO] --------------------&lt; org.acme.example:apache-tika &gt;--------------------
[INFO] Building apache-tika 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
Listening for transport dt_socket at address: 5005
2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running without servlet container.
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-undertow to run Resteasy within a servlet container
2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 549ms
2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 1.361s. Listening on: http://0.0.0.0:8080
2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, tika]
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ ./mvnw clean compile quarkus:dev
[INFO] Scanning for projects...
[INFO]
INFO] --------------------&lt; org.acme.example:apache-tika &gt;--------------------
[INFO] Building apache-tika 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
Listening for transport dt_socket at address: 5005
2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running without servlet container.
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-undertow to run Resteasy within a servlet container
2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 549ms
2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 1.361s. Listening on: http://0.0.0.0:8080
2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, tika]
</seg>
      </tuv>
    </tu>
  </body>
</tmx>
